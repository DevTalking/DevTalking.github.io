<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[程序员说]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.devtalking.com/"/>
  <updated>2016-01-02T11:31:51.000Z</updated>
  <id>http://www.devtalking.com/</id>
  
  <author>
    <name><![CDATA[DevTalking]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[用TVML开发tvOS应用教程]]></title>
    <link href="http://www.devtalking.com//articles/develop-tvos-app-with-tvml/"/>
    <id>http://www.devtalking.com//articles/develop-tvos-app-with-tvml/</id>
    <published>2015-12-30T16:00:00.000Z</published>
    <updated>2016-01-02T11:31:51.000Z</updated>
    <content type="html"><![CDATA[<p>作者：<a href="http://www.raywenderlich.com/u/Kelvin%20Lau" target="_blank" rel="external">Kelvin Lau</a> 原文地址：<a href="http://www.raywenderlich.com/114886/beginning-tvos-development-with-tvml-tutorial" target="_blank" rel="external">Beginning tvOS Development with TVML Tutorial</a></p>
<p>在2015年9月9日的产品发布会中，Apple宣布了新一代的Apple TV以及tvOS，并且在tvOS中集成了App Store。这使得我们多年以来想在Apple TV上开发专属应用的梦想成真了。</p>
<p>我和其他教程团队的成员已经开始深入研究tvOS SDK，并且正在努力为你们准备一些有价值的tvOS教程。在你开这篇文章之前，Chris Wagner已经写了一篇关于tvOS初步印象的<a href="http://www.raywenderlich.com/114313/tvos-initial-impressions" target="_blank" rel="external">文章</a>，我也基于这篇文章，设计了第一个tvOS的教程。</p>
<blockquote>
<p>译者注：可参阅Chris Wagner文章的中译版<a href="http://www.devtalking.com/articles/tvOS-initial-impression/">一个iOS开发者对tvOS SDK的初探</a>。</p>
</blockquote>
<p>在这篇教程中，你将会使用TVML开发你的第一款tvOS应用。信不信由你，你将会使用JavaScript管理你应用的逻辑以及创建TVML模板来展现你应用的UI。</p>
<p>当教程结束后，你应该可以基本理解如果通过TVML和TVJS管理、控制tvOS应用。现在就我们开始吧。</p>
<blockquote>
<p>注意：该教程需要Xcode7.1或更高的版本，你们可以在这里<a href="https://developer.apple.com/xcode/download/" target="_blank" rel="external">下载</a>。虽然你们可以跟着该教程一步一步的进行操作，但我还是建议你们能储备一些基本的JavaScript知识。</p>
</blockquote>
<h2 id="u9009_u62E9_u5F00_u53D1_u65B9_u5F0F"><a href="#u9009_u62E9_u5F00_u53D1_u65B9_u5F0F" class="headerlink" title="选择开发方式"></a>选择开发方式</h2><p>Apple为开发tvOS应用提供了两种方式：</p>
<ol>
<li><strong>TVML Apps</strong>：这类应用是使用完整的新开发技术开发的，比如TVML、TVJS、TVMLKit。在稍后我会解释这些简称的含义以及如何使用它们。</li>
<li><strong>Custom Apps</strong>：这类应用是使用我们已经比较熟悉的开发技术进行开发的，比如大家熟知的一些iOS框架和特性，像Storyboard、UIKit、Auto Layout等。</li>
</ol>
<p>这两种方式没有孰优孰劣之分，都是Apple推荐的方法，只是按需所取，以及你更想尝试哪种方式。</p>
<p>在这篇教程中，你们的目标是开发以个能播放<a href="http://www.rwdevcon.com/" target="_blank" rel="external">RWDevCon</a>讨论视频的tvOS应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-1.gif" alt="tvOS-1"></p>
<p>虽然用上述两种方式都可以开发这个应用，但是使用TVML会更加容易一些。所以这就是你在这篇教程中要学和要做的东西。</p>
<h2 id="u4EC0_u4E48_u662FTVML_uFF1F"><a href="#u4EC0_u4E48_u662FTVML_uFF1F" class="headerlink" title="什么是TVML？"></a>什么是TVML？</h2><p>正如我刚才提到的，第一种开发tvOS应用的方式是通过TVML、TVJS和TVMLKit这些新的技术实现的。如果你们对这些简称比较陌生，不要惊慌，因为他们本就是新鲜玩意。这里我简单解释一下：</p>
<ul>
<li><strong>TVML</strong>是一种XML格式，基于“Television Markup Language”。</li>
<li><strong>TVJS</strong>是基于JavaScript APIs的脚本语言，它可以根据TVML中定义的内容展示应用。</li>
<li><strong>TVMLKit</strong>是连接TVML、TVJS和原生tvOS应用的工具包。</li>
</ul>
<p>如果你是一名经常使用原生API开发原生iOS应用的开发者，那么看到这些类似前端的技术可能会有点退缩。但希望你能保持一颗学习的心，学习了解这些新的强大的特性。</p>
<p>我在这列举一个非常典型的Apple TV的应用场景。大家可以想象一下：你们想把一些内容或信息展现给用户，这些内容和信息储存在你们的服务器上，并且这些内容的格式、查询方式都服务于iPhone或iPad中的应用，那么你肯定会希望你的tvOS中的应用也能方便的使用这些内容，并做到与iOS中应用有相似的展现、查询、导航方式。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-2.jpg" alt="tvOS-2"></p>
<p>上述的这个场景恰恰是我们这片教程中的场景。我们已经有<a href="http://www.rwdevcon.com/" target="_blank" rel="external">RWDevCon</a>网站，上面有许多技术讨论视频，所以运用TVML模板应该很容易实现。并且我们也没有很严格的用户界面的需求，所以我们可以简单方便的使用Apple提供的UI<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">模板</a>。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-3.jpg" alt="tvOS-3"></p>
<p>简而言之：</p>
<ul>
<li><strong>开发TVML App</strong>：如果你主要是通过tvOS应用展现一些内容，不论是音频、视频、文本、图片，并且你已经有服务器存储这些资源。那么使用TVML开发是不错的选择。</li>
<li><strong>开发Custom App</strong>：如果你希望用户不只是被动的通过你的tvOS应用观看或收听内容，而是希望用户与应用有更多的交互，给用户高质量的用户体验。那么你应该选择使用iOS的相关技术开发自定义的应用。</li>
</ul>
<p>现在你们已经大概了解了TVML是如何工作的，以及我们为什么要在这篇教程中使用TVML开发tvOS应用。想要更深入的了解，最好的办法就是由你们在实践中去学习、理解了。让我们开始动手吧！</p>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先你们要确保已经下载并安装了Xcode7.1或更高版本。</p>
<p>然后通过 <strong>File\New\Project</strong> 创建新工程，在侧边栏选择 <strong>tvOS\Application\Single View Application</strong> 模板，然后点击 <strong>Next</strong>：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-4.png" alt="tvOS-4"></p>
<p>项目名称输入 <strong>RWDevCon</strong> ,语言选择 <strong>Swift</strong> ，确保下面的两个复选框为未选中状态，也就是不使用Core Data和单元测试，然后点击 <strong>Next</strong>：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-5.png" alt="tvOS-5"></p>
<p>选择一个目录，点击 <strong>Save</strong> 保存你的项目。Xcode会为你创建一个带有Storyboard的空工程（如果你开发自定义UI的tvOS应用，那么你需要使用Storyboard）。</p>
<p>然而在该教程中你不需要使用Storybard，因为我们会使用TVML来展示应用的UI，而不是用Storybard去设计UI。所以将 <strong>Main.storyboard</strong> 和 <strong>ViewController.swift</strong> 删去，在提示框中选择 <strong>Move To Trash</strong> 彻底删除。</p>
<p>接着打开 <strong>Info.plist</strong> 文件，删掉<code>Main storybaord file base name</code>属性。最后添加新的属性<code>App Transport Security Settings</code>（区分大小写），以及它的子属性<code>Allow Arbitrary Loads</code>，并将其值设为<code>YES</code>。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-6.png" alt="tvOS-6"></p>
<blockquote>
<p>注意：在iOS9中，Apple不允许应用链接非HHTPS协议的服务，所以刚才的操作是很有必要的，因为在该教程中，你们将会以HTTP协议访问本地的服务器，所以你需要在Info.plist中添加上述属性以便允许应用通过HTTP协议访问服务器。</p>
</blockquote>
<h2 id="u52A0_u8F7D_u4F60_u7684TVML"><a href="#u52A0_u8F7D_u4F60_u7684TVML" class="headerlink" title="加载你的TVML"></a>加载你的TVML</h2><p>tvOS应用的生命周期开始于AppDelegate。在这里，你将创建<code>TVApplicationController</code>以及应用上下文，并将它们传给主要的JavaScript文件。</p>
<p>打开<strong>AppDelegate.swift</strong>并做下面这些事：</p>
<ul>
<li>删除所有的方法。</li>
<li>导入<code>TVMLKit</code>。</li>
<li>使AppDelegate遵循<code>TVApplicationControllerDelegate</code>协议。</li>
</ul>
<p>当完成这些事后，你的<strong>AppDelegate.swift</strong>看起来应该像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> TVMLKit</span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span>, <span class="title">TVApplicationControllerDelegate</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> window: <span class="type">UIWindow</span>?</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着添加下面这些属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> appController: <span class="type">TVApplicationController</span>?</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> <span class="type">TVBaseURL</span> = <span class="string">"http://localhost:9001/"</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> <span class="type">TVBootURL</span> = <span class="string">"<span class="subst">\(AppDelegate.TVBaseURL)</span>js/application.js"</span></span><br></pre></td></tr></table></figure>
<p><code>TVApplicationController</code>是<code>TVMLKit</code>中的一个类，它负责与你的服务器的交互。<code>TVBaseURL</code>和<code>TVBootURL</code>包含了你的服务器的地址和JavaScript文件的地址，该JavaScript文件稍后会运行在你的服务器中。</p>
<p>接在在AppDelegate中添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  window = <span class="type">UIWindow</span>(frame: <span class="type">UIScreen</span>.mainScreen().bounds)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> appControllerContext = <span class="type">TVApplicationControllerContext</span>()</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> javaScriptURL = <span class="type">NSURL</span>(string: <span class="type">AppDelegate</span>.<span class="type">TVBootURL</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"unable to create NSURL"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  appControllerContext.javaScriptApplicationURL = javaScriptURL</span><br><span class="line">  appControllerContext.launchOptions[<span class="string">"BASEURL"</span>] = <span class="type">AppDelegate</span>.<span class="type">TVBaseURL</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  appController = <span class="type">TVApplicationController</span>(context: appControllerContext, window: window, delegate: <span class="keyword">self</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码相对还是比较容易理解的：</p>
<ol>
<li>这里你首先创建了一个应用上下文<code>TVApplicationControllerContext</code>的实例，用于稍后初始化你的<code>TVApplicationController</code>。你可以理解为给一个简单的对象设置了一些属性，比如服务器的URL，然后该对象又作为属性设置给了另一个对象。</li>
<li>给应用上下文这个对象实例设置了两个简单的属性：主JavaScript文件的路径和服务器的地址。</li>
<li>通过你刚才设置好的应用上下文初始化<code>TVApplicationController</code>。此时就完全由Apple代码来接管了，他会加载到你的主JavaScript文件，并开始执行其内容。</li>
</ol>
<p>所以到目前为止，是时候让Xcode休息一会了，因为接下来你们将要编写JavaScript了。</p>
<h2 id="The_JavaScript"><a href="#The_JavaScript" class="headerlink" title="The JavaScript"></a>The JavaScript</h2><p>在客户端-服务端这类的tvOS应用中，你的JavaScript文件通常在应用连接的服务器中。在该教程中，你们将会在Mac上搭建一个简单的服务器。</p>
<h3 id="u5BA2_u6237_u7AEF_u4EE3_u7801"><a href="#u5BA2_u6237_u7AEF_u4EE3_u7801" class="headerlink" title="客户端代码"></a>客户端代码</h3><p>为了方便起见，我们把JavaScript文件放在桌面，在你们的 <strong>桌面</strong> 文件夹中新建一个文件夹名为 <strong>client</strong> 。在client文件夹中再新建一个文件夹名为 <strong>js</strong> 。该文件夹将作为你的JavaScript文件的容器。</p>
<p>通过你使用的编辑JavaScript的IDE，新建一个JavaScript文件，名为 <strong>application.js</strong> ，将它保存在你刚才新建的 <strong>js</strong> 文件夹中。然后在 <strong>application.js</strong> 中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">App</span>.onLaunch = function(options) &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> alert = createAlert(<span class="string">"Hello World"</span>, <span class="string">""</span>); <span class="comment">//第二个参数传入空字符串</span></span><br><span class="line">  navigationDocument.presentModal(alert);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> createAlert = function(title, description) &#123;</span><br><span class="line">  <span class="keyword">var</span> alertString = `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">    &lt;document&gt;</span><br><span class="line">      &lt;alertTemplate&gt;</span><br><span class="line">        &lt;title&gt;$&#123;title&#125;&lt;/title&gt;</span><br><span class="line">        &lt;description&gt;$&#123;description&#125;&lt;/description&gt;</span><br><span class="line">      &lt;/alertTemplate&gt;</span><br><span class="line">    &lt;/document&gt;`</span><br><span class="line">    <span class="keyword">var</span> parser = new <span class="type">DOMParser</span>();</span><br><span class="line">    <span class="keyword">var</span> alertDoc = parser.parseFromString(alertString, <span class="string">"application/xml"</span>);</span><br><span class="line">    <span class="keyword">return</span> alertDoc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>App.onLaunch</code>是处理JavaScript文件的入口方法。之前在 <strong>AppDelegate.swift</strong> 中已经初始化好的<code>TVApplicationController</code>会将<code>TVApplicationControllerContext</code>传到这。之后你会使用到上下文中的内容，但是现在，我们只创建一个简单的提示界面并显示在屏幕上。</p>
<ol>
<li>通过下面定义的<code>createAlert</code>函数，我们获得到了为我们展现界面的TVML文件。<code>navigationDocument</code>类似于iOS中的<code>UINavigationController</code>，它提供像栈一样的方式，可以推出或压进展现界面的TVML文件。</li>
<li><code>createAlert</code>是一个返回TVML文件的函数，你可以将它看作类似iOS中的<code>UIAlertController</code>。</li>
</ol>
<p>写到这顺便提一下，Apple已经提供了18种TVML模板供我们使用，你们可以在该<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">Apple TV Markup Language Reference</a>中查阅完成的模板列表。</p>
<p>上述代码中的 <strong>alertTemplate</strong> 就是这18个模板中的其中一个，它的主要用于展示重要信息，比如通过一段消息提示用户在继续操作之前需要执行其他的操作等。此时，距离你们编译运行你们的第一个tvOS应用已为时不远了。</p>
<h3 id="u914D_u7F6E_u670D_u52A1_u5668"><a href="#u914D_u7F6E_u670D_u52A1_u5668" class="headerlink" title="配置服务器"></a>配置服务器</h3><p>打开 <strong>Terminal</strong> 输入如下命令：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd ~/<span class="type">Desktop</span>/client</span><br><span class="line">python -m <span class="type">SimpleHTTPServer</span> <span class="number">9001</span></span><br></pre></td></tr></table></figure>
<p>这两行命令的作用是在先前创建的client目录中开启一个基于Python的web服务器。现在，你们可以准备起飞了！</p>
<p>回到你的Xcode项目中编译运行程序。你应该可以看到你的第一个tvOS TVML应用了！</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-7.png" alt="tvOS-7"></p>
<p>我不知道你们的感觉如何，但是当我第一次运行成功后，我的感受就像下面这个家伙一样：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-8.png" alt="tvOS-8"></p>
<p>在继续进行教程之前，我想花点时间对你们目前已经完成的工作作以总结：</p>
<ol>
<li>你们创建了<code>TVApplicationController</code>实例。它用于管理JavaScript代码。</li>
<li>你们创建了<code>TVApplicationControllerContext</code>实例，并在创建<code>TVApplicationController</code>时将其与之关联。应用上下文有一个<code>launchOption</code>属性，用来构建我们的<code>BASEURL</code>，也就是服务器的地址。该应用上下文也用于配置tvOS应用与哪个服务器连接。</li>
<li>控制器被传到了JavaScript代码中。<code>App.onLaunch</code>作为整个JavaScript文件的入口方法，你们定义了<code>createAlert</code>函数，返回TVML提示信息模板文件，并由<code>navigationDocument</code>管理并展现界面。最后将“Hello World”显示在屏幕上。</li>
</ol>
<p>即使现在你们使用的服务器是运行在本机的，但是你们仍然可以连接一个真实的远程的服务器，可能是一个连着数据库的服务器。你们感受并想象一下应用场景，应该会很酷，对吧？</p>
<h2 id="u5B8C_u5584TVML_u6A21_u677F"><a href="#u5B8C_u5584TVML_u6A21_u677F" class="headerlink" title="完善TVML模板"></a>完善TVML模板</h2><p>我之前提到过，<code>createAlert</code>是一个返回TVML模板文件的函数。有很多属性可由我们在TVML文件中编辑修改，作为一个实验性质的小例子，你们将会在当前的 <strong>alertTemplate</strong> 中添加一个按钮。回到你们的JavaScript代码中，将目光聚焦在<code>createAlert</code>函数上，在模板中添加一个按钮：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> alertString = `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;alertTemplate&gt;</span><br><span class="line">      &lt;title&gt;$&#123;title&#125;&lt;/title&gt;</span><br><span class="line">      &lt;description&gt;$&#123;description&#125;&lt;/description&gt;</span><br><span class="line">      &lt;button&gt;</span><br><span class="line">        &lt;text&gt;<span class="type">OK</span>&lt;/text&gt;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/alertTemplate&gt;</span><br><span class="line">  &lt;/document&gt;`</span><br></pre></td></tr></table></figure>
<p>这里解释一下上述代码：</p>
<ol>
<li>一个TVML文件的第一级标签是<code>&lt;document&gt;</code>，也就是整个模板内容是由<code>&lt;document&gt;</code>和<code>&lt;/document&gt;</code>包起来的。</li>
<li>接着你们开始定义模板。使用Apple提供的 <strong>alertTemplate</strong> 模板，通过<code>createAlert</code>函数将其返回。</li>
<li>在该模板里，根据Apple的<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">Apple TV Markup Language Reference</a>文档规范，添加了按钮、标题、描述三个标签。</li>
</ol>
<p>保存你们刚才编辑的JavaScript文件，再次编译运行。你们看到在提示信息下面出现了一个按钮。瞧，TVML是不是将构建tvOS UI变得很简单！</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-9.png" alt="tvOS-9"></p>
<blockquote>
<p>注意：在一个模板中，你能添加的元素数量和类型基于这个的模板的类型。比如，一个 <strong>loading Template</strong> 就不允许有任何按钮出现。此外，你可以自定义字体、颜色和其他一些属性。但是这些知识已经超越了该教程的范畴。你们可以查阅<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/index.html#//apple_ref/doc/uid/TP40015064-CH41-SW1" target="_blank" rel="external">Apple TV Markup Language Reference</a>文档去了解更多TVML模板的信息。</p>
</blockquote>
<h2 id="u4E30_u5BCCJavaScript_u5BA2_u6237_u7AEF"><a href="#u4E30_u5BCCJavaScript_u5BA2_u6237_u7AEF" class="headerlink" title="丰富JavaScript客户端"></a>丰富JavaScript客户端</h2><p>到目前为止，你们已经完成了一些工作，并且正按照我们的指引一步一步达成目标。在这一节中，你们将要花一点时间在不同的JavaScript文件中将一些逻辑抽象出来，便于能更好的重用。</p>
<p>在 <strong>client/js</strong> 文件夹中新建一个JavaScript文件，名为 <strong>Presenter.js</strong> 。在该文件中，你们将定义<code>Presenter</code>类用于处理导航各个界面，或者说各个TVML模板文件，并且处理事件响应。在 <strong>Presenter.js</strong> 中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Presenter</span> = &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  makeDocument: function(resource) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="type">Presenter</span>.parser) &#123;</span><br><span class="line">      <span class="type">Presenter</span>.parser = new <span class="type">DOMParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> doc = <span class="type">Presenter</span>.parser.parseFromString(resource, <span class="string">"application/xml"</span>);</span><br><span class="line">    <span class="keyword">return</span> doc;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  modalDialogPresenter: function(xml) &#123;</span><br><span class="line">    navigationDocument.presentModal(xml);</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  pushDocument: function(xml) &#123;</span><br><span class="line">    navigationDocument.pushDocument(xml);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们解释一下上述代码：</p>
<ol>
<li>还记得你们在之前<code>createAlert</code>函数中用过的<code>DOMParser</code>类么，它可以将TVML字符串转换为可用于展示的TVML模板对象。因为该类不需要多次创建实例，所以采用单例模式创建它。然后通过<code>DOMParser</code>的<code>parseFormString()</code>方法将TVML字符串转为模板对象。</li>
<li><code>modalDialogPresenter</code>方法通过传入的TVML模板文件，将其模态的展现在屏幕上。</li>
<li><code>pushDocument</code>方法是在导航栈中推送一个TVML模板文件，相当于在iOS中push出一个界面。</li>
</ol>
<p>在之后，你们还会用到<code>Presenter</code>类管理选中处理操作。现在，让我们使用<code>Presenter</code>类对之前的JavaScript代码进行重构。将<code>App.onLaunch</code>中的代码替换为如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">App</span>.onLaunch = function(options) &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> javascriptFiles = [</span><br><span class="line">    `$&#123;options.<span class="type">BASEURL</span>&#125;js/<span class="type">Presenter</span>.js`</span><br><span class="line">  ];</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  evaluateScripts(javascriptFiles, function(success) &#123;</span><br><span class="line">    <span class="keyword">if</span>(success) &#123;</span><br><span class="line">      <span class="keyword">var</span> alert = createAlert(<span class="string">"Hello World!"</span>, <span class="string">""</span>);</span><br><span class="line">      <span class="type">Presenter</span>.modalDialogPresenter(alert);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 3 Handle the error CHALLENGE!//inside else statement of evaluateScripts. </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码相对还是比较容易理解的，我们来看一下：</p>
<ol>
<li>首先创建一个新的JavaScript文件的数组。然后通过<code>options</code>参数获取到<code>BASEURL</code>属性，并组装<code>Presenter.js</code>的路径。这里的<code>options</code>就是之前我们在<code>AppDelegate</code>类中创建的<code>TVApplicationControllerContext</code>，<code>BASEURL</code>自然也是那时我们设置的。</li>
<li><code>evaluateScripts</code>将加载JavaScript文件。</li>
<li>这里，你应该处理异常信息，稍后我们完善这里。</li>
</ol>
<p>在继续进行之前，编译运行程序，确保JavaScript文件修改过之后程序仍能正常运行。此时，我们通过<code>Presenter</code>类对JavaScript代码的重构有了一个良好的开端：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-10.png" alt="tvOS-10"></p>
<p>现在，看看上面代码中被注释的那行，你们能否自行完成对异常处理的挑战呢。如果<code>evaluateScripts</code>处理失败，可能是因为JavaScript文件的路径写错了，那么你可能会希望在此时显示一个提示消息给用户。<strong>提示：</strong> 之所以在这里出现了异常，是因为<code>Presenter</code>类加载失败导致，所以在这里你不能使用<code>Presenter</code>类显示提示信息的界面。</p>
<p>你应该通过之前所学到的知识来解决该问题。如果你们觉得有困难，那么可以参照下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//将这两行代码插入evaluateScripts的else代码块中. </span></span><br><span class="line"><span class="keyword">var</span> errorDoc = createAlert(<span class="string">"Evaluate Scripts Error"</span>, <span class="string">"Error attempting to evaluate external JavaScript files."</span>);</span><br><span class="line">navigationDocument.presentModal(errorDoc);</span><br></pre></td></tr></table></figure>
<p>想要测试错误信息，你们可以修改一下JavaScript文件的路径，比如把<code>Presenter.js</code>改为<code>Presentr.js</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$&#123;options.<span class="type">BASEURL</span>&#125;js/<span class="type">Presentr</span>.js</span><br></pre></td></tr></table></figure>
<h2 id="u4F7F_u7528CatalogTemplate"><a href="#u4F7F_u7528CatalogTemplate" class="headerlink" title="使用CatalogTemplate"></a>使用CatalogTemplate</h2><p><strong>catalogTemplate</strong>模板同样也是Apple提供的18个模板中的一个。它的作用是以分组的形式展现内容，用它来展示你们最喜欢的RWDevCon视频最好不过了！ <strong>catalogTemplate</strong>有许多有意思的元素：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-11.jpg" alt="tvOS-11"></p>
<h3 id="u590D_u5408_u5143_u7D20_u548C_u7B80_u5355_u5143_u7D20"><a href="#u590D_u5408_u5143_u7D20_u548C_u7B80_u5355_u5143_u7D20" class="headerlink" title="复合元素和简单元素"></a>复合元素和简单元素</h3><p>该模板中的<code>banner</code>元素在应用顶部，用于展示应用基本信息，比如名称、标题等。它本身是一个 <strong>复合元素</strong> ，也就是说它是由多个 <strong>简单元素</strong> 组合而成。比如，在<code>banner</code>中很显然有标题，那么该标题就是一个简单的<code>title</code>元素，并且在<code>title</code>背后还有背景图片，这又是另外一个简单元素<code>background</code>。所以<code>banner</code>是由两个简单元素组合而成。</p>
<p>让我们来试试这个模板吧。打开 <strong>client</strong> 文件夹，在 <strong>js</strong> 文件夹的同级目录新建两个文件夹，分别命名为 <strong>images</strong> 和 <strong>templates</strong> 。此时你的 <strong>client</strong> 文件夹里的内容应该是这样的：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-12.png" alt="tvOS-12"></p>
<p>你们会需要图片构建模板中的Cells，在我们这个场景中就是一个一个的视频，图片自然就是视频的封面了。我已经为你们准备好了封面图片，你们可以从<a href="/cdn3.raywenderlich.com/wp-content/uploads/2015/09/images.zip">这里下载</a>。下载成功后，将他们解压放在刚才你们创建的 <strong>images</strong> 文件夹中。</p>
<p>现在，你们即将要做的工作是在屏幕中显示图片!新建一个JavaScript文件，命名为 <strong>RWDevConTemplate.xml.js</strong> ，将其存在 <strong>templates</strong> 文件夹中。</p>
<p>打开 <strong>RWDevConTemplate.xml.js</strong> ，添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Template</span> = function() &#123; <span class="keyword">return</span> `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;catalogTemplate&gt;</span><br><span class="line">      &lt;banner&gt;</span><br><span class="line">        &lt;title&gt;<span class="type">RWDevConHighlights</span>&lt;/title&gt;</span><br><span class="line">      &lt;/banner&gt;</span><br><span class="line">    &lt;/catalogTemplate&gt;</span><br><span class="line">  &lt;/document&gt;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们试图通过<code>catalogTemplate</code>模板显示一个Banner条。但在使用只包含模板信息的JavaScript文件之前，我们需要通过某种方法让其他的JavaScript文件知道该文件的存在并能加载其模板信息，因为当前它没有通过任何方式向其他JavaScript文件暴露过。所以我们要创建的最后一个JavaScript文件： <strong>ResourceLoader.js</strong> 就是用来解决该问题的！</p>
<h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>新建一个JavaScript文件，命名为 <strong>ResourceLoader.js</strong> ，保存在 <strong>js</strong> 文件夹中，和 <strong>application.js</strong> 、 <strong>Presenter.js</strong> 一起。打开 <strong>ResourceLoader.js</strong> 添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function <span class="type">ResourceLoader</span>(baseurl) &#123;</span><br><span class="line">  this.<span class="type">BASEURL</span> = baseurl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">ResourceLoader</span>.prototype.loadResource = function(resource, callback) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">self</span> = this;</span><br><span class="line">  evaluateScripts([resource], function(success) &#123;</span><br><span class="line">    <span class="keyword">if</span>(success) &#123;</span><br><span class="line">      <span class="keyword">var</span> resource = <span class="type">Template</span>.call(<span class="keyword">self</span>);</span><br><span class="line">      callback.call(<span class="keyword">self</span>, resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> title = <span class="string">"Resource Loader Error"</span>,</span><br><span class="line">          description = `<span class="type">Error</span> loading resource '$&#123;resource&#125;'. \n\n <span class="type">Try</span> again later.`,</span><br><span class="line">          alert = createAlert(title, description);</span><br><span class="line">      navigationDocument.presentModal(alert);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不用过于担心看不懂这些代码逐行的含义，你们只要清楚这些代码的作用是加载其他模板文件就可以了。</p>
<p>之前我们的主屏显示的是“Hello World”的提示信息模板，现在试着将它换成我们创建的<code>RWDevConTemplate</code>。打开 <strong>application.js</strong> 文件，根据如下代码修改之前的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> resourceLoader;</span><br><span class="line"> </span><br><span class="line"><span class="type">App</span>.onLaunch = function(options) &#123;</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">var</span> javascriptFiles = [</span><br><span class="line">    `$&#123;options.<span class="type">BASEURL</span>&#125;js/<span class="type">ResourceLoader</span>.js`, </span><br><span class="line">    `$&#123;options.<span class="type">BASEURL</span>&#125;js/<span class="type">Presenter</span>.js`</span><br><span class="line">  ];</span><br><span class="line"> </span><br><span class="line">  evaluateScripts(javascriptFiles, function(success) &#123;</span><br><span class="line">    <span class="keyword">if</span>(success) &#123;</span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      resourceLoader = new <span class="type">ResourceLoader</span>(options.<span class="type">BASEURL</span>);</span><br><span class="line">      resourceLoader.loadResource(`$&#123;options.<span class="type">BASEURL</span>&#125;templates/<span class="type">RWDevConTemplate</span>.xml.js`, function(resource) &#123;</span><br><span class="line">        <span class="keyword">var</span> doc = <span class="type">Presenter</span>.makeDocument(resource);</span><br><span class="line">        <span class="type">Presenter</span>.pushDocument(doc);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> errorDoc = createAlert(<span class="string">"Evaluate Scripts Error"</span>, <span class="string">"Error attempting to evaluate external JavaScript files."</span>);</span><br><span class="line">      navigationDocument.presentModal(errorDoc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 先不管createAlert函数</span></span><br></pre></td></tr></table></figure>
<p>此时你们已经对之前的代码进行了三处的修改：</p>
<ol>
<li>申明了一个<code>resourceLoader</code>变量。</li>
<li>将 <strong>ResourceLoader.js</strong> 文件添加到JavaScript文件数组中。</li>
<li>使用<code>resourceLoader</code>加载TVML模板，然后使用<code>Presenter</code>展现在屏幕上。</li>
</ol>
<p>编译运行程序，你们应该会看到如下界面：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-13.png" alt="tvOS-13"></p>
<p>恭喜你们，现在你们已经可以通过更好的方式从JavaScript文件中加载TVML模板信息了，而不再使用硬编码写死在代码里！</p>
<h3 id="u5B8C_u5584catalogTemplate"><a href="#u5B8C_u5584catalogTemplate" class="headerlink" title="完善catalogTemplate"></a>完善catalogTemplate</h3><p>你管你们信不信，我们要做的tvOS应用马上要接近尾声了。通过TVML开发tvOS应用最优雅的一件事就是添加界面元素非常之简单。</p>
<p>打开 <strong>RWDevConTemplate.xml.js</strong> 文件，按照如下代码更新之前代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Template</span> = function() &#123; <span class="keyword">return</span> `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;catalogTemplate&gt; </span><br><span class="line">      &lt;banner&gt; </span><br><span class="line">        &lt;title&gt;<span class="type">RWDevConHighlights</span>&lt;/title&gt;</span><br><span class="line">      &lt;/banner&gt;</span><br><span class="line">      <span class="comment">//add stuff here</span></span><br><span class="line">      <span class="comment">//1.</span></span><br><span class="line">      &lt;list&gt; </span><br><span class="line">        &lt;section&gt; </span><br><span class="line">          <span class="comment">//2.</span></span><br><span class="line">	  &lt;listItemLockup&gt; </span><br><span class="line">	    &lt;title&gt;<span class="type">Inspiration</span> <span class="type">Videos</span>&lt;/title&gt;</span><br><span class="line">	    &lt;decorationLabel&gt;<span class="number">13</span>&lt;/decorationLabel&gt;</span><br><span class="line">	  &lt;/listItemLockup&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">      &lt;/list&gt;</span><br><span class="line">    &lt;/catalogTemplate&gt;</span><br><span class="line">  &lt;/document&gt;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在上面的代码中，新定义了一个list标签，该标签中的内容就是显示在屏幕上除了Banner以外的全部内容。</li>
<li><code>listItemLockup</code>代表一个组，它以<code>listItemLockup</code>标签开头。在该标签中，通过<code>title</code>标签定义了它的名称“Inspiration Videos”，然后通过<code>decorationLabel</code>标签定义了该组中包含内容的数量。</li>
</ol>
<p>编译运行程序，在模拟器中你们会看到如下界面：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-14.png" alt="tvOS-14"></p>
<p>看着还不赖吧！</p>
<h3 id="u5B8C_u6210catalogTemplate"><a href="#u5B8C_u6210catalogTemplate" class="headerlink" title="完成catalogTemplate"></a>完成catalogTemplate</h3><p>最后，我们准备在模板中添加cell，用于展示每一个视频。打开 <strong>RWDevConTemplate.xml.js</strong> 添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Template</span> = function() &#123; <span class="keyword">return</span> `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;catalogTemplate&gt; </span><br><span class="line">      &lt;banner&gt; </span><br><span class="line">        &lt;title&gt;<span class="type">RWDevConHighlights</span>&lt;/title&gt;</span><br><span class="line">      &lt;/banner&gt;</span><br><span class="line">      &lt;list&gt; </span><br><span class="line">        &lt;section&gt; </span><br><span class="line">	  &lt;listItemLockup&gt; </span><br><span class="line">	    &lt;title&gt;<span class="type">Inspiration</span> <span class="type">Videos</span>&lt;/title&gt;</span><br><span class="line">	    &lt;decorationLabel&gt;<span class="number">13</span>&lt;/decorationLabel&gt;</span><br><span class="line">            <span class="comment">//1. add from here</span></span><br><span class="line">	    &lt;relatedContent&gt; </span><br><span class="line">	      &lt;grid&gt;</span><br><span class="line">	        &lt;section&gt; </span><br><span class="line">                  <span class="comment">//2</span></span><br><span class="line">		  &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Ray-Wenderlich-Teamwork.mp4"</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/ray.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">		  &lt;/lockup&gt;</span><br><span class="line">		  &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Ryan-Nystrom-Contributing.mp4"</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/ryan.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">		  &lt;/lockup&gt;									</span><br><span class="line">	          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Matthijs-Hollemans-Math-Isnt-Scary.mp4"</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/matthijs.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">		  &lt;/lockup&gt;									</span><br><span class="line">		  &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Vicki-Wenderlich-Identity.mp4"</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/vicki.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">		  &lt;/lockup&gt;									</span><br><span class="line">	          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Alexis-Gallagher-Identity.mp4"</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/alexis.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">	          &lt;/lockup&gt;									</span><br><span class="line">		  &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Marin-Todorov-RW-Folklore.mp4"</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/marin.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">		  &lt;/lockup&gt;									</span><br><span class="line">		  &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Chris-Wagner-Craftsmanship.mp4"</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/chris.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">	          &lt;/lockup&gt;									</span><br><span class="line">		  &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Cesare-Rocchi-Cognition.mp4"</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/cesare.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">		  &lt;/lockup&gt;									</span><br><span class="line">		  &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Ellen-Shapiro-Starting-Over.mp4"</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/ellen.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">		  &lt;/lockup&gt;									</span><br><span class="line">		  &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Jake-Gundersen-Opportunity.mp4"</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/jake.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">		  &lt;/lockup&gt;									</span><br><span class="line">		  &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Kim-Pedersen-Finishing.mp4"</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/kim.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">		  &lt;/lockup&gt;									</span><br><span class="line">	          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Tammy-Coron-Possible.mp4"</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/tammy.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">		  &lt;/lockup&gt;									</span><br><span class="line">		  &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Saul-Mora-NSBrief.mp4"</span>&gt;</span><br><span class="line">		    &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/saul.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">		  &lt;/lockup&gt;		</span><br><span class="line">		&lt;/section&gt;</span><br><span class="line">	      &lt;/grid&gt;</span><br><span class="line">	    &lt;/relatedContent&gt;</span><br><span class="line">	  &lt;/listItemLockup&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">      &lt;/list&gt;</span><br><span class="line">    &lt;/catalogTemplate&gt;</span><br><span class="line">  &lt;/document&gt;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>从上述代码中可以看到，在<code>listItemLockup</code>标签中添加了<code>relatedContent</code>，该标签是的作用是显示图中红色圆圈区域的：</li>
</ol>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-15.png" alt="tvOS-15"></p>
<ol>
<li>每个<code>lockup</code>代表一个视频，每个该标签中都有<code>videoURL</code>的属性，它的值就是 <strong>RWDevCon</strong> 网站上视频的地址。对于之后播放视频至关重要。</li>
</ol>
<p>编译运行程序，会看到被你赋予新生命力的应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-16.png" alt="tvOS-16"></p>
<p>现在，我们已经在“Inspiration Videos”这个组里添加了若干视频。让我们打开遥控器的模拟器，选中模拟器，在菜单栏中选择 <strong>Hardware\Show Apple TV Remote</strong> 。你可以通过遥控器中的 <strong>option</strong> 键选择不同的视频。</p>
<h2 id="u64AD_u653E_u89C6_u9891"><a href="#u64AD_u653E_u89C6_u9891" class="headerlink" title="播放视频"></a>播放视频</h2><p>到目前为止，我们已经构建好了应用的页面，看起来还是不错的。此时，你们可以再想想如果用iOS框架完成你们现在已经完成的布局，应该如何做。Apple把一些UI的细节全都抽象了出来，通过一个个模板提供给我们使用，可以让我们简单方便的通过模板创建出完美的界面，不得不说Apple做的太棒了。</p>
<p>接下来让我们完成最后两个遗留的功能：选择视频和播放视频。</p>
<h3 id="u9009_u62E9_u4E8B_u4EF6"><a href="#u9009_u62E9_u4E8B_u4EF6" class="headerlink" title="选择事件"></a>选择事件</h3><p>你们可能已经注意到了，当按下 <strong>enter</strong> 键或者在 <strong>Apple TV Remote</strong> 选择视频时并没有什么反应，所以是时候来实现选择视频的功能了。</p>
<p>打开<code>Presenter</code>，添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">load: function(event) &#123;</span><br><span class="line">  <span class="comment">//1</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">self</span> = this,</span><br><span class="line">  ele = event.target,</span><br><span class="line">  videoURL = ele.getAttribute(<span class="string">"videoURL"</span>)</span><br><span class="line">  <span class="keyword">if</span>(videoURL) &#123;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">var</span> player = new <span class="type">Player</span>();</span><br><span class="line">    <span class="keyword">var</span> playlist = new <span class="type">Playlist</span>();</span><br><span class="line">    <span class="keyword">var</span> mediaItem = new <span class="type">MediaItem</span>(<span class="string">"video"</span>, videoURL);</span><br><span class="line"> </span><br><span class="line">    player.playlist = playlist;</span><br><span class="line">    player.playlist.push(mediaItem);</span><br><span class="line">    player.present();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ol>
<li><code>load</code>函数用来处理视频选择事件。它相当于iOS中的<code>@IBAction</code>，该函数的<code>event</code>参数相当于<code>sender</code>参数。每个<code>event</code>都有一个<code>target</code>，每个<code>target</code>关联着模板中的<code>lockup</code>元素。一个<code>lockup</code>代表应用中的一个视频，它里面有视频封面的属性，以及视频地址<code>videoURL</code>属性。</li>
<li>播放视频非常简单。<code>Player</code>是 <strong>TVJS</strong> 框架提供的一个类，负责所有视频播放的相关功能。你们所要做的只是添加一个播放列表<code>playlist</code>，然后将要播放的项目<code>mediaItem</code>添加到播放列表里。最后通过<code>player.present()</code>方法就可以播放视频了。</li>
</ol>
<p>现在你们已经实现了选择视频后的响应事件。是时候将选择事件与每个视频关联在一起了。打开 <strong>application.js</strong> 文件，在<code>App.onLaunch</code>方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">App</span>.onLaunch = function(options) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//在resourceLoader.loadResource中...</span></span><br><span class="line">  <span class="keyword">var</span> doc = <span class="type">Presenter</span>.makeDocument(resource);</span><br><span class="line">  doc.addEventListener(<span class="string">"select"</span>, <span class="type">Presenter</span>.load.bind(<span class="type">Presenter</span>)); <span class="comment">//add this line</span></span><br><span class="line">  <span class="type">Presenter</span>.pushDocument(doc);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的<code>addEventListener</code>方法相当于iOS中按钮的<code>@IBAction</code>。编译运行程序，选择一个视频播放，你会看到一个完美的视频播放应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-17.gif" alt="tvOS-17"></p>
<p>大家可以在这里下载教程中的完整项目：<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/client.zip" target="_blank" rel="external">client</a>和<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/RWDevCon.zip" target="_blank" rel="external">RWDevCon</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作者：<a href="http://www.raywenderlich.com/u/Kelvin%20Lau" target="_blank" rel="external">Kelvin Lau</a> 原文地址：<a href="http://www.raywender]]>
    </summary>
    
      <category term="Apple TV" scheme="http://www.devtalking.com/tags/Apple-TV/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CALayer Animation - Gradient Animation]]></title>
    <link href="http://www.devtalking.com//articles/calayer-animation-gradient-animation/"/>
    <id>http://www.devtalking.com//articles/calayer-animation-gradient-animation/</id>
    <published>2015-09-21T16:00:00.000Z</published>
    <updated>2016-01-02T15:42:11.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-09-22/2825765" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>在很多人的心目中iPhone的经典机型应该是iPhone4，精湛的工艺、完美的屏幕配上暗色的锁屏壁纸，看着屏幕底部闪烁的<strong>slide to unlock</strong>字样，高逼格彰显无遗。时至今日无论iPhone机身样式如何改变，屏幕尺寸如何改变，iOS系统如何改变，唯有锁屏底部闪烁的<strong>滑动来解锁</strong>不变。它的动画效果是如何实现的呢，这篇文章会告诉你们答案。</p>
<h2 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h2><p>新建一个应用名为<strong>GradientAnimation</strong>，打开<code>Main.storyboard</code>，将ViewController的View背景色设置为灰黑色，拖一个UIView到ViewController中，将其颜色设置为无色并设置好布局约束：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-1.png" alt="GradientAnimation - 1"></p>
<p>接着我们拖一个UILabel到刚才拖入的UIView中，设置高宽等同于它的父视图：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-2.png" alt="GradientAnimation - 2"></p>
<p>我对该UILabel的属性设置如下：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-4.png" alt="GradientAnimation - 4"></p>
<p>之后，我们在<code>ViewController</code>中添加UIView和UILabel的Outlet：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-5.png" alt="GradientAnimation - 5"></p>
<p>接下来回到<code>ViewController.swift</code>，我们添加一个常量属性<code>gradientLayer</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> gradientLayer = <span class="type">CAGradientLayer</span>()</span><br></pre></td></tr></table></figure>
<p>这里出现了CALayer的另一个子类CAGradientLayer，这个类的作用就是能在Layer上绘制出渐变颜色的效果，然后在<code>viewDidLoad()</code>中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gradientLayer.bounds = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: backgroundView.frame.size.width, height: backgroundView.frame.size.height)</span><br><span class="line">gradientLayer.position = <span class="type">CGPoint</span>(x: backgroundView.frame.size.width/<span class="number">2</span>, y: backgroundView.frame.size.height/<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>上述两行的代码是设置Layer的大小及位置，这在上两篇文章中已经讲过，这里就不再累赘了。接着我们继续添加两行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gradientLayer.startPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0.5</span>)</span><br><span class="line">gradientLayer.endPoint = <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>既然CAGradientLayer可以绘制出渐变颜色的效果，那自然有颜色渐变的方向，所以这两行代码的作用就是设置颜色渐变的起始点和结束点，这两个属性共同决定了颜色渐变的方向：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-3.png" alt="GradientAnimation - 3"></p>
<p>从上面的示意图中可以看出，CAGradientLayer是通过起始点和结束点的坐标位置来决定颜色渐变的方向的，起始点的默认值是(0.5, 0)，结束点的默认值是(0.5, 1)，也就是说默认的颜色渐变方向是沿垂直中线从上往下渐变的，我们在这里将它改成了沿水平中线从左往右渐变。</p>
<p>接下来我们设置CAGradientLayer的渐变颜色，接着添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gradientLayer.colors = [</span><br><span class="line">    <span class="type">UIColor</span>.blackColor().<span class="type">CGColor</span>,</span><br><span class="line">    <span class="type">UIColor</span>.whiteColor().<span class="type">CGColor</span>,</span><br><span class="line">    <span class="type">UIColor</span>.blackColor().<span class="type">CGColor</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>CAGradientLayer的<code>colors</code>属性类型是一个数组<code>[AnyObject]</code>，这就意味着我们可以实现多个颜色的渐变效果，并且可以规定各个颜色的顺序。不过在我们这个示例中我们只需要两种颜色，不过需要注意的是虽然颜色只有两种，但是整个颜色渐变的过程中有三个原色点，那就是黑、白、黑，所以我们在这个数组中也需要按照原色点的数量和顺序添加相应的颜色，哪怕颜色都是一样的。</p>
<p>我们既然设置了渐变的三个原色，那么就要对这原色出现的位置进行设置，接着添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gradientLayer.locations = [<span class="number">0.2</span>, <span class="number">0.5</span>, <span class="number">0.8</span>]</span><br></pre></td></tr></table></figure>
<p>从上述代码中不难看出，我们将第一个黑色原色出现的位置设置在了整个Layer长度的十分之二的位置，第二个白色原色在中间，第三个黑色原色在十分之八的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-6.png" alt="GradientAnimation - 6"></p>
<p>设置完CAGradientLayer的相关属性后，我们将<code>gradientLayer</code>添加到<code>backgroundView</code>的Layer中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">backgroundView.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure>
<p>现在我们编译运行一下代码看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-7.png" alt="GradientAnimation - 7"></p>
<p>接下来我们需要让颜色渐变动起来，先创建一个方法<code>gradinetAnimate()</code>，在方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> gradient = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"locations"</span>)</span><br><span class="line">gradient.fromValue = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.25</span>]</span><br><span class="line">gradient.toValue = [<span class="number">0.75</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">gradient.duration = <span class="number">2.5</span></span><br><span class="line">gradient.repeatCount = <span class="type">HUGE</span></span><br><span class="line">gradientLayer.addAnimation(gradient, forKey: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>首先，创建了一个<code>locations</code>类型的动画实例<code>gradient</code>，将<code>fromValue</code>属性，也就是起始位置的属性设置为<code>[0, 0, 0.25]</code>，它的意思是动画开始前，黑色、白色这两个原色的位置在整个Layer的最前端，第二个黑色原色在0.25的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-8.png" alt="GradientAnimation - 8"></p>
<p>而结束位置<code>toValue</code>，将白色和第二个黑色原色位置设置在整个Layer的末端，第一个黑色原色在0.75的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-9.png" alt="GradientAnimation - 9"></p>
<p>从图中可以看出，此时整个Layer都变成了黑色。也就是说，在整个动画中，第一个黑色原色从0移动到0.75的位置，白色原色从0移动到1的位置，第二个黑色原色从0.25移动到1的位置。然后设置动画时间为2.5秒，无线重复次数，最后将<code>gradient</code>动画添加到<code>gradientLayer</code>中。我们在<code>viewDidAppear()</code>方法中调用该动画方法<code>gradientAnimate()</code>，编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-10.gif" alt="GradientAnimation - 10"></p>
<p>动画效果还不赖，但是如何将颜色渐变的动画作用在UILabel的文字上呢？其实非常简单，就是让UILabel上的文字称为CAGradientLayer的遮罩即可，我们先在<code>ViewController</code>中定义一个常量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"DevTalking"</span></span><br></pre></td></tr></table></figure>
<p>然后在<code>viewDidAppear()</code>中的<code>gradientAnimate()</code>方法之前添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">textLabel.text = text</span><br><span class="line">gradientLayer.mask = textLabel.layer</span><br></pre></td></tr></table></figure>
<p>我们再编译运行代码看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-11.gif" alt="GradientAnimation - 11"></p>
<p>到目前为止，锁屏中<strong>滑动来解锁</strong>的动画效果就完成了，这个动画效果在Facebook的Paper应用中也有使用。下一节，我们在该动画的基础上对文字再加点小动画。</p>
<h2 id="Text_Animation"><a href="#Text_Animation" class="headerlink" title="Text Animation"></a>Text Animation</h2><p>首先我们打开<code>AppDelegate.swift</code>，在<code>import UIKit</code>下面添加一个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">delay</span><span class="params">(seconds seconds: Double, completion:<span class="params">()</span></span></span>-&gt;()) &#123;</span><br><span class="line">    <span class="keyword">let</span> intervalTime = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="type">Int64</span>( <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>) * seconds ))</span><br><span class="line">    </span><br><span class="line">    dispatch_after(intervalTime, dispatch_get_main_queue(), &#123;</span><br><span class="line">        completion()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的作用如其名称一样，是一个延迟方法，该方法的第一个参数是想要延迟的时间，第二个参数是一个闭包，也就是延迟的主体。这个方法用到了GCD的知识，<code>dispatch_time</code>主要是用于创建一个类型为<code>dispatch_time_t</code>的相对时间，它的第一个参数指的是起始时间，一般都是用预定义的<code>DISPATCH_TIME_NOW</code>作为第一个参数的值，代表当前的时间。第二个参数代表时间间隔，注意这个参数需要的时间单位是纳秒，所以我们使用预定义的<code>NSEC_PER_SEC</code>纳秒单位乘以希望间隔的秒数。</p>
<p><code>dispatch_after</code>用于在队列中定时执行任务，当你想在一段时间后执行一个任务，那么就可以用这个函数。该函数的第一个参数指定延迟的时间，第二个参数指定一个队列，用于添加任务，第三个参数是一个闭包，也就是要执行的任务。</p>
<p>然后回到<code>ViewController.swift</code>，添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">textAnimate</span><span class="params">(text: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> text.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        textLabel.text = <span class="string">"<span class="subst">\(textLabel.text!)</span><span class="subst">\(text.substringToIndex(text.startIndex.successor()</span>))"</span></span><br><span class="line">        delay(seconds: <span class="number">0.4</span>, completion: &#123;</span><br><span class="line">            <span class="keyword">self</span>.textAnimate(text.substringFromIndex(text.startIndex.successor()))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的参数<code>text</code>就是UILabel中要显示的文字内容。<code>substringToIndex(_ to: Int)</code>方法的作用是从字符串的开头一直截取到指定的位置，但不包括该指定位置的字符。<code>text.startIndex.successor()</code>这句意思是从<code>text</code>的起始位置开始取后面的一个字符。<code>substringFromIndex(_ from: Int)</code>方法的作用是以指定位置并包括指定位置的字符开始，一直截取之后的全部字符。所以整个方法的作用是每隔0.4秒显示一个字符，直到将整个字符串显示完。最后在<code>viewDidAppear()</code>中注释掉<code>textLabel.text = text</code>这行代码，并在方法最后调用<code>textAnimate(text)</code>方法。编译运行代码看看最终效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-12.gif" alt="GradientAnimation - 12"></p>
<p>参考文献来自：<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-09-22/2825765" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>在很多人的心目中iPhone的]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ 一个iOS开发者对tvOS SDK的初探]]></title>
    <link href="http://www.devtalking.com//articles/tvOS-initial-impression/"/>
    <id>http://www.devtalking.com//articles/tvOS-initial-impression/</id>
    <published>2015-09-16T16:00:00.000Z</published>
    <updated>2016-01-01T14:18:38.000Z</updated>
    <content type="html"><![CDATA[<p>作者：<a href="http://www.raywenderlich.com/u/cwagdev" target="_blank" rel="external">Chris Wagner</a>  原文地址：<a href="http://www.raywenderlich.com/114313/tvos-initial-impressions" target="_blank" rel="external">tvOS SDK: An iOS Developer’s Initial Impressions</a></p>
<p>在Walter Isaacson编写的《Steve Jobs》的最后一章中，Steve说过“我最终实现并让它拥有了你们能想象到的最简单的用户界面”。当时他指的就是Apple TV。</p>
<p>Steve不幸离世已经过去很久了，但是人们一直翘首以盼着这款产品。就在昨天2015年9月9日，超过四个春秋的期盼，我们终于等来了这个礼物，虽然可能与Steve对这款产品的愿景和理想有所差距，但是革命的步伐已经坚实的迈出了第一步。</p>
<p>作为一名iOS开发者，昨天的产品发布会让我心潮澎湃，因为Apple宣布，新的Apple TV集成了App Store，这就意味着我们可以为它开发专有的应用，并且会让我们重新认知已了解的iOS知识，以及会开启更多新的展现想法、创意的机会。</p>
<p>我和其他教程团队的成员已经开始深入研究tvOS SDK，并且正在努力准备一些有价值的tvOS教程（通宵达旦！），在此同时，我想从一个iOS开发者的视角与大家分享我对tvOS的初步印象。</p>
<p>让我们一探究竟吧！</p>
<h2 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h2><p>老款的Apple TV其实类似一个机顶盒，主要提供的功能是让用户通过及其简单的操作界面导航或浏览视频内容。昨天发布的新Apple TV在此基础上进一步的扩充功能，使一些成熟的应用能在Apple TV中运行，比如购物应用，甚至是游戏。</p>
<p><img src="http://d.pr/i/lDJy+" alt="tvOS-1"></p>
<p>让我们来看看以下这些信息：</p>
<ul>
<li><strong>硬件规格：</strong> 值得一说规格是64位 A8处理器，32G或64G的存储空间，2G的内存，1080p的分辨率以及支持HDMI，Siri远程遥控，新的Apple TV遥控器。</li>
<li><strong>价格：</strong> 新Apple TV的定价为32G 149美元，64G 199美元。这样的定价出乎大多人的以外，原以为新Apple TV的价格会更高一些。</li>
<li><strong>发售时间：</strong> Apple在发布会上给出了一个非常模糊和不确定的发售时间“十月下旬”，但是Apple在发布会之后就立即向开发者们提供了tvOS SDK。现在离正式发售已时日不多，如果大家有针对新Apple TV好的想法，我建议你们要抓紧时间了。</li>
<li><strong>开发硬件：</strong> Apple已经宣布了一个开发者计划允许已经注册的开发者们请求<a href="https://developer.apple.com/tvos/developer-kit/" target="_blank" rel="external">Apple TV Developer Kit</a>。该计划可以让开发者们提前对Apple TV进行开发测试。这看起来似乎是一件很美好的事，但是如果你真的要加入该开发者计划，那么仔细看看下面的建议：</li>
</ul>
<p>-&gt; <strong>注意：</strong> 众所周知，iOS、OSX的开发者计划都是收费的，tvOS的开发者计划应该也不例外，不过之前对于该计划的收费信息是非常含糊不清的，但是现在我们通过Apple员工在开发者论坛上发的帖子中<a href="https://forums.developer.apple.com/thread/16984#51332" target="_blank" rel="external">确认</a>了该计划只需要话费1美元即可加入。如果大家有意为tvOS贡献一份力量，或者需要编写教程材料的话，强烈建议你们加入该开发计划。</p>
<h2 id="u5F00_u53D1_tvOS__u5E94_u7528"><a href="#u5F00_u53D1_tvOS__u5E94_u7528" class="headerlink" title="开发 tvOS 应用"></a>开发 tvOS 应用</h2><p>啰嗦完一堆后，显然最重要的事就是怎样为新Apple TV开发应用，这应该也是大家最感兴趣的事！</p>
<p>为新Apple TV开发应用实际就是在为tvOS开发应用，当然tvOS这个名字是由Apple根据不同设备而创造的。tvOS仍然是基于iOS开发的，所以有很多框架大家都应该非常熟悉了。</p>
<p>如果要为tvOS开发应用，大家必须要从开发者中心下载<a href="https://developer.apple.com/xcode/download/" target="_blank" rel="external">Xcode7.1</a>进行开发。该版本是Xcode新的beta版，目前只有该版本支持tvOS以及提供tvOS的模拟器。如果你有需要的话，也可同时下载Xcode7 GM版本，他们可以共存于你们的电脑中。</p>
<p>Apple提供了两种在tvOS上开发应用的方法：</p>
<ol>
<li><strong>TVML Apps：</strong> 这类应用是使用完整的新开发技术开发的，比如TVML、TVJS、TVMLKit。这对我们来说是一个巨大的惊喜，我们会在之后有较详细的介绍。</li>
<li><strong>Custom Apps：</strong> 这类应用是使用我们已经比较熟悉的开发技术进行开发的，比如大家熟知的一些iOS框架，Storyboard、UIKit、Auto Layout等。</li>
</ol>
<p>当你们在为Apple TV开发应用时，你们会发现Xcode中会出现单独的程序目标（这意味着用户将会单独购买的形式购买tvOS应用）。虽然Apple在发布会上说Apple TV中的应用支持通用购买模式，也就是针对iOS和tvOS都支持的应用，用户只需要购买一次即可同时在iPhone和Apple TV上使用。但是从目前的情况来看，我们还不确定Apple是如何实现的，或许在Itunes Connect中支持连接两个程序目标的功能即将来临？</p>
<h3 id="TVML_Apps"><a href="#TVML_Apps" class="headerlink" title="TVML Apps"></a>TVML Apps</h3><p>先前我提过，为tvOS开发应用有两种方式，第一种就是通过TVML、TVJS和TVMLKit技术。如果这些缩写对于你们来说非常陌生，那么不要着急，这就告诉你们他们都是什么：</p>
<ul>
<li><strong>TVML</strong>是一种基于“Television Markup Language”的XML格式。</li>
<li><strong>TVJS</strong>是基于JavaScript APIs的脚本语言，它可以根据TVML中定义的内容展示应用。</li>
<li><strong>TVMLKit</strong>是连接TVML、TVJS和原生tvOS应用的工具包。</li>
</ul>
<p>如果你是一名经常使用原生APIs开发原生iOS应用的开发者，那么看到这些类似前端的技术可能会有点退缩。但希望你能保持一颗学习的心，学习了解这些新的强大的特性。</p>
<p>我在这列举一个非常典型的Apple TV的应用场景。大家可以想象一下：你们想把一些内容或信息展现给用户，这些内容和信息储存在你们的服务器上，并且这些内容的格式、查询方式都服务于iPhone或iPad中的应用，那么你肯定会希望你的tvOS中的应用也能方便的使用这些内容，并做到与iOS中应用有相似的展现、查询、导航方式。</p>
<p><img src="http://d.pr/i/14HgX+" alt="tvOS-2"></p>
<p>如果我列举的这个例子正好是你们tvOS应用的需求，那么你可能需要考虑如何使用TVMLKit工具包。Apple已经为我们开发者完成了一些主要的工作，比如提供了许多可重用的tvOS界面展示模板，这些模板大都与iOS应用的界面神似，所以用户们并不会感到陌生，这些模板大概有18种之多。大多数模板都可以让你创建出脱凡的、非常适合家中电视展示的界面。大家可以访问Apple的<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">文档</a>查看这些我们强烈推荐使用的模板。</p>
<p><img src="http://d.pr/i/1iJ3p+" alt="tvOS-3"></p>
<p>我也推荐大家在tvOS模拟器运行<a href="https://developer.apple.com/library/prerelease/tvos/samplecode/TVMLCatalog/Introduction/Intro.html#//apple_ref/doc/uid/TP40016505" target="_blank" rel="external">TVML Catalog sample app</a>去查看每个模板。同时你需要启动一个本地的web服务器，便于tvOS应用通过模板展示内容时访问，所以你需要仔细查阅<strong>README.md</strong>文件去了解相关内容。</p>
<p>诚然TVMLKit还有许多知识点，如果你希望基于它开发一款tvOS应用，那么我提到的一些文档是非常值得你们去查阅参考的。这里我着重推荐大家首先看看如何使用菜单导航类的模板，比如<strong>menuBarTemplate</strong>、<strong>mainTemplate</strong>、<strong>searchTemplate</strong>等。然而，如果你希望用户不只是被动的通过你的tvOS应用观看或收听内容，而是希望用户与应用有更多的交互，给用户高质量的用户体验，那么你们就需要了解如何开发完整的自定义的tvOS应用。</p>
<h3 id="Custom_Apps"><a href="#Custom_Apps" class="headerlink" title="Custom Apps"></a>Custom Apps</h3><p>你所知道的大多数iOS框架，比如UIKit、Core Graphics、CloudKit等等都可以在tvOS中使用。你可以在Apple提供的这个<a href="https://developer.apple.com/library/prerelease/tvos/releasenotes/General/tvOS90APIDiffs/index.html#//apple_ref/doc/uid/TP40016577" target="_blank" rel="external">文档</a>中查看哪些框架可以用，哪些不可以使用。如果你现在正是一名iOS开发者，那么会对这个文档中的列表非常熟悉。而且不管使用Swift还是Objective-C或者C都可以开发tvOS应用。</p>
<p>尽管如此，如果想开发自定义的tvOS应用，还是有许多新的知识需要我们学习，作为一名iOS开发者，也应该掌握甚至精通这些新的知识。</p>
<h2 id="Focus_Engine"><a href="#Focus_Engine" class="headerlink" title="Focus Engine"></a>Focus Engine</h2><p>其中一个对于iOS开发者比较陌生的概念是用户输入/选择方法。在使用Apple TV的过程中，用户不会用手指去按压或滑动屏幕，取而代之的是使用Apple提供的遥控器或者是一些游戏控制器。</p>
<p>tvOS采用了一个被称为<strong>Focus Engine</strong>的引擎系统，它在整个tvOS中有且只有一个。该引擎负责响应当用户使用遥控器上的手势操作或按键操作对菜单或内容进行上下左右的选择。</p>
<p>Focus Engine会自动根据用户的选择决定要聚焦或展示的视图，你不需要在代码中做任何类似选中或导航的处理。比如说，此时展示的界面是你已经在Storyboard中设计好的视图布局，其中有一个视图是当前聚焦状态，那么当用户通过手势往右滑动时，Focus Engine会自动根据当前聚焦的视图找到与之相邻的左边的视图，并将其选中和聚焦。</p>
<p><img src="http://d.pr/i/Lpd3+" alt="tvOS-4"></p>
<p>作为一个开发者，你必须要学习与Focus Engine相关的API，比如当聚焦的视图发生变化时如何获取通知、如何通过编码触发聚焦视图的改变扥等。更多关于Focus Engine的API可以参阅App Programming Guide for tvOS文档中的<a href="https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/WorkingwiththeAppleTVRemote.html#//apple_ref/doc/uid/TP40015241-CH5-SW14" target="_blank" rel="external"> Supporting Focus Within Your App</a>章节。</p>
<h2 id="TVServices"><a href="#TVServices" class="headerlink" title="TVServices"></a>TVServices</h2><p>虽然iOS开发者在tvOS应用的开发过程中，主要使用的是一些已经比较熟悉的iOS框架，但是也有一些tvOS特有的框架需要开发者们去了解掌握，比如像新加入的<code>TVServices</code>框架。</p>
<p><code>TVServices</code>的主要作用是描述你的应用的内容，以便tvOS在首页的顶部栏位显示。在首页顶部栏位显示的应用都是用户自己设置的，用户可以将他们认为最为常用的或最为重要的应用放在首页顶部栏位，便于快速打开或浏览其中主要信息。</p>
<p><img src="http://d.pr/i/1cedk+" alt="tvOS-5"></p>
<p>你们的应用可以在用户不进入应用的情况下，向用户提供简短的、感兴趣的信息，这就会使你的应用有了额外价值，使用<code>TVServices</code>无疑是提高你的应用下载量的绝佳手段。比如一个游戏应用，通过<code>TVServices</code>显示游戏存档，那么用户就可以直接从首页通过游戏存档进入游戏。如果是一个社交应用，那么就可以在首页显示社交动态信息，如果是一个照片分享应用，那么就可以显示近期朋友和家人分享的照片。</p>
<p>更多关于<code>TVServices</code>的信息可以查阅<a href="https://developer.apple.com/library/prerelease/tvos/documentation/TVServices/Reference/TVServices_Ref/index.html#//apple_ref/doc/uid/TP40016412" target="_blank" rel="external">TVServices Framework Reference</a>文档。使用好它对你的应用非常有益。</p>
<h2 id="Parallax_Images"><a href="#Parallax_Images" class="headerlink" title="Parallax Images"></a>Parallax Images</h2><p>还有一件会让你疑惑的可能就是在发布会的Keynote中，Apple着重强调了图片和应用图标的视差效果。这是一个非常棒的视图效果，但是为什么这个特性会被放在Keynote中提及，它为什么这么重要呢？</p>
<p>如果你使用了tvOS模拟器，你就会明白为什么这个特性如此重要。当移动聚焦视图时，你需要向左或向右滑动，但如果你只滑动了一点，Apple会对当前聚焦的视图做一个轻微的旋转处理，目的是让用户知道现在正在作以操作（但是还需要继续滑动来改变聚焦视图）。这是一个着眼于细节但又非常有用的特性。</p>
<p><img src="http://d.pr/i/1d2Gx+" alt="tvOS-6"></p>
<p>Apple把视差效果看做tvOS设计中的一个关键组成部分，并强烈建议应用图标和电影海报使用该特性。不过感谢Apple在App Programming Guide for tvOS文档中提供了<a href="https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/CreatingParallaxArtwork.html#//apple_ref/doc/uid/TP40015241-CH19-SW1" target="_blank" rel="external">Creating Parallax Artwork</a>章节，帮助我们创建视差特性的图片资源，以及为我们提供了视察图片资源的预览应用。</p>
<p><img src="http://d.pr/i/1aHGu+" alt="tvOS-7"></p>
<h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><p>每一个购买了新Apple TV的用户，都会收到一个功能强大的新版遥控器。上一代只能上下左右简单选择方位以及只有几个简单导航按键的遥控器，而新一代的Apple TV遥控器增加了更多令人激动的新特性：</p>
<ul>
<li><strong>玻璃触控板：</strong>位于遥控器的顶部，可以让用户在其上面进行一些手势操作，比如滑动、轻拍、点击。</li>
<li><strong>麦克风：</strong>可以让用户通过遥控器访问Siri（Siri有使用国家的限制）以及可以通过语音控制电视的音量。</li>
<li><strong>陀螺仪：</strong>结合动作传感器可以为用户提供非常棒的游戏体验。用户可以通过倾斜遥控器在游戏中控制方向盘开车，或者控制英雄奔跑穿越山洞。</li>
</ul>
<p><img src="http://d.pr/i/190dr+" alt="tvOS-8"></p>
<p>你可以使用你知道的处理手势操作的API去监听滑动或轻点，还有一些新的API去监听遥控器上不同的按钮，比如<code>pressesBegan()</code>、<code>pressesEnded()</code>、<code>pressesChanged()</code>和<code>pressesCancelled()</code>。</p>
<p>遥控器通过蓝牙技术与Apple TV主机交互，这意味着为蓝牙游戏控制器敞开的大门（恕我直言，用Apple的遥控器玩游戏并不是很好的选择）。Apple已经宣布<a href="https://steelseries.com/gaming-controllers/nimbus" target="_blank" rel="external">Nimbus Steelseries Controller</a>将会支持新Apple TV。想了解更多关于这方面的信息请查阅<a href="https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/WorkingwithGameControllers.html#//apple_ref/doc/uid/TP40015241-CH18-SW1" target="_blank" rel="external">Working with Game Controllers</a>。</p>
<h2 id="tvOS_and_Games"><a href="#tvOS_and_Games" class="headerlink" title="tvOS and Games"></a>tvOS and Games</h2><p>我们衷心的希望游戏能在tvOS上火起来，Apple似乎是直接瞄准了任天堂漠不关心的一个游戏市场。</p>
<p>tvOS有很健壮的游戏技术作为支撑，SpriteKit和SceneKit都可以在tvOS中正常工作，在Keynote中Crossy Roads开发者展示了他们的tvOS游戏，该游戏使用Unity开发，所以这也暗示着在不久的将来tvOS也会支持Unity开发的游戏。</p>
<p>大多数用SceneKit开发的游戏都可以无缝移植到新Apple TV中。比如Ray就将教程中介绍过的Zombie Conga游戏移植到了新Apple TV中，花费时间还不到10分钟，几乎不需要修改任何代码。</p>
<p>-&gt; 注：游戏视频可前往原文查看，但需要科学上网。</p>
<h2 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h2><p>或许目前关于tvOS比较有疑惑的两点就是本地存储和应用大小的限制。</p>
<h3 id="Limitation_3A_Local_Storage"><a href="#Limitation_3A_Local_Storage" class="headerlink" title="Limitation: Local Storage"></a>Limitation: Local Storage</h3><p>关于本地存储，基本确定是没有！如果你的应用需要持久化用户的数据，那么你需要使用iCloud、CloudKit或者自己的备份服务去实现。任何试图存在Apple TV中的数据都不保证在下次打开应用时还嫩存在。如果你想同步不同设置之间的数据，那么你就需要将数据线存在某个地方，但绝不是Apple TV中。</p>
<p><img src="http://d.pr/i/11tBa+" alt="tvOS-9"></p>
<p>一定要牢记这点，它对于你设计tvOS应用的结构时很关键。这里列出了一些规则：</p>
<ul>
<li><strong>如果你需要存储的数据量小于1MB</strong>，iCloud的key-value存储方式是一个可以选择的方案。但是要切记，iCloud KVS严格限制了只能有所属者才可以访问数据，并且不能共享给其他用户。</li>
<li><strong>如果你需要分享事件或者数据给其他用户</strong>，CloudKit是一个不错的选择方案。</li>
<li><strong>如果你开发的是一个跨平台的应用或者有特殊的需求</strong>，你就得使用你自己的备份服务了。</li>
</ul>
<h3 id="Limitation_3A_App_Size"><a href="#Limitation_3A_App_Size" class="headerlink" title="Limitation: App Size"></a>Limitation: App Size</h3><p>另一个限制是关于应用大小的限制，规定不能超过200MB。</p>
<p><img src="http://d.pr/i/xkr7+" alt="tvOS-10"></p>
<p>在你们掀桌之前，请回顾一下WWDC2015以及介绍过的“On-Demand Resources”相关API。这几乎像是Apple为tvOS提前铺垫的。</p>
<p>这些API通过按需下载资源文件减小应用初始安装时的大小。开发者可以在Xcode中给多媒体资源文件用标签进行标记，将应用提交后，App Store会自动根据标记将多媒体资源文件拆分为一个一个下载包。当用户在使用应用时如果需要用到某类标记的资源文件，就可以请求下载该标记的资源文件。当然你得有预期的判断，要先于用户使用资源前开始下载他们需要的资源，这样对于用户来说他们根本不会感受到因为下载资源带来的不好的用户体验。</p>
<p>举一个简单的例子，比如你有一款游戏应用有10个关卡。在用户安装该游戏时可以只包含两个关卡的多媒体资源文件。一旦用户完成了第一个关卡，你应该发送一个下载请求，下载第三个关卡的多媒体资源文件。当用户完成了第二个关卡时，第三个关卡需要的资源文件早已下载好准备妥当。在用户的整个游戏过程中，你就可以运用该机制一步一步去下载所需的资源文件。</p>
<p>虽然这种机制对于开发者来说无疑增加了工作量，但是这对用户来说是一件非常愉悦的事情。你试想一下，用户是愿意等待下载一个1GB大小的游戏呢，还是更愿意下载一个100MB大小的游戏并立即开始游戏呢。不过该机制也存在一个隐患，如果用户的网络条件很差，他们一般都更愿意在晚上挂着下载。那么如果用户在白天玩你的游戏，然后同时用龟速的网络下载后面关卡的资源文件，这简直是令人发指的用户体验。不幸的是作为tvOS开发者，在这种情形下目前也无能为力。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作者：<a href="http://www.raywenderlich.com/u/cwagdev" target="_blank" rel="external">Chris Wagner</a>  原文地址：<a href="http://www.raywenderli]]>
    </summary>
    
      <category term="tvOS" scheme="http://www.devtalking.com/tags/tvOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CALayer Animation - Replicator Animation]]></title>
    <link href="http://www.devtalking.com//articles/calayer-animation-replicator-animation/"/>
    <id>http://www.devtalking.com//articles/calayer-animation-replicator-animation/</id>
    <published>2015-09-08T16:00:00.000Z</published>
    <updated>2016-01-01T14:17:41.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-09-09/2825659" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>上一篇文章通过两个动画示例带大家了解和认识了CALayer动画，包括如何使用CAShapeLayer、CABasicAnimation、CAAnimationGroup等。在这篇文章中，依然会通过两个示例向大家讲解更多CALayer动画的知识。</p>
<p>老规矩，先让我们看看最终要实现的动画效果：</p>
<p><img src="http://d.pr/i/12JvB+" alt="ReplicatorAnimation-17"></p>
<p>经常听音乐的人对第一个动画效果肯定有会觉得很眼熟，类似播放音乐时音频高低起伏的动画，这种动画在应用中常被用作标识正在播放音乐或广播。第二个动画依然是一个等待加载的动画，在我的印象中肯定是有应用使用过，具体的已经记不清了。下面就让我们来实现这两个动画吧。</p>
<h2 id="Replicator_Animation"><a href="#Replicator_Animation" class="headerlink" title="Replicator Animation"></a>Replicator Animation</h2><p>新建一个项目，名为ReplicatorAnimation，打开<code>Main.storyboard</code>，添加一个UIView，颜色位置按大家喜好设定：</p>
<p><img src="http://d.pr/i/1ewgR+" alt="ReplicatorAnimation-1"></p>
<p>添加该UIView在<code>ViewController.swift</code>中的Outlet：</p>
<p><img src="http://d.pr/i/16ULZ+" alt="ReplicatorAnimation-2"></p>
<p>接下来我们在<code>ViewController.swift</code>中添加一个方法<code>firstReplicatorAnimation()</code>，在该方法中编写如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> replicatorLayer = <span class="type">CAReplicatorLayer</span>()</span><br><span class="line">replicatorLayer.bounds = <span class="type">CGRect</span>(x: replicatorAnimationView.frame.origin.x, y: replicatorAnimationView.frame.origin.y, width: replicatorAnimationView.frame.size.width, height: replicatorAnimationView.frame.size.height)</span><br><span class="line">replicatorLayer.anchorPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">replicatorLayer.backgroundColor = <span class="type">UIColor</span>.lightGrayColor().<span class="type">CGColor</span></span><br><span class="line">replicatorAnimationView.layer.addSublayer(replicatorLayer)</span><br></pre></td></tr></table></figure>
<p>这里出现的CAReplicatorLayer是一个新面孔，它也是CALayer的子类，正如它的名称一样，CAReplicatorLayer可以对它自己的子Layer进行复制操作。创建了CAReplicatorLayer实例后，设置了它的尺寸大小、位置、锚点位置、背景色，并且将它添加到了<code>replicatorAnimationView</code>的Layer中:</p>
<p><img src="http://d.pr/i/KAYB+" alt="ReplicatorAnimation-4"></p>
<p>这里要啰嗦几句，Layer的默认锚点坐标是(0.5, 0.5)，也就是Layer的中心点位置，而Layer的<code>position</code>又是根据锚点计算的，所以如果你设置Layer的<code>position</code>属性为(10, 10)，就相当于设置了Layer的中心位置为(10, 10)，并不是你期望的左上角位置。所以如果Layer想使用它父视图的坐标位置，就需要将锚点位置设置为(0, 0)，这样一来Layer的<code>position</code>属性标识的就是Layer左上角的位置：</p>
<p><img src="http://d.pr/i/ywPW+" alt="ReplicatorAnimation-3"></p>
<p>然后我们继续在<code>firstReplicatorAnimation()</code>方法中添加代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> rectangle = <span class="type">CALayer</span>()</span><br><span class="line">rectangle.bounds = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">30</span>, height: <span class="number">90</span>)</span><br><span class="line">rectangle.anchorPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)</span><br><span class="line">rectangle.position = <span class="type">CGPoint</span>(x: replicatorAnimationView.frame.origin.x + <span class="number">10</span>, y: replicatorAnimationView.frame.origin.y + <span class="number">110</span>)</span><br><span class="line">rectangle.cornerRadius = <span class="number">2</span></span><br><span class="line">rectangle.backgroundColor = <span class="type">UIColor</span>.whiteColor().<span class="type">CGColor</span></span><br><span class="line">replicatorLayer.addSublayer(rectangle)</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，再次创建了一个Layer，这次使用的是CALayer，因为我们只需要一个很普通的Layer，为其设置位置、尺寸、背景色、圆角属性，然后添加在<code>replicatorLayer</code>中：</p>
<p><img src="http://d.pr/i/11nLg+" alt="ReplicatorAnimation-5"></p>
<p>动画的主体之一已经绘制好了，下面我们让它动起来。在上述代码后面，接着添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> moveRectangle = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"position.y"</span>)</span><br><span class="line">moveRectangle.toValue = rectangle.position.y - <span class="number">70</span></span><br><span class="line">moveRectangle.duration = <span class="number">0.7</span></span><br><span class="line">moveRectangle.autoreverses = <span class="literal">true</span></span><br><span class="line">moveRectangle.repeatCount = <span class="type">HUGE</span></span><br><span class="line">rectangle.addAnimation(moveRectangle, forKey: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>首先我们创建了按Y轴移动的动画实例，然后设置了移动的目标位置，动画持续时间，重复次数设置为无限大。这里有一个属性大家可能比较陌生，那就是<code>autoreverses</code>，这个属性为Bool类型，设置为true时，开启自动反向执行动画，比如示例中的白色长方形的移动动画为向上移动50个像素，如过<code>autoreverses</code>设置为false，那么动画结束后，会根据重复次数，白色长方形重新回到初始位置，继续向上移动，如果<code>autoreverses</code>设置为true，则当动画结束后，白色长方形会继续向下移动至初始位置，然后再开始第二次的向上移动动画。</p>
<p>编译运行看看效果：</p>
<p><img src="http://d.pr/i/1extL+" alt="ReplicatorAnimation-6"></p>
<p>至此，大家应该也已经看出来了，这个白色的长方形就是动画中第一个上下移动的白色长方形，那么后两个如何创建呢？还需要再写两遍上面的代码吗？请大家在下面的文章中寻找答案。</p>
<p>在上述代码下面再添加一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">replicatorLayer.instanceCount = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>显而易见，这是CAReplicatorLayer的能力了，这行代码的意思是将<code>replicatorLayer</code>的子Layer复制3份，复制Layer与原Layer的大小、位置、颜色、Layer上的动画等等所有属性都一模一样，所以这时编译运行代码我们看不到任何不同的效果，因为三个白色长方形是重合在一起的，所以我们需要设置每个白色长方形的间隔：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">replicatorLayer.instanceTransform = <span class="type">CATransform3DMakeTranslation</span>(<span class="number">40</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>这行代码涉及到CAReplicatorLayer的另一个属性<code>instanceTransform</code>，它的作用是设置每个子Layer如何变化。<code>CATransform3DMakeTranslation</code>这个类的含义是使Layer根据X、Y、Z轴进行平移。现在再编译运行看看效果如何：</p>
<p><img src="http://d.pr/i/11oN5+" alt="ReplicatorAnimation-7"></p>
<p>现在三个白色长方形的运动轨迹和时刻都是一直的，这显然不是我们想要的结果，我们需要三个白色长方形有上下起伏的视觉效果，所以我们继续添加一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">replicatorLayer.instanceDelay = <span class="number">0.3</span></span><br></pre></td></tr></table></figure>
<p><code>instanceDelay</code>这个属性使CAReplicatorLayer中的每个子Layer的动画起始时间逐个递增。这里我们设置为0.3秒，也就是第一个长方形先执行动画，过0.3秒后第二个开始执行动画，再过0.3秒后第三个开始执行动画。我们编译运行看看效果：</p>
<p><img src="http://d.pr/i/1bzkJ+" alt="ReplicatorAnimation-8"></p>
<p>显然我们只想显示<code>replicatorLayer</code>区域里的内容，我们并不想看到超出它边界的内容，所以我们再添加一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">replicatorLayer.masksToBounds = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><code>masksToBounds</code>是CALayer的属性，作用是将Layer视为一个遮罩，只显示遮罩区域内的内容。最后我们回到初始化<code>replicatorLayer</code>的地方，找到这行代码<code>replicatorLayer.backgroundColor = UIColor.lightGrayColor().CGColor</code>，将<code>replicatorLayer</code>的背景色改为无色<code>replicatorLayer.backgroundColor = UIColor.clearColor().CGColor</code>。再次编译运行看看最终效果：</p>
<p><img src="http://d.pr/i/1eWlY+" alt="ReplicatorAnimation-9"></p>
<h2 id="Replicator_Indicator_Animation"><a href="#Replicator_Indicator_Animation" class="headerlink" title="Replicator Indicator Animation"></a>Replicator Indicator Animation</h2><p>CAReplicatorLayer的功能是很强大的，这一节将通过另一个加载动画的实例向大家介绍它的其他特性。</p>
<p>首先打开<code>Main.storyboard</code>，拖进一个新的UIView，位置颜色随大家喜好：</p>
<p><img src="http://d.pr/i/1eq86+" alt="ReplicatorAnimation-10"></p>
<p>随后添加该UIView在<code>ViewController.swift</code>中的Outlet <code>activityIndicatorView</code>：</p>
<p><img src="http://d.pr/i/193bt+" alt="ReplicatorAnimation-11"></p>
<p>然后在<code>ViewController.swift</code>中添加一个方法<code>activityIndicatorAnimation</code>，和上一个动画示例一样，我们先创建一个CAReplicatorLayer：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> replicatorLayer = <span class="type">CAReplicatorLayer</span>()</span><br><span class="line">replicatorLayer.bounds = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: activityIndicatorView.frame.size.width, height: activityIndicatorView.frame.size.height)</span><br><span class="line">replicatorLayer.position = <span class="type">CGPoint</span>(x: activityIndicatorView.frame.size.width/<span class="number">2</span>, y: activityIndicatorView.frame.size.height/<span class="number">2</span>)</span><br><span class="line">replicatorLayer.backgroundColor = <span class="type">UIColor</span>.lightGrayColor().<span class="type">CGColor</span></span><br><span class="line">activityIndicatorView.layer.addSublayer(replicatorLayer)</span><br></pre></td></tr></table></figure>
<p>上述代码和上个示例中的差不多，唯一不同的就是<code>replicatorLayer</code>的锚点使用的是默认值，即锚点就是中点，<code>position</code>属性代表亦是中点，所以将<code>position</code>属性设置为父视图的中点即可。这里意在让大家多多理解CALayer中<code>anchorPoint</code>与<code>position</code>属性。接下来添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> circle = <span class="type">CALayer</span>()</span><br><span class="line">circle.bounds = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">15</span>, height: <span class="number">15</span>)</span><br><span class="line">circle.position = <span class="type">CGPoint</span>(x: activityIndicatorView.frame.size.width/<span class="number">2</span>, y: activityIndicatorView.frame.size.height/<span class="number">2</span> - <span class="number">55</span>)</span><br><span class="line">circle.cornerRadius = <span class="number">7.5</span></span><br><span class="line">circle.backgroundColor = <span class="type">UIColor</span>.whiteColor().<span class="type">CGColor</span></span><br><span class="line">replicatorLayer.addSublayer(circle)</span><br></pre></td></tr></table></figure>
<p>上述代码的目的是用CALayer创建一个圆形，其实CALayer创建出的形状默认是矩形，但是把四个角的弧度设置为边宽的一半，矩形就变成了圆形。将这个圆形的位置设置在父Layer的中间靠上位置，背景色设置为白色。此时该圆形就是文章开头效果图中第二个动画里的主体了：</p>
<p><img src="http://d.pr/i/18D0r+" alt="ReplicatorAnimation-12"></p>
<p>不过在动画中我们看到有许多个小圆形组成一个大圆，如果重复上面的代码，一个一个设置位置，那绝对是令人发指的行为，好在我们有CAReplicatorLayer帮助我们实现，下面就来看看如何使用CAReplicatorLayer复制子Layer，并让子Layer形成一个圆形。让我们接着添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">replicatorLayer.instanceCount = <span class="number">15</span></span><br><span class="line"><span class="keyword">let</span> angle = <span class="type">CGFloat</span>(<span class="number">2</span> * <span class="type">M_PI</span>) / <span class="type">CGFloat</span>(<span class="number">15</span>)</span><br><span class="line">replicatorLayer.instanceTransform = <span class="type">CATransform3DMakeRotation</span>(angle, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>上述的代码中，首先对子Layer，也就是白色圆形复制了15份。然后将360°除以15份，算出每一个圆形针对它前一个圆形应该偏移的角度。最后我们用到了<code>CATransform3DMakeRotation</code>，它同样是<code>CATransform3D</code>的一个结构，含义是使Layer在X、Y、Z轴根据给定的角度旋转。这样我们复制的15份圆形就会按照我们计算的角度排列，并形成一个大圆：</p>
<p><img src="http://d.pr/i/1iCf4+" alt="ReplicatorAnimation-13"></p>
<p>接下来让我们分析一下这个动画，整体看上去感觉像一颗流星拖着尾巴在不停的转圈，但细看每一个小圆点，其实是在不停的进行放大缩小的动画，只不过每个小圆点的动画对于它前一个小圆点的动画有一定的延迟。所以首先我们需要实现小圆点放大缩小的动画，在上述代码后面接着添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> scale = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"transform.scale"</span>)</span><br><span class="line">scale.fromValue = <span class="number">1</span></span><br><span class="line">scale.toValue = <span class="number">0.1</span></span><br><span class="line">scale.duration = <span class="number">1</span></span><br><span class="line">scale.repeatCount = <span class="type">HUGE</span></span><br><span class="line">circle.addAnimation(scale, forKey: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>首先创建一个按比例缩放类型的动画，设置起始比例为1，也就是当前大小。再设置希望缩放到的比例为0.1。动画持续时间为1秒，重复无限次。最后将该动画添加在小圆点中。编译运行看看效果：</p>
<p><img src="http://d.pr/i/115bI+" alt="ReplicatorAnimation-14"></p>
<p>目前每个小圆点是同时执行动画，我们需要设置小圆点的动画延迟时间，接着添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">replicatorLayer.instanceDelay = <span class="number">1</span>/<span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>这里为什么是1/15呢，因为整个动画的时间是由每个小圆点的动画时间决定的，这里也就是1秒，所有小圆点的延迟时间加起来要等于整个动画的持续时间，所以这里就是用1秒除以小圆点的数量15。编译运行看看效果：</p>
<p><img src="http://d.pr/i/14kOC+" alt="ReplicatorAnimation-15"></p>
<p>从效果图中可以看到，刚开始的动画不是很自然，那是因为小圆点的初始比例是1，所以一开始会先看到小圆点，然后才会慢慢开始正常的动画。这个问题很好解决，我们让小圆点的初始比例为0.1，也就是刚开始看不到小圆点，这样就可以避免这个情况了，我们接着加一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">circle.transform = <span class="type">CATransform3DMakeScale</span>(<span class="number">0.01</span>, <span class="number">0.01</span>, <span class="number">0.01</span>)</span><br></pre></td></tr></table></figure>
<p>同时将<code>replicatorLayer</code>的背景色改为无色，再次编译运行看看效果：</p>
<p><img src="http://d.pr/i/1lgd6+" alt="ReplicatorAnimation-16"></p>
<p>展现在我们眼前的是一个完美的加载动画。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>今天主要给大家介绍了CAReplicatorLayer的用法，大家领悟其核心功能复制、延迟后也可以尝试实现其他有趣的动画效果。下篇文章我会向大家介绍CALayer另一个子类的用法，敬请期待吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-09-09/2825659" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>上一篇文章通过两个动画示例带大]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CALayer Animation - Loading Indicator]]></title>
    <link href="http://www.devtalking.com//articles/calayer-animation-loading-lndicator/"/>
    <id>http://www.devtalking.com//articles/calayer-animation-loading-lndicator/</id>
    <published>2015-09-06T16:00:00.000Z</published>
    <updated>2016-01-01T14:16:39.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-09-07/2825633" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="View_vs-_Layer"><a href="#View_vs-_Layer" class="headerlink" title="View vs. Layer"></a>View vs. Layer</h2><p>这篇文章通过两个加载动画向大家介绍CALayer的动画。按照面向对象的思想说，Layer其实就是一个模型类，像Java里的POJO类一样，它包含若干属性，并没有任何处理逻辑的方法，这些属性影响着显示在Layer中的内容。我们先来看看UIView和CALayer之间有什么区别和联系。</p>
<ul>
<li>联系：Layer是View背后的那个女人。每一个UIView后面都有对应的CALayer，大家看到的在UIView中显示的内容其实是在CALayer中。</li>
<li>区别：<ul>
<li>View有复杂的、各种组合的布局机制。Layer只有极简单的布局。</li>
<li>View可以响应用户交互。Layer不能响应用户交互。</li>
<li>View中的绘画逻辑有CPU执行。Layer中的绘画直接有GPU执行。</li>
<li>View有丰富的、功能强大的子类。Layer只有很少的几个子类。</li>
<li>View动画属性较少，局限性较大。Layer由于更底层、动画属性更多，所以可以实现出更灵活、更丰富的动画。</li>
</ul>
</li>
</ul>
<h2 id="u7B2C_u4E00_u4E2ACALayer_u52A8_u753B"><a href="#u7B2C_u4E00_u4E2ACALayer_u52A8_u753B" class="headerlink" title="第一个CALayer动画"></a>第一个CALayer动画</h2><p>Layer动画系列的文章，我不准备系统的从简单到复杂的知识进行讲解，我会通过各种实战示例，示例中用到什么知识点就讲什么知识点。</p>
<p>第一个动画让我们来实现Google Chrome浏览器加载时页签上的等待动画：</p>
<p><img src="http://d.pr/i/gfck+" alt="GoogleLoadingAnimation-1"></p>
<p>新建项目<strong>GoogleLoading</strong>，打开<code>Main.storyboard</code>，拖拽一个UIView到ViewController中，添加好约束，自行设置ViewController和UIView的背景色，这里UIView的背景色我设置为无色：</p>
<p><img src="http://d.pr/i/1lLwH+" alt="GoogleLoadingAnimation-2"></p>
<p>然后添加该View的Outlet到<code>ViewController</code>中，这个UIView就是要展示加载动画的View：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> loadingView: <span class="type">UIView</span>!</span><br></pre></td></tr></table></figure>
<p>打开<code>ViewController.swift</code>，申明一个常量属性<code>ovalShapleLayer</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> ovalShapeLayer: <span class="type">CAShapeLayer</span> = <span class="type">CAShapeLayer</span>()</span><br></pre></td></tr></table></figure>
<p><code>ovalShapleLayer</code>的类型是<code>CAShapleLayer</code>，它是<code>CALayer</code>的为数不多的子类之一。它的作用是在屏幕上画出各种形状，不论是简单的圆形、方形还是复杂的五角星或不规则图形都难不住它。<code>CAShapeLayer</code>有如下一些主要属性：</p>
<ul>
<li>strokeColor：笔画颜色。</li>
<li>strokeStart：笔画开始位置。</li>
<li>strokeEnd：笔画结束位置。</li>
<li>fillColor：图形填充颜色。</li>
<li>lineWidth：笔画宽度，即笔画的粗细程度。</li>
<li>lineDashPattern：虚线模式。</li>
<li>path：图形的路径。</li>
<li>lineCap：笔画未闭合位置的形状。</li>
</ul>
<p>我们之所要申明一个<code>CAShapeLayer</code>，是因为要用它在屏幕上画出一个圆形。下面在<code>viewDidLoad()</code>方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ovalShapeLayer.strokeColor = <span class="type">UIColor</span>.whiteColor().<span class="type">CGColor</span></span><br><span class="line">ovalShapeLayer.fillColor = <span class="type">UIColor</span>.clearColor().<span class="type">CGColor</span></span><br><span class="line">ovalShapeLayer.lineWidth = <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>这几个属性刚才已经向大家介绍过了，这三行代码的意思是我们画出的圆形笔画颜色是白色，没有填充色，笔画的宽度为7。接着我们申明这个圆形的半径，使这个圆形的大小为容纳它视图大小的80%：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> ovalRadius = loadingView.frame.size.height/<span class="number">2</span> * <span class="number">0.8</span></span><br></pre></td></tr></table></figure>
<p>最后我们设置<code>ovalShapeLayer</code>的路径，这是最关键的一步，因为你要告知<code>CAShapeLayer</code>按照什么路径绘制图形，让我们接着添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ovalShapeLayer.path = <span class="type">UIBezierPath</span>(ovalInRect: <span class="type">CGRect</span>(x: loadingView.frame.size.width/<span class="number">2</span> - ovalRadius, y: loadingView.frame.size.height/<span class="number">2</span> - ovalRadius, width: ovalRadius * <span class="number">2</span>, height: ovalRadius * <span class="number">2</span>)).<span class="type">CGPath</span></span><br></pre></td></tr></table></figure>
<p>这里出现了新面孔<code>UIBezierPath</code>，它可以创建基于矢量的路径，是Core Graphics框架关于path的封装。<code>UIBezierPath</code>可以定义简单的形状路径，如椭圆、矩形，或者有多个直线和曲线段组成的形状。在这里我们要使用它的初始化方法<code>init(ovalInRect rect: CGRect)</code>定义一个正圆的路径。设置完路径后，将<code>ovalShapeLayer</code>添加到<code>loadingView</code>视图的Layer中，它就可以按照设定好的路径在<code>loadingView</code>中绘制图形了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">loadingView.layer.addSublayer(ovalShapeLayer)</span><br></pre></td></tr></table></figure>
<p>编译运行看看效果：</p>
<p><img src="http://d.pr/i/SIt0+" alt="GoogleLoadingAnimation-3"></p>
<p>完美的一个圆形。接下来我们要做的是让这个圆只显示一部分，因为Google的加载动画只有大概五分之二的圆形轮廓。让我们继续将目光集中在<code>viewDidLoad()</code>方法中，在<code>loadingView.layer.addSublayer(ovalShapeLayer)</code>这行代码上面添加另一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ovalShapeLayer.strokeEnd = <span class="number">0.4</span></span><br></pre></td></tr></table></figure>
<p>上面的代码将<code>ovalShapeLayer</code>的<code>strokeEnd</code>属性设置为0.4，意思是<code>ovalShapeLayer</code>在绘制圆形时只画整个圆形的五分之二，即笔画结束的位置在整个圆形轮廓的五分之二处。编译运行看看效果：</p>
<p><img src="http://d.pr/i/GKFd+" alt="GoogleLoadingAnimation-4"></p>
<p>看来是我们想要的效果，但是仍有一处细节需要我们完善，看看Google的加载动画，蓝色的部分圆形轮廓两头是圆形的，而我们的圆形轮廓两头是方形的。这个问题很好解决，仍然在<code>loadingView.layer.addSublayer(ovalShapeLayer)</code>这行代码上面添加一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ovalShapeLayer.lineCap = kCALineCapRound</span><br></pre></td></tr></table></figure>
<p>这行代码的意思是将笔画两头的形状设置为圆形，对应的还有两个常量<code>kCALineCapButt</code>，<code>kCALineCapSquare</code>，大家可以试试。再次编译运行看看效果：</p>
<p><img src="http://d.pr/i/zmfv+" alt="GoogleLoadingAnimation-5"></p>
<p>到目前为止，我们通过CALayer绘制出了动画的主体，接下来要让它动起来。在<code>ViewController.swift</code>中添加<code>beginSimpleAnimate()</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">beginSimpleAnimation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> rotate = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"transform.rotation"</span>)</span><br><span class="line">    rotate.duration = <span class="number">1.5</span></span><br><span class="line">    rotate.fromValue = <span class="number">0</span></span><br><span class="line">    rotate.toValue = <span class="number">2</span> * <span class="type">M_PI</span></span><br><span class="line">    rotate.repeatCount = <span class="type">HUGE</span></span><br><span class="line">    loadingView.layer.addAnimation(rotate, forKey: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，我们又看到了新面孔<code>CABasicAnimation</code>，该类提供了基本的、单关键帧的Layer属性动画，通过<code>animationWithKeyPath:</code>初始化方法，根据<code>keyPath</code>创建不同的<code>CAPropertyAnimation</code>实例。常用的<code>keyPath</code>有如下一些：</p>
<ul>
<li><code>transform.rotation</code>：旋转动画。</li>
<li><code>transform.ratation.x</code>：按x轴旋转动画。</li>
<li><code>transform.ratation.y</code>：按y轴旋转动画。</li>
<li><code>transform.ratation.z</code>：按z轴旋转动画。</li>
<li><code>transform.scale</code>：按比例放大缩小动画。</li>
<li><code>transform.scale.x</code>：在x轴按比例放大缩小动画。</li>
<li><code>transform.scale.y</code>：在y轴按比例放大缩小动画。</li>
<li><code>transform.scale.z</code>：在z轴按比例放大缩小动画。</li>
<li><code>position</code>：移动位置动画。</li>
<li><code>opacity</code>：透明度动画。</li>
</ul>
<p>以上只是一部分常用的动画<code>keyPath</code>，更多的希望大家在实际运用中去挖掘。在<code>beginSimpleAnimation()</code>方法中，我们使用了<code>transform.rotation</code>，创建了一个旋转动画的实例，然后给该动画设置了四个属性：</p>
<ul>
<li><code>duration</code>：动画持续时间。</li>
<li><code>fromValue</code>：动画起始值。</li>
<li><code>toValue</code>：动画结束值。</li>
<li><code>repeatCount</code>：重复次数。</li>
</ul>
<p>该方法设置这几个属性的含义为使动画主体不停的旋转，旋转一圈的时间为1.5秒。以上这几个概念在UIView的动画中同样存在，大家应该都已经比较熟悉了。然后使用Layer的<code>addAnimation(anim: CAAnimation, forKey key: String?)</code>方法将旋转动画实例添加到目标Layer中，该方法的<code>key</code>是用来标示添加的动画，便于以后重复使用时能方便的检索，如果没有需求可以传值<code>nil</code>。最后<code>viewWillAppear</code>方法中调用<code>beginSimpleAnimation()</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(animated: Bool)</span></span> &#123;</span><br><span class="line">    beginSimpleAnimation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行看看效果：</p>
<p><img src="http://d.pr/i/1f9dB+" alt="GoogleLoadingAnimation-6"></p>
<p>至此我们的第一个简单的CALayer动画就完成了，在下一节我们一起实现一个更加有意思的加载动画，从而向大家介绍新的动画类型及动画组合。</p>
<h2 id="Stroke_Animation_u4E0EAnimation_Group"><a href="#Stroke_Animation_u4E0EAnimation_Group" class="headerlink" title="Stroke Animation与Animation Group"></a>Stroke Animation与Animation Group</h2><p>让我们先看看要实现的效果：</p>
<p><img src="http://d.pr/i/ML23+" alt="GoogleLoadingAnimation-7"></p>
<p>这种加载动画在很多应用中都出现过，比如网易新闻、Win版的谷歌浏览器中都有使用。下面就让我们一步一步来实现吧，首先打开<code>Main.storyboard</code>，新添加一个UIView，在<code>ViewController.swift</code>中添加Outlet：</p>
<p><img src="http://d.pr/i/18gGj+" alt="GoogleLoadingAnimation-8"></p>
<p>然后定义一个新的CAShapeLayer：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> anotherOvalShapeLayer: <span class="type">CAShapeLayer</span> = <span class="type">CAShapeLayer</span>()</span><br></pre></td></tr></table></figure>
<p>在<code>viewDidLoad()</code>方法中对它进行设置，并将其添加到刚才创建的<code>complexLoadingView</code>中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">anotherOvalShapeLayer.strokeColor = <span class="type">UIColor</span>.whiteColor().<span class="type">CGColor</span></span><br><span class="line">anotherOvalShapeLayer.fillColor = <span class="type">UIColor</span>.clearColor().<span class="type">CGColor</span></span><br><span class="line">anotherOvalShapeLayer.lineWidth = <span class="number">7</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> anotherOvalRadius = complexLoadingView.frame.size.height/<span class="number">2</span> * <span class="number">0.8</span></span><br><span class="line">anotherOvalShapeLayer.path = <span class="type">UIBezierPath</span>(ovalInRect: <span class="type">CGRect</span>(x: complexLoadingView.frame.size.width/<span class="number">2</span> - anotherOvalRadius, y: complexLoadingView.frame.size.height/<span class="number">2</span> - anotherOvalRadius, width: anotherOvalRadius * <span class="number">2</span>, height: anotherOvalRadius * <span class="number">2</span>)).<span class="type">CGPath</span></span><br><span class="line">anotherOvalShapeLayer.lineCap = kCALineCapRound</span><br><span class="line">        </span><br><span class="line">complexLoadingView.layer.addSublayer(anotherOvalShapeLayer)</span><br></pre></td></tr></table></figure>
<p>这些操作在上一个动画都已经做过一遍了，这里就不再解释。编译运行看看是否屏幕上又出现了一个圆圈呢：</p>
<p><img src="http://d.pr/i/1k7bX+" alt="GoogleLoadingAnimation-9"></p>
<p>接下来在<code>ViewController.swift</code>中添加一个方法<code>beginComplexAnimation()</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> strokeStartAnimate = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"strokeStart"</span>)</span><br><span class="line">strokeStartAnimate.fromValue = -<span class="number">0.5</span></span><br><span class="line">strokeStartAnimate.toValue = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> strokeEndAnimate = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"strokeEnd"</span>)</span><br><span class="line">strokeEndAnimate.fromValue = <span class="number">0.0</span></span><br><span class="line">strokeEndAnimate.toValue = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> strokeAnimateGroup = <span class="type">CAAnimationGroup</span>()</span><br><span class="line">strokeAnimateGroup.duration = <span class="number">1.5</span></span><br><span class="line">strokeAnimateGroup.repeatCount = <span class="type">HUGE</span></span><br><span class="line">strokeAnimateGroup.animations = [strokeStartAnimate, strokeEndAnimate]</span><br><span class="line">anotherOvalShapeLayer.addAnimation(strokeAnimateGroup, forKey: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这里出现了两个新的动画类型，笔画开始动画和笔画结束动画，我们虽然使用CAShapeLayer绘制了一个圆圈，但是它也存在笔画起始位置和笔画终止位置，只不过它俩在同一个位置而已，笔画动画的位置取值在0-1之间，0代表绘制路径的起始位置，1代表绘制路径的终止位置。所以<code>strokeStartAnimate</code>动画让绘制圆圈的笔画起始位置从-0.5开始，目的是让笔画起始绘制时等待一段时间，也就是起始位置延迟绘制。而<code>strokeEndAnimate</code>动画让绘制圆圈的笔画终止位置正常的从0绘制到1。这样一来笔画两头绘制的时间就会不一样，会有一个时间差，这样就有圆圈不断绘制又不断被擦除的效果。</p>
<p><code>strokeStartAnimate</code>和<code>strokeEndAnimate</code>是两个动画，如何作用于一个Layer上呢？这时就要用到<code>CAAnimationGroup</code>，顾名思义它是将多个动画组成一个组，在一个动画组里，子动画会同时进行。动画组可以设置动画持续时间、重复次数以及子动画数组。最后将动画组加在Layer上即可。</p>
<p>最后在<code>viewWillAppear()</code>方法中调用<code>beginComplexAnimation()</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(animated: Bool)</span></span> &#123;</span><br><span class="line">    beginSimpleAnimation()</span><br><span class="line">    beginComplexAnimation()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行看看效果：</p>
<p><img src="http://d.pr/i/p0uj+" alt="GoogleLoadingAnimation-10"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>CALayer动画可以实现比UIView动画更丰富、更底层、效率更高的动画。但是在实际的应用开发中，我们应该按需所用，能用UIView动画实现的我们就可以不用CALayer动画，它俩没有谁优谁劣之分。这篇文章只是CALayer动画的引子，让大家对CALayer动画有初步的了解和认识，之后我在文章中会通过更多的实例帮大家更深入的认识CALayer动画，从而提升自己应用的用户体验。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-09-07/2825633" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="View_vs-_L]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIStackView小窥]]></title>
    <link href="http://www.devtalking.com//articles/uistackview/"/>
    <id>http://www.devtalking.com//articles/uistackview/</id>
    <published>2015-08-03T16:00:00.000Z</published>
    <updated>2016-01-01T14:15:48.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-08-04/2825372/1" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>自适应、适配、布局这几个关键词一直伴随着iOS开发，从以前的单一尺寸屏幕，到现在的多尺寸屏幕，Apple一直致力于让开发人员尽可能少在这些事上耗费过多的精力，所以Apple在2012年推出了Auto Layout特性，2014年又推出了Adaptive Layout、Size Classes，2015年又推出了Stack View。这些无一不是我们开发者做适配的利器。今天就让我们看看StackView是怎么一回事。</p>
<blockquote>
<p>注：示例开发环境为Xcode7 Beta2</p>
</blockquote>
<p>我们先来看看下面这个常见的布局：</p>
<p><img src="http://d.pr/i/1ibUz+" alt="StackView-1"></p>
<p>这是一种很常见的汉堡布局，如果我们需要让它自适应不同尺寸的屏幕，我们要添加哪些约束呢？</p>
<p><img src="http://d.pr/i/1aIW6+" alt="StackView-2"></p>
<p>看看图中这些约束，你们会不会感到莫名的烦躁呢，至少我是的。更让人抓狂的是，如果需要在中间再添加一个长方形，那么你要修改关联的好几个约束，有没有掀桌的冲动呢？</p>
<p>不过，我们开发人员总是幸运的，Apple在Xcode7中添加了一个新的特性StackView，它能完美的解决这个闹心的问题。</p>
<p>StackView其实一个视图容器，不过它会对它的子视图根据一定规则自动布局，将子视图按栈的排列方式进行布局，并且有几个主要的属性：</p>
<ul>
<li><p>方向<br>StackView有水平和垂直两个方向的布局模式：<br><img src="http://d.pr/i/1g6hM+" alt="StackView-3"></p>
</li>
<li><p>间隔<br>StackView可以设置子视图之间的间隔：<br><img src="http://d.pr/i/1hvDq+" alt="StackView-4"></p>
</li>
<li><p>对齐方式<br>StackView可以设置子视图的对齐方式（水平方向和垂直方向的该属性值有所区别）：<br><img src="http://d.pr/i/1k4E1+" alt="StackView-5"></p>
<ul>
<li>Fill：子视图填充StackView。</li>
<li>Leading：靠左对齐。</li>
<li>Trailing：靠右对齐。</li>
<li>Center：子视图以中线为基准对齐。</li>
<li>Top：靠顶部对齐。</li>
<li>Bottom：靠底部对齐。</li>
<li>First Baseline：按照第一个子视图中文字的第一行对齐。</li>
<li>Last Baseline：按照最后一个子视图中文字的最后一行对齐。</li>
</ul>
</li>
<li><p>分布比例<br>StackView可以设置子视图的分布比例：<br><img src="http://d.pr/i/1iER5+" alt="StackView-6"></p>
<ul>
<li>Fill：默认分布方式。</li>
<li>Fill Equally：子视图的高度或宽度保持一致。</li>
<li>Fill：Proportionally：StackView自己计算出它认为合适的分布方式。</li>
<li>Equal Spacing：子视图保持同等间隔的分布方式。</li>
<li>Equal Centering：每个子视图中心线之间保持一致的分布方式。</li>
</ul>
</li>
</ul>
<p>一切让示例来说话，在这篇文章中我们将逐步开发一个电影影评的应用来详细讲解如何使用StackView。</p>
<h2 id="u7B2C_u4E00_u4E2AStackView"><a href="#u7B2C_u4E00_u4E2AStackView" class="headerlink" title="第一个StackView"></a>第一个StackView</h2><p>打开Xcode，新建一个项目，命名为MovieRate，语言选择Swift。打开Storyboard，删掉当前的ViewController视图，重新拖入TableViewController视图，然后内嵌一个NavigationController，配色大家随意：</p>
<p><img src="http://d.pr/i/17gto+" alt="StackView-7"></p>
<p>然后再删掉初始的<code>ViewController.swfit</code>文件，新建一个UITableViewController名为<code>MovieListTableViewController.swift</code>，以及一个UITableViewCell名为<code>MovieTabelViewCell.swift</code>：</p>
<p><img src="http://d.pr/i/1jtPi+" alt="StackView-8"></p>
<p>这两个文件的作用不言而喻：</p>
<p><img src="http://d.pr/i/Z5QN+" alt="StackView-9"></p>
<p>接下来新建一个plist文件<code>Movie.plist</code>，当做TableView的数据源：</p>
<p><img src="http://d.pr/i/12jTy+" alt="StackView-10"></p>
<p>然后打开StoryBoard，选择<code>MovieListTableViewController</code>，给<code>MovieTableViewCell</code>设置一个标示符<code>MovieCell</code>，往<code>MovieTableViewCell</code>中拖入两个UIImageView和一个UILabel，不用理会他们的位置和尺寸：</p>
<p><img src="http://d.pr/i/15wRk+" alt="StackView-11"></p>
<p>按着command键，同时选中这三个视图，然后点击右下角的Stack按钮：</p>
<p><img src="http://d.pr/i/1c0w4+" alt="StackView-12"></p>
<p>这时，我们便创建的一个UIStackView，包含刚才选中的那三个视图，或者说我们将选中的那三个视图组合成了一个UIStackView：</p>
<p><img src="http://d.pr/i/U22r+" alt="StackView-13"></p>
<p>选中这个StackView，打开右侧的属性编辑窗口，可以看到在文章前言中讲过的四个主要属性：</p>
<p><img src="http://d.pr/i/17Gk7+" alt="StackView-14"></p>
<p>虽然被包含的两个的UIImageView和UILabel可以由UIStackView的属性设置布局，但是就UIStackView本身而言，我们还是需要设置它的相关约束：</p>
<p><img src="http://d.pr/i/187Ii+" alt="StackView-15"></p>
<p>这两个UIImageView一个展示电影封面图片，一个展示评分，我们在StoryBoard中设置它们的image属性，并将Model设置为Aspect Fit，看看效果：</p>
<p><img src="http://d.pr/i/Y42Z+" alt="StackView-16"></p>
<p>理想总是很丰满，现实总是很骨感，设置了图片后并不是我们想要的结果，图片的大小以及与文字的间隔都有问题。而且还出现了约束错误：</p>
<p><img src="http://d.pr/i/1iiaP+" alt="StackView-17"></p>
<p>意思是StackView里的这三个内容没有指定x坐标的约束或者宽度的约束。但是作为StackView的子视图，它们的布局情况是由StackView通过各个属性设置的，断然不能在自身上添加约束，那么如何解决这个问题呢？其实很简单，我们选中中间的UILabel，然后打开右侧的尺寸属性面板，找到这两栏：</p>
<p><img src="http://d.pr/i/10mn6+" alt="StackView-18"></p>
<p><em>Content Hugging Priority</em>是水平、垂直方向的拉伸优先级，我们将<em>Horizontal</em>设置为250。这样就可以告诉StackView，中间的UILabel水平拉伸的优先级是最高的，当StackView的宽度变大时优先拉伸UILabel的宽度，这样前后两个UIImageView的宽度是保持不变的，否则会默认拉伸StackView中的第一个子视图，所以我们看到第一个UIImageView的宽度被拉伸了。</p>
<p><em>Content Compression Resistance Priority</em>是水平、垂直方向的压缩优先级，道理和上面的拉伸优先级是一样的，我们将UILabel的水平压缩优先级设为749。</p>
<p>现在你们会发现约束错误消失了，第一个UIImageView的宽度也正常了，而中间的UILabel被拉伸了：</p>
<p><img src="http://d.pr/i/FJ4h+" alt="StackView-19"></p>
<p>接下来在<code>MovieTableViewCell</code>中添加这两个UIImageView和UILabel的<code>IBOutlet</code>：</p>
<p><img src="http://d.pr/i/113Z7+" alt="StackView-20"></p>
<p>然后在<code>MovieListTableViewController</code>中实现TableView的数据展示：</p>
<p><img src="http://d.pr/i/9pVG+" alt="StackView-21"></p>
<p>然后编译运行程序看看效果：</p>
<p><img src="http://d.pr/i/1iUjp+" alt="StackView-22"></p>
<p>横屏也很完美：</p>
<p><img src="http://d.pr/i/QdSW+" alt="StackView-27"></p>
<p>一个完美的Movie List页面已经展现在我们眼前，电影封面、电影名称、电影评分被StackView按合理的布局组织在TableViewCell里，我们只是给StackView设置了简单的四个约束而已。可见StackView在视图布局方面可以给我们带来很大的便利。</p>
<h2 id="StackView_u7684_u5D4C_u5957"><a href="#StackView_u7684_u5D4C_u5957" class="headerlink" title="StackView的嵌套"></a>StackView的嵌套</h2><p>既然UIStackView继承了UIView，那么UIStackView是否可以看做是一个UIView而被包含在UIStackView内呢？答案是肯定的，这一节向大家介绍UIStackView的嵌套。</p>
<p>一些界面发杂的App，只要你仔细分析，总会发现StackView嵌套的布局，或看似相似的布局：</p>
<p><img src="http://d.pr/i/qL2h+" alt="StackView-23"></p>
<p>在MovieRate这个示例中，我们将StackView的嵌套运用在电影详情页面里：</p>
<p><img src="http://d.pr/i/1froW+" alt="StackView-24"></p>
<p>上图是电影详情页的布局图，从图中我们可以看到一共有三个StackView，一个嵌套在一个里面。我们在Storyboard中把这个页面创建出来（StackView的创建方法在上一节中已经介绍过了，这里就不再累赘了）：</p>
<p><img src="http://d.pr/i/Vn6C+" alt="StackView-25"></p>
<p>详情页的数据直接写在Storyboard中了，因为只是说明StackView的嵌套特性，所以界面比较粗糙。点击TableViewCell跳转到详情页的过程不再累赘了，编译运行看看效果：</p>
<p><img src="http://d.pr/i/1aK15+" alt="StackView-26"></p>
<p>虽然有点丑，但是这个页面展示出了StackView的嵌套特性。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>诚然UIStackView不是万能的，但是无疑它可以在布局和自适应方面给开发者带来便利，在恰当的情形下使用StackView可以事半功倍。而且因为UIStackView是UIView的子类，所以也可以将动画效果作用于UIStackView上，在方便布局之余还能提高用户体验，何乐而不为呢，那么让我们用起来吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-08-04/2825372/1" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="u524D_u8]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="UIKit" scheme="http://www.devtalking.com/tags/UIKit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS UIView Animation - Keyframe]]></title>
    <link href="http://www.devtalking.com//articles/uiview-keyframe-animation/"/>
    <id>http://www.devtalking.com//articles/uiview-keyframe-animation/</id>
    <published>2015-07-27T16:00:00.000Z</published>
    <updated>2016-01-01T14:14:40.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p> 本文首发<a href="http://www.csdn.net/article/2015-07-28/2825314-ios-uiview-animation-5" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
</blockquote>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>有些时候大家可能会遇到制作复杂、具有连贯性UIView动画的需求，这时大家可能会使用在<code>completion</code>闭包中衔接一段一段的动画，使之成为一段连续的动画。</p>
<p>如果我们只是连接2个，或者3个动画，这种方式或许还行得通，但如果有更多的动画片段需要连接的时候，这种方式会带来灾难性的问题，你的代码会非常的冗余，不断的在<code>completion</code>闭包中嵌套代码，使代码维护起来相当的困难。所以今天向大家介绍能更好地实现这个需求的方法，Keyframe动画。</p>
<p>Keyframe动画可以让我们有效的拆分由若干段动画连接而成的复杂动画，可以较为精准的定义每段动画的起始点及持续时间，并且在代码组织方面也非常清晰。先看看今天要带大家实现的动画Demo：</p>
<iframe src="https://player.vimeo.com/video/134543973?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<h2 id="u4F7F_u7528_u573A_u666F"><a href="#u4F7F_u7528_u573A_u666F" class="headerlink" title="使用场景"></a>使用场景</h2><p>我们先来认识一下，在什么样的场景下需要使用Keyframe动画。如图下所示，这是一个由四段动画组成的一个复杂动画，让UIView沿着长方形的轨迹运动：</p>
<p><img src="http://d.pr/i/1e4Jg+" alt="Keyframe-1"></p>
<p>我们来看看用代码如何实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, animations: &#123;</span><br><span class="line">    view.center.x += <span class="number">200.0</span></span><br><span class="line">&#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, animations: &#123;</span><br><span class="line">        view.center.y += <span class="number">100.0</span></span><br><span class="line">    &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        <span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, animations: &#123;</span><br><span class="line">            view.center.x -= <span class="number">200.0</span></span><br><span class="line">        &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, animations: &#123;</span><br><span class="line">                view.center.y -= <span class="number">100.0</span></span><br><span class="line">            &#125;, completion: <span class="literal">nil</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>通过上面的伪代码可以看到，我们使用了<code>completion</code>闭包的方式连接每一段的动画，代码看起来尚且算清晰，可读性也马马虎虎。但是大家想象一下，如果我们使UIView按照一个复杂的路线运行，这一段动画可能有十几、几十段动画组成的，那么如果再使用<code>completion</code>闭包这种方式连接，那代码是多么的惨不忍睹。幸好我们有Keyframe动画，下面就让我们来看看如何使用Keyframe动画。</p>
<h2 id="Keyframe_u52A8_u753B"><a href="#Keyframe_u52A8_u753B" class="headerlink" title="Keyframe动画"></a>Keyframe动画</h2><p>首先我们会使用到UIView的另一个动画方法<code>animateKeyframesWithDuration(_: delay: options: animations: completion: )</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateKeyframesWithDuration(<span class="number">2</span>, delay: <span class="number">0</span>, options: [], animations: &#123;</span><br><span class="line">    <span class="comment">// add keyframes</span></span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这个方法的几个参数与前几个使用过的动画方法参数一样。上面代码片段的意思是整个关键帧动画的持续时间为2秒、无延迟、无动画选项、执行完毕后无后续执行的代码。</p>
<blockquote>
<p>注：该方法的动画选项不再是<code>UIViewAnimationOptions</code>，而是<code>UIViewKeyframeAnimationOptions</code>。具体的内容大家可以去查阅Apple的文档。</p>
</blockquote>
<p>接下来我们要在<code>animations</code>闭包中添加关键帧了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateKeyframesWithDuration(<span class="number">2</span>, delay: <span class="number">0</span>, options: [], animations: &#123;</span><br><span class="line">    <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0</span>, relativeDuration: <span class="number">0.25</span>, animations: &#123;</span><br><span class="line">        view.center.x += <span class="number">200.0</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p><code>addKeyframeWithRelativeStartTime(_: relativeDuration: animations: )</code>是UIView添加关键帧的方法，该方法有三个参数：</p>
<ul>
<li>startTime：关键帧开始时间，该时间是相对整个关键帧动画持续时间的相对时间，一般值在0到1之间。如果为0，则表明这一关键帧从整个动画的第0秒开始执行，如果设为0.5，则表明从整个动画的中间开始执行。</li>
<li>relativeDuration：关键帧持续时间，该时间同样是相对整个关键帧动画持续时间的相对时间，一般值也在0到1之间。如果设为0.25，则表明这一关键帧的持续时间为整个动画持续时间的四分之一。</li>
<li>animations：设置视图动画属性的动画闭包。</li>
</ul>
<p>我们解释一下上面这段代码。整个关键帧动画的持续时间为2秒，第一个关键帧从第0秒开始，运行0.5秒结束。下面我们完成其他三个关键帧：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateKeyframesWithDuration(<span class="number">2</span>, delay: <span class="number">0</span>, options: [], animations: &#123;</span><br><span class="line">    <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0</span>, relativeDuration: <span class="number">0.25</span>, animations: &#123;</span><br><span class="line">        view.center.x += <span class="number">200.0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0.25</span>, relativeDuration: <span class="number">0.25</span>, animations: &#123;</span><br><span class="line">        view.center.y += <span class="number">100.0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0.5</span>, relativeDuration: <span class="number">0.25</span>, animations: &#123;</span><br><span class="line">        view.center.x -= <span class="number">200.0</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0.75</span>, relativeDuration: <span class="number">0.25</span>, animations: &#123;</span><br><span class="line">        view.center.y -= <span class="number">100.0</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>第二个关键帧的开始时间为0.25，也就是从整个动画时间的第0.5时开始执行，同样持续0.5秒。后两个关键帧的参数就不难理解了。</p>
<p>现在整个代码看起来非常整洁，条理清晰，可读性非常好，而且可以有更精确的控制。即使再多几个关键帧也同样可以从容应对。</p>
<p>关键帧动画不仅仅用于同一个视图的分段动画，也可使使用于不同视图的组合动画，由于我们还没讲到图层动画，所以，开篇的示例动画中就使用了关键帧动画实现了多个视图的组合动画。</p>
<h2 id="u793A_u4F8B_u52A8_u753B"><a href="#u793A_u4F8B_u52A8_u753B" class="headerlink" title="示例动画"></a>示例动画</h2><p>在这个示例中虽然看起来是一个纸飞机视图的连续动画，但其实是由三个纸飞机视图组合而成的：</p>
<p><img src="http://d.pr/i/1hiaq+" alt="Keyframe-2"></p>
<p>从图中可以看到其实是有三个纸飞机视图，只不过在界面加载之前2号和3号纸飞机视图的透明度都是为零。</p>
<p>整个动画是由这三个纸飞机视图通过关键帧动画组合而成：</p>
<p><img src="http://d.pr/i/10vBK+" alt="Keyframe-3"></p>
<p>图中标示出了三个飞机视图的运行轨迹、视图大小、视图透明度的状态，我们来看看代码如何实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> zoomInScaleTransform = <span class="type">CGAffineTransformMakeScale</span>(<span class="number">0.2</span>, <span class="number">0.2</span>)</span><br><span class="line"><span class="type">UIView</span>.animateKeyframesWithDuration(<span class="number">3</span>, delay: <span class="number">0</span>, options: [], animations: &#123;</span><br><span class="line">    <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0</span>, relativeDuration: <span class="number">0.2</span>, animations: &#123;</span><br><span class="line">        <span class="keyword">self</span>.customHeaderView.paperAirplane.center.x += <span class="keyword">self</span>.view.frame.width</span><br><span class="line">        <span class="keyword">self</span>.customHeaderView.paperAirplane.center.y += -<span class="number">180</span></span><br><span class="line">        <span class="keyword">self</span>.customHeaderView.paperAirplane.transform = zoomInScaleTransform</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0.3</span>, relativeDuration: <span class="number">0.01</span>, animations: &#123;</span><br><span class="line">        <span class="keyword">self</span>.customHeaderView.paperAirplaneOpposite.alpha = <span class="number">1</span></span><br><span class="line">        <span class="keyword">self</span>.customHeaderView.paperAirplaneOpposite.transform = zoomInScaleTransform</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0.3</span>, relativeDuration: <span class="number">0.5</span>, animations: &#123;</span><br><span class="line">        <span class="keyword">self</span>.customHeaderView.paperAirplaneOpposite.transform = <span class="type">CGAffineTransformIdentity</span></span><br><span class="line">        <span class="keyword">self</span>.customHeaderView.paperAirplaneOpposite.center.x -= <span class="keyword">self</span>.view.frame.width</span><br><span class="line">        <span class="keyword">self</span>.customHeaderView.paperAirplaneOpposite.center.y += <span class="number">90</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0.9</span>, relativeDuration: <span class="number">0.01</span>, animations: &#123;</span><br><span class="line">        <span class="keyword">self</span>.customHeaderView.paperAirplaneComeBack.alpha = <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="type">UIView</span>.addKeyframeWithRelativeStartTime(<span class="number">0.9</span>, relativeDuration: <span class="number">0.2</span>, animations: &#123;</span><br><span class="line">        <span class="keyword">self</span>.customHeaderView.paperAirplaneComeBack.center.x += <span class="number">33</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">self</span>.restorePaperAirplaneStatus()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>大家看到这大家可能会有疑问了，三段动画怎么会有五个关键帧呢，我们来刨析一下：</p>
<ul>
<li>第一个关键帧：完成1号纸飞机视图运动到右上角并移出屏幕，视图逐渐变小的动画。该关键帧从整个动画的第0秒开始执行，持续时间为0.6秒。</li>
<li>第二个关键帧：由于2号纸飞机视图的初始透明度为零，所以在第二个关键帧将透明度设为1，并且缩小视图。注意这两个动作需要在瞬间完成，所以<code>relativeDuration</code>设为0.01，一个极短的时间。开始时间为整个动画的第0.9秒开始，较第一个关键帧延迟0.3秒。</li>
<li>第三个关键帧：与第二个关键帧同时开始执行，完成2号纸飞机视图从小变大、并且往左下角运动，一直移出屏幕。持续时间为1.5秒。</li>
<li>第四个关键帧：与第二个关键帧作用相似，改变3号纸飞机视图的透明度，同样是在瞬间完成。</li>
<li>第五个关键帧：与第四个关键帧同时执行， 完成向右移动的动画，持续0.6秒。</li>
</ul>
<p>关键帧完成之后，在<code>completion</code>闭包中调用<code>restorePaperAirplaneStatus()</code>方法，恢复3个纸飞机视图的状态及位置，以便再次执行动画。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>大家在使用关键帧动画时，对于关键帧的开始时间和持续时间需要仔细设置，保证每个关键帧在合适的时间开始，执行恰当的持续时间。在必要时候也需要在关键帧里修改视图的一些状态，但要设置极短的持续时间，表示瞬间完成。</p>
<p>下一篇会向大家介绍在使用Auto Layout的情况下，如何通过约束实现动画，好了今天就先到这里吧。</p>
<p>参考文献来自：<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p> 本文首发<a href="http://www.csdn.net/article/2015-07-28/2825314-ios-uiview-animation-5" target="_blank" rel="external">CSDN</a>]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS UIView Animation - Practice]]></title>
    <link href="http://www.devtalking.com//articles/uiview-animation-practice/"/>
    <id>http://www.devtalking.com//articles/uiview-animation-practice/</id>
    <published>2015-07-20T16:00:00.000Z</published>
    <updated>2016-01-01T14:13:27.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p> 本文首发<a href="http://www.csdn.net/article/2015-07-20/2825255-ios-uiview-animation-4-practice/1" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
</blockquote>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>上三篇关于UIView Animation的文章向大家介绍了基础的UIView动画，包括移动位置、改变大小、旋转、弹簧动画、过渡动画。这些虽然看起来很简单，但是如果我们仔细分析、分解一个复杂动画时，就会发现这些复杂的动画其实是由若干基础的动画组合而成的。今天这篇文章是实践篇，我选择了Raywenderlich <a href="http://www.raywenderlich.com/73286/top-5-ios-7-animations" target="_blank" rel="external">Top 5 iOS 7 Animations</a>这篇文章中的一个动画效果，带大家一起实现。要实现这个动画效果，除了用到我们上三篇介绍过的知识点以外，还有两个知识点在这篇会介绍给大家，我们先看看实现的效果：</p>
<iframe src="https://player.vimeo.com/video/133654890?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>这个动画示例实现的是一个展示航班信息的应用，左右滑动显示不同的航班信息。我们可以分析一下都用到了哪些动画：</p>
<ul>
<li>淡入淡出：起飞地和目的地、起飞地和目的地下面的横线、底部的航班时间都使用了该动画。</li>
<li>位置移动：起飞地和目的地、小飞机都使用了该动画。</li>
<li>旋转：航站楼登机口前面的小箭头、小飞机都使用了该动画。</li>
<li>过渡动画： 背景图片使用了淡入淡出效果的图片替换过渡动画。</li>
<li>伪3D动画：顶部的时间、航班号、航站楼登机口信息、底部的起飞降落文字都是用了该动画。</li>
</ul>
<p>前三个动画我们之前已经介绍过了，现在我们来介绍后两个动画。</p>
<h2 id="u4F2A3D_u52A8_u753B_u6548_u679C"><a href="#u4F2A3D_u52A8_u753B_u6548_u679C" class="headerlink" title="伪3D动画效果"></a>伪3D动画效果</h2><p>这个伪3D的效果模拟的是一个立体长方形由一面翻转到另一面。因为这不是真正的3D效果，所以我们可以分析一下它是如何模拟的，以上面动画中从下往上翻的效果为例。首先显示的是一个<code>UILabel</code>，当开始进行翻转时，当前显示的<code>UILabel</code>的高度开始慢慢变矮：</p>
<p><img src="http://d.pr/i/176qE+" alt="Practice-1"></p>
<p>我们看看用代码怎么实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.devtalkingLabel.transform = <span class="type">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">0.5</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>我们可以使用一个转换动画，使用<code>CGAffineTransformMakeScale</code>，它的第一个参数是x坐标的比例，第二个参数是y坐标的比例，这两个值的范围是1.0到0之间。上面的代码用白话文翻译出来就是在1秒内，<code>devtalkingLabel</code>的宽度不变，高度减少一半，减少的过程会自动生成补间动画。</p>
<p>我们接着来分析，在<code>UILabel</code>高度减少的同时，它的位置也会向上移动，我们可以用另外一个转换的动画：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.devtalkingLabel.transform = <span class="type">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">0.5</span>)</span><br><span class="line">    <span class="keyword">self</span>.devtalkingLabel.transform = <span class="type">CGAffineTransformMakeTranslation</span>(<span class="number">1.0</span>, -<span class="keyword">self</span>.devtalkingLabel.frame.height / <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>CGFffineTransformMakeTranslation</code>这个转换动画可以移动UIView的位置，这里需要注意它是以初始位置为基础进行移动的，所以上述代码在字面上的意思是<code>devtalkingLabel</code>在高度变小的同时向上移动它初始宽度一半的距离：</p>
<p><img src="http://d.pr/i/1e5LF+" alt="Practice-2"></p>
<p>但是当我们编译运行后发现事与愿违，转换动画不像动画属性动画那样可以在<code>animations</code>闭包中写多个进行组合，而是由另一个组合转换动画来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.devtalkingLabel.transform = <span class="type">CGAffineTransformConcat</span>(<span class="type">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">0.5</span>), <span class="type">CGAffineTransformMakeTranslation</span>(<span class="number">1.0</span>, -<span class="keyword">self</span>.devtalkingLabel.frame.height / <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">self</span>.devtalkingLabel.alpha = <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>来看看效果：</p>
<p><img src="http://d.pr/i/13OWM+" alt="Practice-4"></p>
<p>此时，3D翻转效果的一个面已经成型了，也就是当前显示的这一面被向上翻转到顶部去了。接下来我们要实现底部的面翻转到当前显示的这一面。很明显这需要两个面，但我们只有一个<code>UILabel</code>，所以在执行整个翻转效果前需要先复制一个当前<code>UILabel</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> devtalkingLabelCopy = <span class="type">UILabel</span>(frame: <span class="keyword">self</span>.devtalkingLabel.frame)</span><br><span class="line">devtalkingLabelCopy.alpha = <span class="number">0</span></span><br><span class="line">devtalkingLabelCopy.text = <span class="keyword">self</span>.devtalkingLabel.text</span><br><span class="line">devtalkingLabelCopy.font = <span class="keyword">self</span>.devtalkingLabel.font</span><br><span class="line">devtalkingLabelCopy.textAlignment = <span class="keyword">self</span>.devtalkingLabel.textAlignment</span><br><span class="line">devtalkingLabelCopy.textColor = <span class="keyword">self</span>.devtalkingLabel.textColor</span><br><span class="line">devtalkingLabelCopy.backgroundColor = <span class="type">UIColor</span>.clearColor()</span><br></pre></td></tr></table></figure>
<p>这样我们就复制了一个<code>devtalkingLabel</code>，这个复制品将作为底部的那一面，而且在一开始它的透明度是零，因为底面是看不到的。我们可以想象一下底面向上翻转的效果，其实就是底面的高度从很小慢慢变大，位置从下慢慢向上移动，然后有一个淡入的效果，所以我们在复制出<code>devtalkingLabelCopy</code>后，要调整它的高度和位置，然后添加到父视图中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">devtalkingLabelCopy.transform = <span class="type">CGAffineTransformConcat</span>(<span class="type">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">0.1</span>), <span class="type">CGAffineTransformMakeTranslation</span>(<span class="number">1.0</span>, <span class="keyword">self</span>.devtalkingLabel.frame.height / <span class="number">2</span>))</span><br><span class="line"><span class="keyword">self</span>.view.addSubview(devtalkingLabelCopy)</span><br></pre></td></tr></table></figure>
<p>上述代码将<code>devtalkingLabelCopy</code>的高度减小到原本的十分之一，位置向下移动半个高度的位置，然后在之前的<code>animateWithDuration</code>方法的<code>animations</code>闭包中添加如下两行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">devtalkingLabelCopy.alpha = <span class="number">1</span></span><br><span class="line">devtalkingLabelCopy.transform = <span class="type">CGAffineTransformIdentity</span></span><br></pre></td></tr></table></figure>
<p><code>CGAffineTransformIdentity</code>的作用是将<code>UIView</code>的<code>transform</code>恢复到初始状态，然后将透明度设为1。编译运行代码我们会看到<code>devtalkingLabel</code>的高度会慢慢变小，位置慢慢上移，最后淡出，<code>devtalkingLabelCopy</code>的高度慢慢变大，位置慢慢上移，最后淡入，整个效果看上去就像一个长方体在向上翻转，达到3D的效果：</p>
<p><img src="http://d.pr/i/1aVmo+" alt="Practice-5"></p>
<h2 id="u66FF_u6362UIView_u8FC7_u6E21_u52A8_u753B"><a href="#u66FF_u6362UIView_u8FC7_u6E21_u52A8_u753B" class="headerlink" title="替换UIView过渡动画"></a>替换UIView过渡动画</h2><p>在要实现的动画示例中，背景图做了淡入淡出的图片替换过渡动画，这个动画很简单，我们来看看这段伪代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.transitionWithView(backgroundImageView, duration: <span class="number">2</span>, options: .<span class="type">TransitionCrossDissolve</span>, animations: &#123;</span><br><span class="line">    backgroundImageView.image = <span class="type">UIImage</span>(named: <span class="string">"imageName"</span>)</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这个方法在上一篇文章中已经介绍过，我们只需要设置动画选项为<code>.TransitionCrossDissolve</code>，在<code>animations</code>闭包中给目标<code>UIImageView</code>设置要过渡的图片即可。</p>
<h2 id="u793A_u4F8B_u52A8_u753B"><a href="#u793A_u4F8B_u52A8_u753B" class="headerlink" title="示例动画"></a>示例动画</h2><p>至此，示例动画中用到的动画知识点都向大家介绍过了，在这一节我会将示例动画中主要的效果的伪代码贴出来给大家说说。关于左右滑动的手势以及<code>PageControl</code>在这里就不在累赘了。</p>
<h3 id="u6570_u636E_u6E90"><a href="#u6570_u636E_u6E90" class="headerlink" title="数据源"></a>数据源</h3><p>为了方便，我们创建一个<code>Flight.plist</code>文件作为数据源：</p>
<p><img src="http://d.pr/i/1bqwt+" alt="Practice-6"></p>
<p>我们定义一个延迟加载的属性<code>flight</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> flight: <span class="type">NSArray</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> path = <span class="type">NSBundle</span>.mainBundle().pathForResource(<span class="string">"Flight"</span>, ofType: <span class="string">"plist"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">NSArray</span>(contentsOfFile: path!)!</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<h3 id="u80CC_u666F_u56FE_u7247_u8FC7_u6E21"><a href="#u80CC_u666F_u56FE_u7247_u8FC7_u6E21" class="headerlink" title="背景图片过渡"></a>背景图片过渡</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.transitionWithView(<span class="keyword">self</span>.backgroundImageView, duration: <span class="number">2</span>, options: .<span class="type">TransitionCrossDissolve</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.backgroundImageView.image = <span class="type">UIImage</span>(named: flightItem[<span class="string">"bg"</span>] <span class="keyword">as</span>! <span class="type">String</span>)</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>上一节刚介绍过，只是这里图片名称是从数据源中获取的。</p>
<h3 id="3D_u7FFB_u8F6C"><a href="#3D_u7FFB_u8F6C" class="headerlink" title="3D翻转"></a>3D翻转</h3><p>因为有3D翻转动画效果的<code>UIView</code>比较多，而且有<code>UILabel</code>也有<code>UIImageView</code>，所以我们可以提炼成一个方法，将目标<code>UIView</code>和数据源作为参数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">cubeAnimate</span><span class="params">(targetView: UIView, flightInfo: String)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 判断UIView的具体实现类</span></span><br><span class="line">    <span class="keyword">if</span> targetView.isKindOfClass(<span class="type">UILabel</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> virtualTargetView = targetView <span class="keyword">as</span>! <span class="type">UILabel</span></span><br><span class="line">        <span class="comment">// 复制UIView，作为底面</span></span><br><span class="line">        <span class="keyword">let</span> viewCopy = <span class="type">UILabel</span>(frame: virtualTargetView.frame)</span><br><span class="line">        viewCopy.alpha = <span class="number">0</span></span><br><span class="line">        viewCopy.text = flightInfo</span><br><span class="line">        viewCopy.font = virtualTargetView.font</span><br><span class="line">        viewCopy.textAlignment = virtualTargetView.textAlignment</span><br><span class="line">        viewCopy.textColor = virtualTargetView.textColor</span><br><span class="line">        viewCopy.backgroundColor = <span class="type">UIColor</span>.clearColor()</span><br><span class="line">        <span class="comment">// 设置底面UIView的初始位置和高度</span></span><br><span class="line">        viewCopy.transform = <span class="type">CGAffineTransformConcat</span>(<span class="type">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">0.1</span>), <span class="type">CGAffineTransformMakeTranslation</span>(<span class="number">1.0</span>, viewCopy.frame.height / <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">self</span>.topView.addSubview(viewCopy)</span><br><span class="line">        <span class="type">UIView</span>.animateWithDuration(<span class="number">2</span>, animations: &#123;</span><br><span class="line">            <span class="comment">// 执行UIView和UIViewCopy的动画</span></span><br><span class="line">            virtualTargetView.transform = <span class="type">CGAffineTransformConcat</span>(<span class="type">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">0.1</span>), <span class="type">CGAffineTransformMakeTranslation</span>(<span class="number">1.0</span>, -virtualTargetView.frame.height / <span class="number">2</span>))</span><br><span class="line">            virtualTargetView.alpha = <span class="number">0</span></span><br><span class="line">            viewCopy.alpha = <span class="number">1</span></span><br><span class="line">            viewCopy.transform = <span class="type">CGAffineTransformIdentity</span></span><br><span class="line">        &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 当动画执行完毕后，将UIViewCopy的信息赋值给UIView，并还原UIView的状态，即与UIViewCopy相同的状态，然后移除UIViewCopy</span></span><br><span class="line">            virtualTargetView.alpha = <span class="number">1</span></span><br><span class="line">            virtualTargetView.text = viewCopy.text</span><br><span class="line">            virtualTargetView.transform = <span class="type">CGAffineTransformIdentity</span></span><br><span class="line">            viewCopy.removeFromSuperview()</span><br><span class="line">        &#125;)</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> targetView.isKindOfClass(<span class="type">UIImageView</span>) &#123;</span><br><span class="line">         <span class="keyword">let</span> virtualTargetView = targetView <span class="keyword">as</span>! <span class="type">UIImageView</span></span><br><span class="line">         <span class="keyword">let</span> viewCopy = <span class="type">UIImageView</span>(frame: virtualTargetView.frame)</span><br><span class="line">         viewCopy.alpha = <span class="number">0</span></span><br><span class="line">         viewCopy.image = <span class="type">UIImage</span>(named: flightInfo)</span><br><span class="line">         viewCopy.transform = <span class="type">CGAffineTransformConcat</span>(<span class="type">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">0.1</span>), <span class="type">CGAffineTransformMakeTranslation</span>(<span class="number">1.0</span>, viewCopy.frame.height / <span class="number">2</span>))</span><br><span class="line">         <span class="keyword">self</span>.topView.addSubview(viewCopy)</span><br><span class="line">         <span class="type">UIView</span>.animateWithDuration(<span class="number">2</span>, animations: &#123;</span><br><span class="line">             virtualTargetView.transform = <span class="type">CGAffineTransformConcat</span>(<span class="type">CGAffineTransformMakeScale</span>(<span class="number">1.0</span>, <span class="number">0.1</span>), <span class="type">CGAffineTransformMakeTranslation</span>(<span class="number">1.0</span>, -virtualTargetView.frame.height / <span class="number">2</span>))</span><br><span class="line">             virtualTargetView.alpha = <span class="number">0</span></span><br><span class="line">             viewCopy.alpha = <span class="number">1</span></span><br><span class="line">             viewCopy.transform = <span class="type">CGAffineTransformIdentity</span></span><br><span class="line">         &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">             virtualTargetView.alpha = <span class="number">1</span></span><br><span class="line">             virtualTargetView.image = viewCopy.image</span><br><span class="line">             virtualTargetView.transform = <span class="type">CGAffineTransformIdentity</span></span><br><span class="line">             viewCopy.removeFromSuperview()</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体有这么几个步骤：</p>
<ul>
<li>判断<code>UIView</code>的具体实现类，判断是<code>UILabel</code>还是<code>UIImageView</code>。</li>
<li>复制一份<code>UIView</code>，作为底面。</li>
<li>设置<code>UIViewCopy</code>的初始位置和高度。</li>
<li>执行UIView<code>和</code>UIViewCopy`的动画。</li>
<li>当动画执行完毕后，将<code>UIViewCopy</code>的信息赋值给<code>UIView</code>，并还原<code>UIView</code>的状态，即与<code>UIViewCopy</code>相同的状态，然后移除<code>UIViewCopy</code>。</li>
</ul>
<h3 id="u5C0F_u7BAD_u5934_u65CB_u8F6C_u52A8_u753B"><a href="#u5C0F_u7BAD_u5934_u65CB_u8F6C_u52A8_u753B" class="headerlink" title="小箭头旋转动画"></a>小箭头旋转动画</h3><p>因为航班信息有已降落和即将起飞两种状态，所以小箭头旋转涉及到一个方向问题，我们可以先定义一个枚举类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RotateDirection</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Positive</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Negative</span> = -<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后写一个箭头旋转的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rotateAnimate</span><span class="params">(direction: Int)</span></span> &#123;</span><br><span class="line">   <span class="type">UIView</span>.animateWithDuration(<span class="number">2</span>, animations: &#123;</span><br><span class="line">       <span class="comment">// 判断向上还是向下旋转</span></span><br><span class="line">       <span class="keyword">if</span> <span class="type">RotateDirection</span>.<span class="type">Positive</span>.rawValue == direction &#123;</span><br><span class="line">           <span class="comment">// 在这个示例中小箭头的初始状态是飞机已降落状态，所以想要箭头从起飞状态旋转到降落状态，只要恢复初始状态即可</span></span><br><span class="line">           <span class="keyword">self</span>.landedOrDepatureSmallArrowImageView.transform = <span class="type">CGAffineTransformIdentity</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 向上旋转</span></span><br><span class="line">           <span class="keyword">let</span> rotation = <span class="type">CGAffineTransformMakeRotation</span>(<span class="type">CGFloat</span>(<span class="type">RotateDirection</span>.<span class="type">Negative</span>.rawValue) * <span class="type">CGFloat</span>(<span class="type">M_PI_2</span>))</span><br><span class="line">           <span class="keyword">self</span>.landedOrDepatureSmallArrowImageView.transform = rotation</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给大家解释一下上述方法的几个步骤：</p>
<ul>
<li>首先判断旋转的方向，通过传入的<code>direction</code>参数。</li>
<li>如果判断出是降落状态的箭头，也就是向下旋转的箭头，那么我们只需要将<code>landedOrDepatureSmallArrowImageView</code>的<code>transform</code>属性恢复初始值即可，因为在这个示例中小箭头的初始状态就是飞机降落状态。</li>
<li>向上旋转时创建一个<code>CGAffineTransformMakeRotation</code>，然后设置正确地方向和角度即可。</li>
</ul>
<blockquote>
<p> 注：<code>CGAffineTransformMakeRotation</code>转换每次都是以初始位置为准，<code>CGAffineTransformRotation</code>转换是以每次的旋转位置为准。</p>
</blockquote>
<h3 id="u5730_u70B9_u548C_u98DE_u673A_u52A8_u753B"><a href="#u5730_u70B9_u548C_u98DE_u673A_u52A8_u753B" class="headerlink" title="地点和飞机动画"></a>地点和飞机动画</h3><p>起飞地、目的地、飞机的动画是一个组合动画，因为这里面存在飞机出现和消失，以及旋转的时机问题，我们来看看这个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">placeAndAirplaneAnimate</span><span class="params">(flightItem: NSDictionary)</span></span> &#123;</span><br><span class="line">    <span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, delay: <span class="number">0</span>, options: [], animations: &#123;</span><br><span class="line">        <span class="comment">// 将起飞地向上移动，同时淡出</span></span><br><span class="line">        <span class="keyword">self</span>.targetPlace.center.y += <span class="number">100</span></span><br><span class="line">        <span class="keyword">self</span>.targetPlace.alpha = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 将目的地向下移动，同时淡出</span></span><br><span class="line">        <span class="keyword">self</span>.sourcePlace.center.y -= <span class="number">100</span></span><br><span class="line">        <span class="keyword">self</span>.sourcePlace.alpha = <span class="number">0</span></span><br><span class="line">        <span class="comment">// 将飞机向右移出屏幕</span></span><br><span class="line">        <span class="keyword">self</span>.airplaneImageView.center.x += <span class="keyword">self</span>.view.bounds.width / <span class="number">1.5</span></span><br><span class="line">        &#125;, completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 根据传入的数据源更改起飞地和目的地</span></span><br><span class="line">            <span class="keyword">self</span>.targetPlace.text = flightItem[<span class="string">"targetPlace"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">            <span class="keyword">self</span>.sourcePlace.text = flightItem[<span class="string">"sourcePlace"</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">            <span class="comment">// 将飞机移到屏幕左侧外，这里没有补间动画</span></span><br><span class="line">            <span class="keyword">self</span>.airplaneImageView.center.x -= <span class="keyword">self</span>.view.bounds.width * <span class="number">1.5</span></span><br><span class="line">            <span class="comment">// 将飞机向上旋转一个角度，这里没有补间动画</span></span><br><span class="line">            <span class="keyword">self</span>.airplaneImageView.transform = <span class="type">CGAffineTransformMakeRotation</span>(-<span class="number">3.14</span>/<span class="number">10</span>)</span><br><span class="line">            <span class="type">UIView</span>.animateWithDuration(<span class="number">1.0</span>, animations: &#123;</span><br><span class="line">                <span class="comment">// 将起飞地向下移动，也就是恢复到初始位值，同时淡入</span></span><br><span class="line">                <span class="keyword">self</span>.targetPlace.center.y -= <span class="number">100</span></span><br><span class="line">                <span class="keyword">self</span>.targetPlace.alpha = <span class="number">1</span></span><br><span class="line">                <span class="comment">// 将目的地向上移动，也就是恢复到初始位值，同时淡入</span></span><br><span class="line">                <span class="keyword">self</span>.sourcePlace.center.y += <span class="number">100</span></span><br><span class="line">                <span class="keyword">self</span>.sourcePlace.alpha = <span class="number">1</span></span><br><span class="line">                <span class="comment">// 将飞机移动到初始位置</span></span><br><span class="line">                <span class="keyword">self</span>.airplaneImageView.center = <span class="keyword">self</span>.airplaneImageViewOriginalCenter</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="type">UIView</span>.animateWithDuration(<span class="number">0.7</span>, delay: <span class="number">0.5</span>, options: [], animations: &#123;</span><br><span class="line">                <span class="comment">// 将飞机的角度恢复到初始状态</span></span><br><span class="line">                <span class="keyword">self</span>.airplaneImageView.transform = <span class="type">CGAffineTransformIdentity</span></span><br><span class="line">            &#125;, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刨析一下这个方法：</p>
<ul>
<li>首先是起飞地向上移动同时淡出、目的地向下移动同时淡出、将飞机向右移出屏幕，这些动画属性的改变会产生补间动画。</li>
<li>然后当上面这些动画结束后，根据数据源参数更改起飞地和目的地的值，同时将飞机移动屏幕左侧外并向上旋转一个角度，这些属性的改变是不会产生补间动画的，应为它们在<code>completion</code>闭包中。</li>
<li>最后再使用两个动画方法将起飞地向下移动，也就是恢复到初始位值同时淡入，将目的地向上移动，也就是恢复到初始位值同时淡入，将飞机移动到初始位置，将飞机的角度恢复到初始状态。这里为什么不把恢复飞机角度和恢复位置放在一个动画方法里呢？因为恢复飞机角度需要一个延迟时间，也就是当飞机飞入屏幕一会后再恢复角度，表示一个降落的效果，使动画看起来更加逼真。</li>
</ul>
<p>还有底部的时间还有地点下地横线都是淡入淡出的动画比较简单，这里就不在累赘了。</p>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>再简单地动画效果只要组合的恰当，值设置的考究都可以做出出色的动画效果。这些简单地动画效果也是复杂动画效果的基础。上述动画示例的代码可能写的不够精细，还可以提炼的有层次，不过大家了解了知识点后可以自己实现更考究的代码结构，实现更精致的动画。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p> 本文首发<a href="http://www.csdn.net/article/2015-07-20/2825255-ios-uiview-animation-4-practice/1" target="_blank" rel="externa]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS UIView Animation - Transition]]></title>
    <link href="http://www.devtalking.com//articles/uiview-transition-animation/"/>
    <id>http://www.devtalking.com//articles/uiview-transition-animation/</id>
    <published>2015-07-07T16:00:00.000Z</published>
    <updated>2016-01-01T14:12:24.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p> 本文首发<a href="http://www.csdn.net/article/2015-07-06/2825139-ios-uiview-animation-3" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
</blockquote>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>在上两篇文章中向大家介绍了如何创建基于动画属性的视图动画，比如位置、透明度等。但是大家有没有想过添加或删除一个视图时怎样添加相应地动画呢？</p>
<p>当然我们可以用第一篇文章中对用户名、密码输入框的处理办法，但是还有更好的办法处理这种状况。那就是在这篇文章中将向大家介绍的过渡转变（Transition）动画。</p>
<p>过渡转变动画是Apple预定义的动画集，它没有更改视图某属性起始值和终止值的概念，而只需要你设定不同的动画选项即可。</p>
<h2 id="u6DFB_u52A0_u65B0_u89C6_u56FE"><a href="#u6DFB_u52A0_u65B0_u89C6_u56FE" class="headerlink" title="添加新视图"></a>添加新视图</h2><p>在进行示例之前，大家需要注意一点过渡转变动画与动画属性动画的不同之处。我们在创建动画属性动画时只需要在<code>animations</code>闭包中添加对视图动画属性修改的代码即可，它没有作用域或作用视图的概念。而在过渡转变动画中有作用视图的概念，也就是说我们调用过渡转变动画方法时需要指定一个作用视图。</p>
<p>明确这点不同之后，我们对作用视图再作进一步的说明。过渡转变动画中的作用视图并不是我们的目标视图，而是目标视图的容器视图，那么大家不难想象，如果该容器视图中有多个子视图，那么这些子视图都会有过渡转变动画效果。下面用示例像大家说明。</p>
<p>先看看一个简单的视图结构：</p>
<p><img src="http://d.pr/i/VeYP+" alt="视图结构"></p>
<p>很明显，我们添加了一个视图作为容器视图，并且尺寸等于屏幕尺寸。在<code>ViewController.swift</code>中有该容器视图的Outlet以及一个图片视图：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> containerView: <span class="type">UIView</span>!</span><br><span class="line"><span class="keyword">let</span> ipadView = <span class="type">UIImageView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">151.5</span>))</span><br></pre></td></tr></table></figure>
<p>在<code>viewDidLoad()</code>方法中给<code>ipadView</code>指定图片：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ipadView.image = <span class="type">UIImage</span>(named: <span class="string">"ipad"</span>)</span><br></pre></td></tr></table></figure>
<p>然后在<code>viewDidAppear()</code>方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.transitionWithView(<span class="keyword">self</span>.containerView, duration: <span class="number">1.5</span>, options: .<span class="type">TransitionFlipFromBottom</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.containerView.addSubview(<span class="keyword">self</span>.ipadView)</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>上述代码就是我们今天的主角，过渡转变方法之一，它同样是<code>UIView</code>的类方法，共有五个参数：</p>
<ul>
<li><code>view</code>：第一个参数，也就是作用视图，一般都是容器视图。</li>
<li><code>duration</code>：动画持续时间。</li>
<li><code>options</code>：过渡转变动画选项，由它来确定过渡转变的具体展现形式。</li>
<li><code>animations</code>：动画闭包。</li>
<li><code>completion</code>：动画结束后执行该闭包中的代码。</li>
</ul>
<p>除了第一个参数，其他四个参数大家应该都不会陌生。这段代码用文字解释出来就是将容器视图（<code>containerView</code>）添加子视图（<code>ipadView</code>）的过程使用<code>.TransitionFlipFromBottom</code>类型的过渡转变动画展示出来，持续时间为1.5秒。编译运行看看效果：</p>
<iframe src="https://player.vimeo.com/video/132628194?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>我们再来添加一个子视图（该子视图的初始化代码不再累赘）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.transitionWithView(<span class="keyword">self</span>.containerView, duration: <span class="number">1.5</span>, options: .<span class="type">TransitionFlipFromBottom</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.containerView.addSubview(<span class="keyword">self</span>.ipadView)</span><br><span class="line">    <span class="keyword">self</span>.containerView.addSubview(<span class="keyword">self</span>.iphoneView)</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>编译运行看看效果：</p>
<iframe src="https://player.vimeo.com/video/132628304?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>大家可以看到这两个子视图都依托与它们的容器视图进行了过渡转变动画。下面的列表是所有过渡转变动画的动画选项，大家可以在你们自己的项目中逐个实验：</p>
<ul>
<li><code>.TransitionFlipFromLeft</code></li>
<li><code>.TransitionFlipFromRight</code></li>
<li><code>.TransitionCurlUp</code></li>
<li><code>.TransitionCurlDown</code></li>
<li><code>.TransitionCrossDissolve</code></li>
<li><code>.TransitionFlipFromTop</code></li>
<li><code>.TransitionFlipFromBottom</code></li>
</ul>
<p>如果我们有多个目标视图，想进行不同的过渡转变动画怎么办？那我们就创建多个目标视图的容器视图，尺寸与目标视图一致，放置在合适的位置：</p>
<p><img src="http://d.pr/i/1406Q+" alt="视图结构"></p>
<p>从上图中可以看出，我们在屏幕上放置了四个容器视图，显而易见，我们要分别对这四个容器视图添加过渡转变动画。当然容器视图里要添加什么样的视图随个人喜好。</p>
<p>在<code>viewDidLoad()</code>方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.transitionWithView(<span class="keyword">self</span>.ipadContainerView, duration: <span class="number">1.5</span>, options: [.<span class="type">CurveEaseOut</span>, .<span class="type">TransitionFlipFromBottom</span>], animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.ipadContainerView.addSubview(<span class="keyword">self</span>.ipadView)</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">UIView</span>.transitionWithView(<span class="keyword">self</span>.iphoneContainerView, duration: <span class="number">1.5</span>, options: [.<span class="type">CurveEaseOut</span>, .<span class="type">TransitionFlipFromLeft</span>], animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.iphoneContainerView.addSubview(<span class="keyword">self</span>.iphoneView)</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">UIView</span>.transitionWithView(<span class="keyword">self</span>.webContainerView, duration: <span class="number">1.5</span>, options: [.<span class="type">CurveEaseOut</span>, .<span class="type">TransitionFlipFromRight</span>], animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.webContainerView.addSubview(<span class="keyword">self</span>.webView)</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">UIView</span>.transitionWithView(textContainerView, duration: <span class="number">2</span>, options: [.<span class="type">CurveEaseOut</span>, .<span class="type">TransitionCrossDissolve</span>], animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.textContainerView.addSubview(<span class="keyword">self</span>.textView)</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>通过上述代码可以看出，我们对四个容器视图分别添加了过渡转变动画，并且<code>options</code>参数使用了<code>.CurveEaseOut</code>和不同的过渡转变动画选项。编译运行看看效果：</p>
<iframe src="https://player.vimeo.com/video/132628896?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>是不是有点儿意思！不过细心的朋友应该发现了，过渡转变动画的方法没有<code>delay</code>这个很有用的属性，这就导致过渡转变动画都是同时发生，不能设置延迟时间。不过我们可以曲线救国，自己写一个<code>delay</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">delay</span><span class="params">(seconds: Double, completion:<span class="params">()</span></span></span>-&gt;()) &#123;</span><br><span class="line">    <span class="keyword">let</span> popTime = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="type">Int64</span>( <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>) * seconds ))</span><br><span class="line">    dispatch_after(popTime, dispatch_get_main_queue()) &#123;</span><br><span class="line">        completion()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们修改<code>viewDidLoad()</code>方法中的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">delay(<span class="number">0</span>, completion: &#123;</span><br><span class="line">   <span class="type">UIView</span>.transitionWithView(<span class="keyword">self</span>.ipadContainerView, duration: <span class="number">1.5</span>, options: [.<span class="type">CurveEaseOut</span>, .<span class="type">TransitionFlipFromBottom</span>], animations: &#123;</span><br><span class="line">       <span class="keyword">self</span>.ipadContainerView.addSubview(<span class="keyword">self</span>.ipadView)</span><br><span class="line">   &#125;, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">delay(<span class="number">1</span>, completion: &#123;</span><br><span class="line">    <span class="type">UIView</span>.transitionWithView(<span class="keyword">self</span>.iphoneContainerView, duration: <span class="number">1.5</span>, options: [.<span class="type">CurveEaseOut</span>, .<span class="type">TransitionFlipFromLeft</span>], animations: &#123;</span><br><span class="line">        <span class="keyword">self</span>.iphoneContainerView.addSubview(<span class="keyword">self</span>.iphoneView)</span><br><span class="line">    &#125;, completion: <span class="literal">nil</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">        </span><br><span class="line">delay(<span class="number">2</span>, completion: &#123;</span><br><span class="line">    <span class="type">UIView</span>.transitionWithView(<span class="keyword">self</span>.webContainerView, duration: <span class="number">1.5</span>, options: [.<span class="type">CurveEaseOut</span>, .<span class="type">TransitionFlipFromRight</span>], animations: &#123;</span><br><span class="line">        <span class="keyword">self</span>.webContainerView.addSubview(<span class="keyword">self</span>.webView)</span><br><span class="line">     &#125;, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">delay(<span class="number">3</span>, completion: &#123;</span><br><span class="line">    <span class="type">UIView</span>.transitionWithView(<span class="keyword">self</span>.textContainerView, duration: <span class="number">2</span>, options: [.<span class="type">CurveEaseOut</span>, .<span class="type">TransitionCrossDissolve</span>], animations: &#123;</span><br><span class="line">        <span class="keyword">self</span>.textContainerView.addSubview(<span class="keyword">self</span>.textView)</span><br><span class="line">    &#125;, completion: <span class="literal">nil</span>)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>
<p>我们将每个过渡转变动画延迟1秒进行，编译运行看看效果：</p>
<iframe src="https://player.vimeo.com/video/132629174?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>现在的效果是不是更好了呢！ : ]</p>
<h2 id="u79FB_u9664_u89C6_u56FE"><a href="#u79FB_u9664_u89C6_u56FE" class="headerlink" title="移除视图"></a>移除视图</h2><p>过渡转变动画同样可以用来移除视图。我们在屏幕底部添加一个<code>UIButton</code>，当点击这个按钮的时候，通过过渡转变动画移除按钮上方的那两排字，并且改变屏幕背景色。<code>go()</code>方法是按钮连接在代码中的<strong>Touch Up Inside</strong>方法，在该方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.5</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = <span class="type">UIColor</span>(red: <span class="number">252.0</span>/<span class="number">255.0</span>, green: <span class="number">155.0</span>/<span class="number">255.0</span>, blue: <span class="number">65.0</span>/<span class="number">255.0</span>, alpha: <span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 编译运行看看效果：</p>
 <iframe src="https://player.vimeo.com/video/132629842?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<h2 id="u66FF_u6362_u89C6_u56FE"><a href="#u66FF_u6362_u89C6_u56FE" class="headerlink" title="替换视图"></a>替换视图</h2><p> 在这一节我们将要学习过渡转变动画的另一个方法，替换视图方法。我设计的场景是当点击<strong>Go</strong>按钮后，除了上一节中的动画效果以外，iPad、iPhone、Web视图也会移位并且替换为别的视图，我们继续在<code>go()</code>方法中的添加如下代码：</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, delay: <span class="number">0</span>, options: [], animations: &#123;</span><br><span class="line">     <span class="keyword">self</span>.iphoneView.frame = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">334</span>, <span class="number">72</span>)</span><br><span class="line">     <span class="keyword">self</span>.iphoneContainerView.frame = <span class="type">CGRectMake</span>(<span class="number">26</span>, <span class="number">130</span>, <span class="number">334</span>, <span class="number">72</span>)</span><br><span class="line">  &#125;, completion: &#123;</span><br><span class="line">  		(flag: <span class="type">Bool</span>) <span class="keyword">in</span></span><br><span class="line">        		<span class="keyword">if</span> flag &#123;</span><br><span class="line">                		<span class="type">UIView</span>.transitionFromView(<span class="keyword">self</span>.iphoneContainerView, toView: <span class="keyword">self</span>.supportIphone, duration: <span class="number">0.33</span>, options: .<span class="type">TransitionCrossDissolve</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">               	&#125;</span><br><span class="line"> &#125;)</span><br><span class="line">        </span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, delay: <span class="number">1</span>, options: [], animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.ipadView.frame = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">334</span>, <span class="number">72</span>)</span><br><span class="line">    <span class="keyword">self</span>.ipadContainerView.frame = <span class="type">CGRectMake</span>(<span class="number">26</span>, <span class="number">242</span>, <span class="number">334</span>, <span class="number">72</span>)</span><br><span class="line">  &#125;, completion: &#123;</span><br><span class="line">  		(flag: <span class="type">Bool</span>) <span class="keyword">in</span></span><br><span class="line">        		<span class="keyword">if</span> flag &#123;</span><br><span class="line">                		<span class="type">UIView</span>.transitionFromView(<span class="keyword">self</span>.ipadContainerView, toView: <span class="keyword">self</span>.supportIpad, duration: <span class="number">0.33</span>, options: .<span class="type">TransitionCrossDissolve</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">                &#125;</span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, delay: <span class="number">2</span>, options: [], animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.webView.frame = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">334</span>, <span class="number">72</span>)</span><br><span class="line">    <span class="keyword">self</span>.webContainerView.frame = <span class="type">CGRectMake</span>(<span class="number">26</span>, <span class="number">354</span>, <span class="number">334</span>, <span class="number">72</span>)</span><br><span class="line">&#125;, completion: &#123;</span><br><span class="line">		(flag: <span class="type">Bool</span>) <span class="keyword">in</span></span><br><span class="line">        		<span class="keyword">if</span> flag &#123;</span><br><span class="line">                		<span class="type">UIView</span>.transitionFromView(<span class="keyword">self</span>.webContainerView, toView: <span class="keyword">self</span>.supportWeb, duration: <span class="number">0.33</span>, options: .<span class="type">TransitionCrossDissolve</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">        		&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p> 我们来解释一下上述的代码，拿iPhone视图为例，首先通过动画属性动画改变它的尺寸大小和位置。然后在<code>completion</code>闭包中添加替换视图方法，该方法有五个参数：</p>
<ul>
<li><code>fromView</code>：被替换的视图。</li>
<li><code>toView</code>：替换之后的视图。</li>
<li><code>duration</code>：动画持续时间。</li>
<li><code>options</code>：动画选项。</li>
<li><code>completion</code>：动画执行结束后执行该闭包中的代码。</li>
</ul>
<p>要注意的是该方法的作用视图可以是容器视图，也可以是目标视图。编译运行看看效果：</p>
<iframe src="https://player.vimeo.com/video/132631364?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<h2 id="u663E_u793A/_u9690_u85CF_u89C6_u56FE"><a href="#u663E_u793A/_u9690_u85CF_u89C6_u56FE" class="headerlink" title="显示/隐藏视图"></a>显示/隐藏视图</h2><p>过渡转变动画也可以用于显示或隐藏视图，这里给出伪代码供参考：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.transitionWithView(<span class="keyword">self</span>.someContainerView, duration: <span class="number">1.5</span>, options: [.<span class="type">CurveEaseOut</span>, .<span class="type">TransitionFlipFromBottom</span>], animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.someView.hidden = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// self.someView.hidden = false</span></span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>过渡转变动画有很多动画选项，大家可以自行试试，找出自己喜欢的或最合适的过渡转变动画选项，并且可以尝试过渡转变动画和属性动画的组合，可以使你们的App更加有趣。好了今天就到这里。</p>
<p>参考文献来自：<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p> 本文首发<a href="http://www.csdn.net/article/2015-07-06/2825139-ios-uiview-animation-3" target="_blank" rel="external">CSDN</a>]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS UIView Animation - Spring]]></title>
    <link href="http://www.devtalking.com//articles/uiview-spring-animation/"/>
    <id>http://www.devtalking.com//articles/uiview-spring-animation/</id>
    <published>2015-07-01T16:00:00.000Z</published>
    <updated>2016-01-01T14:11:26.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文首发<a href="http://www.csdn.net/article/2015-07-03/2825122-ios-uiview-animation-2" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
</blockquote>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>通过上一篇文章，大家应该学会了如何使用<code>UIKit</code>创建最基本的视图动画，包括如何指定视图某属性的起始值和结束值，以及动画持续时间、动画延迟时间、动画选项等概念。</p>
<p>但是目前大家实现的动画不论是位置移动还是大小改变都是以一个单一的方向在运动，比如位置从A点到B点，大小半径从1到2:</p>
<p><img src="http://d.pr/i/13ugd+" alt="图1"></p>
<p>在这篇文章中，大家会学到更复杂一点的动画，让视图在一次动画中的运动轨迹像弹簧一样，有多次不同方向的运动，最后停止在终点：</p>
<p><img src="http://d.pr/i/iUUC+" alt="图2"></p>
<p>如果给位置移动的动画添加弹簧效果，那么视图的运动轨迹应该像下图中展现的一样：</p>
<p><img src="http://d.pr/i/1hFxO+" alt="图3"></p>
<p>这会使你的动画看起来更逼真、更真实、更贴近现实。在某些情况下带给用户更好的用户体验。那么让我们开始学习吧。</p>
<h2 id="Spring_u52A8_u753B"><a href="#Spring_u52A8_u753B" class="headerlink" title="Spring动画"></a>Spring动画</h2><p>我们还是以上一篇文章中的登录页面为例，大家应该发现了那个呆板的登录按钮吧，我们今天就让它Q弹起来。</p>
<p>打开<code>ViewController.swift</code>，在<code>viewWillAppear()</code>方法的底部添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">self</span>.loginButton.center.y += <span class="number">30</span></span><br><span class="line"><span class="keyword">self</span>.loginButton.alpha = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>让登录按钮在屏幕呈现之前位置下移30，并且让它透明。然后在<code>viewDidAppear()</code>方法的底部添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, delay: <span class="number">0.5</span>, usingSpringWithDamping: <span class="number">0.5</span>, initialSpringVelocity: <span class="number">0</span>, options: .<span class="type">AllowUserInteraction</span>, animations: &#123;</span><br><span class="line">     <span class="keyword">self</span>.loginButton.center.y -= <span class="number">30</span></span><br><span class="line">     <span class="keyword">self</span>.loginButton.alpha = <span class="number">1</span></span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>上述的代码大家是不是似曾相识，没错，依然是<code>UIView</code>的类方法，不过又多了两个参数：</p>
<ul>
<li><code>usingSpringWithDamping</code>：弹簧动画的阻尼值，也就是相当于摩擦力的大小，该属性的值从0.0到1.0之间，越靠近0，阻尼越小，弹动的幅度越大，反之阻尼越大，弹动的幅度越小，如果大道一定程度，会出现弹不动的情况。</li>
<li><code>initialSpringVelocity</code>：弹簧动画的速率，或者说是动力。值越小弹簧的动力越小，弹簧拉伸的幅度越小，反之动力越大，弹簧拉伸的幅度越大。这里需要注意的是，如果设置为0，表示忽略该属性，由动画持续时间和阻尼计算动画的效果。</li>
</ul>
<p>下面我们先来看看不同动力的效果：</p>
<ul>
<li>持续时间为3秒，阻尼为0.5，动力为1：</li>
</ul>
<iframe src="https://player.vimeo.com/video/132389962?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<ul>
<li>持续时间为3秒，阻尼为0.5，动力为20：</li>
</ul>
<iframe src="https://player.vimeo.com/video/132389963?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>当<code>initialSpringVelocity</code>的值为1时，登录按钮上下弹力并不是很强劲，当设置为20时，登录按钮直接冲过了密码输入框，这就是动力的效果。</p>
<p>然后我们再看看不同阻尼的效果：</p>
<ul>
<li>持续时间为3秒，阻尼为0.1，动力为0：</li>
</ul>
<iframe src="https://player.vimeo.com/video/132389964?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<ul>
<li>持续时间为3秒，阻尼为1，动力为0：</li>
</ul>
<iframe src="https://player.vimeo.com/video/132389966?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>当<code>usingSpringWithDamping</code>属性值为0.1时，表示阻尼很小，虽然没有动力因素的影响，但登录按钮弹动的幅度依然比较大，相当于在冰面滑行一样。当该属性为1时，表示阻尼非常大，可以看到登录按钮几乎是没有什么弹动的幅度。这就是阻尼的效果。</p>
<p>大家需要注意的一点是，弹簧动画并不只作用于位置的变化，它可以作用于所有动画属性的变化，比如我们在<code>animations</code>的闭包中除了位置的变化外，还有透明度的变化，它也同样有弹簧动画的效果，只不过它没有位置变化那么明显和贴近真实，它会表现出一闪一闪的效果：</p>
<iframe src="https://player.vimeo.com/video/132389969?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>大家可以尝试这几个属性不同值的组合，选出一个自己觉得满意的弹簧效果即可。</p>
<h2 id="u5C06_u52A8_u753B_u8FD0_u7528_u5230_u4EBA_u673A_u4EA4_u4E92"><a href="#u5C06_u52A8_u753B_u8FD0_u7528_u5230_u4EBA_u673A_u4EA4_u4E92" class="headerlink" title="将动画运用到人机交互"></a>将动画运用到人机交互</h2><p>上一节讲的弹簧动画的确可以让我们的UI变得鲜活起来，但这仅仅是看在眼里的，对于用户的操作却并没有什么响应和反馈。在这节会教大家如何让视图在用户进行点击操作时以动画的形式给予响应和反馈。</p>
<p>在<code>ViewController.swift</code>中有一个名为<code>login()</code>的方法，关联了登录按钮的<strong>Touch Up Inside</strong>事件，在该方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.5</span>, delay: <span class="number">0.0</span>, usingSpringWithDamping: <span class="number">0.2</span>, initialSpringVelocity: <span class="number">0.0</span>, options: .<span class="type">AllowUserInteraction</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.loginButton.bounds.size.width += <span class="number">25</span></span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>此时每当我们点击登录按钮一次，它就会变胖一些。编译运行看一下效果：</p>
<iframe src="https://player.vimeo.com/video/132390547?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>我们可以再组合一个效果，使点击登录按钮时不仅让它变胖，还有轻微的向下弹跳效果。在<code>login()</code>方法底部添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.3</span>, delay: <span class="number">0.0</span>, usingSpringWithDamping: <span class="number">0.6</span>, initialSpringVelocity: <span class="number">0.0</span>, options: .<span class="type">AllowUserInteraction</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.loginButton.center.y += <span class="number">10</span></span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>编译运行看一下效果：</p>
<iframe src="https://player.vimeo.com/video/132390546?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>以上只是两个简单的将动画运用到人机交互的例子，大家可以在自己的项目中将一些用户的操作加上视图的动画反馈，让你的应用鲜活起来。</p>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>这一篇文章向大家讲解了<code>UIView</code>的Spring动画，以及将动画运用到人机交互中，使提升应用的用户体验，大家可以多多尝试Spring动画的各个属性，以及结合<a href="http://www.devtalking.com/articles/uiview-first-animation/">上一篇文章</a>的知识，组合出更美妙的动画效果。下一篇文章会给大家介绍<code>UIView</code>的Transition动画，敬请期待。</p>
<p>参考文献来自：<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文首发<a href="http://www.csdn.net/article/2015-07-03/2825122-ios-uiview-animation-2" target="_blank" rel="external">CSDN</a>，]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS UIView Animation - First Animation]]></title>
    <link href="http://www.devtalking.com//articles/uiview-first-animation/"/>
    <id>http://www.devtalking.com//articles/uiview-first-animation/</id>
    <published>2015-06-27T16:00:00.000Z</published>
    <updated>2016-01-01T14:08:15.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文首发<a href="http://www.csdn.net/article/2015-07-02/2825115-ios-uiview-animation-1" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
</blockquote>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>在一个看脸的社会中，不论什么事物，长的好看总是能多吸引一些目光。App同样不例外，一款面相不错的App就算功能已经被轮子千百遍，依然会有人买账，理由就是看的顺眼，于是平面设计人员越来越被重视。白驹过隙，斗转星移，人们已然不满足于静态的美感，于是动态的用户体验应运而生，平面设计人员捉襟见肘，是我们程序员出马的时候了。</p>
<p>这篇文章是UIView Animation的第一篇，从极简的概念开始，为大家揭开Animation的神秘面纱。我们以一个登录界面为例。美丽的太阳，婀娜的云，还有几个小山包，中间静躺着用户名、密码输入框和登录按钮。搁以前，这个界面许是会亮瞎眼现如今尼玛狗都嫌。所以我们的目标是赋予这个界面生命力。</p>
<p><img src="http://d.pr/i/18wNj+" alt="登录页"></p>
<blockquote>
<p>注意：本文章基于Swift 2.0和Xcode 7 Beta2编写。登录界面中的所有元素都已经连接到了代码中（outlet），在这个示例中我们先不使用Auto Layout和SizeClasses。</p>
</blockquote>
<h2 id="u4F1A_u52A8_u7684_u8F93_u5165_u6846"><a href="#u4F1A_u52A8_u7684_u8F93_u5165_u6846" class="headerlink" title="会动的输入框"></a>会动的输入框</h2><p>我们的第一个场景应该是这样。用户打开App，启动画面过后显示登录界面，此时屏幕上还没有用户名和密码的输入框，下一秒他们从屏幕左侧飘然而至。</p>
<h3 id="u9996_u5148"><a href="#u9996_u5148" class="headerlink" title="首先"></a>首先</h3><p>我们需要在登录界面还没有展现给用户的时候把用户名和密码的输入框移至屏幕外面。打开<code>ViewController.swift</code>，在<code>viewWillAppear()</code>方法中添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">self</span>.username.center.x -= <span class="keyword">self</span>.view.bounds.width</span><br><span class="line"><span class="keyword">self</span>.password.center.x -= <span class="keyword">self</span>.view.bounds.width</span><br></pre></td></tr></table></figure>
<p>这两行代码使用户名、密码输入框移出屏幕外，这里可以使用简单暴力的方式，直接让<code>center</code>的<code>x</code>减去屏幕宽度。</p>
<p><img src="http://d.pr/i/11QbT+" alt="输入框移出屏幕"></p>
<h3 id="u7136_u540E"><a href="#u7136_u540E" class="headerlink" title="然后"></a>然后</h3><p>我们在<code>viewDidAppear()</code>方法中添加以下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.5</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.username.center.x += <span class="keyword">self</span>.view.bounds.width</span><br><span class="line">    <span class="keyword">self</span>.password.center.x += <span class="keyword">self</span>.view.bounds.width</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>animationWithDuration(_:animations:)</code>是<code>UIView</code>的类方法，从方法名就可以看出，该方法可使<code>UIView</code>动起来。它有两个参数：</p>
<ul>
<li><code>duration</code>：动画的持续时间。</li>
<li><code>animation</code>：动画闭包，在这个闭包中你可以改变<code>UIView</code>的各种动画属性。</li>
</ul>
<p>因为该方法是一个类方法，所以在闭包中你可以同时改变多个<code>views</code>的动画属性。所以在上述代码中，同时改变了用户名和密码输入框的位置。编译运行，我们可以看到如下效果：</p>
<p><img src="http://d.pr/i/1lMOX+" alt="FirstAnimation-1"></p>
<p>但是由于两个输入框是同时从屏幕外滑入，略显呆板，所以我们用另一个方法再来润色一下。</p>
<h3 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h3><p>我们更新<code>viewDidAppear()</code>中的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.5</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.username.center.x += <span class="keyword">self</span>.view.bounds.width</span><br><span class="line"><span class="comment">//  self.password.center.x += self.view.bounds.width</span></span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.5</span>, delay: <span class="number">0.3</span>, options: .<span class="type">AllowUserInteraction</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.password.center.x += <span class="keyword">self</span>.view.bounds.width</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p><code>animationWithDuration(_:delay:options:animations:completion:)</code>方法同样是<code>UIView</code>的类方法，但是多了3个参数：</p>
<ul>
<li><code>delay</code>：顾名思义，动画迟延执行的时间。</li>
<li><code>options</code>：自定义动画的一些效果，比如重复动画、前后运动等。这个参数在后面的文章中会说明。</li>
<li><code>completion</code>：也是一个闭包，当动画执行完之后会执行该闭包中的逻辑，可以用来连接动画，或者是在动画结束后你需要做一些清理工作等。</li>
</ul>
<p>现在编译运行，可以看到如下效果：</p>
<p><img src="http://d.pr/i/15Ork+" alt="FirstAnimation-2"></p>
<p>用户名输入框先滑入屏幕，在0.3秒的延迟后，密码输入框紧随其后。</p>
<h2 id="u52A8_u753B_u5C5E_u6027"><a href="#u52A8_u753B_u5C5E_u6027" class="headerlink" title="动画属性"></a>动画属性</h2><p>在上一节，我们体验了视图的简单动画效果，不难发现，其实真正导致视图动起来的是<code>animations</code>闭包中的代码，也就是对视图属性的改变，然后<code>UIView</code>的类方法生成了视图某属性的起始值和终止值之间的补间动画。这引出了另一个概念，那就是视图的动画属性，诚然不是所有的视图属性都是动画属性，下面给大家介绍一下视图的动画属性。</p>
<h3 id="u4F4D_u7F6E_u548C_u5927_u5C0F"><a href="#u4F4D_u7F6E_u548C_u5927_u5C0F" class="headerlink" title="位置和大小"></a>位置和大小</h3><ul>
<li><code>bounds</code>：改变视图内容的位置和尺寸大小的属性。</li>
<li><code>frame</code>：改变视图的位置和尺寸大小的属性。</li>
<li><code>center</code>：改变视图位置的属性。</li>
</ul>
<h3 id="u5916_u89C2"><a href="#u5916_u89C2" class="headerlink" title="外观"></a>外观</h3><ul>
<li><code>backgroundColor</code>：改变背景色时，<code>UIKit</code>会线性的从原始颜色转变为目标颜色。</li>
<li><code>alpha</code>：改变透明度，<code>UIKit</code>会创建淡入淡出的效果。</li>
</ul>
<h3 id="u8F6C_u6362"><a href="#u8F6C_u6362" class="headerlink" title="转换"></a>转换</h3><p><code>transform</code>属性的类型为<code>CGAffineTransform</code>，它是一个结构体，<code>CoreGraphics</code>中有若干方法可生成不同的<code>CGAffineTransform</code>结构，使视图旋转、按比例缩放、翻转等，我们来看看它如何使用。在<code>viewDidAppear()</code>方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> rotation = <span class="type">CGAffineTransformMakeRotation</span>(<span class="type">CGFloat</span>(<span class="type">M_PI</span>))</span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.sun.transform = rotation</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>首先创建了一个旋转的结构，参数是一个<code>CGFloat</code>类型的角度，这里我们使用预定义好的常量比如<code>M_PI</code>代表3.14…，也就是旋转一周、<code>M_PI_2</code>代表1.57…，也就是旋转半周等。</p>
<p>然后在<code>animations</code>闭包中将创建的旋转结构赋值给屏幕上太阳视图的<code>transform</code>属性。编译运行可以看到如下效果：</p>
<iframe src="https://player.vimeo.com/video/132005476?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>我们再来看看缩放，在<code>viewDidAppear()</code>方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> scale = <span class="type">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>, <span class="number">0.5</span>)       </span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">1</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.cloudBig.transform = scale</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>首先创建了一个缩放的结构，第一个参数是x轴的缩放比例，第二个参数是y轴的缩放比例。同样在<code>animations</code>闭包中将创建的缩放结构赋值给屏幕上云朵视图的<code>transform</code>属性。编译运行可以看到如下效果：</p>
<iframe src="https://player.vimeo.com/video/132005775?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<h2 id="u52A8_u753B_u9009_u9879"><a href="#u52A8_u753B_u9009_u9879" class="headerlink" title="动画选项"></a>动画选项</h2><p>大家应该还记得我们之前使用过<code>animationWithDuration(_:delay:options:animations:completion:)</code>方法，其中的<code>options</code>当时没有详细的讲述，这节会向大家说明该属性。<code>options</code>选项可以使你自定义让<code>UIKit</code>如何创建你的动画。该属性需要一个或多个<code>UIAnimationOptions</code>枚举类型，让我们来看看都有哪些动画选项吧。</p>
<h3 id="u91CD_u590D_u7C7B"><a href="#u91CD_u590D_u7C7B" class="headerlink" title="重复类"></a>重复类</h3><ul>
<li><code>.Repeat</code>：该属性可以使你的动画永远重复的运行。</li>
<li><code>.Autoreverse</code>：该属性可以使你的动画当运行结束后按照相反的行为继续运行回去。该属性只能和<code>.Repeat</code>属性组合使用。</li>
</ul>
<p>我们来看看怎么使用这两个属性，我们修改一个密码输入框的动画：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.5</span>, delay: <span class="number">0.3</span>, options: .<span class="type">Repeat</span>, animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.password.center.x += <span class="keyword">self</span>.view.bounds.width</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>编译运行看看效果：</p>
<iframe src="https://player.vimeo.com/video/132008765?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>可以看到密码输入框不停的从左向右滑入。大家可以自己试试<code>.Autoreverse</code>的效果或者<code>[.Repeat, .Autoreverse]</code>组合效果。</p>
<h3 id="u52A8_u753B_u7F13_u51B2"><a href="#u52A8_u753B_u7F13_u51B2" class="headerlink" title="动画缓冲"></a>动画缓冲</h3><p>在现实生活中，几乎没有什么东西可以突然开始运动，然后突然停止一动不动。可以运动的物体基本都是以较慢的速度启动，逐渐加速，达到一个稳定的速度，然后当要停止时，会逐渐减速，最后停止。所以要使动画更加逼真，也可以采用这种方式，那就是<strong>ease-in</strong>和<strong>ease-out</strong>。</p>
<ul>
<li><code>.CurveLinear</code> ：该属性既不会使动画加速也不会使动画减速，只是做以线性运动。</li>
<li><code>.CurveEaseIn</code>：该属性使动画在开始时加速运行。</li>
<li><code>.CurveEaseOut</code>：该属性使动画在结束时减速运行。</li>
<li><code>.CurveEaseInOut</code>：该属性结合了上述两种情况，使动画在开始时加速，在结束时减速。</li>
</ul>
<p>下面依然以密码输入框作为示例，修改密码输入框的动画代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.5</span>, delay: <span class="number">0.3</span>, options: [.<span class="type">Repeat</span>, .<span class="type">Autoreverse</span>, .<span class="type">CurveEaseOut</span>], animations: &#123;</span><br><span class="line">    <span class="keyword">self</span>.password.center.x += <span class="keyword">self</span>.view.bounds.width</span><br><span class="line">&#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码中组合了三种动画选项，首先让动画重复执行，然后让动画在一次执行完毕后接着反方向再次执行，最后让动画在结束时减速。编译运行，这次我们减慢动画的运行速度来看看：</p>
<iframe src="https://player.vimeo.com/video/132012000?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>从上面的效果中可以看到当密码输入框滑入屏幕的后半段时速度有明显的减慢。大家也可以在自己的项目中试试其他动画选项的组合。</p>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>看完这篇文章后，相信大家对iOS的动画有了大致的了解，也学会了如何实现简单的视图动画，当然这些只是iOS Animation的冰山一角，我会陆续向大家介绍iOS Animation的其他知识，今天就先到这吧。</p>
<p>参考文献来自：<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文首发<a href="http://www.csdn.net/article/2015-07-02/2825115-ios-uiview-animation-1" target="_blank" rel="external">CSDN</a>，]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 2.0初探]]></title>
    <link href="http://www.devtalking.com//articles/what-is-new-in-swift/"/>
    <id>http://www.devtalking.com//articles/what-is-new-in-swift/</id>
    <published>2015-06-19T16:00:00.000Z</published>
    <updated>2016-01-01T14:07:00.000Z</updated>
    <content type="html"><![CDATA[<p>转眼间，Swift已经一岁多了，这门新鲜、语法时尚、类型安全、执行速度更快的语言已经渐渐的深入广大开发者的心。我同样也是非常喜爱这门新的编程语言。</p>
<p>今年6月，一年一度的WWDC大会如期而至，在大会上Apple发布了Swift 2.0，引入了很多新的特性，以帮助开发者能更快，更简单的构建应用。我在这里也说道说道Swift 2.0中值得大家注意的新特性。</p>
<h2 id="guard_u8BED_u53E5"><a href="#guard_u8BED_u53E5" class="headerlink" title="guard语句"></a><code>guard</code>语句</h2><p><code>guard</code>语句和<code>if</code>语句有点类似，都是根据其关键字之后的表达式的布尔值决定下一步执行什么。但与<code>if</code>语句不同的是，<code>guard</code>语句只会有一个代码块，不像<code>if</code>语句可以<code>if else</code>多个代码块。</p>
<p>那么<code>guard</code>语句的作用到底是什么呢？顾名思义，就是守护。<code>guard</code>语句判断其后的表达式布尔值为<code>false</code>时，才会执行之后代码块里的代码，如果为<code>true</code>，则跳过整个<code>guard</code>语句，我们举例来看看。</p>
<p>我们以今年高考为例，在进入考场时一般都会检查身份证和准考证，我们写这样一个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">checkup</span><span class="params">(person: [String: String!])</span></span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 检查身份证，如果身份证没带，则不能进入考场</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> id = person[<span class="string">"id"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"没有身份证，不能进入考场!"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查准考证，如果准考证没带，则不能进入考场</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> examNumber = person[<span class="string">"examNumber"</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"没有准考证，不能进入考场!"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 身份证和准考证齐全，方可进入考场</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"您的身份证号为:<span class="subst">\(id)</span>，准考证号为:<span class="subst">\(examNumber)</span>。请进入考场!"</span>)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkup([<span class="string">"id"</span>: <span class="string">"123456"</span>]) <span class="comment">// 没有准考证，不能进入考场!</span></span><br><span class="line">checkup([<span class="string">"examNumber"</span>: <span class="string">"654321"</span>]) <span class="comment">// 没有身份证，不能进入考场!</span></span><br><span class="line">checkup([<span class="string">"id"</span>: <span class="string">"123456"</span>, <span class="string">"examNumber"</span>: <span class="string">"654321"</span>]) <span class="comment">// 您的身份证号为:123456，准考证号为:654321。请进入考场!</span></span><br></pre></td></tr></table></figure>
<p>上述代码中的第一个<code>guard</code>语句用于检查身份证，如果检查到身份证没带，也就是表达式为<code>false</code>时，执行大括号里的代码，并返回。第二个<code>guard</code>语句则检查准考证。</p>
<p>如果两证齐全，则执行最后一个打印语句，上面的两个<code>guard</code>语句大括号内的代码都不会执行，因为他们表达式的布尔值都是<code>true</code>。</p>
<p>这里值得注意的是，<code>id</code>和<code>examNumber</code>可以在<code>guard</code>语句之外使用，也就是说当<code>guard</code>对其表达式进行验证后，<code>id</code>和<code>examNumber</code>可在整个方法的作用域中使用，并且是解包后的。</p>
<p>我们再用<code>if else</code>语句写一个类似的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">checkupUseIf</span><span class="params">(person: [String: String!])</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> id = person[<span class="string">"id"</span>], <span class="keyword">let</span> examNumber = person[<span class="string">"examNumber"</span>] &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"您的身份证号为:<span class="subst">\(id)</span>，准考证号为:<span class="subst">\(examNumber)</span>。请进入考场！"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"证件不齐全，不能进入考场!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"您的身份证号为:<span class="subst">\(id)</span>，准考证号为:<span class="subst">\(examNumber)</span>"</span>)  <span class="comment">// 报异常</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkupUseIf([<span class="string">"id"</span>: <span class="string">"123456"</span>]) <span class="comment">// 证件不齐全，不能进入考场!</span></span><br><span class="line">checkupUseIf([<span class="string">"examNumber"</span>: <span class="string">"654321"</span>]) <span class="comment">// 证件不齐全，不能进入考场!</span></span><br><span class="line">checkupUseIf([<span class="string">"id"</span>: <span class="string">"123456"</span>, <span class="string">"examNumber"</span>: <span class="string">"654321"</span>]) <span class="comment">// 您的身份证号为:123456，准考证号为:654321。请进入考场!</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到用<code>if else</code>实现的方法显然不如<code>guard</code>实现的那么精准。而且<code>id</code>和<code>examNumber</code>的作用域只限在<code>if</code>的第一个大括号内，超出这个作用域编译就会报错。</p>
<p>通过上述两个小例子不难看出，<code>guard</code>语句正如一个称职的守卫，层层把关，严防一切不允许发生的事，并且让代码具有更高的可读性，非常棒。</p>
<h2 id="u5F02_u5E38_u5904_u7406"><a href="#u5F02_u5E38_u5904_u7406" class="headerlink" title="异常处理"></a>异常处理</h2><p>在Swift 1.0时代是没有异常处理和抛出机制的，如果要处理异常，要么使用<code>if else</code>语句或<code>switch</code>语句判断处理，要么使用闭包形式的回调函数处理，再要么就使用<code>NSError</code>处理。以上这些方法都不能像Java中的<code>try catch</code>异常控制语句那样行如流水、从容不迫的处理异常，而且也会降低代码的可读性。当Swift 2.0到来后，一切都不一样了。</p>
<p>在Swift 2.0中Apple提供了使用<code>throws</code>、<code>throw</code>、<code>try</code>、<code>do</code>、<code>catch</code>这五个关键字组成的异常控制处理机制。下面我们来举例看看如何使用，我用使用手机刷朋友圈为例。</p>
<p>首先我们需要定义异常枚举，在Swift 2.0中Apple提供了<code>ErrorType</code>协议需要我们自定义的异常枚举遵循：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WechatError</span>: <span class="title">ErrorType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">NoBattery</span> <span class="comment">// 手机没电</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">NoNetwork</span> <span class="comment">// 手机没网</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">NoDataStream</span> <span class="comment">// 手机没有流量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了导致不能刷微信的错误枚举<code>’wechatError</code>。然后定义一个检查是否可以刷微信的方法<code>checkIsWechatOk()</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">checkIsWechatOk</span><span class="params">(isPhoneHasBattery: Bool, isPhoneHasNetwork: Bool, dataStream: Int)</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> isPhoneHasBattery <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">WechatError</span>.<span class="type">NoBattery</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> isPhoneHasNetwork <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">WechatError</span>.<span class="type">NoNetwork</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> dataStream &gt; <span class="number">50</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">WechatError</span>.<span class="type">NoDataStream</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意，在方法名后有<code>throws</code>关键字，意思为该方法产生的异常向上层抛出。在方法体内使用<code>guard</code>语句对各种状态进行判断，然后使用<code>throw</code>关键字抛出对应的异常。然后我们定义刷微信的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">playWechat</span><span class="params">(isPhoneHasBattery: Bool, isPhoneHasNetwork: Bool, dataStream: Int)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> checkIsWechatOk(isPhoneHasBattery, isPhoneHasNetwork: isPhoneHasNetwork, dataStream: dataStream)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"放心刷，刷到天昏地暗！"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="type">WechatError</span>.<span class="type">NoBattery</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"手机都没电，刷个鬼啊！"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="type">WechatError</span>.<span class="type">NoNetwork</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"没有网络哎，洗洗玩单机吧！"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="type">WechatError</span>.<span class="type">NoDataStream</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"没有流量了，去蹭Wifi吧！"</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"见鬼了！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">playWechat(<span class="literal">true</span>, isPhoneHasNetwork: <span class="literal">true</span>, dataStream: <span class="number">60</span>) <span class="comment">// 放心刷，刷到天昏地暗！</span></span><br><span class="line">playWechat(<span class="literal">true</span>, isPhoneHasNetwork: <span class="literal">false</span>, dataStream: <span class="number">60</span>) <span class="comment">// 没有网络哎，洗洗玩单机吧！</span></span><br><span class="line">playWechat(<span class="literal">false</span>, isPhoneHasNetwork: <span class="literal">true</span>, dataStream: <span class="number">60</span>) <span class="comment">// 手机都没电，刷个鬼啊！</span></span><br><span class="line">playWechat(<span class="literal">true</span>, isPhoneHasNetwork: <span class="literal">true</span>, dataStream: <span class="number">30</span>) <span class="comment">// 没有流量了，去蹭Wifi吧！</span></span><br></pre></td></tr></table></figure>
<p>上述的代码示例中，首先检查是否可以刷微信的方法前使用<code>try</code>关键字，表示允许该方法抛出异常，然后使用了<code>do catch</code>控制语句捕获抛出的异常，进而做相关的逻辑处理。</p>
<p>这套异常处理机制使Swift更加的全面和安全，并且提高了代码的可读性，非常棒。</p>
<h2 id="u534F_u8BAE_u6269_u5C55"><a href="#u534F_u8BAE_u6269_u5C55" class="headerlink" title="协议扩展"></a>协议扩展</h2><p>在Swift 1.0 时代，协议（<code>Protocol</code>）基本上类似一个接口，定义若干属性和方法，供类、结构体、枚举遵循和实现。在Swift 2.0中，可以对协议进行属性或者方法的扩展，和扩展类与结构体类似。这让我们开启了面向协议编程的篇章。</p>
<p>Swift中，大多数基础对象都遵循了<code>CustomStringConvertible</code>协议，比如<code>Array</code>、<code>Dictionary</code>（Swift 1.0中的<code>Printable</code>协议），该协议定义了<code>description</code>方法，用于<code>print</code>方法打印对象。现在我们对该协议扩展一个方法，让其打印出大写的内容:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">"hello"</span>, <span class="string">"world"</span>]</span><br><span class="line"><span class="built_in">print</span>(arr.description) <span class="comment">// "[hello, world]"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> upperDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="keyword">self</span>.description.uppercaseString)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(arr.upperDescription) <span class="comment">// "[HELLO, WORLD]"</span></span><br></pre></td></tr></table></figure>
<p>如果在Swfit 1.0时代，要想达到上述示例的效果，那么我们需要分别对<code>Array</code>、<code>Dictionary</code>进行扩展，所以协议的扩展极大的提高了我们的编程效率，也同样使代码更简洁和易读。</p>
<h2 id="u6253_u5370_u8BED_u53E5_u7684_u6539_u53D8"><a href="#u6253_u5370_u8BED_u53E5_u7684_u6539_u53D8" class="headerlink" title="打印语句的改变"></a>打印语句的改变</h2><p>在Swift1中，有’println()’和’print()’两个在控制台打印语句的方法，前者是换行打印，后者是连行打印。在Swift2中，’println()’已成为过去，取而代之的是他俩的结合体。如果你想做换行打印，现在需要这样写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"我要换行！"</span>, appendNewline: <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<h2 id="available_u68C0_u67E5"><a href="#available_u68C0_u67E5" class="headerlink" title="available检查"></a><code>available</code>检查</h2><p>作为iOS开发者，谁都希望使用最新版本iOS的Api进行开发，省事省力。但常常事与愿违，因为我们经常需要适配老版本的iOS，这就会面临一个问题，一些新特性特性或一些类无法在老版本的iOS中使用，所以在编码过程中经常会对iOS的版本做以判断，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="type">NSClassFromString</span>(<span class="string">"NSURLQueryItem"</span>) != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// iOS 8或更高版本</span></span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// iOS8之前的版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这只是一种方式，在Swift 2.0之前也没有一个标准的模式或机制帮助开发者判断iOS版本，而且容易出现疏漏。在Swift 2.0到来后，我们有了标准的方式来做这个工作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">8</span>, *) &#123;</span><br><span class="line">    <span class="comment">// iOS 8或更高版本</span></span><br><span class="line">    <span class="keyword">let</span> queryItem = <span class="type">NSURLQueryItem</span>()</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// iOS8之前的版本</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个特性让我们太幸福。</p>
<h2 id="do-while_u8BED_u53E5_u91CD_u547D_u540D"><a href="#do-while_u8BED_u53E5_u91CD_u547D_u540D" class="headerlink" title="do-while语句重命名"></a><code>do-while</code>语句重命名</h2><p>经典的<code>do-while</code>语句改名了，改为了<code>repeat-while</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">repeat</span> &#123;</span><br><span class="line">    i++</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">&#125; <span class="keyword">while</span> i &lt; <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>个人感觉更加直观了。</p>
<h2 id="defer_u5173_u952E_u5B57"><a href="#defer_u5173_u952E_u5B57" class="headerlink" title="defer关键字"></a><code>defer</code>关键字</h2><p>在一些语言中，有<code>try/finally</code>这样的控制语句，比如Java。这种语句可以让我们在<code>finally</code>代码块中执行必须要执行的代码，不管之前怎样的兴风作浪。在Swift 2.0中，Apple提供了<code>defer</code>关键字，让我们可以实现同样的效果。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">checkSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"CheckPoint 1"</span>)</span><br><span class="line">    doSomething()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"CheckPoint 4"</span>)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"CheckPoint 2"</span>)</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Clean up here"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"CheckPoint 3"</span>)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">checkSomething() <span class="comment">// CheckPoint 1, CheckPoint 2, CheckPoint 3, Clean up here, CheckPoint 4</span></span><br></pre></td></tr></table></figure>
<p>上述示例可以看到，在打印出“CheckPoint 2”之后并没有打印出“Clean up here”，而是“CheckPoint 3”，这就是<code>defer</code>的作用，它对进行了<code>print(&quot;Clean up here&quot;)</code>延迟。我们再来看一个I/O的示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">writeSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> file = <span class="type">OpenFile</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> ioStatus = fetchIOStatus()</span><br><span class="line">    <span class="keyword">guard</span> ioStatus != <span class="string">"error"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    file.write()</span><br><span class="line">    </span><br><span class="line">    closeFile(file)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述示例是一个I/O操作的伪代码，如果获取到的<code>ioStatus</code>正常，那么该方法没有问题，如果<code>ioStatus</code>取到的是<code>error</code>，那么会被<code>guard</code>语句抓到执行<code>return</code>操作，这样的话<code>closeFile(file)</code>就永远都不会执行了，一个严重的Bug就这样产生了。下面我们看看如何用<code>defer</code>来解决这个问题：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">writeSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> file = <span class="type">OpenFile</span>()</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">        closeFile(file)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> ioStatus = fetchIOStatus()</span><br><span class="line">    <span class="keyword">guard</span> ioStatus != <span class="string">"error"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    file.write()</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将<code>closeFile(file)</code>放在<code>defer</code>代码块里，这样即使<code>ioStatus</code>为<code>error</code>，在执行<code>return</code>前会先执行<code>defer</code>里的代码，这样就保证了不管发生什么，最后都会将文件关闭。</p>
<p><code>defer</code>又一个保证我们代码健壮性的特性，我非常喜欢。</p>
<p>Swift 2.0中的新特性当然不止以上这些，但窥一斑可见全豹，Swift 2.0努力将更快、更安全做到极致，这是开发人员的福音，让我们尽情享受这门美妙的语言吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>转眼间，Swift已经一岁多了，这门新鲜、语法时尚、类型安全、执行速度更快的语言已经渐渐的深入广大开发者的心。我同样也是非常喜爱这门新的编程语言。</p>
<p>今年6月，一年一度的WWDC大会如期而至，在大会上Apple发布了Swift 2.0，引入了很多新的特性，以帮助]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift中的iOS设计模式（二）]]></title>
    <link href="http://www.devtalking.com//articles/ios-design-pattern-in-swift-2/"/>
    <id>http://www.devtalking.com//articles/ios-design-pattern-in-swift-2/</id>
    <published>2015-01-13T16:00:00.000Z</published>
    <updated>2016-01-01T14:05:49.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Facade_u8BBE_u8BA1_u6A21_u5F0F"><a href="#Facade_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="Facade设计模式"></a>Facade设计模式</h2><p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-7.png" alt="pic"></p>
<p>Facade设计模式为多个子模块或子系统提供统一的、单独的API接口。也就是说，不用给用户暴露一堆乱七八糟的接口，只需要暴露一个简单的、标准的接口即可。</p>
<p>下面这张图能更好的描述这个概念：</p>
<p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-8.png" alt="pic"></p>
<p>用户在使用我们暴露的标准的API时，根本不知道在这个API底下其实疏导着大量复杂的接口。该设计模式是暴露大量接口的最佳模式，尤其当接口使用很复杂、很难理解时，尤为体现该模式的价值。</p>
<p>Facade模式可以有效保证调用各个模块功能的接口和你隐藏起来的实现模块功能的逻辑代码是一个松耦合的关系。同时也可以减少你的子系统或子模块对外部代码的依赖。例如一个遵循Facade模式的类，如果逻辑有变化，需要修改内部实现代码，但是并不需要修改该逻辑的接口。使用接口的用户甚至根本都不知道你已经修改了该接口背后的某些逻辑功能。</p>
<h2 id="u5982_u4F55_u4F7F_u7528Facade_u8BBE_u8BA1_u6A21_u5F0F"><a href="#u5982_u4F55_u4F7F_u7528Facade_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="如何使用Facade设计模式"></a>如何使用Facade设计模式</h2><p>目前，你们已经有<code>PersistencyManager</code>类用于在本地保存专辑的数据，以及<code>HTTPClient</code>类用于和远程服务器进行交互。项目中的其他类压根不会知道这两个类中具体的处理逻辑，因为他们将要遵循Facade模式，隐藏与<code>LibraryAPI</code>身后。</p>
<p>要遵循Facade模式，我们要有一个暴露给用户接口的类，那就是<code>LibraryAPI</code>，它持有<code>PersistencyManager</code>和<code>HTTPClient</code>的实例，并暴露一些简单的接口来访问这两个类中的方法：</p>
<p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-9.png" alt="pic"></p>
<p><code>LibraryAPI</code>就是作为暴露给其他类的标准接口，它能有效的向接口使用者规避掉<code>HTTPClient</code>和<code>PersistencyManager</code>复杂的逻辑代码。</p>
<p>打开<code>LibraryAPI.swift</code>文件添加如下常量属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> persistencyManager: <span class="type">PersistencyManager</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> httpClient: <span class="type">HTTPClient</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> isOnline: <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<p><code>isOnline</code>属性决定了是否向远程服务器上更新专辑数据的变化，比如添加或删除专辑。</p>
<p>然后需要添加<code>init</code>初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">  persistencyManager = <span class="type">PersistencyManager</span>()</span><br><span class="line">  httpClient = <span class="type">HTTPClient</span>()</span><br><span class="line">  isOnline = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为本篇教程中的示例应用只是为了向大家介绍如何运用各种设计模式，所以没有远程服务器的需求，<code>HTTPClient</code>自然不会用到。所以这里<code>isOnline</code>属性总是设置为<code>false</code>。</p>
<p>下一步，向<code>LibraryAPI.swift</code>文件中添加如下三个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getAlbums</span><span class="params">()</span></span> -&gt; [<span class="type">Album</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> persistencyManager.getAlbums()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addAlbum</span><span class="params">(album: Album, index: Int)</span></span> &#123;</span><br><span class="line">  persistencyManager.addAlbum(album, index: index)</span><br><span class="line">  <span class="keyword">if</span> isOnline &#123;</span><br><span class="line">    httpClient.postRequest(<span class="string">"/api/addAlbum"</span>, body: album.description())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">deleteAlbum</span><span class="params">(index: Int)</span></span> &#123;</span><br><span class="line">  persistencyManager.deleteAlbumAtIndex(index)</span><br><span class="line">  <span class="keyword">if</span> isOnline &#123;</span><br><span class="line">    httpClient.postRequest(<span class="string">"/api/deleteAlbum"</span>, body: <span class="string">"<span class="subst">\(index)</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家看一下<code>addAlbum(_:index:)</code>方法，该方法顾名思义是添加专辑的方法，在实现时会先更新本地的数据，如果网络连通且需要使用远程服务的时候，再调用远程服务接口更新数据状态。当该模块以外的类调用了<code>LibraryAPI</code>接口的<code>addAlbum</code>方法时，它并不知道添加专辑的具体实现逻辑，并且也不需要知道，这就是Facade设计模式的魅力所在。</p>
<p>现在编译运行你们的应用。你们会看到两个空的视图，和一个Toolbar。顶部的视图用于显示专辑的封面，下面的视图会以列表的形式显示该专辑的相关信息。</p>
<p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-10.png" alt="pic"></p>
<p>接下来的工作就是将专辑的数据或图片等显示在屏幕上，这就给我们带来了学习另一个设计模式的机会 – <strong>Decorator设计模式</strong>。</p>
<h2 id="Decorator_u8BBE_u8BA1_u6A21_u5F0F"><a href="#Decorator_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="Decorator设计模式"></a>Decorator设计模式</h2><p>Decorator模式可以自动的为对象添加某些行为或响应能力，并且不需要对该对象做任何修改。</p>
<p>该模式可以通过将希望添加的行为或响应能力打包到另一个对象中，然后通过该对象获得添加的行为或响应能力。</p>
<p>在Swift中，有两种最为常用的实现该模式的方案： <strong>Extensions</strong> 和 <strong>Delegation</strong>。</p>
<h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><p>你们可以对class、struct或者enum添加Extension，用于添加新的行为或响应能力，最关键的是不需要让它们继承乱七八糟的父类。更厉害的是通过Extension你们甚至不需要去访问目标class、struct或enum，就可以给它们添加新的能力。这意味着，你们可以让Cocoa框架中的对象元素更加符合你们自己的口味，比如给UIView或UIImage添加你们想要的能力。这就是Extension机制的强大之处。</p>
<p>这里要注意，通过Extension新添加的方法在编译阶段被加载，然后你们可以像使用某类的原生方法一样使用扩展的方法。但是与传统的Decorator模式有些许不同的是，扩展体不会持有被扩展对象的实例，说白了就是你不能实例化一个扩展体，只能通过实例化被扩展的对象，才能使用其扩展的方法。</p>
<h3 id="u5982_u4F55_u4F7F_u7528Extensions"><a href="#u5982_u4F55_u4F7F_u7528Extensions" class="headerlink" title="如何使用Extensions"></a>如何使用Extensions</h3><p>下图中展示了一种情况，你现在有了<code>Albun</code>对象，然后你想把该对象中的数据展示在一个UITableView中：</p>
<p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-11.png" alt="pic"></p>
<p>在该情况下，专辑的这些数据从哪来呢？很明显是从<code>Album</code>对象中获取，因为它是一个Model对象，而且它根本不关心它持有的数据要如何展现，展现在哪里。那么这时，你就要使用额外的代码让<code>Album</code>具备将数据按需归位的能力，并且不能直接修改该类。</p>
<p>这就需要使用Extension机制了，你们将通过Extension机制扩展<code>Album</code>类，目的是给<code>Album</code>添加一个方法，并返回一个<code>UITableView</code>便于使用的数据结构。</p>
<p>该数据结构图如下：</p>
<p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-12.png" alt="pic"></p>
<p>接下来我们新建一个Swift文件，名为 <strong>AlbumExtensions</strong> ，然后打开 <strong>AlbumExtensions.swift</strong> 文件，添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Album</span> </span>&#123;</span><br><span class="line">  <span class="func"><span class="keyword">func</span> <span class="title">ae_tableRepresentation</span><span class="params">()</span></span> -&gt; (titles:[<span class="type">String</span>], values:[<span class="type">String</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> ([<span class="string">"Artist"</span>, <span class="string">"Album"</span>, <span class="string">"Genre"</span>, <span class="string">"Year"</span>], [artist, title, genre, year])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里注意该方法名的开头<code>ae_</code>，它是<code>AlbumExtensions</code>的缩写。这是一个约定俗成的扩展方法名的写法，目的在于防止扩展方法与原生方法名产生冲突。</p>
<blockquote>
<p><strong>注意：</strong>通常类可以重写父类的方法或属性，但是在Extension中不可以。Extension中的方法名、属性名也不能和原生方法名、原生属性名相同。</p>
</blockquote>
<p>我们再来总结一下Extension机制：</p>
<ul>
<li>当<code>Album</code>被扩展后，直接使用<code>Album</code>访问扩展方法。</li>
<li>你们通过扩展的方式已经给<code>Album</code>添加了新的能力，如果你们还想通过子类的方式，那么依然可以这么做。</li>
<li>上面这个简单的扩展可以看出，你们不用对<code>Album</code>做任何改动，它就具备了可以返回适用于<code>UITableView</code>数据格式的能力。</li>
</ul>
<h3 id="Delegation"><a href="#Delegation" class="headerlink" title="Delegation"></a>Delegation</h3><p>另一个Decorator设计模式是Delegation，它是一种代表其他对象或协调其他对象的机制。</p>
<p>比如当你使用<code>UITableView</code>时，你必须要实现<code>tableView(_:numberOfRowsInSection:)</code>方法，你不要期望<code>UITableView</code>会知道你希望每个Section里有多少行。因此，计算每个Section有多少行的任务就交给了<code>UITableView</code>的代理。这样就可以使<code>UITableView</code>显示与数据松耦合，独立开来。</p>
<p>下图是<code>UITableView</code>和它的代理之间的运行关系示意图：</p>
<p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-13.png" alt="pic"></p>
<p><code>UITableView</code>的工作是将一些信息展示在一个列表视图中。但是它只关注于展示，并不会持有需要展示的数据。那么这时就需要向它的代理询问获取相关的信息了。在Objective-C的代理模式中，代理或协议可以申明两种类型的方法，一种是必须类型，另一种是可选类型。前者是遵循该协议的类必须要实现的方法，后者是可以实现，也可以不实现的方法。你们在该教程中会实践到这些内容。</p>
<p>这时大伙可能会有疑问了，为何我们要使用协议而不直接继承一个对象，然后重写需要的方法呢？这样不是更省事么？但是你们考虑一下，如果这样做，你们只能基于一个单独的父类去实现其子类，也就是说，该父类只能作为某一个对象的代理。如果想让一个对象成为多个对象的代理，那么用继承父类这种形式就行不通了。</p>
<blockquote>
<p><strong>注意：</strong>代理机制是一个很重要的模式。Apple在UIKit框架中大量应用了该模式，比如<code>UITableView</code>、<code>UITextView</code>、<code>UITextField</code>、<code>UIWebView</code>、<code>UIAlert</code>、<code>UIActionSheet</code>、<code>UICollectionView</code>、<code>UIPickerView</code>、<code>UIGestrueRecognizer</code>、<code>UIScrollView</code>等等。</p>
</blockquote>
<h2 id="u5982_u4F55_u4F7F_u7528Delegate_u6A21_u5F0F"><a href="#u5982_u4F55_u4F7F_u7528Delegate_u6A21_u5F0F" class="headerlink" title="如何使用Delegate模式"></a>如何使用Delegate模式</h2><p>打开<code>ViewController.swift</code>文件，然后添加以下私有属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> allAlbums = [<span class="type">Album</span>]()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> currentAlbumData : (titles:[<span class="type">String</span>], values:[<span class="type">String</span>])?</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> currentAlbumIndex = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后重写<code>viewDidLoad</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  <span class="comment">//1</span></span><br><span class="line">  <span class="keyword">self</span>.navigationController?.navigationBar.translucent = <span class="literal">false</span></span><br><span class="line">  currentAlbumIndex = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  allAlbums = <span class="type">LibraryAPI</span>.sharedInstance.getAlbums()</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="comment">// the uitableview that presents the album data</span></span><br><span class="line">  dataTable.delegate = <span class="keyword">self</span></span><br><span class="line">  dataTable.dataSource = <span class="keyword">self</span></span><br><span class="line">  dataTable.backgroundView = <span class="literal">nil</span></span><br><span class="line">  view.addSubview(dataTable!)		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们对上述的代码来进行一一讲解：</p>
<ol>
<li>关闭导航栏的透明效果。</li>
<li>通过API获取所有专辑的列表。这里要记住，要使用符合Facade模式的<code>LibraryAPI</code>而不是直接使用<code>PersisencyManager</code>。</li>
<li>对<code>UITableView</code>进行相关设置，将它的delegate和datasource设置为当前的ViewController。这样一来<code>UITableView</code>所有对数据的请求都会由当前的ViewController响应并提供了。这里需要注意的是如果你们在Storeboard中创建<code>UIViewController</code>和<code>UITableView</code>，那么也可以在Storeboard中通过拖拽来设置delegate和datasource。</li>
</ol>
<p>接下来，在<code>ViewController.swift</code>中添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">showDataForAlbum</span><span class="params">(albumIndex: Int)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 保证代码健壮性，确保专辑数至少大于0，避免数组下标越界的错误</span></span><br><span class="line">  <span class="keyword">if</span> (albumIndex &lt; allAlbums.<span class="built_in">count</span> &amp;&amp; albumIndex &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//获取专辑对象</span></span><br><span class="line">    <span class="keyword">let</span> album = allAlbums[albumIndex]</span><br><span class="line">    <span class="comment">// 保存专辑的数据，用于一会在tableview中展现</span></span><br><span class="line">    currentAlbumData = album.ae_tableRepresentation()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    currentAlbumData = <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 我们已经获取到了需要的数据，可以刷新tableview来显示数据了</span></span><br><span class="line">  dataTable!.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>showDataForAlbum()</code>方法的作用是从专辑数组中获取到专辑的对象，然后请求并保存专辑的数据。当你想显示新的数据或有改变的数据时，你只需要调用<code>reloadData</code>方法即可。这样<code>UItableView</code>会重新请求它的代理获取相关数据，比如一共要显示多少个Section、每个Section里显示多少行、每行看起来是什么样的等等。</p>
<p>我们在<code>viewDidLoad</code>方法中再加入一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">self</span>.showDataForAlbum(currentAlbumIndex)</span><br></pre></td></tr></table></figure>
<p>该行代码让应用启动时就开始加载专辑数据。因为之前已经将<code>currentAlbumIndex</code>的值设为了0，所以从专辑数组中的第一个专辑开始显示。</p>
<p>现在，是时候实现DataSource协议的方法了，你们可以将DataSource的方法直接写在ViewController里。也可以通过使用扩展的方式使代码保持整洁。</p>
<p>如果使用扩展的方式，那么一定要确保它们是写在文件的最下面，并且要在ViewController类定义的大括号之外！</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">UITableViewDelegate</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这两行代码的含义就是ViewController通过扩展的方式遵循了Delegate和DataSource协议 – 你可以把协议想象成是与委托之间的约定，只要你实现了约定的方法，就算是实现了委托。在我们的代码中，ViewController需要遵守<code>UITableViewDataSource</code>和<code>UITableViewDelegate</code>这两个协议。这样 UITableView 才能明确的知道，需要用到的代理中的方法是由这个ViewController实现的。</p>
<p>在遵循<code>UITableViewDataSource</code>协议的扩展中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> albumData = currentAlbumData &#123;</span><br><span class="line">    <span class="keyword">return</span> albumData.titles.<span class="built_in">count</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath)</span></span> -&gt; <span class="type">UITableViewCell</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> cell:<span class="type">UITableViewCell</span> = tableView.dequeueReusableCellWithIdentifier(<span class="string">"Cell"</span>, forIndexPath: indexPath) <span class="keyword">as</span> <span class="type">UITableViewCell</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> albumData = currentAlbumData &#123;</span><br><span class="line">    cell.textLabel?.text = albumData.titles[indexPath.row]</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> detailTextLabel = cell.detailTextLabel &#123;</span><br><span class="line">        detailTextLabel.text = albumData.values[indexPath.row]</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>tableView(_:numberOfRowsInSection:)</code>方法返回每个Section中显示多少行内容，这里对应着专辑数据结构中的标题。</p>
<p><code>tableView(_:cellForRowAtIndexPath:)</code>方法会逐个创建每行的内容，包括专辑标题和它的值。</p>
<blockquote>
<p><strong>注意：</strong>你们可以把这些协议的方法直接加在类声明里面，也可以放在扩展里，编译器不会去管DataSource的方法是放在扩展里还是类申明里，只要实现了必须的方法即可。而我们之所以这样写，是为了保证代码的整洁性和可读性。</p>
</blockquote>
<p>编译并运行你们的项目，你们的应用应该已经可以显示出专辑的基本信息了：</p>
<p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-14.png" alt="pic"></p>
<p>未完待续……</p>
<p>原文地址：<a href="http://www.raywenderlich.com/86477/introducing-ios-design-patterns-in-swift-part-1" target="_blank" rel="external">Introducing iOS Design Patterns in Swift</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Facade_u8BBE_u8BA1_u6A21_u5F0F"><a href="#Facade_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="Facade设计模式"></a>Facade设计模式</h2><]]>
    </summary>
    
      <category term="Design Pattern" scheme="http://www.devtalking.com/tags/Design-Pattern/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift中的iOS设计模式（一）]]></title>
    <link href="http://www.devtalking.com//articles/ios-design-pattern-in-swift-1/"/>
    <id>http://www.devtalking.com//articles/ios-design-pattern-in-swift-1/</id>
    <published>2015-01-04T16:00:00.000Z</published>
    <updated>2016-01-01T14:04:52.000Z</updated>
    <content type="html"><![CDATA[<p><strong>iOS设计模式</strong> - 大伙应该都听说过，但是有多少人真正的了解他们呢？虽然大多数开发者都认同设计模式的重要性，但是在实际开发中却并不怎么注意使用设计模式，而且关于设计模式的文章也是凤毛麟角，这更使得开发者无从下手去学习设计模式。</p>
<p>设计模式是一个处理软件设计中常见问题的解决方法，并可以重复使用。它向开发者提供了设计模板，使开发者更容易写出逻辑清晰、具有可复用性的代码。它还可以使代码具有松耦合性，能让开发者轻松的更新或替换项目中使用的组件。</p>
<p>在本教程中，大伙要开发一个音乐仓库应用，能显示你们收藏的专辑以及相关信息。</p>
<p>在开发过程中，大伙会逐渐掌握大多数通用的Cocoa设计模式：</p>
<ul>
<li><strong>构建设计模式：</strong>Singleton。</li>
<li><strong>架构设计模式：</strong>MVC，Decorator，Adapter，Facade。</li>
<li><strong>行为设计模式：</strong>Observer，Memento。</li>
</ul>
<p>千万不要认为该文章只是对设计模式理论上的讲解，大伙需要在你们的音乐仓库应用中运用到这些设计模式。你们的应用最终看起来大概是这个模样：</p>
<p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-1.png" alt="pic"></p>
<h2 id="u51C6_u5907_u5F00_u59CB"><a href="#u51C6_u5907_u5F00_u59CB" class="headerlink" title="准备开始"></a>准备开始</h2><p>从这里下载<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2014/11/BlueLibrarySwift-Starter.zip" target="_blank" rel="external">初始项目</a>，解压Zip文件，然后在Xcode中打开<strong>BlueLibrarySwift.xcodeproj</strong>工程。</p>
<p>在开始之前，有三件事需要大伙注意：</p>
<ul>
<li>在<code>ViewController</code>中有两个<code>IBOutlet</code>连接着Storyboard中的TableView和Toolbar。</li>
<li>在Storyboard中的<code>ViewController</code>里含有三个组件，并且设置了AutoLayout布局约束。最上面的组件用来显示音乐专辑的封面。中间是一个TableView，用来显示与该专辑相关的信息。最下面是两个Toolbar按钮，一个是撤销操作按钮，另一个是删除选中专辑的按钮。你们的Storyboard看起来应该是下面这个样子：</li>
</ul>
<p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-2.png" alt="pic"></p>
<ul>
<li>在工程里还有一个HTTP Client类（<code>HTTPClient</code>），这个类目前是空的，但是你们在之后会充实它。</li>
</ul>
<blockquote>
<p><strong>注意：</strong>你们知道吗，当你们创建了一个新的Xcode项目后，你们所编写的代码其实就已经在遵循一定的设计模式了，Model-View-Controller, Delegate, Protocol, Singleton这些设计模式统统可以免费使用哦。</p>
</blockquote>
<p>在带你们深入了解第一个设计模式之前，你们需要创建两个类，用于存储和展示音乐专辑的数据。</p>
<p>点击菜单 <strong>File\New\File…</strong> （或者按下 <strong>Command+N</strong> 快捷键）。选择 <strong>iOS &gt; Cocoa Touch Class</strong> ，点击 <strong>Next</strong>。设置该类的名称为 <strong>Album</strong> ，并让它继承 <strong>NSObject</strong>。最后选择语言为 <strong>Swift</strong> 然后点击 <strong>Next</strong>，最后点击 <strong>Create</strong>。</p>
<p>打开<strong>Album.swift</strong>文件，在<strong>Album</strong>类中定义如下属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> title : <span class="type">String</span>!</span><br><span class="line"><span class="keyword">var</span> artist : <span class="type">String</span>!</span><br><span class="line"><span class="keyword">var</span> genre : <span class="type">String</span>!</span><br><span class="line"><span class="keyword">var</span> coverUrl : <span class="type">String</span>!</span><br><span class="line"><span class="keyword">var</span> year : <span class="type">String</span>!</span><br></pre></td></tr></table></figure>
<p>然后添加一个初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">init</span>(title: <span class="type">String</span>, artist: <span class="type">String</span>, genre: <span class="type">String</span>, coverUrl: <span class="type">String</span>, year: <span class="type">String</span>) &#123;</span><br><span class="line">  <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">self</span>.title = title</span><br><span class="line">  <span class="keyword">self</span>.artist = artist</span><br><span class="line">  <span class="keyword">self</span>.genre = genre</span><br><span class="line">  <span class="keyword">self</span>.coverUrl = coverUrl</span><br><span class="line">  <span class="keyword">self</span>.year = year</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码为<strong>Album</strong>类创建了一个初始化方法，当你要创建一个新的专辑时你要通过这个初始化方法，传入专辑名称、演唱者、风格、专辑封面图片的URL以及年份这些属性。</p>
<p>接下来需要再添加一个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">description</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"title: <span class="subst">\(title)</span>"</span> +</span><br><span class="line">   <span class="string">"artist: <span class="subst">\(artist)</span>"</span> +</span><br><span class="line">   <span class="string">"genre: <span class="subst">\(genre)</span>"</span> +</span><br><span class="line">   <span class="string">"coverUrl: <span class="subst">\(coverUrl)</span>"</span> +</span><br><span class="line">   <span class="string">"year: <span class="subst">\(year)</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>description()</code>方法将专辑的这些属性拼成一个字符串，并返回。</p>
<p>我们再次通过刚才创建类的步骤创建一个名为<strong>AlibumView</strong>的类，注意该类要继承<strong>UIView</strong>。</p>
<p>打开<strong>AlbumView.swift</strong>文件，在该类中添加两个属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> coverImage: <span class="type">UIImageView</span>! </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> indicator: <span class="type">UIActivityIndicatorView</span>!</span><br></pre></td></tr></table></figure>
<p><code>coverImage</code>属性用来展示专辑封面，<code>indicator</code>是当正在下载封面图片时转动的菊花。</p>
<p>大伙注意，这里的两个属性分配了<code>private</code>访问级别，也就是说这两个属性只能在<strong>AlbumView.swift</strong>文件中使用，因为其他的类压根没有必要知道这两个属性的存在。（译者：其实这里用不用private都无所谓，因为咱们写的又不是library或者framework。）</p>
<p>接下来为<code>AlbumView</code>类添加初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">required</span> <span class="keyword">init</span>(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">  <span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">init</span>(frame: <span class="type">CGRect</span>, albumCover: <span class="type">String</span>) &#123;</span><br><span class="line">  <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">  backgroundColor = <span class="type">UIColor</span>.blackColor()</span><br><span class="line">  coverImage = <span class="type">UIImageView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">5</span>, <span class="number">5</span>, frame.size.width - <span class="number">10</span>, frame.size.height - <span class="number">10</span>))</span><br><span class="line">  addSubview(coverImage)</span><br><span class="line">  indicator = <span class="type">UIActivityIndicatorView</span>()</span><br><span class="line">  indicator.center = center</span><br><span class="line">  indicator.activityIndicatorViewStyle = .<span class="type">WhiteLarge</span></span><br><span class="line">  indicator.startAnimating()</span><br><span class="line">  addSubview(indicator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>UIView</code>遵循了<code>NSCoding</code>，而<code>AlbumView</code>又继承了<code>UIView</code>，所以这里需要写一个<code>NSCoder</code>的初始化方法，但我们不会在这个方法中处理什么逻辑，所以调用<code>super.init</code>即可。</p>
<p><code>AlbumView</code>真正的初始化方法是另外一个<code>init</code>方法，在这个方法中设置了一些默认的属性，比如将背景色设置为黑色、实例化了<code>coverImage</code>属性，并让它与父容器有5px的四周间距、实例化<code>indicator</code>并设置位置及风格。</p>
<p>最后再添加一个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">highlightAlbum</span><span class="params">(#didHighlightView: Bool)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> didHighlightView == <span class="literal">true</span> &#123;</span><br><span class="line">    backgroundColor = <span class="type">UIColor</span>.whiteColor()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    backgroundColor = <span class="type">UIColor</span>.blackColor()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是专辑封面高亮开关，高亮时专辑封面背景色为白色，否则为黑色。</p>
<p>现在编译你们的工程，确保一切都没有问题，然后准备开始第一个设计模式的学习。</p>
<h2 id="u8BBE_u8BA1_u6A21_u5F0F_u7684_u738B_u8005_-_MVC_u6A21_u5F0F"><a href="#u8BBE_u8BA1_u6A21_u5F0F_u7684_u738B_u8005_-_MVC_u6A21_u5F0F" class="headerlink" title="设计模式的王者 - MVC模式"></a>设计模式的王者 - MVC模式</h2><p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-3.png" alt="pic"></p>
<p>Model-View-Controller (MVC)设计模式是Cocoa框架的基石，毋庸置疑它是开发者们最常用的设计模式没有之一。它把应用中的对象按它们的角色进行分类，并鼓励开发者按这种角色分类创建项目目录，将代码放置在合适的位置，保证项目结构清晰明确。</p>
<p>顾名思义，MVC中有三种角色：</p>
<ul>
<li><strong>Model：</strong>这种对象保存应用程序的数据，并定义如何操作处理这些数据。比如之前你们创建的<code>Album</code>类就是一个Model对象。</li>
<li><strong>View：</strong>这种对象主要负责Model对象的呈现，以及用户交互。基本上，由<code>UIView</code>衍生出的类都是View对象。在你们的音乐仓库应用中<code>AlbumView</code>就是一个View对象。</li>
<li><strong>Controller：</strong>这种对象充当着应用程序的协调者，由它来协调所有的事情。它会访问Model对象的数据，然后展示在相应的View对象中；它也会监听用户在View对象上的交互，从而通知Model对象进行相应的数据操作等等。你们应用中的<code>ViewController</code>就是一个Controller对象。</li>
</ul>
<p>下图可以很好的说明Model对象和View对象是如何通过Controller对象进行通信的：</p>
<p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-4.png" alt="pic"></p>
<p>当Model对象的数据发生改变时，它会通知Controller对象，然后Controller对象更新对应的View对象上展示的数据。当用户在View对象进行了交互操作时，View对象会通知Controller对象，然后Controller对象会更新对应的Model对象中的数据。</p>
<p>你们可能会有这样的疑惑，为什么不把这些操作处理都写在Controller对象中呢，这样就不用通知来通知去的，不是更简单吗？</p>
<p>我告诉你们两个概念，你们就明白这样做的目的了，那就是低耦合性和高复用性。我举个例子，在一个应用中每个界面中的数据大多数是来自于多个Model对象，如果把View对象和Model对象绑定死了，那么就没法处理这种情况了。</p>
<p>拿咱们这个音乐仓库的应用来说，如果你们以后想做一个电影仓库或者图书仓库，你仍然可以使用<code>AlbumView</code>这个View对象来展示你的电影或者图书Model对象。假如你的电影仓库应用需要展示电影主题曲的一些信息，那么或许你就可以直接复用<code>Album</code>对象，因为<code>Album</code>对象不依赖于任何View对象。这就是MVC设计模式的强大之处。</p>
<h2 id="u5982_u4F55_u4F7F_u7528MVC_u8BBE_u8BA1_u6A21_u5F0F"><a href="#u5982_u4F55_u4F7F_u7528MVC_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="如何使用MVC设计模式"></a>如何使用MVC设计模式</h2><p>首先，你要确保项目中每个类的功能，要么是Controller，要么是View，要么是Model。千万不要将两种角色混合于一个类，每个类只有单一的职责。不过，到目前为止，你们已经创建了标准的Model类<code>Album</code>和View类<code>AlbumView</code>。</p>
<p>其次，为了使项目目录结构清晰明了，以及能够更感官的实行MVC模式，你们需要在工程中创建三个文件组，来区分开这三种角色的文件。</p>
<p>通过<strong>File\New\Group</strong>（或同时按下<strong>Command+Option+N</strong>）在工程中创建一个名为 <strong>Model</strong> 的文件组，然后以同样的方式创建 <strong>View</strong> 文件组和 <strong>Model</strong> 文件组。</p>
<p>最后将 <strong>Album.swift</strong> 文件拖进Model文件组，将 <strong>AlbumView.swift</strong>文件拖进View文件组，将 <strong>ViewController.swift</strong> 文件拖进Model文件组。</p>
<p>此时，你们的项目目录结构应该是这样的：</p>
<p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-5.png" alt="pic"></p>
<p>现在的项目结构看起来已然井然有序，当然你们还可以创建其他的文件组和类文件，但是要记住的是，Model、View、Controller这三个文件组是整个程序的核心所在。</p>
<p>现在项目结构已经理清楚了，接下来的工作就需要从某个地方获取到专辑的相关数据。你们可以创建一个名为API的类，用于负责整个应用的数据管理工作。并且将拉开你们要了解的下一个设计模式 – Singleton。</p>
<h2 id="Singleton_u8BBE_u8BA1_u6A21_u5F0F"><a href="#Singleton_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="Singleton设计模式"></a>Singleton设计模式</h2><p>单例模式使一个类在整个应用生命周期内只存在一个实例，并且有一个全局的方法来访问这个实例。在单例模式下，当第一次访问某个类的实例时，该类通常使用延迟加载的方式创建该类的单例。</p>
<blockquote>
<p><strong>注意：</strong> Apple在iOS和OSX中大量使用了单例模式，比如： <strong>NSUserDefaults.standardUserDefaults()</strong>， <strong>UIApplication.sharedApplication()</strong>， <strong>UIScreen.mainScreen()</strong>， <strong>NSFileManager.defaultManager()</strong>。</p>
</blockquote>
<p>你们可能会有疑问，为什么我们要这么在意一个类有一个或多个实例？代码和内存现在是如此的廉价，不是么？</p>
<p>其实不然，有些情况下，确实只需要类实例化一次，且仅有一次。比如有这么一种情况，在一个应用的生命周期里，应用（Application）设备的主屏幕是只存在一份的，那么你当然希望应用和设备屏幕的实例有且只有一个。或者你需要一个全局的处理配置的类，这样能线程安全的访问配置文件，避免多个配置类同时访问一个配置文件。这些就是单例模式的好处所在。</p>
<h2 id="u5982_u4F55_u4F7F_u7528Singleton_u8BBE_u8BA1_u6A21_u5F0F"><a href="#u5982_u4F55_u4F7F_u7528Singleton_u8BBE_u8BA1_u6A21_u5F0F" class="headerlink" title="如何使用Singleton设计模式"></a>如何使用Singleton设计模式</h2><p>先看看下面这张图：</p>
<p><img src="http://www.devtalking.com/postImages/ios-design-pattern-in-swift-1-6.png" alt="pic"></p>
<p>上图是Logger的类图，从图中可以看出，Logger有一个<code>instance</code>属性以及<code>sharedInstance</code>和<code>init</code>两个方法。</p>
<p>当第一次调用<code>sharedInstance</code>方法时，<code>instance</code>属性还没有初始化，所以你会创建一个新的Logger类实例，并返回一个该实例的引用。</p>
<p>当再次调用<code>sharedInstance</code>方法时，<code>instance</code>属性会立即返回，并且不需要再进行任何实例化操作。这个逻辑就保证了Logger类的实例有且仅有一份。</p>
<p>你们将要通过Singleton设计模式，创建一个单例的类用于管理所有专辑的数据。</p>
<p>你们应该注意到了，在项目的目录结构中，有一个文件组叫做API，这个文件组里存放的类基本都是为应用提供服务的类。我们在这个文件组中创建一个名为 <strong>LibraryAPI</strong> 的类。</p>
<p>打开 <strong>LibraryAPI.swift</strong> 文件，添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">sharedInstance</span>: <span class="title">LibraryAPI</span> </span>&#123;</span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> instance = <span class="type">LibraryAPI</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">Singleton</span>.instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个类变量的计算属性。类变量类似Objective-C中的类方法，也就是说在任何时候你访问<code>sharedInstance</code>属性时，都不需要对<code>LibraryAPI</code>进行实例化，关于属性类型更多的知识请参阅Swift文档 – <a href="https://developer.apple.com/library/ios/documentation/swift/conceptual/swift_programming_language/Properties.html" target="_blank" rel="external">properties</a>。</li>
<li>在类变量中内嵌一个结构体，名为<code>Singleton</code>。</li>
<li><code>Singleton</code>中包含一个名为<code>instance</code>的静态常量属性。用<code>static</code>申明属性意味着该属性只能存在一份。这里要注意的是Swift中的静态属性都会延迟加载，也就是说只有<code>instance</code>被使用时，才会初始化它。还要注意的一点是，一旦<code>instance</code>被初始化了，那么它就是一个常量属性，不会有第二次初始化的机会了。这就是Singleton模式的精髓所在。</li>
<li>返回该计算属性的值。</li>
</ol>
<blockquote>
<p><strong>注意：</strong>如果想了解Swift中创建单例的其他方法请参阅这里：<a href="https://github.com/hpique/SwiftSingleton" target="_blank" rel="external">Github page</a>。</p>
</blockquote>
<p>你们现在已经有一个单例模式的对象，作为管理专辑数据的入口。接下来要更进一步，创建一个类，用于处理你们数据的持久性。</p>
<p>继续在 <strong>API</strong> 这个文件组中创建一个类，名为<code>PersistencyManager</code>，并让它继承<code>NSObject</code>类。</p>
<p>打开 <strong>PersistencyManager.swift</strong> 文件，申明一个属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> albums = [<span class="type">Album</span>]()</span><br></pre></td></tr></table></figure>
<p>这里申明了一个private访问权限的变量属性，用于储存专辑数据。这个数组是可变数组，所以你们可以很轻松的增删专辑。</p>
<p>接下来我们在该类中添加如下初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">  <span class="comment">//Dummy list of albums</span></span><br><span class="line">  <span class="keyword">let</span> album1 = <span class="type">Album</span>(title: <span class="string">"Best of Bowie"</span>,</span><br><span class="line">         artist: <span class="string">"David Bowie"</span>,</span><br><span class="line">         genre: <span class="string">"Pop"</span>,</span><br><span class="line">         coverUrl: <span class="string">"http://www.coversproject.com/static/thumbs/album/album_david%20bowie_best%20of%20bowie.png"</span>,</span><br><span class="line">         year: <span class="string">"1992"</span>)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> album2 = <span class="type">Album</span>(title: <span class="string">"It's My Life"</span>,</span><br><span class="line">         artist: <span class="string">"No Doubt"</span>,</span><br><span class="line">         genre: <span class="string">"Pop"</span>,</span><br><span class="line">         coverUrl: <span class="string">"http://www.coversproject.com/static/thumbs/album/album_no%20doubt_its%20my%20life%20%20bathwater.png"</span>,</span><br><span class="line">         year: <span class="string">"2003"</span>)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> album3 = <span class="type">Album</span>(title: <span class="string">"Nothing Like The Sun"</span>,</span><br><span class="line">         artist: <span class="string">"Sting"</span>,</span><br><span class="line">         genre: <span class="string">"Pop"</span>,</span><br><span class="line">         coverUrl: <span class="string">"http://www.coversproject.com/static/thumbs/album/album_sting_nothing%20like%20the%20sun.png"</span>,</span><br><span class="line">         year: <span class="string">"1999"</span>)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> album4 = <span class="type">Album</span>(title: <span class="string">"Staring at the Sun"</span>,</span><br><span class="line">         artist: <span class="string">"U2"</span>,</span><br><span class="line">         genre: <span class="string">"Pop"</span>,</span><br><span class="line">         coverUrl: <span class="string">"http://www.coversproject.com/static/thumbs/album/album_u2_staring%20at%20the%20sun.png"</span>,</span><br><span class="line">         year: <span class="string">"2000"</span>)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> album5 = <span class="type">Album</span>(title: <span class="string">"American Pie"</span>,</span><br><span class="line">         artist: <span class="string">"Madonna"</span>,</span><br><span class="line">         genre: <span class="string">"Pop"</span>,</span><br><span class="line">         coverUrl: <span class="string">"http://www.coversproject.com/static/thumbs/album/album_madonna_american%20pie.png"</span>,</span><br><span class="line">         year: <span class="string">"2000"</span>)</span><br><span class="line"> </span><br><span class="line">  albums = [album1, album2, album3, album4, album5]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化方法中，你们可以构建一些专辑添加到<code>albums</code>数组中，这里我构建了5个专辑。</p>
<p>然后再添加几个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getAlbums</span><span class="params">()</span></span> -&gt; [<span class="type">Album</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> albums</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addAlbum</span><span class="params">(album: Album, index: Int)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (albums.<span class="built_in">count</span> &gt;= index) &#123; </span><br><span class="line">    albums.insert(album, atIndex: index)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    albums.append(album)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">deleteAlbumAtIndex</span><span class="params">(index: Int)</span></span> &#123;</span><br><span class="line">  albums.removeAtIndex(index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些方法可以让你们方便的存、取、删除<code>album</code>数组中的专辑。</p>
<p>然后编译你们的项目，确保编译通过。此时大伙也许又有了疑问，我们应该如何使用<code>PersistencyManager</code>类呢？别着急，在下一节里，会向大家介绍 <strong>Facade</strong> 设计模式，届时你们就会明白<code>LibraryAPI</code>与<code>PersistencyManager</code>之间的关系，以及如何使用<code>PersistencyManager</code>了。</p>
<p>未完待续……</p>
<p>原文地址：<a href="http://www.raywenderlich.com/86477/introducing-ios-design-patterns-in-swift-part-1" target="_blank" rel="external">Introducing iOS Design Patterns in Swift</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>iOS设计模式</strong> - 大伙应该都听说过，但是有多少人真正的了解他们呢？虽然大多数开发者都认同设计模式的重要性，但是在实际开发中却并不怎么注意使用设计模式，而且关于设计模式的文章也是凤毛麟角，这更使得开发者无从下手去学习设计模式。</p>
<p]]>
    </summary>
    
      <category term="Design Pattern" scheme="http://www.devtalking.com/tags/Design-Pattern/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在Swift中运用Text Kit框架（二）]]></title>
    <link href="http://www.devtalking.com//articles/text-kit-tutorial-in-swift-2/"/>
    <id>http://www.devtalking.com//articles/text-kit-tutorial-in-swift-2/</id>
    <published>2014-12-10T16:00:00.000Z</published>
    <updated>2016-01-01T14:03:38.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u52A8_u6001_u7684_u6587_u672C_u683C_u5F0F_u548C_u5B58_u50A8"><a href="#u52A8_u6001_u7684_u6587_u672C_u683C_u5F0F_u548C_u5B58_u50A8" class="headerlink" title="动态的文本格式和存储"></a>动态的文本格式和存储</h2><p>在上篇文章中，同学们已经看到了Text Kit可以根据用户在设置选项里对文本属性设置而动态的改变App中的文本属性。但你们不知道它还有更酷的功能，那就是可以根据文本本身的某种字符而更改文本属性。</p>
<p>比如说，你们也许希望我们这个应用中还有以下这些自动的功能：</p>
<ul>
<li>被波浪号（~）括起来的文本会显示艺术字体。</li>
<li>被下划线（_）括起来的文本会显示斜体。</li>
<li>被破折号（-）括起来的文本会在其上划一道横线。</li>
<li>所有大写字体会显示红色。</li>
</ul>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-12.png" alt="pic"></p>
<p>如何用TextKit实现上述这些功能就是这篇文章将要向同学们介绍的内容。</p>
<p>在学习这些之前，大家需要先理解在TextKit中，文本的存储系统是如何工作的。下面的图展示了TextKit中对文本进行存储、渲染、显现的基本流程：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-13.png" alt="pic"></p>
<p>在开发过程中，如果你创建了<code>UITextView</code>、<code>UILabel</code>或<code>UITextField</code>，那么同时Apple会在幕后自动创建上图中的这些类。你可以使用这些类默认实现的行为，也可以自己实现这些类，从而达到你想要的一些对文本控制的行为。让我们来看看这些类的作用：</p>
<ul>
<li><code>NSTextStorage</code>的功能是存储文本，并通过字符串属性渲染文本。当文本内容发生任何变化的时候，它会告知布局管理器（Layout Manager）。你们也许脑海中已经有了一点想法，那就是实现一个<code>NSTextStorage</code>的子类，以便实现当文本更新时动态改变文本属性的功能，Bingo！想法基本正确（在后文中你将会看到它的运用）。</li>
<li><code>NSLayoutManager</code>的功能是从<code>NSTextStorage</code>中获取文本并在屏幕上渲染文本。它将作为你应用中的布局引擎。</li>
<li><code>NSTextContainer</code>的功能是在屏幕上描绘一个几何图形区域，要显示的文本就是在这个区域内进行渲染的。每个Text Container一般都和一和<code>UITextView</code>相关联。你可以实现一个<code>NSTextContainer</code>的子类，描绘一个复杂的几何图形，让文本在其中进行渲染。</li>
</ul>
<p>如果想要在我们的应用中实现动态文本格式的功能，那么就需要实现一个<code>NSTextStorage</code>的子类，然后根据用户键入的字符动态的设置文本格式属性。</p>
<p>一旦你实现了<code>NSTextStorage</code>的子类，那么你就要替换<code>UITextView</code>默认的存储类示例，同学们接着往下看。</p>
<h2 id="UITextStorage_u7684_u5B50_u7C7B"><a href="#UITextStorage_u7684_u5B50_u7C7B" class="headerlink" title="UITextStorage的子类"></a>UITextStorage的子类</h2><p>我们选中左侧项目结构目录中的<strong>SwiftTextKitNotepad</strong>，然后选择菜单栏中的<strong>New File…</strong> ，接着选择<strong>iOS/Source/Cocoa Touch Class</strong> ，点击<strong>Next</strong>。</p>
<p>我们给该类起名为<strong>SyntaxHighlightTextStorage</strong>，让它继承<code>NSTextStorage</code>，确认<strong>Language</strong>选项为 <strong>Swift</strong>，然后点击 <strong>Next</strong> ，最后点击<strong>Create</strong>。 </p>
<p>打开<strong>SyntaxHighlightTextStorage.swift</strong>文件，申明一个新的属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> backingStore = <span class="type">NSMutableAttributedString</span>()</span><br></pre></td></tr></table></figure>
<p>文本存储的子类必须要保证自己的持久性，因此使用<code>NSMutableAttributedString</code>作为<code>backingStore</code>的类型。后面我们会经常用到。</p>
<p>然后在该类中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">var</span> string: <span class="type">String</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> backingStore.string</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">attributesAtIndex</span><span class="params">(index: Int, effectiveRange range: NSRangePointer)</span></span> -&gt; [<span class="type">NSObject</span> : <span class="type">AnyObject</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> backingStore.attributesAtIndex(index, effectiveRange: range)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们重写了计算属性<code>string</code>的<code>get</code>方法，让它返回咱们定义的<code>backingStore</code>中字符串的值，同样重写了<code>attributesAtIndex</code>方法，并返回<code>backingStore</code>的<code>attributesAtIndex</code>方法的返回值。</p>
<p>最后重写这些必须要重写的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">replaceCharactersInRange</span><span class="params">(range: NSRange, withString str: String)</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"replaceCharactersInRange:<span class="subst">\(range)</span> withString:<span class="subst">\(str)</span>"</span>)</span><br><span class="line"> </span><br><span class="line">  beginEditing()</span><br><span class="line">  backingStore.replaceCharactersInRange(range, withString:str)</span><br><span class="line">  edited(.<span class="type">EditedCharacters</span> | .<span class="type">EditedAttributes</span>, range: range, changeInLength: (str <span class="keyword">as</span> <span class="type">NSString</span>).length - range.length)</span><br><span class="line">  endEditing()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">setAttributes</span><span class="params">(attrs: [NSObject : AnyObject]!, range: NSRange)</span></span> &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"setAttributes:<span class="subst">\(attrs)</span> range:<span class="subst">\(range)</span>"</span>)</span><br><span class="line"> </span><br><span class="line">  beginEditing()</span><br><span class="line">  backingStore.setAttributes(attrs, range: range)</span><br><span class="line">  edited(.<span class="type">EditedAttributes</span>, range: range, changeInLength: <span class="number">0</span>)</span><br><span class="line">  endEditing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上面一样，这些方法的实现都使用我们自己定义的<code>backingStore</code>属性的相同方法代替。然而，从上面的示例代码中可以看到使用<code>backingStore</code>的相关方法时，它是被包围在<code>beginEditing</code>、<code>edited</code>和<code>endEditing</code>三个方法中的。这三个方法是必须要写的，它们的作用是当文本准备被编辑时通知与之相关联的布局管理器（Layout Manager）。</p>
<p>通过上面的示例代码你们可能已经注意到了要实现一个<code>NSTextStorage</code>的子类要重写这么多的方法（写这么多的代码）。因为<code>NSTextStorage</code>是一个<strong>类集群</strong>的公共接口，所以在实现它的子类时只重写一两个方法是没法真正扩展其功能的，上面这几个主要的方法是我们必须要重写的。</p>
<blockquote>
<p>注意：<strong>类集群</strong>是Apple框架中经常使用的一种设计模式。类集群是Objective-C对抽象工厂设计模式的一种简单的实现，它的作用就是将相似的类聚集到一起，通过一个工厂类暴露给开发者，该工厂类提供若干工厂方法，每个或每几个工厂方法对应其包含的某个类。我们比较熟悉的像<code>NSArray</code>、<code>NSNumber</code>都是类集群。</p>
</blockquote>
<p>Apple使用类集群将私有的具体的子类压缩到一个公共的抽象超类中，该超类会申明一些方法，用于创建其包含子类的实例。开发者不必关心公共抽象类内部的事情，也无法得知，因为开发者永远只是和这个抽象类打交道。</p>
<p>使用类集群确实可以简化接口，使类的使用和学习更加简单，但是有一点很重要，那就是在使用类集群时要权衡可扩展性和易用性。比如说如果使用类集群，那么你就很难创建一个个性化的子类。</p>
<p>现在，我们已经有了一个自定义的<code>NSTextStorage</code>，接下来就需要用<code>UITextView</code>来使用它了。</p>
<h2 id="u8BA9UITextView_u4F7F_u7528_u6211_u4EEC_u81EA_u5B9A_u4E49_u7684Text_Kit_Stack"><a href="#u8BA9UITextView_u4F7F_u7528_u6211_u4EEC_u81EA_u5B9A_u4E49_u7684Text_Kit_Stack" class="headerlink" title="让UITextView使用我们自定义的Text Kit Stack"></a>让UITextView使用我们自定义的Text Kit Stack</h2><p>如果我们在Storyboard中创建一个<code>UITextView</code>，那么就同时会自动创建<code>NSTextStorage</code>、<code>NSLayoutManager</code>和<code>NSTextContainer</code>这三个类的实例（也就是<strong>Text Kit Stack</strong>），并且这三个实例是只读状态的。也就意味着在Storyboard中，我们没法让<code>UITextView</code>使用我们自己定义的Text Kit Stack。真的没招了吗？非也，我们可以在代码中创建<code>UITextView</code>，然后让它使用自定义的Text Kit Stack。</p>
<p>打开<code>Main.storyboard</code>，找到<code>NoteEditorViewController</code>，展开它，在<strong>Detail Scene/Detail/View</strong>中找到 <strong>Text View</strong>，然后删掉<code>UITextView</code>实例。</p>
<p>然后打开<code>NoteEditorViewController.swift</code>文件，移除<code>UITextView</code>的<code>outlet</code>。添加如下代码重新申明<code>UITextView</code>和<code>SyntaxHighlightTextStorage</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> textView: <span class="type">UITextView</span>!</span><br><span class="line"><span class="keyword">var</span> textStorage: <span class="type">SyntaxHighlightTextStorage</span>!</span><br></pre></td></tr></table></figure>
<p>接下来移除<code>viewDidLoad</code>方法中的这两行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">textView.text = note.contents</span><br><span class="line">textView.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleBody</span>)</span><br></pre></td></tr></table></figure>
<p>因为我们已经移除了<code>UITextView</code>的<code>outlet</code>，并且手动申明了新的<code>UITextView</code>，所以这两行就不需要了，因为我们先要对新的<code>UITextView</code>进行初始化和相关设置。</p>
<p>继续在<code>NoteEditorViewController.swift</code>中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createTextView</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1. 初始化用于备份编辑器中文本的存储器</span></span><br><span class="line">  <span class="keyword">let</span> attrs = [<span class="type">NSFontAttributeName</span> : <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleBody</span>)]</span><br><span class="line">  <span class="keyword">let</span> attrString = <span class="type">NSAttributedString</span>(string: note.contents, attributes: attrs)</span><br><span class="line">  textStorage = <span class="type">SyntaxHighlightTextStorage</span>()</span><br><span class="line">  textStorage.appendAttributedString(attrString)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> newTextViewRect = view.bounds</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2. 创建layoutManager</span></span><br><span class="line">  <span class="keyword">let</span> layoutManager = <span class="type">NSLayoutManager</span>()</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3. 创建text container</span></span><br><span class="line">  <span class="keyword">let</span> containerSize = <span class="type">CGSize</span>(width: newTextViewRect.width, height: <span class="type">CGFloat</span>.<span class="built_in">max</span>)</span><br><span class="line">  <span class="keyword">let</span> container = <span class="type">NSTextContainer</span>(size: containerSize)</span><br><span class="line">  container.widthTracksTextView = <span class="literal">true</span></span><br><span class="line">  layoutManager.addTextContainer(container)</span><br><span class="line">  textStorage.addLayoutManager(layoutManager)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 4. 初始化并设置UITextView</span></span><br><span class="line">  textView = <span class="type">UITextView</span>(frame: newTextViewRect, textContainer: container)</span><br><span class="line">  textView.delegate = <span class="keyword">self</span></span><br><span class="line">  view.addSubview(textView)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次加的代码有点多，不过没关系，我们一一来分析：</p>
<ol>
<li>初始化我们之前自定义的文本存储类，并定义了文本的属性。</li>
<li>创建了一个布局管理器。</li>
<li>创建了一个文本容器，并添加到上步创建的布局管理器中，然后又将布局管理器添加到我们自定义的文本存储器中。</li>
<li>初始化文本视图，其<code>frame</code>为父视图的大小，<code>textContainer</code>为上步创建的容器。然后设置了文本视图的代理，并将其添加到父视图中。</li>
</ol>
<p>到目前为止，之前向大家展示过的这张图中的四个关键点（存储，布局器，容器，文本视图）之间的关系应该会更容易了理解了：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-14.png" alt="pic"></p>
<p>这里要注意的是，在上面添加的代码中文本容器的宽度为屏幕的宽度，但是高度是无限大的，这样设置的目的是为了当<code>UITextView</code>中的文本很长的时候可以上下滚动。</p>
<p>现在我们就可以在<code>viewDidLoad</code>方法中调用<code>createTextView()</code>方法了，不过要记得加在<code>super.viewDidLoad()</code>方法的后面：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">createTextView()</span><br></pre></td></tr></table></figure>
<p>最后还有一点需要注意的是：在代码中创建的自定义的视图不能沿用storyboard中添加的布局约束，这就意味着当改变设备的横竖屏方向时，代码中创建的视图是不能根据布局约束改变大小和位置的。你需要在代码中添加布局约束。</p>
<p>此时我们还需要在<code>viewDidLayoutSubviews</code>方法中加一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">textView.frame = view.bounds</span><br></pre></td></tr></table></figure>
<p>编译并运行应用，在应用中打开一条笔记，然后去编辑它，此时注意观察Xcode的控制台，你可以看到在控制台中像瀑布一般的刷出好多日志信息：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-15.png" alt="pic"></p>
<p>产生这些日志信息的来源是<code>SyntaxHighlightTextStorage</code>类，该类中输出的日志信息可以让你们知道你们自定义的类是否在正常的工作。</p>
<p>现在文本解析器的基本框架看似已经可以稳定的运行了，接下来实现动态文本格式吧！</p>
<h2 id="u52A8_u6001_u6587_u672C_u683C_u5F0F"><a href="#u52A8_u6001_u6587_u672C_u683C_u5F0F" class="headerlink" title="动态文本格式"></a>动态文本格式</h2><p>在接下来的步骤中，你们要对自定义的文本存储类进行修改，让它实现被星号包围起来的文本加粗的功能。</p>
<p>打开<code>SyntaxHighlightTextStorage.swift</code>文件，添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">applyStylesToRange</span><span class="params">(searchRange: NSRange)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1. 创建一些字体</span></span><br><span class="line">  <span class="keyword">let</span> fontDescriptor = <span class="type">UIFontDescriptor</span>.preferredFontDescriptorWithTextStyle(<span class="type">UIFontTextStyleBody</span>)</span><br><span class="line">  <span class="keyword">let</span> boldFontDescriptor = fontDescriptor.fontDescriptorWithSymbolicTraits(.<span class="type">TraitBold</span>)</span><br><span class="line">  <span class="keyword">let</span> boldFont = <span class="type">UIFont</span>(descriptor: boldFontDescriptor, size: <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">let</span> normalFont = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleBody</span>)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2. 匹配由星号包围的文本</span></span><br><span class="line">  <span class="keyword">let</span> regexStr = <span class="string">"(\\*\\w+(\\s\\w+)*\\*)"</span></span><br><span class="line">  <span class="keyword">let</span> regex = <span class="type">NSRegularExpression</span>(pattern: regexStr, options: <span class="literal">nil</span>, error: <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">let</span> boldAttributes = [<span class="type">NSFontAttributeName</span> : boldFont]</span><br><span class="line">  <span class="keyword">let</span> normalAttributes = [<span class="type">NSFontAttributeName</span> : normalFont]</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3. 遍历所有匹配上的文本，设置加粗字体属性</span></span><br><span class="line">  regex.enumerateMatchesInString(backingStore.string, options: <span class="literal">nil</span>, range: searchRange) &#123;</span><br><span class="line">    match, flags, stop <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> matchRange = match.rangeAtIndex(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">self</span>.addAttributes(boldAttributes, range: matchRange)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 4. 还原字体格式</span></span><br><span class="line">    <span class="keyword">let</span> maxRange = matchRange.location + matchRange.length</span><br><span class="line">    <span class="keyword">if</span> maxRange + <span class="number">1</span> &lt; <span class="keyword">self</span>.length &#123;</span><br><span class="line">      <span class="keyword">self</span>.addAttributes(normalAttributes, range: <span class="type">NSMakeRange</span>(maxRange, <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码主要功能是：</p>
<ol>
<li>通过<code>UIFontDescriptor</code>创建一个加粗的字体格式和一个正常的字体格式。<code>UIFontDescriptor</code>可帮助你们避免使用硬编码来设置字体的类型和格式。</li>
<li>创建一个正则表达式，用于查找被星号包围的文本。比如说，这有一个字符串”iOS8是*非常完美*的一个系统”,那么正则表达式就可以将”*非常完美*“过滤出来。如果你不熟悉正则表达式也没关系，在后面会详细给大家介绍的。</li>
<li>遍历通过正则表达式过滤出的文本，将我们定义的加粗字体属性设置给它们。</li>
<li>重置跟在最后一个星号后的文本的属性为正常，确保只在闭合星号内的文本才显示为粗体。</li>
</ol>
<p>在上面的方法后面添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performReplacementsForRange</span><span class="params">(changedRange: NSRange)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> extendedRange = <span class="type">NSUnionRange</span>(changedRange, <span class="type">NSString</span>(string: backingStore.string).lineRangeForRange(<span class="type">NSMakeRange</span>(changedRange.location, <span class="number">0</span>)))</span><br><span class="line">  extendedRange = <span class="type">NSUnionRange</span>(changedRange, <span class="type">NSString</span>(string: backingStore.string).lineRangeForRange(<span class="type">NSMakeRange</span>(<span class="type">NSMaxRange</span>(changedRange), <span class="number">0</span>)))</span><br><span class="line">  applyStylesToRange(extendedRange)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法的作用是设置检查被星号包围文本的范围。这个方法是很重要的，因为<code>changedRange</code>通常代表一个字符，而<code>lineRangeForRange</code>将其扩展到一行的范围。</p>
<p>最后在<code>performReplacementsForRange()</code>方法后再添加一个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">processEditing</span><span class="params">()</span></span> &#123;</span><br><span class="line">  performReplacementsForRange(<span class="keyword">self</span>.editedRange)</span><br><span class="line">  <span class="keyword">super</span>.processEditing()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当文本发生改变时，<code>processEditing</code>方法会向布局管理器发送通知，告知布局管理器文本发生了变化。</p>
<p>编译运行应用，打开一条笔记，输入一些文本信息，然后用星号包围几段文本，你会看到被星号包围的文本变成了粗体：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-16.png" alt="pic"></p>
<p>是不是很方便呢，你还可以依法炮制，举一反三，比如两个下划线包围的文本显示为斜体等等。</p>
<h2 id="u6DF1_u5165_u5B8C_u5584"><a href="#u6DF1_u5165_u5B8C_u5584" class="headerlink" title="深入完善"></a>深入完善</h2><p>实现该功能的基本方法其实很简单：在<code>applyStylesToRange</code>方法中通过正则表达式过滤出你想要的文本信息，然后给过滤出的文本设置新的文本属性。</p>
<p>打开<code>SyntaxHighlightTextStorage.swift</code>文件，添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createAttributesForFontStyle</span><span class="params">(style: String, withTrait trait: UIFontDescriptorSymbolicTraits)</span></span> -&gt; [<span class="type">NSObject</span> : <span class="type">AnyObject</span>] &#123;</span><br><span class="line">  <span class="keyword">let</span> fontDescriptor = <span class="type">UIFontDescriptor</span>.preferredFontDescriptorWithTextStyle(<span class="type">UIFontTextStyleBody</span>)</span><br><span class="line">  <span class="keyword">let</span> descriptorWithTrait = fontDescriptor.fontDescriptorWithSymbolicTraits(trait)</span><br><span class="line">  <span class="keyword">let</span> font = <span class="type">UIFont</span>(descriptor: descriptorWithTrait, size: <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> [<span class="type">NSFontAttributeName</span> : font]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法可以创建正文文本字体的样式。在该方法中，构建<code>UIFont</code>时，其构造函数中的<code>size</code>属性设置为0，这是为了让字体的大小使用用户当前设置的字体大小。</p>
<p>接下来，在该类中添加一个属性和一个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> replacements: [<span class="type">String</span> : [<span class="type">NSObject</span> : <span class="type">AnyObject</span>]]!</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">createHighlightPatterns</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> scriptFontDescriptor = <span class="type">UIFontDescriptor</span>(fontAttributes: [<span class="type">UIFontDescriptorFamilyAttribute</span> : <span class="string">"Zapfino"</span>])</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 1. 让我们的手写字体的大小基于首选设置中正文字体的大小</span></span><br><span class="line">  <span class="keyword">let</span> bodyFontDescriptor = <span class="type">UIFontDescriptor</span>.preferredFontDescriptorWithTextStyle(<span class="type">UIFontTextStyleBody</span>)</span><br><span class="line">  <span class="keyword">let</span> bodyFontSize = bodyFontDescriptor.fontAttributes()[<span class="type">UIFontDescriptorSizeAttribute</span>] <span class="keyword">as</span> <span class="type">NSNumber</span></span><br><span class="line">  <span class="keyword">let</span> scriptFont = <span class="type">UIFont</span>(descriptor: scriptFontDescriptor, size: <span class="type">CGFloat</span>(bodyFontSize.floatValue))</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2. 创建一些字体属性</span></span><br><span class="line">  <span class="keyword">let</span> boldAttributes = createAttributesForFontStyle(<span class="type">UIFontTextStyleBody</span>, withTrait:.<span class="type">TraitBold</span>)</span><br><span class="line">  <span class="keyword">let</span> italicAttributes = createAttributesForFontStyle(<span class="type">UIFontTextStyleBody</span>, withTrait:.<span class="type">TraitItalic</span>)</span><br><span class="line">  <span class="keyword">let</span> strikeThroughAttributes = [<span class="type">NSStrikethroughStyleAttributeName</span> : <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">let</span> scriptAttributes = [<span class="type">NSFontAttributeName</span> : scriptFont]</span><br><span class="line">  <span class="keyword">let</span> redTextAttributes = [<span class="type">NSForegroundColorAttributeName</span> : <span class="type">UIColor</span>.redColor()]</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 创建一个正则表达式的字典</span></span><br><span class="line">  replacements = [</span><br><span class="line">    <span class="string">"(\\*\\w+(\\s\\w+)*\\*)"</span> : boldAttributes,</span><br><span class="line">    <span class="string">"(_\\w+(\\s\\w+)*_)"</span> : italicAttributes,</span><br><span class="line">    <span class="string">"([0-9]+\\.)\\s"</span> : boldAttributes,</span><br><span class="line">    <span class="string">"(-\\w+(\\s\\w+)*-)"</span> : strikeThroughAttributes,</span><br><span class="line">    <span class="string">"(~\\w+(\\s\\w+)*~)"</span> : scriptAttributes,</span><br><span class="line">    <span class="string">"\\s([A-Z]&#123;2,&#125;)\\s"</span> : redTextAttributes</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要有以下几个功能：</p>
<ul>
<li>首先，使用Zapfino字体创建一个手写风格的字体。然后让它的字体大小基于正文文本设置的字体大小。</li>
<li>其次，创建若干用于匹配的字体属性。</li>
<li>最后，创建了一个字典，key为各种正则表达式，值为刚才创建的字体属性。</li>
</ul>
<p>如果你们不熟悉正则表达式，可能这个字典看起来会比较奇怪。但是如果你们一点一点去解析它，就会发现其实很简单。</p>
<p>我们拿出字典中的第一个正则表达式，也就是过滤被星号围绕的文本的表达式来看看：</p>
<pre><code>(\\*\\w+(\\s\\w+)*\\*)
</code></pre><p>在正则表达式中一个反斜杠“\”代表将下一个字符标记为特殊字符或一个原义字符，双反斜杠的作用是不会使程序解析时忽略“\”，如果你把额外的一个反斜杠去掉，那么该正则表达式应该是这样：</p>
<pre><code>(\*\w+(\s\w+)*\*)
</code></pre><p>现在我们来一步一步解析这个正则表达式：</p>
<ol>
<li><strong>(*</strong> - 匹配一个星号。</li>
<li><strong>\w+</strong> - 匹配包括下划线在内任何单词字符以及该字符之前的字符。</li>
<li><strong>(\s\w+)*</strong> - 这是一个字表达式，\s的含义是匹配任何空白字符，包括空格、制表符、换页符等，*的含义是匹配前面的子表达式0次或多次。</li>
<li><strong>*)</strong> - 匹配后面的星号。</li>
</ol>
<blockquote>
<p><strong>注意</strong>：如果你想了解更多关于正则表达式的知识，请查阅这篇文章<a href="http://www.raywenderlich.com/?p=30288" target="_blank" rel="external">NSRegularExpression tutorial and cheat sheet</a></p>
</blockquote>
<p>接下来我们在<code>SyntaxHighlightTextStorage</code>类的初始化方法中调用<code>createHighlightPatterns()</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">	<span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">	createHighlightPatterns()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">required</span> <span class="keyword">init</span>(coder aDecoder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">	<span class="keyword">super</span>.<span class="keyword">init</span>(coder: aDecoder)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们来修改<code>applyStylesToRange()</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">applyStylesToRange</span><span class="params">(searchRange: NSRange)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> normalAttrs = [<span class="type">NSFontAttributeName</span> : <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleBody</span>)]</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 遍历每个需要替换字体属性的文本</span></span><br><span class="line">  <span class="keyword">for</span> (pattern, attributes) <span class="keyword">in</span> replacements &#123;</span><br><span class="line">    <span class="keyword">let</span> regex = <span class="type">NSRegularExpression</span>(pattern: pattern, options: <span class="literal">nil</span>, error: <span class="literal">nil</span>)</span><br><span class="line">    regex.enumerateMatchesInString(backingStore.string, options: <span class="literal">nil</span>, range: searchRange) &#123;</span><br><span class="line">      match, flags, stop <span class="keyword">in</span></span><br><span class="line">      <span class="comment">// 设置字体属性</span></span><br><span class="line">      <span class="keyword">let</span> matchRange = match.rangeAtIndex(<span class="number">1</span>)</span><br><span class="line">      <span class="keyword">self</span>.addAttributes(attributes, range: matchRange)</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 还原字体样式</span></span><br><span class="line">      <span class="keyword">let</span> maxRange = matchRange.location + matchRange.length</span><br><span class="line">      <span class="keyword">if</span> maxRange + <span class="number">1</span> &lt; <span class="keyword">self</span>.length &#123;</span><br><span class="line">        <span class="keyword">self</span>.addAttributes(normalAttrs, range: <span class="type">NSMakeRange</span>(maxRange, <span class="number">1</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前，该方法只使用一个正则表达式过滤出被星号围绕的文本，并将其设置为粗体，现在，虽然该方法所做的事情没有变，但是却不只使用一个正则表达式，而是遍历正则表达式字典中的所有表达式，过滤出文本中所有被符号围绕的文本，然后设置相应的字体样式。</p>
<p>现在再次编译运行应用，你看到了什么？</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-17.png" alt="pic"></p>
<p>到目前为止，似乎这个记事本应用已经大功告成了，但是还有几个小问题需要解决。</p>
<p>第一个问题是如果在使用该应用时，改变手机的方向，也就是从竖屏变为横屏，你会注意到屏幕上的内容并没有变化，这是因为自定义的子类不支持这种转变，之前我们也提到过。</p>
<p>第二个问题是当一条笔记中有很多文本信息的时候，文本的底部会被键盘遮住，这时你打字写东西就很困难。</p>
<p>也是时候解决这两个问题了。</p>
<h2 id="u56DE_u987E_u52A8_u6001_u7C7B_u578B"><a href="#u56DE_u987E_u52A8_u6001_u7C7B_u578B" class="headerlink" title="回顾动态类型"></a>回顾动态类型</h2><p>要想通过动态类型正确的解决该问题，你们得修改代码，当文本显示区域大小发生改变的通知发生时，要通过字体属性来改变字体。</p>
<p>在<code>SyntaxHighlightTextStorage</code>类中添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">update</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// update the highlight patterns</span></span><br><span class="line">  createHighlightPatterns()</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// change the 'global' font</span></span><br><span class="line">  <span class="keyword">let</span> bodyFont = [<span class="type">NSFontAttributeName</span> : <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleBody</span>)]</span><br><span class="line">  addAttributes(bodyFont, range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, length))</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// re-apply the regex matches</span></span><br><span class="line">  applyStylesToRange(<span class="type">NSMakeRange</span>(<span class="number">0</span>, length))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法更新了所有与各种正则表达式相关联的字体，让所有字符串都基于正文文本的属性，然后重新过滤文本。</p>
<p>最后，打开<code>NoteEditorViewController.swift</code>文件，更新<code>preferredContentSizeChanged()</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">preferredContentSizeChanged</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">  textStorage.update()</span><br><span class="line">  updateTimeIndicatorFrame()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行应用，在设置中修改文本大小，看看会发生什么：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-18.png" alt="pic"></p>
<h2 id="u6539_u53D8_u6587_u672C_u89C6_u56FE_u7684_u5927_u5C0F"><a href="#u6539_u53D8_u6587_u672C_u89C6_u56FE_u7684_u5927_u5C0F" class="headerlink" title="改变文本视图的大小"></a>改变文本视图的大小</h2><p>剩下的另一个问题就是编辑长文本时，键盘会遮住一半文本的问题。</p>
<p>解决这个问题的核心就是当键盘弹出时减小文本视图的高度。</p>
<p>打开<code>NoteEditorViewController.swift</code>文件，在<code>viewDidLoad()</code>方法中的<code>createTextView()</code>后面加一行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">textView.scrollEnabled = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这行代码允许文本视图开启滚动条。</p>
<p>然后在<code>viewDidLoad()</code>的最后面添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector: <span class="string">"keyboardDidShow:"</span>, name: <span class="type">UIKeyboardDidShowNotification</span>, object: <span class="literal">nil</span>)</span><br><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, selector: <span class="string">"keyboardDidHide:"</span>, name: <span class="type">UIKeyboardDidHideNotification</span>, object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>这两个通知可以让你捕捉到键盘弹出和收起的事件，好让你修改文本视图的相应大小。</p>
<p>再在该类中添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">updateTextViewSizeForKeyboardHeight</span><span class="params">(keyboardHeight: CGFloat)</span></span> &#123;</span><br><span class="line">  textView.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: view.frame.width, height: view.frame.height - keyboardHeight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法让文本视图的高度减去键盘的高度，保证合适的文本视图高度。</p>
<p>最后就是实现<code>keyboardDidShow</code>和<code>keyboardDidHide</code>方法了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">keyboardDidShow</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> rectValue = notification.userInfo?[<span class="type">UIKeyboardFrameBeginUserInfoKey</span>] <span class="keyword">as</span>? <span class="type">NSValue</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> keyboardSize = rectValue.<span class="type">CGRectValue</span>().size</span><br><span class="line">    updateTextViewSizeForKeyboardHeight(keyboardSize.height)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">keyboardDidHide</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">  updateTextViewSizeForKeyboardHeight(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当键盘弹出时，你需要从通知中获取到键盘的高度，然后让文本视图减去这个高度，当键盘收回时，要复原文本视图的高度。</p>
<blockquote>
<p><strong>注意：</strong>在iOS8之前的版本中，当设备的方向发生变化时，也就是从竖屏变为横屏时，我们要计算新的文本视图的大小（因为<code>UIView的高和宽会交换，但是键盘的高和宽不会交换</code>），但是在iOS8中已经没这个必要了。</p>
</blockquote>
<p>现在编译运行应用，选择一条长文本的日记，编辑文本，此时弹出的键盘就不会再遮挡文本信息了：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-19.png" alt="pic"></p>
<p>原文链接：<a href="http://www.raywenderlich.com/77092/text-kit-tutorial-swift" target="_blank" rel="external">Text Kit Tutorial in Swift</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u52A8_u6001_u7684_u6587_u672C_u683C_u5F0F_u548C_u5B58_u50A8"><a href="#u52A8_u6001_u7684_u6587_u672C_u683C_u5F0F_u548C_u5B58_u50A8" ]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="TextKit" scheme="http://www.devtalking.com/tags/TextKit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用WatchKit实现Page-Based Navigation]]></title>
    <link href="http://www.devtalking.com//articles/watchkit-pagebase-navigation/"/>
    <id>http://www.devtalking.com//articles/watchkit-pagebase-navigation/</id>
    <published>2014-11-24T16:00:00.000Z</published>
    <updated>2016-01-01T14:02:20.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章向大家展示如何使用WatchKit创建Page-Based Navigation，我们还是在Helloworld项目的基础上进行改善。</p>
<h2 id="u521B_u5EFAController"><a href="#u521B_u5EFAController" class="headerlink" title="创建Controller"></a>创建Controller</h2><p>打开<code>Interface.storyboard</code>，再添加两个Interface Controller，然后给它们添加不同的背景色。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-1.png" alt="pic"></p>
<p>现在给每个Controller之间添加Segue，选中第一个Controller，按着control+鼠标左键拖拽至第二个Controller，然后选择next page。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-2.png" alt="pic"></p>
<p>编译运行，看看它是如何工作的：</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-3.gif" alt="pic"></p>
<h2 id="Interface_Controller_u751F_u547D_u5468_u671F"><a href="#Interface_Controller_u751F_u547D_u5468_u671F" class="headerlink" title="Interface Controller生命周期"></a>Interface Controller生命周期</h2><p>接下来我们自定义两个<code>WKInterfaceController</code>，分别设置给新添加的两个Interface Controller。然后我们来看看InterfaceController的生命周期。首先在<code>GreenInterfaceController</code>和<code>RedInterfaceController</code>中添加如下三个方法：</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-4.png" alt="pic"></p>
<p>编译运行，当Watch模拟器显示出内容时，在控制台中我们可以看到<code>GreenInterfaceController</code>和<code>RedInterfaceController</code>执行了<code>init</code>方法：</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-5.png" alt="pic"></p>
<p>当切换到绿色InterfaceController时，在控制台中可以看到<code>GreenInterfaceController</code>执行了<code>willActivate</code>方法：</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-6.png" alt="pic"><br>当切换到粉红色InterfaceController时，在控制台中可以看到<code>RedInterfaceController</code>执行了<code>willActivate</code>方法，而<code>GreenInterfaceController</code>执行了<code>didDeactivate</code>方法：</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-pagebase-navigation-7.png" alt="pic"></p>
<p>所以由此可见InterfaceController的生命周期主要由三个方法组成：</p>
<ul>
<li><strong>initWithContext</strong>：当Watch App第一次启动，把三个InterfaceController压入栈的时候调用该方法。</li>
<li><strong>willActivate</strong>：当进入InterfaceController时，调用该方法。类似<code>UIViewController</code>中的<code>viewDidAppear</code>方法。</li>
<li><strong>didDeactivate</strong>：当InterfaceController不在当前屏幕显示时调用该方法。类似<code>UIViewController</code>中的<code>viewDidDisappear</code>方法。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章向大家展示如何使用WatchKit创建Page-Based Navigation，我们还是在Helloworld项目的基础上进行改善。</p>
<h2 id="u521B_u5EFAController"><a href="#u521B_u5EFAControlle]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="WatchKit" scheme="http://www.devtalking.com/tags/WatchKit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何使用WatchKit创建Table]]></title>
    <link href="http://www.devtalking.com//articles/watchkit-create-table/"/>
    <id>http://www.devtalking.com//articles/watchkit-create-table/</id>
    <published>2014-11-22T16:00:00.000Z</published>
    <updated>2016-01-01T13:59:50.000Z</updated>
    <content type="html"><![CDATA[<p>上篇文章向大家演示了如何创建一个Helloworld Apple Watch App。这篇文章向大家演示如何使用WatchKit给你的Watch App创建Table。我们在Helloworld项目的基础上进行完善。</p>
<h2 id="u521B_u5EFA_u4E00_u4E2ATable"><a href="#u521B_u5EFA_u4E00_u4E2ATable" class="headerlink" title="创建一个Table"></a>创建一个Table</h2><p>打开<strong>Interface.storyboard</strong>文件，删除我们之前添加的Label，然后将一个Table组件拖拽到你的Watch屏幕中。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-1.png" alt="pic"></p>
<p>这里要注意一下，WatchKit中每一个WKInterfaceTableRow都是一个<strong>Table Row Controller</strong>，如果你展开它，你会发现它里面有一个<strong>Group</strong>，我们分别将一个Label和Image组件拖拽至Group中。调整Label和Image的大小，调整到你觉得合适就可以。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-2.png" alt="pic"></p>
<h2 id="u521B_u5EFA_u81EA_u5B9A_u4E49_u7684Table_Row_Controller"><a href="#u521B_u5EFA_u81EA_u5B9A_u4E49_u7684Table_Row_Controller" class="headerlink" title="创建自定义的Table Row Controller"></a>创建自定义的Table Row Controller</h2><p>我们选中TableRowController，然后选择右侧工具栏的Identify inspector，我们可以在<strong>Custom Class</strong>一栏中看到，其实TableRowController是一个<strong>NSObject</strong>。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-3.png" alt="pic"></p>
<p>我们可以创建一个自己的NSObject，然后将TableRowController的class设置为我们创建的NSObject，这样就达到了自定义的目的。我们在<strong>HelloworldWatchKit WatchKit Extension</strong>目录中创建一个Swfit文件，让它继承NSObject，然后导入WatchKit框架。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-4.png" alt="pic"></p>
<p>将TableRowController的class设置为<code>MyTableRowController</code>，并给它设置一个Identifier。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-5.png" alt="pic"></p>
<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-6.png" alt="pic"></p>
<p>现在你就可以在<code>MyTableRowController</code>中添加Label和Image的<strong>IBOutlet</strong>了。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-7.png" alt="pic"></p>
<h2 id="u521B_u5EFA_u6570_u636E_u6E90"><a href="#u521B_u5EFA_u6570_u636E_u6E90" class="headerlink" title="创建数据源"></a>创建数据源</h2><p>我们知道，在UIKit的<code>UITableView</code>或者<code>UITableViewController</code>中都有DataSource，负责Table Row中的数据，但是在WatchKit中的TableRowController并没有DataSource，但是这个概念是有的，也就是说我们要为TableRowController创建一个数据源，不论是数组还是字典。在这里，我们创建一个数组，作为TableRowController的数据源，数组中的元素都是<code>String</code>。因为我们的TableRowController中有一个Image组件、一个Label组件，所以我们将图片的名字作为数组的元素。</p>
<p>我们在<code>InterfaceController</code>中创建一个数据源<code>weather</code>数组，数组元素是图片名称，然后创建Table的IBOutlet。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-8.png" alt="pic"></p>
<h2 id="u52A0_u8F7D_u6570_u636E_u6E90"><a href="#u52A0_u8F7D_u6570_u636E_u6E90" class="headerlink" title="加载数据源"></a>加载数据源</h2><p>我们在<code>InterfaceController</code>中添加<code>loadTableData()</code>方法，然后在<code>init()</code>方法中调用。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-9.png" alt="pic"></p>
<p>现在编译运行一下，你就会看到Watch中显示出了Table，是不是很酷呢！</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-10.png" alt="pic"></p>
<p><img src="http://www.devtalking.com/postImages/watchkit-create-table-11.png" alt="pic"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>上篇文章向大家演示了如何创建一个Helloworld Apple Watch App。这篇文章向大家演示如何使用WatchKit给你的Watch App创建Table。我们在Helloworld项目的基础上进行完善。</p>
<h2 id="u521B_u5EFA_u4E0]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="WatchKit" scheme="http://www.devtalking.com/tags/WatchKit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Helloworld Apple Watch App]]></title>
    <link href="http://www.devtalking.com//articles/helloworld-watchkit-app/"/>
    <id>http://www.devtalking.com//articles/helloworld-watchkit-app/</id>
    <published>2014-11-21T16:00:00.000Z</published>
    <updated>2016-01-01T13:59:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u4E0B_u8F7DXcode_6-2_Beta"><a href="#u4E0B_u8F7DXcode_6-2_Beta" class="headerlink" title="下载Xcode 6.2 Beta"></a>下载Xcode 6.2 Beta</h2><p>首先我们需要下载最新的<a href="https://developer.apple.com/xcode/downloads/" target="_blank" rel="external">Xcode 6.2 Beta</a>。</p>
<h2 id="u521B_u5EFA_u4E00_u4E2A_u65B0_u9879_u76EE"><a href="#u521B_u5EFA_u4E00_u4E2A_u65B0_u9879_u76EE" class="headerlink" title="创建一个新项目"></a>创建一个新项目</h2><p>启动Xcode，选择<strong>Create a new Xcode project</strong>， 然后选择<strong>Single View Application</strong>创建一个单视图应用。</p>
<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app1.png" alt="PIC">  </p>
<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app2.png" alt="PIC"></p>
<h2 id="u521B_u5EFAWatch_App_Target"><a href="#u521B_u5EFAWatch_App_Target" class="headerlink" title="创建Watch App Target"></a>创建Watch App Target</h2><p>选择菜单中的<strong>File -&gt; New -&gt; Target</strong>， 然后选择<strong>Apple Watch -&gt; Watch App</strong>， 点击<strong>Next</strong>。  </p>
<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app3.png" alt="PIC">  </p>
<p>在Target的基本属性设置界面中不要勾选<strong>Include Notification Scene</strong> 和<strong>Include Glance Scene</strong>这两个选项，因为我们是在做一个<strong>Hello World</strong>， 最后点击<strong>Finish</strong>完成 <strong>Watch App Target</strong>的创建。  </p>
<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app4.png" alt="PIC">  </p>
<h2 id="u6DFB_u52A0Label"><a href="#u6DFB_u52A0Label" class="headerlink" title="添加Label"></a>添加Label</h2><p>打开<strong>HelloworldWatchKit Watch App</strong>目录下的 <strong>Interface.storyboard</strong>。</p>
<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app5.png" alt="PIC">    </p>
<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app6.png" alt="PIC">    </p>
<p>然后将一个Label拖拽到<code>InterfaceController</code>中，在Label中输入文字“Hello，World!”，并将Label的<strong>Position</strong>属性设置为 <strong>Horizontal:Center，Vertical:Center</strong>，让Label居中。这里不再需要AutoLayout。</p>
<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app7.png" alt="PIC">  </p>
<h2 id="u8FD0_u884CApp"><a href="#u8FD0_u884CApp" class="headerlink" title="运行App"></a>运行App</h2><p>首先选择Active Scheme为<strong>HelloworldWatchKit Watch App</strong>， 然后选择任意型号的iPhone模拟器。</p>
<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app8.png" alt="PIC"> </p>
<p>运行应用，这时你可能还看不到Apple Watch模拟器，别着急，这里还需要一个设置。选择iPhone模拟器，在菜单中选择<strong>Hardware -&gt; External Displays -&gt; Apple Watch - 38mm | Apple Watch - 42mm</strong>。</p>
<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app9.png" alt="PIC"> </p>
<p>然后重新运行应用，你就会看到你的第一个Apple Watch App了！</p>
<p><img src="http://www.devtalking.com/postImages/helloworld-watchkit-app10.png" alt="PIC"> </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u4E0B_u8F7DXcode_6-2_Beta"><a href="#u4E0B_u8F7DXcode_6-2_Beta" class="headerlink" title="下载Xcode 6.2 Beta"></a>下载Xcode 6.2 Beta</h2]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="WatchKit" scheme="http://www.devtalking.com/tags/WatchKit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WatchKit初探]]></title>
    <link href="http://www.devtalking.com//articles/watchkit-initial-impressions/"/>
    <id>http://www.devtalking.com//articles/watchkit-initial-impressions/</id>
    <published>2014-11-19T16:00:00.000Z</published>
    <updated>2016-01-01T13:58:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u6574_u4F53_u529F_u80FD_u9884_u89C8"><a href="#u6574_u4F53_u529F_u80FD_u9884_u89C8" class="headerlink" title="整体功能预览"></a>整体功能预览</h2><p>总体而言，WatchKit第一版SDK提供的功能远远超出了我的期望。因为我原本以为第一版WatchKit可能侧重于对iOS Today Extension功能的延伸，而不是真正开发Watch App。所以当知道真相后，我即惊讶又感到高兴，第一版WatchKit并不是我所想的那样，它可以为Watch App创建全新的交互界面，而且可以通过iOS App Extension去控制他们。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-initial-impressions-1.jpg" alt="pic"></p>
<p>所以我们能做的并不只是一个简单的所谓iOS Apple Watch Extension的玩意，而是有很多新的功能需要我们去挖掘。目前提供的比如特定的UI控制方式    、Glance、可自定义的Notification、和Handoff的深度结合、图片缓存等等，作为开发者，这些功能已经让我为之兴奋了。</p>
<h2 id="Apple_Watch_u7684_u67B6_u6784"><a href="#Apple_Watch_u7684_u67B6_u6784" class="headerlink" title="Apple Watch的架构"></a>Apple Watch的架构</h2><p>WatchKit带给我的惊讶之一是它的架构。目前Watch App的运行是由两部分相互结合进行工作的:</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-initial-impressions-2.jpg" alt="pic"></p>
<ul>
<li><strong>你的Apple Watch</strong>主要包含用户界面元素文件（Storyboard文件和静态的图片文件）和处理用户的输入行为。并不会真正在Apple Watch中运行代码。换句话说，Apple Watch仅是一个“视图”容器。</li>
<li><strong>你的iPhone</strong>包含所有的逻辑代码用于响应用户在Apple Watch上产生的诸如应用启动、点击按钮、滑动滑杆等行为。换言之，iPhone包含了控制器和模型。</li>
</ul>
<p>有趣的是Apple Watch和iPhone的这种交互是在幕后自动完成的。你要做的工作只是在Storyboard中设置好UI的Outlet，然后其他的事都由WatchKit SDK在幕后通过蓝牙技术自动进行交互。即使iPhone和Apple Watch是两个独立的设备，你也只需要关注你本地的代码以及Outlet的连接情况，这真是一件很酷的事情。</p>
<h2 id="WatchKit_u5E03_u5C40"><a href="#WatchKit_u5E03_u5C40" class="headerlink" title="WatchKit布局"></a>WatchKit布局</h2><p>一个令我惊讶的是Watch App的UI布局方式，我们不能再用AutoLayout进行布局了。取而代之的是一种新的布局方式<strong>Group</strong>，你需要将界面元素比如按钮、Label添加到Group中，然后Group会自动为你添加的界面元素在其内部进行布局。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-initial-impressions-3.jpg" alt="pic"></p>
<p>你可以将一个Group嵌入到另一个Group中，用于实现较为复杂一点的界面布局，并在Group中还可以设置背景色、边距、圆角半径等属性。</p>
<p>这让我想起了Java中的<a href="https://docs.oracle.com/javase/tutorial/uiswing/layout/visual.html" target="_blank" rel="external">BoxLayout</a>或者XAML中的<a href="http://msdn.microsoft.com/en-us/library/ms754152.aspx" target="_blank" rel="external">StackPanel</a>。</p>
<h2 id="Glances_u548CNotifications"><a href="#Glances_u548CNotifications" class="headerlink" title="Glances和Notifications"></a>Glances和Notifications</h2><p>Watch App中最酷的功能我觉得就是Glances和Notifications了。我个人认为，Apple Watch的应用中最有用的功能之一就是能让用户很方便的（比如一抬手）就能看到自己感兴趣的事物的提醒通知，比如有人在Twitter中提及到了你或者比特币现在的价位等等。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-initial-impressions-4.jpg" alt="pic"></p>
<p>Glances和Notifications能为你带来什么呢？</p>
<ul>
<li><strong>Glances</strong>能让你在应用中快速预览信息，有点像iOS8中的Today Extension。</li>
<li><strong>Notifications</strong>能让你在Apple Watch中接收到各类通知。Apple Watch中的通知分为两种级别。第一种是提示，只显示应用图标和简单的文本信息。当你抬起手腕或者点击屏幕时就会进入到第二种级别，你就可以看到该通知更多详细的信息，甚至有交互按钮。</li>
</ul>
<p>在Glance和Notification这两种情形下，你都可以点击屏幕进入到对应的Watch App中，并且使用Handoff。你甚至可以将特定的View Controller作为Glance或Notification的内容发送给用户。</p>
<p>我预期在未来几个月我们会在Glance和Notification上面投入较大的时间。</p>
<h2 id="u52A8_u753B"><a href="#u52A8_u753B" class="headerlink" title="动画"></a>动画</h2><p>Apple Watch中不支持动画，这多少让人觉得有点奇怪。如果你希望某个UI元素具有动画效果，你必须要生成一堆图片，这些图片的内容是连续动画每一帧的内容，然后循环显示这些图片，感觉又回到了GIF动画时代。所以在Apple Watch中不支持iOS中UIView或CALayer这种动画，只支持帧动画。</p>
<p>举个例子，你们可以看看Apple的<a href="https://developer.apple.com/library/prerelease/ios/samplecode/Lister/Introduction/Intro.html" target="_blank" rel="external">Lister example</a>示例，你会发现Apple通过360张图片来实现一个画圆的动画效果。</p>
<p><img src="http://www.devtalking.com/postImages/watchkit-initial-impressions-5.jpg" alt="pic"></p>
<p>这显然是一个灾难性的工作量，不过如果需要，也可以借助某些工具去生成一个动画需要的所有图片。不过，因为Apple Watch的容量很悠闲，所以你要谨慎加入帧动画，因为需要大量图片占用内存，除非有画龙点睛的动画，否则还是尽量少使用动画。</p>
<h2 id="u8BBE_u8BA1_u8D44_u6E90"><a href="#u8BBE_u8BA1_u8D44_u6E90" class="headerlink" title="设计资源"></a>设计资源</h2><p>如果你是一名设计者（或者对设计有浓厚的兴趣爱好），一下两点建议对你有很好的帮助：</p>
<ol>
<li>放下你手中所有的事情，阅读Apple提供的针对Apple Watch的<a href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/WatchHumanInterfaceGuidelines/index.html" target="_blank" rel="external">Human Interface Guidelines (HIG)</a>。里面有非常不错的指导和参考能帮助你理解Apple Watch UI设计中你有疑惑的地方，因为设计Apple Watch App是一个全新的世界。</li>
<li>你一定要下载<a href="https://developer.apple.com/watchkit/#agreement" target="_blank" rel="external">Apple Watch Design Resources</a>。这里有大量关于设计Apple Watch App的PSD素材，比如UI控制模型、颜色、元素间距的指导、笔画粗细的指导等等，有很多有用的东西，给我留下了非常深刻的印象，这里强烈推荐。</li>
</ol>
<p>原文地址：<a href="http://www.raywenderlich.com/89473/watchkit-initial-impressions" target="_blank" rel="external">WatchKit: Initial Impressions</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u6574_u4F53_u529F_u80FD_u9884_u89C8"><a href="#u6574_u4F53_u529F_u80FD_u9884_u89C8" class="headerlink" title="整体功能预览"></a>整体功能预览</h2]]>
    </summary>
    
      <category term="Apple Watch" scheme="http://www.devtalking.com/tags/Apple-Watch/"/>
    
      <category term="WatchKit" scheme="http://www.devtalking.com/tags/WatchKit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何在Swift中运用Text Kit框架（一）]]></title>
    <link href="http://www.devtalking.com//articles/text-kit-tutorial-in-swift-1/"/>
    <id>http://www.devtalking.com//articles/text-kit-tutorial-in-swift-1/</id>
    <published>2014-10-30T16:00:00.000Z</published>
    <updated>2016-01-01T13:57:21.000Z</updated>
    <content type="html"><![CDATA[<p>由于Apple近几年在iOS系统的不断改进过程中添加了许多新的特性和功能，这使得iOS系统对文本的渲染能力有了大大的提升。在iOS7中我们就已经能感觉到在文本渲染方面有了很大改进和提升。现在iOS8发布了，在文本渲染方面在延续了之前强大功能的基础上，又提升了其易用性。简单纵观iOS文本渲染的发展史，你也许对目前文本渲染的强大能有更深刻的体会。</p>
<p>在iOS6之前，使用web视图渲染文本是当时最为容易的一种方式，因为它能较为有效的处理混合编排的文本，比如有粗体字、斜体字、有颜色的字等。</p>
<p>2012年，iOS6在UIKit框架中添加一些支持字符串编辑或渲染的控件。这使得在渲染文本时，使用web视图不再是唯一的选择了。并且在文本排版方面不用再依赖通过HTML布局这种方式了。</p>
<p>在iOS6中，UIKit中支持字符串编辑和渲染的控件是同时基于WebKit和Core Graphic的<code>String drawing</code>函数开发出的，整个如下图所示：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-1.png" alt="pic"></p>
<blockquote>
<p>注意：在这张图上有没有让你疑惑的地方呢？没错，<code>UITextView</code>是基于WebKit框架的。实际上，UIKit中与文本相关的这些控件在底层还是使用HTML渲染的。没有深入研究过相关框架的开发者是不太容易察觉这一点的。</p>
</blockquote>
<p>尽管iOS6中提供的这些文本控件在实际开发中的确带来了不少便利，但是当遇到复杂的布局、多行混合渲染等这种高级应用场景时，这些控件就显得捉襟见肘了，此时虽然Core Text是相对底层而且用法繁复的框架，但使用它来解决问题仍是唯一可以选择的方法。</p>
<p>直到iOS7的问世，这种窘境得以改善。随着扁平化的设计思路，iOS的UI拚弃了沿用多年的拟物化风格，将重点和关注点集中在排版工艺上。比如<code>UIButton</code>在iOS7中去掉了整个外边框和阴影，只留下了按钮文字。所以Apple在iOS7中加入了用于文本编排和渲染的<strong>Text Kit</strong>框架就不足为奇了。</p>
<p>在iOS7中关于文本渲染的控件及框架结构就比较清晰和合理了。因为所有UIKit中的文本控件都基于Text Kit框架，而不像iOS6中还有基于Web Kit框架的：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-2.png" alt="pic"></p>
<p>Text Kit在继承了Core Text所有强大功能的基础上，将功能封装为面向对象的API，让开发者们都乐开了花。</p>
<p>在这篇教程中，你要去探索Text Kit的各种功能特性，并且你要创建一个简单的但又功能丰富的iPhone笔记应用。</p>
<p>本教程包含一个初始的项目，里面含有事先创建好的UI部分，以便使同学们只关注于Text Kit的部分。在这里可以下载该<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/09/SwiftTextKitNotepad-starter6.zip" target="_blank" rel="external">项目</a>。下载完成后解压并在Xcode中打开项目，编译运行后你会看到如下的界面：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-3.png" alt="pic"></p>
<p>该示例应用创建了一个初始的数组用于存放笔记实例，然后在TableViewController中将其渲染出来，当你点击选择某条笔记时，Storyboard和segue会捕获到你的行为，然后处理视图转换的先关工作，使你看到该条笔记的详细信息。</p>
<h2 id="Dynamic_Type"><a href="#Dynamic_Type" class="headerlink" title="Dynamic Type"></a>Dynamic Type</h2><p><strong>Dynamic Type</strong>是iOS7中给我们的开发带来变化最多的特性之一，它的作用是让应用中的字体大小遵循你设置的字体大小和粗细。</p>
<p>在iOS7中，打开设置，可以在 <strong>通用/辅助功能（General/Accessibility）</strong> 和 <strong>通用/字体大小（General/Text Size）</strong> 中查看和设置系统中应用显示字体的属性： </p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-4.png" alt="pic"></p>
<p>在iOS8中，打开设置，可以在 <strong>通用/辅助功能/更大字体（General/Accessibility/Larger Text）</strong> 查看Dynamic Type的文本尺寸。</p>
<p>不管是增加文字粗细还是改变文字大小，在支持Dynamic Type的应用中这都能给用户带来极大的便利，增加了文字的可读性。</p>
<p>为了让应用支持Dynamic Type，你需要设置文本遵循某一<strong>风格</strong>，而不是明确的指定文本的字体名称和大小。在iOS7中已经为<code>UIFont</code>增加了一个新的方法<code>preferredFontForTextStyle</code>，它的作用是给创建出一个由用户在设置中根据自身需要设定的风格的字体。</p>
<p>下表中展示了六种不同字体样式的不同大小和粗细程度：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-5.png" alt="pic"></p>
<p>表中最左边的字体是用户可选择的最小的字体，中间是可选择的最大的字体，最右边是选择了辅助功能中给字体加粗后的样式。</p>
<h2 id="u6700_u57FA_u672C_u7684_u529F_u80FD_u652F_u6301"><a href="#u6700_u57FA_u672C_u7684_u529F_u80FD_u652F_u6301" class="headerlink" title="最基本的功能支持"></a>最基本的功能支持</h2><p>实现动态文本的基本功能还是相对较简单的。应用中的字体不再是一个明确的字体，而是需要请求一个特殊的字体样式。在运行时，应用会根据用户在设置应用中对字体的设置以及请求到的字体样式中选择一个合适的字体样式。</p>
<p>到了iOS8，Apple让实现Dynamic Type变得比iOS7更加容易了。尤其是TableView中的默认Label自动支持Dynamic Type，这个很赞！但是如果还想适配iOS7的话那就要在TableView中使用自定义的Label了。所以首先同学们要学会如何在iOS7中处理Dynamic Type，然后你就会发现到了iOS8后，生活是多么美好，晴空万里，没有雾霾！</p>
<h2 id="u4E3A_u4EC0_u4E48iOS7_u662F_u4F18_u79C0_u7684_u7CFB_u7EDF_uFF0C_u800CiOS8_u662F_u8D8B_u8FD1_u5B8C_u7F8E_u7684_u7CFB_u7EDF"><a href="#u4E3A_u4EC0_u4E48iOS7_u662F_u4F18_u79C0_u7684_u7CFB_u7EDF_uFF0C_u800CiOS8_u662F_u8D8B_u8FD1_u5B8C_u7F8E_u7684_u7CFB_u7EDF" class="headerlink" title="为什么iOS7是优秀的系统，而iOS8是趋近完美的系统"></a>为什么iOS7是优秀的系统，而iOS8是趋近完美的系统</h2><p>该教程中初始项目的设置和配置是基于iOS8的。在我们开始学习之前，先编译运行应用，然后尝试改变默认的文本字体大小，多试几次不同的字体大小。你会发现不光是字体大小变了，TableView列表的Cell高度也相应发生了改变。但是你对这个项目还没动过一根手指。同时你也应该发现了点击选择一条笔记后，该笔的详细信息的文本字体却没有发生变化。</p>
<p>但在iOS7中我们的确还要做一些额外的事，没有十全十美的事应该指的就是这个吧。如果你的编译环境是iOS7或iOS8（确保你使用的Xcode版本是6），那么本教程的绝大部分内容都是没问题的。现在我们需要将Xcode的编译环境设置为iOS7已经选择合适的iOS模拟器（iPhone5s）。如果你不打算支持iOS8之前的系统，那么你可以直接使用iOS8的编译环境。</p>
<p>现在咱们在iOS7下编译运行应用，然后重复之前修改字体的操作，你会发现什么？没错，发现了悲剧。应用中的字体会忽略你对字体的设置，根本不起作用。所以，同学们必须要做点什么让Dynamic Type在iOS7跑起来。</p>
<p>打开<strong>NoteEditorViewController.swift</strong>，在<code>viewDidLoad</code>方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">textView.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleBody</span>)</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是你并没有给<code>textView.font</code>设置具体的字体，比如Helvetica Neue之类。相反，你只是请求了一个适合主体文本的字体样式<code>UIFontTextStyleBody</code>。</p>
<p>然后打开<strong>NotesListViewController.swift</strong>，在<code>tableView(_:cellForRowAtIndexPath:)</code>方法的<code>return</code>语句后添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cell.textLabel?.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleHeadline</span>)</span><br></pre></td></tr></table></figure>
<p>你依然没有给字体具体的类型，而是请求了一个合适的字体样式。</p>
<p>使用语义接近的字体样式名称，比如<code>UIFontTextStyleSubHeadline</code>，可以避免在代码中对字体样式使用硬编码，并确保你的应用中的文本信息能正确的响应用户的设置。</p>
<p>现在再编译和运行应用，你会发现TableView和笔记详细信息页面中的文本字体都发生了变化。下面的截图是设置不同字体大小后的笔记详细信息页面：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-6.png" alt="pic"></p>
<p>目前看起来一起都很完美，但是细心的读者可能会发现这种解决方法只能解决一半的问题。让我们回到设置应用然后再次更改字体大小，然后我们通过后台程序回到我们的笔记应用中，我们发现了什么？没错，文本字体没有响应我们刚才的设置从而发生变化。</p>
<p>我相信我们的用户是不会允许这种事情发生的。又一个挑战出现了，让我们来看看如何解决这个问题。</p>
<h2 id="u5373_u65F6_u54CD_u5E94_u5B57_u4F53_u8BBE_u7F6E"><a href="#u5373_u65F6_u54CD_u5E94_u5B57_u4F53_u8BBE_u7F6E" class="headerlink" title="即时响应字体设置"></a>即时响应字体设置</h2><p>打开<code>NoteEditorViewController.swift</code>，在<code>viewDidLoad</code>方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, </span><br><span class="line">    selector: <span class="string">"preferredContentSizeChanged:"</span>, </span><br><span class="line">    name: <span class="type">UIContentSizeCategoryDidChangeNotification</span>,</span><br><span class="line">    object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>上面这段代码的作用是将我们的<code>NodeEditorViewController</code>注册到通知中心里，当字体发生改变时会通知<code>NodeEditorViewController</code>中的<code>preferredContentSizeChanged</code>方法。</p>
<p>我们再来看看<code>preferredContentSizeChanged</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">preferredContentSizeChanged</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">  textView.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleBody</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中我们就可以改变文本的字体样式了。</p>
<blockquote>
<p>注意：这里你可能会有疑惑，已经更改过字体样式了，为什么这里再次请求样式的时候还是<code>UIFontTextStyleBody</code>呢？当用户更改完字体样式后，你需要通过<code>preferredFontForTextStyle</code>方法重新请求一次字体样式，该方法的参数只代表文本的类型和所在位置，比如是Body里的还是Head中的等，所以<code>UIFont.preferredFontForTextStyle(UIFontTextStyleBody)</code>的意思就是请求类型和位置在Body中显示文本的字体样式，每次请求都是获取最新一次设置的字体样式。</p>
</blockquote>
<p>打开<code>NotesListViewController.swift</code>，重写<code>viewDidLoad</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>,</span><br><span class="line">      selector: <span class="string">"preferredContentSizeChanged:"</span>, </span><br><span class="line">      name: <span class="type">UIContentSizeCategoryDidChangeNotification</span>, </span><br><span class="line">      object: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同学们应该注意到了，我们刚才添加的方法和<code>NoteEditorViewController.swift</code>中添加的方法一样。没错，给<code>NSNotificationCenter</code>注册的方法是相同的，但是<code>preferredContentSizeChanged</code>方法会有点区别。</p>
<p>然后在<code>NotesListViewController.swift</code>中再添加<code>preferredContentSizeChanged</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">preferredContentSizeChanged</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">  tableView.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码的作用是让Tableview重新加载可见的Cell，在更新时就会触发<code>preferredFontForTextStyle()</code>方法，将新设置的字体样式应用到Tableview的Cell中。</p>
<p>再次编译运行应用，设置字体样式，然后看看我们的应用有没有正确的响应你的设置。</p>
<h2 id="u4F7FCell_u9AD8_u5EA6_u81EA_u9002_u5E94"><a href="#u4F7FCell_u9AD8_u5EA6_u81EA_u9002_u5E94" class="headerlink" title="使Cell高度自适应"></a>使Cell高度自适应</h2><p>响应字体设置这部分到目前为止我们已经处理完了，效果也不错，但是当你把字体设置为一个足够小的，或者最小的字体时，在TableView中看起来就不怎么好看了，因为Cell的高度没有变化，而字体很小，所以看起来很不美观，比如下面左侧的截图一样：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-7.png" alt="pic"></p>
<p>这个问题是iOS7中在Dynamic Type中比较坑爹的一个问题。想要使你的应用在不同字体样式下都显示的比较完美，你必须要让Cell的高度根据字体样式的大小做出相应的调整。虽然Auto Layout能帮你解决大部分布局适配上的问题，但在这个问题上，它就比较无力了，这得需要你自己去解决了。</p>
<p>解决这个问题的原理很简单，就是让TableView的Cell高度根据字体样式的大小进行改变。那么可以通过实现<code>UITextViewDelegate</code>的<code>tableView(_:heightForRowAtIndexPath:)</code>方法来解决该问题。</p>
<p>在<code>NotesListViewController.swift</code>中加入如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> label: <span class="type">UILabel</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> temporaryLabel = <span class="type">UILabel</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">Int</span>.<span class="built_in">max</span>, height: <span class="type">Int</span>.<span class="built_in">max</span>))</span><br><span class="line">  temporaryLabel.text = <span class="string">"test"</span></span><br><span class="line">  <span class="keyword">return</span> temporaryLabel</span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView!, heightForRowAtIndexPath indexPath: NSIndexPath!)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">  label.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleHeadline</span>)</span><br><span class="line">  label.sizeToFit()</span><br><span class="line">  <span class="keyword">return</span> label.frame.height * <span class="number">1.7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，首先创建了一个<code>UILabel</code>的实例，用于计算TableView中Cell的高度，也就是这个<code>UILabel</code>的高度就是Cell的高度，然后在<code>tableView(_:heightForRowAtIndexPath:)</code>方法中设置该<code>UILabel</code>的字体样式，调用<code>sizeToFit</code>方法使Label的高度适配字体的高度，最后将Label的高度返回，也就相当于将Cell的高度设置为Label的高度了。这里需要注意的是当调用完<code>sizeToFit</code>方法后，Label与它里面字体之间几乎没有上下间隔，所以我们在返回高度的时候乘以一个上下间隔的比例系数。</p>
<p>再次编译和运行你的应用，多更改几次字体样式，你会看到Cell的高度随着字体样式也进行着调整：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-8.png" alt="pic"></p>
<h2 id="u7ED9_u6587_u672C_u6DFB_u52A0_u5370_u5237_u6548_u679C"><a href="#u7ED9_u6587_u672C_u6DFB_u52A0_u5370_u5237_u6548_u679C" class="headerlink" title="给文本添加印刷效果"></a>给文本添加印刷效果</h2><p>给文本添加一点高亮和阴影来达到文本像嵌入纸张的那种印刷效果。</p>
<p>打开<code>NotesListViewController.swift</code>用下面的代码替换<code>tableView(_:cellForRowAtIndexPath:)</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!)</span></span> -&gt; <span class="type">UITableViewCell</span>? &#123;</span><br><span class="line">  <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"Cell"</span>, forIndexPath: indexPath) <span class="keyword">as</span> <span class="type">UITableViewCell</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> note = notes[indexPath.row]</span><br><span class="line">  <span class="keyword">let</span> font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleHeadline</span>)</span><br><span class="line">  <span class="keyword">let</span> textColor = <span class="type">UIColor</span>(red: <span class="number">0.175</span>, green: <span class="number">0.458</span>, blue: <span class="number">0.831</span>, alpha: <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> attributes = [</span><br><span class="line">    <span class="type">NSForegroundColorAttributeName</span> : textColor,</span><br><span class="line">    <span class="type">NSFontAttributeName</span> : font,</span><br><span class="line">    <span class="type">NSTextEffectAttributeName</span> : <span class="type">NSTextEffectLetterpressStyle</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">let</span> attributedString = <span class="type">NSAttributedString</span>(string: note.title, attributes: attributes)</span><br><span class="line"> </span><br><span class="line">  cell.textLabel?.attributedText = attributedString</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码给TableView的Cell中的文本添加了颜色和<code>NSTextEffectLetterpressStyle</code>文字样式。</p>
<p>编译运行应用，你会看到更加立体的文本：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-9.png" alt="pic"></p>
<p>这种印刷效果虽然只是一种较为细微的效果，但这并不代表你就能滥用这种效果，它虽然能使文本看起来有立体感，但是有可能会影响到文本的清晰度。</p>
<h2 id="u6587_u672C_u7ED5_u884C_u6392_u7248"><a href="#u6587_u672C_u7ED5_u884C_u6392_u7248" class="headerlink" title="文本绕行排版"></a>文本绕行排版</h2><p>一般我们在常用的文本编辑器，比如Word中都能看到文本围绕图片或表格等其他元素的排版格式。TextKit也提供了能让文本按指定的路径排版或按一定形状排版的功能，叫做绕行路径。</p>
<p>下面我们希望在笔记详细页中添加一个圆形的视图，放在右上角，用于显示这篇笔记的创建时间。</p>
<p>当你创建完视图摆好位置后，你会发现这个圆形的视图会遮盖住笔记文本信息，所以我们需要给文本创建一个绕行路径来绕开这个圆形的视图。</p>
<h3 id="u6DFB_u52A0_u5706_u5F62_u89C6_u56FE"><a href="#u6DFB_u52A0_u5706_u5F62_u89C6_u56FE" class="headerlink" title="添加圆形视图"></a>添加圆形视图</h3><p>打开<code>NoteEditorViewController.swift</code>，申明一个属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> timeView: <span class="type">TimeIndicatorView</span>!</span><br></pre></td></tr></table></figure>
<p>然后在<code>viewDidLoad</code>方法的最后添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">timeView = <span class="type">TimeIndicatorView</span>(date: note.timestamp)</span><br><span class="line">textView.addSubview(timeView)</span><br></pre></td></tr></table></figure>
<p>创建一个<code>timeView</code>的示例，然后将它作为一个子视图添加到<code>textView</code>中。</p>
<p>刚才创建的视图需要合适的尺寸大小，你需要一种机制在ViewController绘制子视图调用<code>updateSize</code>方法来计算尺寸。</p>
<p>所以我们加入如下两个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">  updateTimeIndicatorFrame()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">updateTimeIndicatorFrame</span><span class="params">()</span></span> &#123;</span><br><span class="line">  timeView.updateSize()</span><br><span class="line">  timeView.frame = <span class="type">CGRectOffset</span>(timeView.frame, textView.frame.width - timeView.frame.width, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>viewDidLayoutSubviews</code>方法会调用<code>updateTimeIndicatorFrame</code>方法，该方法会处理两件事，一个是调用<code>updateSize</code>方法设置<code>timeView</code>的尺寸，另一个是设置<code>timeView</code>的位置，使它处于<code>textView</code>的右上角。</p>
<p>之后每次当ViewController接收到文本字体样式更改的时候都会调用<code>updateTimeIndicatorFrame</code>方法，以便将<code>timeView</code>的尺寸和位置调整到合适的状态。所以我们更改一下<code>preferredContentSizeChanged</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">preferredContentSizeChanged</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">  textView.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleBody</span>)</span><br><span class="line">  updateTimeIndicatorFrame()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在编译运行应用，点击笔记条目进入详细信息页后你就会在右上角看到一个显示创建时间的圆形视图：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-10.png" alt="pic"></p>
<p>你可以在设置中改变字体样式，显示创建日期的视图会根据字体样式自动调整到合适的大小。</p>
<p>但是你们会发现还有一些美中不足的地方，那就是日期视图把笔记文本信息给遮住了，幸运的是TextKit提供的文本绕行路径能帮我们解决这个问题。</p>
<h3 id="u521B_u5EFA_u7ED5_u884C_u8DEF_u5F84"><a href="#u521B_u5EFA_u7ED5_u884C_u8DEF_u5F84" class="headerlink" title="创建绕行路径"></a>创建绕行路径</h3><p>打开<code>TimeIndicatorView.swift</code>，看看<code>curvePathWithOrigin</code>方法，日期视图在填充渲染背景色的时候会调用该方法，但是你可以通过该方法来决定文本的绕行路径，该方法会自己计算视图的贝塞尔曲线，也就相当于是文本的绕行路径了。</p>
<p>打开<code>NoteEditorViewController.swift</code>，在<code>updateTimeIndicatorFrame</code>方法末尾中添加如下两行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> exclusionPath = timeView.curvePathWithOrigin(timeView.center)</span><br><span class="line">textView.textContainer.exclusionPaths = [exclusionPath]</span><br></pre></td></tr></table></figure>
<p>上面的代码通过日期视图的<code>curvePathWithOrigin</code>方法基于贝塞尔曲线计算出绕行路径，然后放在数组中赋值给<code>textView.textContainter.exclusionPaths</code>属性。这里要注意的是绕行路径的起点和坐标与文本信息是相对位置。</p>
<p>编译运行应用，现在你就可以看到文本信息都绕开了日期视图：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-11.png" alt="pic"></p>
<p>这个简单的示例只是体现出了绕行路径强大功能的冰山一角，从上面的代码中你可能也注意到了，绕行路径是放在数组中进行赋值的，所以这就意味着每个容器，不管是文本容器还是其他容器都可以被设置多个绕行路径。</p>
<p>除此之外，绕行路径可以随着你的想法变得简单或者复杂，你甚至可以让文本围绕着星星形状或者蝴蝶形状排版。</p>
<p>每当绕行路径发生改变时，文本容器就会通知布局管理器，你可以让绕行路径进行动态的改变，比如从星星形状的路径变成蝴蝶形状的路径，此时文本容器也会动态的改变排版。但是这样做会得不偿失，因为用户在阅读的时候看到文字动来动去，估计会砸了手机！</p>
<p>未完待续……</p>
<p>原文地址：<a href="http://www.raywenderlich.com/77092/text-kit-tutorial-swift" target="_blank" rel="external">Text Kit Tutorial in Swift</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于Apple近几年在iOS系统的不断改进过程中添加了许多新的特性和功能，这使得iOS系统对文本的渲染能力有了大大的提升。在iOS7中我们就已经能感觉到在文本渲染方面有了很大改进和提升。现在iOS8发布了，在文本渲染方面在延续了之前强大功能的基础上，又提升了其易用性。简单纵]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="TextKit" scheme="http://www.devtalking.com/tags/TextKit/"/>
    
  </entry>
  
</feed>
