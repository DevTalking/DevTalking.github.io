<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[程序员说]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.devtalking.com/"/>
  <updated>2018-06-14T16:43:16.000Z</updated>
  <id>http://www.devtalking.com/</id>
  
  <author>
    <name><![CDATA[DevTalking]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[基于OmniFocus的任务系统]]></title>
    <link href="http://www.devtalking.com//articles/task-manage-omnifocus/"/>
    <id>http://www.devtalking.com//articles/task-manage-omnifocus/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-06-14T16:43:16.000Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="OmniFocus_u7684_u51E0_u4E2A_u4E3B_u8981_u6982_u5FF5"><a href="#OmniFocus_u7684_u51E0_u4E2A_u4E3B_u8981_u6982_u5FF5" class="headerlink" title="OmniFocus的几个主要概念"></a>OmniFocus的几个主要概念</h2><p>文章中所有的内容都是以OmniFocus 3为例。</p>
<ul>
<li>文件夹：OmniFocus中任务的组织结构最顶级一层，但只是用于分类，本身没有什么属性。</li>
<li>项目：顾名思义，用于定义我们生活和工作中大大小小的项目，项目本身也有属性设置，可设置标签、其内任务的关系（并行、串行、单个），截止日期等。项目下可包含多个任务。</li>
<li>任务：OmniFocus中承载事件的最小颗粒。因为OmniFocus支持任务无限嵌套，所以当多个任务在一个任务下时该任务就成为一个任务组。</li>
<li>任务组：任务组本身也是一个任务，但是它又是其他任务的父任务，所以任务组有子任务关系（并行、串行、单个）的设置。</li>
<li>标签：任务、项目身上都可以设置一到多个标签。标签可以嵌套，并且标签支持设置地理位置，并且有根据进入，走出两个行为和距离范围设置通知。</li>
<li>透视：根据各种条件筛选任务的视图。比如查看有标签“办公室”，即将截至的任务。条件可以按照包含任意、全部包含和不包含进行组合。然后还可以设置筛选出来任务的排列、分组方式。</li>
</ul>
<h2 id="u4EFB_u52A1_u7CFB_u7EDF"><a href="#u4EFB_u52A1_u7CFB_u7EDF" class="headerlink" title="任务系统"></a>任务系统</h2><p>我参照John Z. Sonmez的看板+番茄钟的系统，将其调整为OmniFocus+番茄钟的系统。</p>
<h3 id="u7CFB_u7EDF_u8BBE_u7F6E"><a href="#u7CFB_u7EDF_u8BBE_u7F6E" class="headerlink" title="系统设置"></a>系统设置</h3><ul>
<li>在截止日期这一项，将即将截止日期的表示设置为今天。</li>
<li>今天和Watch这一项，设置为自定义透视的<strong>今日</strong>（该透视下面会讲到）。</li>
</ul>
<h3 id="u6784_u5EFA_u7CFB_u7EDF_u7684_u4E3B_u8981_u6807_u7B7E"><a href="#u6784_u5EFA_u7CFB_u7EDF_u7684_u4E3B_u8981_u6807_u7B7E" class="headerlink" title="构建系统的主要标签"></a>构建系统的主要标签</h3><ul>
<li>仪式：周期性重复的任务会设置该标签。</li>
<li>地点：标明某个任务能在何种场所进行。<ul>
<li>办公室</li>
<li>家</li>
<li>通勤中</li>
</ul>
</li>
<li>状态：进行任务时需要投入的专注度。<ul>
<li>集中精力</li>
<li>放松</li>
</ul>
</li>
<li>跟踪：需要跟踪的任务会设置该标签，比如安排下去的任务需要在某个时间点知道完成的结果。</li>
<li>采购：需要购买东西的任务会设置该标签。</li>
<li>星期：规划一周任务时设置的标签。<ul>
<li>周一</li>
<li>周二</li>
<li>周三</li>
<li>周四</li>
<li>周五</li>
<li>周六</li>
<li>周日</li>
</ul>
</li>
<li>二分钟：能在很短时间内完成的任务会设置该标签。</li>
</ul>
<a id="more"></a>
<h3 id="u4EFB_u52A1_u6C60_u900F_u89C6"><a href="#u4EFB_u52A1_u6C60_u900F_u89C6" class="headerlink" title="任务池透视"></a>任务池透视</h3><h4 id="u529E_u516C_u5BA4-_u805A_u7126"><a href="#u529E_u516C_u5BA4-_u805A_u7126" class="headerlink" title="办公室-聚焦"></a>办公室-聚焦</h4><p>该透视能筛选出所有我需要在办公室内并且投入100%专注度要做的事情。是我在规划一周内工作的主要透视视图。</p>
<p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>标签为全部以下内容：办公室、集中精力</li>
<li>无以下内容：标签为任何以下内容：周一、周二、周三、周四、周五、周六、周日</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：整个项目</li>
<li>项目分组方式：未分组</li>
<li>项目排列方式：到期 </li>
</ul>
<h4 id="u529E_u516C_u5BA4-_u653E_u677E"><a href="#u529E_u516C_u5BA4-_u653E_u677E" class="headerlink" title="办公室-放松"></a>办公室-放松</h4><p>该透视能筛选出所有我需要在办公室内处理，但是不需要投入很多专注度的事情。是我在规划一周内工作时补充任务的透视，还有当每天清空任务后，会从该透视中进行补充。</p>
<p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>标签为全部以下内容：办公室、放松</li>
<li>无以下内容：标签为任何以下内容：周一、周二、周三、周四、周五、周六、周日</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：整个项目</li>
<li>项目分组方式：未分组</li>
<li>项目排列方式：到期 </li>
</ul>
<h4 id="u5BB6-_u805A_u7126"><a href="#u5BB6-_u805A_u7126" class="headerlink" title="家-聚焦"></a>家-聚焦</h4><p>该透视能筛选出所有我需要在家并且投入100%专注度要做的事情。是我在规划一周内业余时间工作的主要透视视图。</p>
<p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>标签为全部以下内容：家、集中精力</li>
<li>无以下内容：标签为任何以下内容：周一、周二、周三、周四、周五、周六、周日</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：整个项目</li>
<li>项目分组方式：未分组</li>
<li>项目排列方式：到期 </li>
</ul>
<h4 id="u5BB6-_u653E_u677E"><a href="#u5BB6-_u653E_u677E" class="headerlink" title="家-放松"></a>家-放松</h4><p>该透视能筛选出所有我需要在家处理，但是不需要投入很多专注度的事情。是我在规划一周内业余时间工作时补充任务的透视。</p>
<p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>标签为全部以下内容：家、放松</li>
<li>无以下内容：标签为任何以下内容：周一、周二、周三、周四、周五、周六、周日</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：整个项目</li>
<li>项目分组方式：未分组</li>
<li>项目排列方式：到期 </li>
</ul>
<h4 id="u901A_u52E4"><a href="#u901A_u52E4" class="headerlink" title="通勤"></a>通勤</h4><p>该透视能筛选出所有我需要在通勤路上处理的事情，比如回邮件、看书等。</p>
<p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>标签为全部以下内容：通勤中</li>
<li>无以下内容：标签为任何以下内容：周一、周二、周三、周四、周五、周六、周日</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：整个项目</li>
<li>项目分组方式：未分组</li>
<li>项目排列方式：已标注</li>
</ul>
<h4 id="u8DDF_u8E2A"><a href="#u8DDF_u8E2A" class="headerlink" title="跟踪"></a>跟踪</h4><p>该透视能筛选出所有我需要跟踪处理的事情，比如我需要在两天后收到报告等。</p>
<p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>标签为全部以下内容：跟踪</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：整个项目</li>
<li>项目分组方式：未分组</li>
<li>项目排列方式：已标注</li>
</ul>
<h3 id="u4EFB_u52A1_u67E5_u770B_u900F_u89C6"><a href="#u4EFB_u52A1_u67E5_u770B_u900F_u89C6" class="headerlink" title="任务查看透视"></a>任务查看透视</h3><p>上面的透视其实都是我的任务池，只不过区分了不同的地点和精力状态，根据具体情况从这些任务池中挑选出任务，也就是规划工作的过程。那么任务挑选的问题就来了，如何挑选？如何处理任务算是已挑选？挑选出的任务去哪看？</p>
<h4 id="u5982_u4F55_u5904_u7406_u4EFB_u52A1_u7B97_u662F_u5DF2_u6311_u9009_uFF1F"><a href="#u5982_u4F55_u5904_u7406_u4EFB_u52A1_u7B97_u662F_u5DF2_u6311_u9009_uFF1F" class="headerlink" title="如何处理任务算是已挑选？"></a>如何处理任务算是已挑选？</h4><p>我先从挑选任务说起，我挑选任务有三步：</p>
<ul>
<li>给任务设置截至日期。</li>
<li>给任务设置对应周的标签。</li>
<li>编辑任务标题，注明需要几个番茄钟。</li>
</ul>
<p>给任务设置截至日期的范围一般是本周内，比如周一规划任务，那么给任务设置的最晚截至日期是周日，也就是说，如果某个任务的到期日超过了本周，那么在本周规划时，在<strong>设置截至日期这个维度</strong>我是不会关注的。</p>
<p>给任务设置对应周标签的方式是挑选我认为应该在本周内处理的任务，不考虑该任务的截至日期，不过有本周范围内截至日期的任务已经在上一步筛选完了，所以设置对应周标签的任务在要么没有截至日期，要么是截止日期超过本周的任务范围内。</p>
<p>OmniFocus中，任务有一个预估时长的属性，其实变相的代表了番茄钟的数量，但是查看很不直观。所以我就会在挑选完任务后，给这些任务的标题上注明番茄钟的数量，我一般会用“🍅”表示，有一个🍅就表示该任务需要一个番茄钟，以此类推。这种方式能让我在查看今日任务时能一目了然任务所需的番茄钟数量。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h4 id="u6311_u9009_u51FA_u7684_u4EFB_u52A1_u53BB_u54EA_u770B_uFF1F"><a href="#u6311_u9009_u51FA_u7684_u4EFB_u52A1_u53BB_u54EA_u770B_uFF1F" class="headerlink" title="挑选出的任务去哪看？"></a>挑选出的任务去哪看？</h4><p>一周的任务通过上面的方式规划好后，应该怎么查看呢？这时候还是用到透视。我创建了周一至周日七个透视，每天只关注当天的透视，里面筛选出的任务必定就是我规划好应该在这天干的任务。</p>
<h5 id="u5468_u4E00"><a href="#u5468_u4E00" class="headerlink" title="周一"></a>周一</h5><p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>无以下内容：标签为任何以下内容：周二、周三、周四、周五、周六、周日</li>
<li>任何以下内容：<ul>
<li>标签为全部以下内容：周一</li>
<li>状态：即将到期</li>
</ul>
</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：单独操作</li>
<li>项目分组方式：到期</li>
<li>项目排列方式：已标注</li>
</ul>
<h5 id="u5468_u4E8C"><a href="#u5468_u4E8C" class="headerlink" title="周二"></a>周二</h5><p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>无以下内容：标签为任何以下内容：周一、周三、周四、周五、周六、周日</li>
<li>任何以下内容：<ul>
<li>标签为全部以下内容：周二</li>
<li>状态：即将到期</li>
</ul>
</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：单独操作</li>
<li>项目分组方式：到期</li>
<li>项目排列方式：已标注</li>
</ul>
<h5 id="u5468_u4E09"><a href="#u5468_u4E09" class="headerlink" title="周三"></a>周三</h5><p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>无以下内容：标签为任何以下内容：周一、周二、周四、周五、周六、周日</li>
<li>任何以下内容：<ul>
<li>标签为全部以下内容：周三</li>
<li>状态：即将到期</li>
</ul>
</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：单独操作</li>
<li>项目分组方式：到期</li>
<li>项目排列方式：已标注</li>
</ul>
<h5 id="u5468_u56DB"><a href="#u5468_u56DB" class="headerlink" title="周四"></a>周四</h5><p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>无以下内容：标签为任何以下内容：周一、周二、周三、周五、周六、周日</li>
<li>任何以下内容：<ul>
<li>标签为全部以下内容：周四</li>
<li>状态：即将到期</li>
</ul>
</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：单独操作</li>
<li>项目分组方式：到期</li>
<li>项目排列方式：已标注</li>
</ul>
<h5 id="u5468_u4E94"><a href="#u5468_u4E94" class="headerlink" title="周五"></a>周五</h5><p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>无以下内容：标签为任何以下内容：周一、周二、周三、周四、周六、周日</li>
<li>任何以下内容：<ul>
<li>标签为全部以下内容：周五</li>
<li>状态：即将到期</li>
</ul>
</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：单独操作</li>
<li>项目分组方式：到期</li>
<li>项目排列方式：已标注</li>
</ul>
<h5 id="u5468_u516D"><a href="#u5468_u516D" class="headerlink" title="周六"></a>周六</h5><p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>无以下内容：标签为任何以下内容：周一、周二、周三、周四、周五、周日</li>
<li>任何以下内容：<ul>
<li>标签为全部以下内容：周六</li>
<li>状态：即将到期</li>
</ul>
</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：单独操作</li>
<li>项目分组方式：到期</li>
<li>项目排列方式：已标注</li>
</ul>
<h5 id="u5468_u65E5"><a href="#u5468_u65E5" class="headerlink" title="周日"></a>周日</h5><p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>无以下内容：标签为任何以下内容：周一、周二、周三、周四、周五、周六</li>
<li>任何以下内容：<ul>
<li>标签为全部以下内容：周日</li>
<li>状态：即将到期</li>
</ul>
</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：单独操作</li>
<li>项目分组方式：到期</li>
<li>项目排列方式：已标注</li>
</ul>
<h4 id="u661F_u671F_u900F_u89C6_u89E3_u8BFB"><a href="#u661F_u671F_u900F_u89C6_u89E3_u8BFB" class="headerlink" title="星期透视解读"></a>星期透视解读</h4><p>以上这七个透视筛选的任务表示了在一周里，每天需要做的事情。它会根据条件筛选以下两种任务：</p>
<ul>
<li>可用的，并且没有其他星期的标签，并且设置了当天星期的标签的任务。</li>
<li>可用的，并且没有其他星期的标签，并且在今天到期的任务。</li>
</ul>
<p>其实这两个筛选条件就是在前面小节挑选任务时，对任务做的操作。</p>
<p>另外在排序方面，不按项目分组，只安到期日分类，并且排序顺序安是否已标注排序。也就是说，我在处理今天的任务时，不是特别关心这个任务属于哪个项目，而是关注任务在今天的到期时间，并且如果是打了标注的，表名优先级最高，排在最前面。</p>
<h3 id="u5176_u4ED6_u900F_u89C6"><a href="#u5176_u4ED6_u900F_u89C6" class="headerlink" title="其他透视"></a>其他透视</h3><p>上面的透视是组成我任务系统的核心透视，还有几个其他的透视可以辅助我查看一些有共性的任务。</p>
<h4 id="u4ECA_u65E5"><a href="#u4ECA_u65E5" class="headerlink" title="今日"></a>今日</h4><p>这个透视主要是用于OmniFocus的通知小组件和Apple Watch的小组件使用的。该视图主要作用的是提示我今天有多少个即将到期的任务。</p>
<p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>任何以下内容：即将到期</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：整个项目</li>
<li>项目分组方式：未分组</li>
<li>项目排列方式：项目顺序</li>
</ul>
<h4 id="u4EEA_u5F0F"><a href="#u4EEA_u5F0F" class="headerlink" title="仪式"></a>仪式</h4><p>该视图主要显示哪些周期性重复执行的任务。</p>
<p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>标签为全部以下内容：仪式</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：整个项目</li>
<li>项目分组方式：未分组</li>
<li>项目排列方式：到期</li>
</ul>
<h4 id="u8D2D_u4E70_u6E05_u5355"><a href="#u8D2D_u4E70_u6E05_u5355" class="headerlink" title="购买清单"></a>购买清单</h4><p>该视图主要显示我的待购物品清单，不考虑什么时候买，但只要有想买的念头就会记下来，在这里显示。</p>
<p>筛选规则：</p>
<ul>
<li>可用性：可用</li>
<li>标签为任何以下内容：采购</li>
</ul>
<p>排列规则：</p>
<ul>
<li>群组和分类：整个项目</li>
<li>项目分组方式：未分组</li>
<li>项目排列方式：到期</li>
</ul>
<h2 id="u756A_u8304_u949F_u7CFB_u7EDF"><a href="#u756A_u8304_u949F_u7CFB_u7EDF" class="headerlink" title="番茄钟系统"></a>番茄钟系统</h2><p>番茄钟这个时间管理工具在这里不做解释。我选择番茄钟应用的原则是有较好的统计功能，能明确的看到一定范围内我的工作时间和番茄数，如果能跨多个平台当然更好，所以我最终选择了Flat Tomato这个番茄钟应用。该应用有iOS版、WatchOS版、MacOS版，在任何环境下我都可以快速的开始一个25分钟的番茄时间，并且它有比较好的统计系统。另外该应用还有一个亮点功能是自带一个轻量级的任务管理系统，也借鉴了一点GTD的概念，并且可以对每一个任务设置番茄钟数量预估，可以快速启动对应的项目的番茄钟，并且番茄时间、休息时间、再番茄时间是可以自动进行的，可以有效提供我们连续专注的效率。</p>
<p>因为OmniFocus没有集成任何番茄系统，而Flat Tomato也没有集成OF，所以我的番茄系统目前属于半外挂形式，也就是当要执行OF中的任务时，标题上标注的🍅数量只是一个参考作用，然后再单独启动Flat Tomato的番茄时间，每个番茄钟完成后还需要手动标注这个番茄钟做了什么事。</p>
<p>那么为什么说是半外挂呢？因为Flat Tomato集成了Todoist，它可以同步Todoist中的项目和任务，从而给每个任务设置番茄钟，所以我将Todoist作为一个任务中转站。将OmniFocus中的项目和任务同步到Todoist中，然后在Flat Tomato里就可以规划番茄数量了。这样每当我要执行OF中的任务时，我就可以直接在Flat Tomato中找到开始番茄钟。目前这种方式我只在做系统的任务分解时候才会用到。</p>
<h3 id="u4EFB_u52A1_u5206_u89E3"><a href="#u4EFB_u52A1_u5206_u89E3" class="headerlink" title="任务分解"></a>任务分解</h3><p>首先我做任务分解时并不在OmniFocus里做，而是在Day One中，其实或者任意iOS中的文本App就可以。其次将任务同步进Todoist中使用了它提供的REST API和<a href="https://support.omnigroup.com/omnifocus-taskpaper-reference/" target="_blank" rel="external">OmniFocus支持TaskPaper规范导入</a>的功能。因为目前OmniFocus 3的Mac版还没有发布，只发布了iOS版。所以我制作了一个<a href="https://workflow.is/workflows/13a29ed7370b4b09923e8bd6ccaa672f" target="_blank" rel="external">Workflow</a>，将我在Day One中规划的任务创建进OmniFocus，同时通过REST API同步进Todoist。</p>
<h2 id="u7EFC_u8FF0"><a href="#u7EFC_u8FF0" class="headerlink" title="综述"></a>综述</h2><p>以上就是我的任务系统的核心点。当然我还依然遵循GTD的方法，比如收集的概念，检查回顾等，这里就不再做解释了。希望大家能和我一起交流任务管理、时间管理的心得。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4115205380866695"
     data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="OmniFocus_u7684_u51E0_u4E2A_u4E3B_u8981_u6982_u5FF5"><a href="#OmniFocus_u7684_u51E0_u4E2A_u4E3B_u8981_u6982_u5FF5" class="headerlink" title="OmniFocus的几个主要概念"></a>OmniFocus的几个主要概念</h2><p>文章中所有的内容都是以OmniFocus 3为例。</p>
<ul>
<li>文件夹：OmniFocus中任务的组织结构最顶级一层，但只是用于分类，本身没有什么属性。</li>
<li>项目：顾名思义，用于定义我们生活和工作中大大小小的项目，项目本身也有属性设置，可设置标签、其内任务的关系（并行、串行、单个），截止日期等。项目下可包含多个任务。</li>
<li>任务：OmniFocus中承载事件的最小颗粒。因为OmniFocus支持任务无限嵌套，所以当多个任务在一个任务下时该任务就成为一个任务组。</li>
<li>任务组：任务组本身也是一个任务，但是它又是其他任务的父任务，所以任务组有子任务关系（并行、串行、单个）的设置。</li>
<li>标签：任务、项目身上都可以设置一到多个标签。标签可以嵌套，并且标签支持设置地理位置，并且有根据进入，走出两个行为和距离范围设置通知。</li>
<li>透视：根据各种条件筛选任务的视图。比如查看有标签“办公室”，即将截至的任务。条件可以按照包含任意、全部包含和不包含进行组合。然后还可以设置筛选出来任务的排列、分组方式。</li>
</ul>
<h2 id="u4EFB_u52A1_u7CFB_u7EDF"><a href="#u4EFB_u52A1_u7CFB_u7EDF" class="headerlink" title="任务系统"></a>任务系统</h2><p>我参照John Z. Sonmez的看板+番茄钟的系统，将其调整为OmniFocus+番茄钟的系统。</p>
<h3 id="u7CFB_u7EDF_u8BBE_u7F6E"><a href="#u7CFB_u7EDF_u8BBE_u7F6E" class="headerlink" title="系统设置"></a>系统设置</h3><ul>
<li>在截止日期这一项，将即将截止日期的表示设置为今天。</li>
<li>今天和Watch这一项，设置为自定义透视的<strong>今日</strong>（该透视下面会讲到）。</li>
</ul>
<h3 id="u6784_u5EFA_u7CFB_u7EDF_u7684_u4E3B_u8981_u6807_u7B7E"><a href="#u6784_u5EFA_u7CFB_u7EDF_u7684_u4E3B_u8981_u6807_u7B7E" class="headerlink" title="构建系统的主要标签"></a>构建系统的主要标签</h3><ul>
<li>仪式：周期性重复的任务会设置该标签。</li>
<li>地点：标明某个任务能在何种场所进行。<ul>
<li>办公室</li>
<li>家</li>
<li>通勤中</li>
</ul>
</li>
<li>状态：进行任务时需要投入的专注度。<ul>
<li>集中精力</li>
<li>放松</li>
</ul>
</li>
<li>跟踪：需要跟踪的任务会设置该标签，比如安排下去的任务需要在某个时间点知道完成的结果。</li>
<li>采购：需要购买东西的任务会设置该标签。</li>
<li>星期：规划一周任务时设置的标签。<ul>
<li>周一</li>
<li>周二</li>
<li>周三</li>
<li>周四</li>
<li>周五</li>
<li>周六</li>
<li>周日</li>
</ul>
</li>
<li>二分钟：能在很短时间内完成的任务会设置该标签。</li>
</ul>]]>
    
    </summary>
    
      <category term="任务管理" scheme="http://www.devtalking.com/tags/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    
      <category term="生产力" scheme="http://www.devtalking.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习笔记四之kNN算法、超参数、数据归一化]]></title>
    <link href="http://www.devtalking.com//articles/machine-learning-4/"/>
    <id>http://www.devtalking.com//articles/machine-learning-4/</id>
    <published>2018-01-26T16:00:00.000Z</published>
    <updated>2018-07-10T12:10:31.527Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>上一篇笔记主要介绍了NumPy，Matplotlib和Scikit Learn中Datasets三个库的用法，以及基于欧拉定理的kNN算法的基本实现。这一篇笔记的主要内容是通过PyCharm封装kNN算法并且在Jupyter Notebook中调用，以及计算器算法的封装规范，kNN的<code>k</code>值如何计算，如何使用Scikit Learn中的kNN算法，还有机器学习算法中的一些主要概念，比如训练数据集、测试数据集，分类准确度，超参数，数据归一化。另外会具体用代码实现第一篇笔记中介绍过的线性回归算法。</p>
<h2 id="u5C01_u88C5kNN_u7B97_u6CD5"><a href="#u5C01_u88C5kNN_u7B97_u6CD5" class="headerlink" title="封装kNN算法"></a>封装kNN算法</h2><p>上一篇笔记中我们对kNN算法在Jupyter Notebook中进行了实现，但是想要复用这个算法就很不方便，所以我们来看看如何在PyCharm中封装算法，并且在Jupyter Notebook中进行调用。</p>
<p>PyCharm的配置这里我就不再累赘，如图所示，我们创建了一个Python文件<code>kNN.py</code>，然后定义了<code>kNNClassify</code>方法，该方法有4个参数，分别是kNN算法的<code>k</code>值，训练样本特征数据集<code>XTrain</code>，训练样本类别数据集<code>yTrain</code>，预测特征数据集<code>x</code>。该方法中的实现和在Jupyter Notebook中实现的一模一样，只不过加了三个断言，让方法的健壮性更好一点。我们给出<strong>N维欧拉定理</strong>：</p>
<p>$$ \sqrt {\sum_{i=1}^n(x_i^{(a)}-x_i^{(b)})^2} $$</p>
<p><img src="http://paxigrdp0.bkt.clouddn.com/574075757e0d0a820e2a8a7ef37f79ec.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kNN.py</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kNNClassify</span><span class="params">(k, XTrain, yTrain, x)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">assert</span> <span class="number">1</span> &lt;= k &lt;= XTrain.shape[<span class="number">0</span>], <span class="string">"k 的取值范围不正确"</span></span><br><span class="line">	<span class="keyword">assert</span> XTrain.shape[<span class="number">0</span>] == yTrain.shape[<span class="number">0</span>], <span class="string">"训练样本数据行数应该与训练结果集行数相同"</span></span><br><span class="line">	<span class="keyword">assert</span> XTrain.shape[<span class="number">1</span>] == x.shape[<span class="number">0</span>], <span class="string">"训练样本数据特性个数应该与被预测数据特性个数相同"</span></span><br><span class="line"></span><br><span class="line">	distances = [sqrt(np.sum((xTrain - x) ** <span class="number">2</span>)) <span class="keyword">for</span> xTrain <span class="keyword">in</span> XTrain]</span><br><span class="line">	nearest = np.argsort(distances)</span><br><span class="line"></span><br><span class="line">	topKy = [yTrain[i] <span class="keyword">for</span> i <span class="keyword">in</span> nearest[:k]]</span><br><span class="line">	votes = Counter(topKy)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> votes.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>这样我们就在PyCharm中封装好了kNN算法的方法，我们再来看看如何在Jupyter Notebook中调用封装好的方法呢，这就需要使用<code>%run</code>这个命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">raw_data_X = [[<span class="number">3.393533211</span>, <span class="number">2.331273381</span>],</span><br><span class="line">			  [<span class="number">3.110073483</span>, <span class="number">1.781539638</span>],</span><br><span class="line">			  [<span class="number">1.343808831</span>, <span class="number">3.368360954</span>],</span><br><span class="line">			  [<span class="number">3.582294042</span>, <span class="number">4.679179110</span>],</span><br><span class="line">			  [<span class="number">2.280362439</span>, <span class="number">2.866990263</span>],</span><br><span class="line">			  [<span class="number">7.423436942</span>, <span class="number">4.696522875</span>],</span><br><span class="line">			  [<span class="number">5.745051997</span>, <span class="number">3.533989803</span>],</span><br><span class="line">			  [<span class="number">9.172168622</span>, <span class="number">2.511101045</span>],</span><br><span class="line">			  [<span class="number">7.792783481</span>, <span class="number">3.424088941</span>],</span><br><span class="line">			  [<span class="number">7.939820817</span>, <span class="number">0.791637231</span>]</span><br><span class="line">			 ]</span><br><span class="line">raw_data_y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">XTrain = np.array(raw_data_X)</span><br><span class="line">yTrain = np.array(raw_data_y)</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">8.093607318</span>, <span class="number">3.365731514</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用%run命令可以引入Python文件，并可使用该Python文件中定义的属性和方法</span></span><br><span class="line">%run ../pycharm/kNN.py</span><br><span class="line">predicty = kNNClassify(<span class="number">6</span>, XTrain, yTrain, x)</span><br><span class="line">predicty</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="u673A_u5668_u5B66_u4E60_u6D41_u7A0B"><a href="#u673A_u5668_u5B66_u4E60_u6D41_u7A0B" class="headerlink" title="机器学习流程"></a>机器学习流程</h2><p>这一小节我们来看看机器学习的大概流程是怎样的，如下图所示：<br><img src="http://paxigrdp0.bkt.clouddn.com/13a8bbc81eef52f649e82539248d29ad.jpg" alt=""></p>
<p>监督学习算法首先需要的是训练数据集，然后通过一个机器学习算法生成一个模型，最后就可以用这个模型来预测新的数据得到结果。通常，我们将使用机器学习生成模型的过程用fit来表示，使用模型预测新的数据的过程用predict来表示。这就是机器学习最基本的一个流程。</p>
<p>在第一篇笔记中，介绍了线性回归的概念，我们最后得到了一个二元线性回归的公式：$ F(a,b) = \sum_{i=1}^n(y_i-(ax_i + b))^2 $。这个公式其实就是通过线性回归算法得到的模型，通过fit过程，训练模型得到<code>a</code>，<code>b</code>，然后通过predict过程预测新的样例数据得到结果。</p>
<p>但是我们发现kNN算法不存在训练模型的过程，因为新的样例数据其实是需要通过训练数据集来进行预测的，所以换个角度来看，kNN算法的模型就是它的训练数据集，在上图中模型阶段其实就是把训练数据集复制了一份作为模型来使用，那么对于fit和predict过程而言，kNN算法的predict过程其实是核心，而fit过程非常简单。</p>
<h2 id="u4F7F_u7528Scikit_Learn_u4E2D_u7684kNN_u7B97_u6CD5"><a href="#u4F7F_u7528Scikit_Learn_u4E2D_u7684kNN_u7B97_u6CD5" class="headerlink" title="使用Scikit Learn中的kNN算法"></a>使用Scikit Learn中的kNN算法</h2><p>这一节我们来看看如何使用Scikit Learn中封装的kNN算法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入Scikit Learn中的kNN算法的类库</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="comment"># 初始化kNN算法分类器的实例，参数n_neighbors就是k值</span></span><br><span class="line">kNNClassifier = KNeighborsClassifier(n_neighbors=<span class="number">6</span>)</span><br><span class="line"><span class="comment"># 训练，拟合模型</span></span><br><span class="line">kNNClassifier.fit(XTrain, yTrain)</span><br><span class="line"><span class="comment"># 预测新的样例数据，该方法接受的参数类型为二维数组，如果只有一行也需要转换为一行的二维数组</span></span><br><span class="line">kNNClassifier.predict(x.reshape(<span class="number">1</span>, -<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>从示例代码中可以看出，Scikit Learn中封装的kNN算法严格遵从了上一节介绍的机器学习的基本流程，其实不止是kNN算法，Scikit Learn中的所有机器学习算法都遵从这个基本流程。</p>
<h2 id="u91CD_u65B0_u5C01_u88C5kNN_u7B97_u6CD5"><a href="#u91CD_u65B0_u5C01_u88C5kNN_u7B97_u6CD5" class="headerlink" title="重新封装kNN算法"></a>重新封装kNN算法</h2><p>所以我们可以优化一下我们之前封装的kNN算法的方法，将其封装为类似Scikit Learn中的方式：<br><img src="http://paxigrdp0.bkt.clouddn.com/ab2b99d15c26edf50171a5dbb8e8cecb.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KNNClassifier</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 初始化kNN分类器</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">		<span class="keyword">assert</span> k &gt;= <span class="number">1</span>, <span class="string">"k 值不能小于1"</span></span><br><span class="line"></span><br><span class="line">		self.k = k</span><br><span class="line">		self._XTrain = <span class="keyword">None</span></span><br><span class="line">		self._yTrain = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 根据训练数据集XTrain和yTrain训练kNN分类器，在kNN中这一步就是复制训练数据集</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, XTrain, yTrain)</span>:</span></span><br><span class="line">		<span class="keyword">assert</span> XTrain.shape[<span class="number">0</span>] == yTrain.shape[<span class="number">0</span>], \</span><br><span class="line">			<span class="string">"训练样本特征数据集的行数要与训练样本分类结果数据集的行数相同"</span></span><br><span class="line">		<span class="keyword">assert</span> XTrain.shape[<span class="number">0</span>] &gt;= self.k, \</span><br><span class="line">			<span class="string">"训练样本特征数据集的行数，既样本点的数量要大于等于k值"</span></span><br><span class="line"></span><br><span class="line">		self._XTrain = XTrain</span><br><span class="line">		self._yTrain = yTrain</span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 输入样本数据，根据模型进行预测</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, XPredict)</span>:</span></span><br><span class="line">		<span class="keyword">assert</span> self._XTrain <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> self._yTrain <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>, \</span><br><span class="line">			<span class="string">"在执行predict方法前必须先执行fit方法"</span></span><br><span class="line">		<span class="keyword">assert</span> XPredict.shape[<span class="number">1</span>] == self._XTrain.shape[<span class="number">1</span>], \</span><br><span class="line">			<span class="string">"被预测数据集的特征数，既列数必须与模型数据集中的特征数相同"</span></span><br><span class="line"></span><br><span class="line">		ypredict = [self._predict(x) <span class="keyword">for</span> x <span class="keyword">in</span> XPredict]</span><br><span class="line">		<span class="keyword">return</span> np.array(ypredict)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 实现私有的预测方法，kNN算法的核心代码</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_predict</span><span class="params">(self, x)</span>:</span></span><br><span class="line">		<span class="keyword">assert</span> x.shape[<span class="number">0</span>] == self._XTrain.shape[<span class="number">1</span>], \</span><br><span class="line">			<span class="string">"输入的样本数据的特征数量必须等于模型数据，既训练样本数据的特征数量"</span></span><br><span class="line"></span><br><span class="line">		distance = [sqrt(np.sum((xTrain - x) ** <span class="number">2</span>)) <span class="keyword">for</span> xTrain <span class="keyword">in</span> self._XTrain]</span><br><span class="line">		nearest = np.argsort(distance)</span><br><span class="line">		topK = [self._yTrain[i] <span class="keyword">for</span> i <span class="keyword">in</span> nearest[:self.k]]</span><br><span class="line">		votes = Counter(topK)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> votes.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"kNN(k=%d)"</span> % self.k</span><br></pre></td></tr></table></figure>
<p>上面的代码清晰的定义了<code>fit</code>和<code>predict</code>方法，至于<code>_predict</code>这个私有方法可以随意，可以将逻辑直接写在<code>predict</code>方法里，也可以拆分出来。然后我们在Jupyter Notebook中再来使用一下我们封装的kNN算法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%run ../pycharm/kNN/kNN.py</span><br><span class="line">myKNNClassifier = KNNClassifier(<span class="number">6</span>)</span><br><span class="line">myKNNClassifier.fit(XTrain, yTrain)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">kNN(k=<span class="number">6</span>)</span><br><span class="line">xTrain = x.reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">myKNNClassifier.predict(xTrain)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="u5224_u65AD_u673A_u5668_u5B66_u4E60_u7B97_u6CD5_u7684_u6027_u80FD"><a href="#u5224_u65AD_u673A_u5668_u5B66_u4E60_u7B97_u6CD5_u7684_u6027_u80FD" class="headerlink" title="判断机器学习算法的性能"></a>判断机器学习算法的性能</h2><p>现在大家应该知道机器算法的目的主要是训练出模型，然后输入样本，通过模型来预测结果，可见这个模型是非常关键的，模型的好坏直接影响预测结果的准确性，继而对实际运用会产生巨大的影响。模型的训练除了机器学习算法以外，对它影响比较大的还有训练样本数据，我们在实现kNN算法时，是将所有的样本数据用于训练模型，那么模型训练出来后就已经没有数据供我们验证模型的好坏了，只能直接投入真实环境使用，这样的风险是很大的。</p>
<p>所以为了避免上述这种情况，最简单的做法是将所有训练样本数据进行切分，将大部分数据用于训练模型，而另外一小部分数据用来测试训练出的模型，这样如果我们用测试数据发现这个模型不够好，那么我们就有机会在将模型投入真实环境使用之前改进算法，训练出更好的模型。</p>
<p>我们来看看如何封装拆分训练数据的方法：<br><img src="http://paxigrdp0.bkt.clouddn.com/30144371e3f3e8726b2f83c5cef76564.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练样本数据 X 和 y 按照 test_radio 分割成 X_train, y_train, X_test, y_test</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_test_split</span><span class="params">(X, y, test_radio = <span class="number">0.2</span>, seed = None)</span>:</span></span><br><span class="line">	<span class="keyword">assert</span> X.shape[<span class="number">0</span>] == y.shape[<span class="number">0</span>], \</span><br><span class="line">		<span class="string">"训练样本特征数据集的行数要与训练样本分类结果数据集的行数相同"</span></span><br><span class="line">	<span class="keyword">assert</span> <span class="number">0.0</span> &lt;= test_radio &lt;= <span class="number">1.0</span>, \</span><br><span class="line">		<span class="string">"test_radio 的值必须在 0 到 1 之间"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 如果 seed 有值，将其设置进numpy的随机函数中</span></span><br><span class="line">	<span class="keyword">if</span> seed:</span><br><span class="line">		np.random.seed(seed)</span><br><span class="line"></span><br><span class="line">	shuffled_indexes = np.random.permutation(len(X))</span><br><span class="line">	test_size = int(len(X) * test_radio)</span><br><span class="line">	test_indexes = shuffled_indexes[:test_size]</span><br><span class="line">	train_indexes = shuffled_indexes[test_size:]</span><br><span class="line"></span><br><span class="line">	X_train = X[train_indexes]</span><br><span class="line">	y_train = y[train_indexes]</span><br><span class="line"></span><br><span class="line">	X_test = X[test_indexes]</span><br><span class="line">	y_test = y[test_indexes]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> X_train, y_train, X_test, y_test</span><br></pre></td></tr></table></figure>
<p>我们来解读一下上面的代码：</p>
<ul>
<li>首先<code>train_test_split</code>函数有四个参数，两个必填参数，两个非必填有默认值的参数。<code>X</code>是训练样本特征数据集，<code>y</code>是训练样本分类结果数据集，<code>test_radio</code>是设置训练数据和测试数据的比例，<code>seed</code>就很好理解了，就是NumPy的随机函数提供的随机种子机制。</li>
<li>上面代码中有一个方法大家之前应该没见过，那就是<code>permutation(x)</code>，该方法表示返回一个乱序的一维向量，元素从0到x，所以<code>shuffled_indexes</code>是一个乱序的一维向量数组，它的元素总数为训练样本数据的总数，既训练样本数据矩阵的行数，元素的范围从0到训练样本数据的总数。</li>
<li>根据<code>test_radio</code>计算出需要分割出的测试数据数量<code>test_size</code>。</li>
<li>根据<code>test_size</code>从<code>shuffled_indexes</code>中取出<code>test_indexes</code>和<code>train_indexes</code>，这两个数组中存的元素就是作为索引来用的。</li>
<li>根据<code>test_indexes</code>和<code>train_indexes</code>从<code>X</code>和<code>y</code>中得到<code>X_train</code>、<code>y_train</code>、<code>X_test</code>、<code>y_test</code>。</li>
</ul>
<p>之前在Jupyter Notebook中我们使用<code>%run</code>命令使用我们封装的代码 ，这一节我们来看看如何使用<code>import</code>的方式使用我们自己封装的代码。其实这和Jupyter Notebook没多大关系，我们需要做的只是给Python设置一个搜索包的路径而已，这里这会对MacOS，以及安装了Anaconda的环境作以说明，Windows系统大同小异。</p>
<p>首先找到路径<code>/anaconda3/lib/python3.6/site-packages</code>，在该路径下创建一个文件<code>XXX.pth</code>，该文件的扩展名必须为<code>pth</code>，文件名称可以随意。然后在该文件中输入你希望Python搜索包的绝对路径即可。</p>
<p>设置完搜索路径后，我们需要修改一下PyCharm中的目录结构：<br><img src="http://paxigrdp0.bkt.clouddn.com/42bf4dc0e2e8cf0d11afd17037d16b59.jpg" alt=""></p>
<p>我新建了一个目录名为<code>myML</code>，<code>kNN.py</code>是我们之前封装的kNN算法相关的方法，<code>modelSelection.py</code>里就是我们刚才封装好的拆分训练和测试数据的方法，另外还增加了一个<code>__init__.py</code>的文件，因为有了这个文件，<code>myML</code>就变为了一个包。<code>__init__.py</code>的作用这里不做过多解释。</p>
<p>这样我们就可以在Jupyter Notebook中用<code>import</code>的方式导入我们封装的模块了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> myML.modelSelection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, y_train, X_test, y_test = train_test_split(X, y)</span><br><span class="line">X_train.shape</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="number">120</span>, <span class="number">4</span>)</span><br><span class="line">y_train.shape</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="number">120</span>,)</span><br><span class="line">X_test.shape</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="number">30</span>, <span class="number">4</span>)</span><br><span class="line">y_test.shape</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="number">30</span>,)</span><br></pre></td></tr></table></figure>
<p>这样就可以很方便的使用我们封装的模块了，下面我们来看看怎么判断我们封装的kNN算法的好坏程度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先用训练数据训练模型，然后输入测试样本特征数据，得到预测结果</span></span><br><span class="line"><span class="keyword">from</span> myML.kNN <span class="keyword">import</span> KNNClassifier</span><br><span class="line">my_knn_classifier = KNNClassifier(<span class="number">6</span>)</span><br><span class="line">my_knn_classifier.fit(X_train, y_train)</span><br><span class="line">my_y_test = my_knn_classifier.predict(X_test)</span><br><span class="line">my_y_test</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">	   <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># 用预测出的结果和测试样本分类结果数据做对比，得出准确率</span></span><br><span class="line">y_test</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">	   <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">	   </span><br><span class="line">sum(my_y_test == y_test) / len(y_test)</span><br><span class="line"><span class="comment"># 结果，准确率为96.67%</span></span><br><span class="line"><span class="number">0.96666666666666667</span></span><br></pre></td></tr></table></figure>
<p>这样我们就得出了一个算法的好坏程度。</p>
<h2 id="u8D85_u53C2_u6570"><a href="#u8D85_u53C2_u6570" class="headerlink" title="超参数"></a>超参数</h2><p>目前我们在使用kNN算法时，<code>k</code>的值都是我们给定的值，这个作为算法的参数值称为超参数，也就是在运行机器学习算法之前需要指定的参数。还有一类参数称为模型参数，既在算法过程中学习的参数，但是大家已经知道kNN算法实际是没有模型的，所以也不存在模型参数，但是<code>k</code>值是一个典型的超参数。</p>
<h3 id="u5BFB_u627E_u6700_u597D_u7684k_u503C"><a href="#u5BFB_u627E_u6700_u597D_u7684k_u503C" class="headerlink" title="寻找最好的k值"></a>寻找最好的k值</h3><p>Scikit Learn中kNN算法的<code>k</code>值默认是5，有时候这个值并不是最优的值，那么我们可以通过一个简单的方式来寻找到最优的<code>k</code>值，那就是给定一个<code>k</code>值的范围，然后循环传入算法求训练分数最好的那个<code>k</code>值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先我们使用scikit learn中的手写数字数据集，并将其拆分为训练数据集和测试数据集</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">digits = datasets.load_digits()</span><br><span class="line">X = digits.data</span><br><span class="line">y = digits.target</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">666</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后通过循环的方式寻找最好的k值</span></span><br><span class="line">best_score = <span class="number">0.0</span></span><br><span class="line">best_k = -<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">	knn_clf = KNeighborsClassifier(n_neighbors = k)</span><br><span class="line">	knn_clf.fit(X_train, y_train)</span><br><span class="line">	score = knn_clf.score(X_test, y_test)</span><br><span class="line">	<span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">		best_k = k</span><br><span class="line">		best_score = score</span><br><span class="line">		</span><br><span class="line">print(<span class="string">"best_k = "</span>, best_k)</span><br><span class="line">print(<span class="string">"best_score = "</span>, best_score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">best_k =  <span class="number">4</span></span><br><span class="line">best_score =  <span class="number">0.991666666667</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码示例中可以看到，在1到10这个范围的<code>k</code>值中，4是训练分数最高的<code>k</code>值。不过这里需要注意的是，如果求出<code>k</code>为10，那么我们需要再扩大范围进行寻找，因为有可能10并不是最优的<code>k</code>值，只因为我们给定的范围最大到10，所以这种情况下，我们需要根据实际情况对8至20的<code>k</code>值范围再进行计算，如果结果仍然为10，那么才认定10为最优<code>k</code>值。</p>
<h3 id="u8DDD_u79BB_u7684_u6743_u91CD"><a href="#u8DDD_u79BB_u7684_u6743_u91CD" class="headerlink" title="距离的权重"></a>距离的权重</h3><p><img src="http://paxigrdp0.bkt.clouddn.com/b29f73d52a86bfcc04a919471f6e730f.jpg" alt=""></p>
<p>上面这张图如果用之前我们了解过的kNN算法来分析的话，绿色的点肯定是属于蓝色点分类的，但是我们之前都一直忽略了一个问题，<strong>那就是当找到<code>k</code>个相邻的点后，在投票时是没有再考虑未知分类点与相邻点之间的距离的</strong>。就比如上图，如果考虑了3个最近相邻点与绿色点之间的距离的话，那么绿色点的分类就会属于红色点的分类，因为在计算距离权重时是取距离的倒数，所以绿色点与红色点的距离权重为1，绿色点与两个蓝色点的距离权重为1/3 + 1/4 = 7/12。</p>
<p><img src="http://paxigrdp0.bkt.clouddn.com/53a1c3214fa97bb5c905e80898cbad63.jpg" alt=""></p>
<p>上图的情况如果不考虑距离权重的话，就会出现平票的情况，那么只能随机在三个分类中选一个作为绿色点的分类，如果加上距离权重，就能确定得出绿色点的分类了。</p>
<p>所以与相邻点的距离权重是kNN算法的另一个重要的超参数，大家可以看一下Scikit Learn的<a href="http://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html" target="_blank" rel="external">kNN</a>官网，<code>KNeighborsClassifier</code>的构造函数中有一个参数<code>weights</code>，这就是距离权重参数，默认值为<code>uniform</code>，既不考虑距离权重，如果要考虑距离权重的话，需要设置值为<code>distance</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">knn_clf = KNeighborsClassifier(n_neighbors = <span class="number">4</span>, weights = <span class="string">'distance'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="u8DDD_u79BB_u7684_u7C7B_u578B"><a href="#u8DDD_u79BB_u7684_u7C7B_u578B" class="headerlink" title="距离的类型"></a>距离的类型</h3><p>到目前为止，我们自己封装的kNN算法使用的距离公式是欧拉距离，其实还有其他的距离公式，比如<strong>曼哈顿距离</strong>:</p>
<p>$$\sum_{i=1}^n |X_i^{(a)}-X_i^{(b)}|$$</p>
<p>其实曼哈顿距离和欧拉距离在数学公式表现形式上是有一定相似性的，我们可以将欧拉距离做以转换：</p>
<p>$$ \sqrt {\sum_{i=1}^n(x_i^{(a)}-x<em>i^{(b)})^2} = \sqrt {\sum</em>{i=1}^n|x_i^{(a)}-x<em>i^{(b)}|^2} = (\sum</em>{i=1}^n|x_i^{(a)}-x_i^{(b)}|^2)^\frac 1 2 $$ </p>
<p>对曼哈顿距离也做以转换：</p>
<p>$$ \sum_{i=1}^n |X_i^{(a)}-X<em>i^{(b)}| = （\sum</em>{i=1}^n |X_i^{(a)}-X_i^{(b)}|^1）^\frac 1 1 $$</p>
<p>通过上面两个公式可以得到一个共性的公式：</p>
<p>$$ （\sum_{i=1}^n |X_i^{(a)}-X_i^{(b)}|^p）^\frac 1 p $$</p>
<p>这个公式就称之为<strong>明可夫斯基距离（Minkowski Distance）</strong>。</p>
<p>既当<code>p</code>为1时为曼哈顿距离，当<code>p</code>为2时为欧拉距离，当<code>p</code>大于2时表示其他距离，所以<code>p</code>又是一个kNN算法的超参数，在<code>KNeighborsClassifier</code>的构造函数中同样有一个参数<code>p</code>就是表示使用的距离类型，默认为2，既默认为欧拉距离。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">best_score = <span class="number">0.0</span></span><br><span class="line">best_k = -<span class="number">1</span></span><br><span class="line">best_p = -<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">	<span class="keyword">for</span> p <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">		knn_clf = KNeighborsClassifier(n_neighbors = k, weights = <span class="string">"distance"</span>, p = p)</span><br><span class="line">		knn_clf.fit(X_train, y_train)</span><br><span class="line">		score = knn_clf.score(X_test, y_test)</span><br><span class="line">		<span class="keyword">if</span> score &gt; best_score:</span><br><span class="line">			best_k = k</span><br><span class="line">			best_score = score</span><br><span class="line">			best_p = p</span><br><span class="line"></span><br><span class="line">print(<span class="string">"best_p = "</span>, best_p)            </span><br><span class="line">print(<span class="string">"best_k = "</span>, best_k)</span><br><span class="line">print(<span class="string">"best_score = "</span>, best_score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">best_p =  <span class="number">2</span></span><br><span class="line">best_k =  <span class="number">3</span></span><br><span class="line">best_score =  <span class="number">0.988888888889</span></span><br></pre></td></tr></table></figure>
<p>从上面代码运行的结果来看，最优的<code>p</code>值为2，也就是欧拉距离，考虑了距离权重后，最优<code>k</code>值为3。而且一些超参数是组合使用的，比如当使用超参数<code>p</code>时，距离权重的超参数<code>weights</code>的取值就必须是<code>distance</code>。并且<code>k</code>和<code>p</code>这两个超参数双重嵌套循环，就组成了一个类似网格的搜索方式，所幸Scikit Learn提供了封装好的网格搜索的方法供我们使用。</p>
<h2 id="u7F51_u683C_u641C_u7D22_u8D85_u53C2_u6570"><a href="#u7F51_u683C_u641C_u7D22_u8D85_u53C2_u6570" class="headerlink" title="网格搜索超参数"></a>网格搜索超参数</h2><p>在使用网格搜索前，我们需要先将各种超参数的组合定义出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">param_grid = [</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">'weights'</span>: [<span class="string">'uniform'</span>],</span><br><span class="line">		<span class="string">'n_neighbors'</span>: [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)]</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">'weights'</span>: [<span class="string">'distance'</span>],</span><br><span class="line">		<span class="string">'n_neighbors'</span>: [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)],</span><br><span class="line">		<span class="string">'p'</span>: [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>)]</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>我们定义了一个<code>param_grid</code>数组，元素为字典，每个字典描述了一种超参数的组合，下面我们使用Scikit Learn提供的<code>GridSearchCV</code>来使用我们定义好的超参数组合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">knn_clf = KNeighborsClassifier()</span><br><span class="line">grid_search = GridSearchCV(knn_clf, param_grid)</span><br><span class="line">grid_search.fit(X_train, y_train)</span><br><span class="line">new_knn_clf = grid_search.best_estimator_</span><br><span class="line">new_knn_clf</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">KNeighborsClassifier(algorithm=<span class="string">'auto'</span>, leaf_size=<span class="number">30</span>, metric=<span class="string">'minkowski'</span>,</span><br><span class="line">		   metric_params=<span class="keyword">None</span>, n_jobs=<span class="number">1</span>, n_neighbors=<span class="number">3</span>, p=<span class="number">3</span>,</span><br><span class="line">		   weights=<span class="string">'distance'</span>)</span><br></pre></td></tr></table></figure>
<p>上面的示例代码不难理解，我们使用构建出的kNN分类器<code>knn_clf</code>和超参数组合<code>param_grid</code>构造出了网格搜索对象<code>grid_search</code>，通过它进行<code>fit</code>操作，这个过程就是根据我们提供的超参数组合进行搜寻，找到最优的超参数组合。通过<code>best_estimator_</code>返回新的，已经设置了最优超参数组合的kNN分类器对象。从输出结果其实已经可以看到首先是选择了考虑距离权重的超参数组合，然后求出了<code>k</code>值，也就是<code>n_neighbors</code>为3，<code>p</code>值为3。</p>
<p><code>GridSearchCV</code>也提供了几个属性，可以让我们方便的查看超参数和模型评分：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">grid_search.best_params_</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">&#123;<span class="string">'n_neighbors'</span>: <span class="number">3</span>, <span class="string">'p'</span>: <span class="number">3</span>, <span class="string">'weights'</span>: <span class="string">'distance'</span>&#125;</span><br><span class="line"></span><br><span class="line">grid_search.best_score_</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0.98538622129436326</span></span><br></pre></td></tr></table></figure>
<h3 id="GridSearchCV_u7684_u5176_u4ED6_u53C2_u6570"><a href="#GridSearchCV_u7684_u5176_u4ED6_u53C2_u6570" class="headerlink" title="GridSearchCV的其他参数"></a>GridSearchCV的其他参数</h3><p>在构造<code>GridSearchCV</code>对象时除了kNN分类器和超参数组合外，还有几个比较有用的参数：</p>
<ul>
<li><code>n_jobs</code>：该参数决定了在进行网格搜索时使用当前计算机的CPU核数，1就是使用1个核，2就是使用2个核，如果设置为-1，那么代表使用所有的核进行搜索。</li>
<li><code>verbose</code>：该参数决定了在网格搜索时的日志输出级别。</li>
</ul>
<h2 id="u6570_u636E_u5F52_u4E00_u5316"><a href="#u6570_u636E_u5F52_u4E00_u5316" class="headerlink" title="数据归一化"></a>数据归一化</h2><p><img src="http://paxigrdp0.bkt.clouddn.com/43b6730765831fcc1dbecb24069ed177.jpg" alt=""></p>
<p>大家先看看上面表格中的样本数据，两个样本的肿瘤大小相差有5倍，从医学角度来讲这个差距已经是非常大了，但从实际数值差距来讲并不是很大。再看看发现时间，两个样本之间相差100天，在数值上的差距远远大于肿瘤大小的差距。所以如果使用kNN算法，用欧拉距离计算的话，两个样本发现时间之差远远大于肿瘤大小之差，所以就会主导样本间的距离，这个显然是有问题的，对预测的结果是有偏差的。</p>
<p>所以我们就需要对样本数据进行数据归一化，将所有的数据映射到同一尺度。比较简便的方式就是<strong>最值归一化</strong>，既用下面的公式把所有数据映射到0-1之间：</p>
<p>$$ x<em>{scale} = \frac {x - x</em>{min}} {x<em>{max} - x</em>{min}} $$</p>
<p>最值归一化虽然简便，但是是有一定适用范围的，那就是适用于样本数据有明显分布边界的情况，比如学生的考试分数，从0到100分，或者像素值，从0到255等。假如像人的月收入这种没有边界的样本数据集，就不能使用最值归一化了，此时就需要用到另外一个数据归一化的方法<strong>均值方差归一化</strong>，该方法就是把所有数据归一到均值为0方差为1的分布中，公式如下：</p>
<p>$$ x<em>{scale} = \frac {x - x</em>{mean}} S $$</p>
<p>就是将每个值减去均值，然后除以方差，通过均值方差归一化后的数据不一定在0-1之间，但是他们的均值为0，方差为1。</p>
<p>下面我们来分别实现一下这两个数据归一化方法。先来看看最值归一化的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 生成从0到100，一共100个元素的数组</span></span><br><span class="line">x = np.random.randint(<span class="number">0</span>, <span class="number">100</span>, size = <span class="number">100</span>)</span><br><span class="line"><span class="comment"># 变更数组元素的类型</span></span><br><span class="line">x = np.array(x, dtype = float)</span><br><span class="line">x_scale = (x - np.min(x)) / (np.max(x) - np.min(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成50行，2列的矩阵，元素在0到100之间</span></span><br><span class="line">X = np.random.randint(<span class="number">0</span>, <span class="number">100</span>, (<span class="number">50</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 对每一列数据进行最值归一化</span></span><br><span class="line">X[:, <span class="number">0</span>] = (X[:, <span class="number">0</span>] - np.min(X[:, <span class="number">0</span>])) / (np.max(X[:, <span class="number">0</span>]) - np.min(X[:, <span class="number">0</span>]))</span><br><span class="line">X[:, <span class="number">1</span>] = (X[:, <span class="number">1</span>] - np.min(X[:, <span class="number">1</span>])) / (np.max(X[:, <span class="number">1</span>]) - np.min(X[:, <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用matplotlib将X展示出来</span></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/96cc0403babcacae118a05b14b5d9730.jpg" alt=""></p>
<p>可以看到最值归一化后数据都在0到1之间。我们再来看看均值方差归一化的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X2 = np.random.randint(<span class="number">0</span>, <span class="number">100</span>, (<span class="number">50</span>, <span class="number">2</span>))</span><br><span class="line">X2 = np.array(X2, dtype = float)</span><br><span class="line">X2[:, <span class="number">0</span>] = (X2[:, <span class="number">0</span>] - np.mean(X2[:, <span class="number">0</span>])) / np.std(X2[:, <span class="number">0</span>])</span><br><span class="line">X2[:, <span class="number">1</span>] = (X2[:, <span class="number">1</span>] - np.mean(X2[:, <span class="number">1</span>])) / np.std(X2[:, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值接近0</span></span><br><span class="line">np.mean(X2[:, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">6.2172489379008772e-17</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方差接近1</span></span><br><span class="line">np.std(X2[:, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0.99999999999999989</span></span><br><span class="line"></span><br><span class="line">plt.scatter(X2[:, <span class="number">0</span>], X2[:, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/f4dbe1f0c876372c0263013bd3e27043.jpg" alt=""></p>
<h2 id="u5982_u4F55_u5BF9_u6D4B_u8BD5_u6570_u636E_u96C6_u8FDB_u884C_u5F52_u4E00_u5316"><a href="#u5982_u4F55_u5BF9_u6D4B_u8BD5_u6570_u636E_u96C6_u8FDB_u884C_u5F52_u4E00_u5316" class="headerlink" title="如何对测试数据集进行归一化"></a>如何对测试数据集进行归一化</h2><p>之前我们说过会对样本数据进行拆分，拆分为训练数据和测试数据，对于训练数据我们可以直接使用最值归一化或均值方法归一化，但是对测试数据我们就不能直接使用归一化的方法了，因为测试数据其实充当了真实环境中需要预测的数据，很多时候需要预测的数据只有一组，这时候我们是没办法对一组数据进行归一化的，因为无法得到均值和方差，所以我们需要结合归一化后训练数据归一化测试数据：<code>(x_test - mean_train) / std_train</code>。那么我们就需要保存训练数据归一化后的数据，此时我们就可以用到Scikit Learn提供的数据归一化的对象<code>Scalar</code>。</p>
<p><img src="http://paxigrdp0.bkt.clouddn.com/c962c7f93465af5cff9be84f884c97fd.jpg" alt=""></p>
<p><code>Scalar</code>的使用流程和机器学习算法的使用流程很像，输入训练数据集，进行<code>fit</code>操作，这里的<code>fit</code>操作就不是训练模型了，而是进行数据归一化处理，然后是<code>transform</code>，既对需要预测的数据进行归一化。我们来看看如何使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用鸢尾花数据集</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割出训练数据集和测试数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">666</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入StandardScaler，也就是均值方差归一化的对象</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">standardScaler = StandardScaler()</span><br><span class="line">standardScaler.fit(X_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将特征训练数据集和特征测试数据集进行归一化处理</span></span><br><span class="line">X_train_standard = standardScaler.transform(X_train)</span><br><span class="line">X_test_standard = standardScaler.transform(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用kNN</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">knn_clf = KNeighborsClassifier(n_neighbors = <span class="number">3</span>)</span><br><span class="line">knn_clf.fit(X_train_standard, y_train)</span><br><span class="line">knn_clf.score(X_test_standard, y_test)</span><br></pre></td></tr></table></figure>
<h2 id="u5C01_u88C5_u81EA_u5DF1_u7684_u6570_u636E_u5F52_u4E00_u5316_u65B9_u6CD5"><a href="#u5C01_u88C5_u81EA_u5DF1_u7684_u6570_u636E_u5F52_u4E00_u5316_u65B9_u6CD5" class="headerlink" title="封装自己的数据归一化方法"></a>封装自己的数据归一化方法</h2><p><img src="http://paxigrdp0.bkt.clouddn.com/a446676198ff1ff737c340099f48c7cb.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardScaler</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.mean_ = <span class="keyword">None</span></span><br><span class="line">		self.scaler_ = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 获取训练数据集的平均值和方差</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X)</span>:</span></span><br><span class="line">		<span class="keyword">assert</span> X.ndim == <span class="number">2</span>, <span class="string">"X 的维度必须为2，既X是一个矩阵"</span></span><br><span class="line"></span><br><span class="line">		self.mean_ = np.array([np.mean(X[:, i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(X.shape[<span class="number">1</span>])])</span><br><span class="line">		self.scaler_ = np.array([np.std(X[:, i]) <span class="keyword">for</span> i <span class="keyword">in</span> range(X.shape[<span class="number">1</span>])])</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 进行均值方差归一化处理</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self, X)</span>:</span></span><br><span class="line">		<span class="keyword">assert</span> X.ndim == <span class="number">2</span>, <span class="string">"X 的维度必须为2，既X是一个矩阵"</span></span><br><span class="line">		<span class="keyword">assert</span> self.mean_ <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> self.scaler_ <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>, <span class="string">"均值和方差不能为空"</span></span><br><span class="line">		<span class="keyword">assert</span> X.shape[<span class="number">1</span>] == len(self.mean_), <span class="string">"训练数据集矩阵的列数必须等于均值数组的元素个数"</span></span><br><span class="line">		<span class="keyword">assert</span> X.shape[<span class="number">1</span>] == len(self.scaler_), <span class="string">"训练数据集矩阵的列数必须等于方差数组的元素个数"</span></span><br><span class="line"></span><br><span class="line">		X_transform = np.empty(shape=X.shape, dtype=float)</span><br><span class="line">		<span class="keyword">for</span> col <span class="keyword">in</span> range(X.shape[<span class="number">1</span>]):</span><br><span class="line">			X_transform[:, col] = (X[:, col] - self.mean_[col]) / self.scaler_[col]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> X_transform</span><br></pre></td></tr></table></figure>
<p>这样我们就封装好了自己的均值方差归一化的方法，另外，Scikit Learn也提供了最值归一化的对象<code>MinMaxScaler</code>，使用流程都是一样的，大家也可是试试看。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这一篇笔记主要介绍了kNN算法实现逻辑以外的概念，但也是机器学习中非常重要的一些概念，以后也会经常看到它们的身影。通过两篇笔记的介绍，我们知道kNN算法是一个解决多分类问题的算法，而且算法实现相对比较简单，但效果很强大。下一篇我们来实现第一篇笔记中介绍过的线性回归法。</p>
<blockquote>
<p>申明：本文为慕课网<a href="https://www.imooc.com/t/108955" target="_blank" rel="external">liuyubobobo</a>老师<a href="https://coding.imooc.com/learn/list/169.html" target="_blank" rel="external">《Python3入门机器学习 经典算法与应用》</a>课程的学习笔记，未经允许不得转载。</p>
</blockquote>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4115205380866695"
     data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>上一篇笔记主要介绍了NumPy，Matplotlib和Scikit Learn中Datasets三个库的用法，以及基于欧拉定理的kNN算法的基本实现。这一篇笔记的主要内容是通过PyCharm封装kNN算法并且在Jupyter Notebook中调用，以及计算器算法的封装规范，kNN的<code>k</code>值如何计算，如何使用Scikit Learn中的kNN算法，还有机器学习算法中的一些主要概念，比如训练数据集、测试数据集，分类准确度，超参数，数据归一化。另外会具体用代码实现第一篇笔记中介绍过的线性回归算法。</p>
<h2 id="u5C01_u88C5kNN_u7B97_u6CD5"><a href="#u5C01_u88C5kNN_u7B97_u6CD5" class="headerlink" title="封装kNN算法"></a>封装kNN算法</h2><p>上一篇笔记中我们对kNN算法在Jupyter Notebook中进行了实现，但是想要复用这个算法就很不方便，所以我们来看看如何在PyCharm中封装算法，并且在Jupyter Notebook中进行调用。</p>
<p>PyCharm的配置这里我就不再累赘，如图所示，我们创建了一个Python文件<code>kNN.py</code>，然后定义了<code>kNNClassify</code>方法，该方法有4个参数，分别是kNN算法的<code>k</code>值，训练样本特征数据集<code>XTrain</code>，训练样本类别数据集<code>yTrain</code>，预测特征数据集<code>x</code>。该方法中的实现和在Jupyter Notebook中实现的一模一样，只不过加了三个断言，让方法的健壮性更好一点。我们给出<strong>N维欧拉定理</strong>：</p>
<p>$$ \sqrt {\sum_{i=1}^n(x_i^{(a)}-x_i^{(b)})^2} $$</p>
<p><img src="http://paxigrdp0.bkt.clouddn.com/574075757e0d0a820e2a8a7ef37f79ec.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kNN.py</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kNNClassify</span><span class="params">(k, XTrain, yTrain, x)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">assert</span> <span class="number">1</span> &lt;= k &lt;= XTrain.shape[<span class="number">0</span>], <span class="string">"k 的取值范围不正确"</span></span><br><span class="line">	<span class="keyword">assert</span> XTrain.shape[<span class="number">0</span>] == yTrain.shape[<span class="number">0</span>], <span class="string">"训练样本数据行数应该与训练结果集行数相同"</span></span><br><span class="line">	<span class="keyword">assert</span> XTrain.shape[<span class="number">1</span>] == x.shape[<span class="number">0</span>], <span class="string">"训练样本数据特性个数应该与被预测数据特性个数相同"</span></span><br><span class="line"></span><br><span class="line">	distances = [sqrt(np.sum((xTrain - x) ** <span class="number">2</span>)) <span class="keyword">for</span> xTrain <span class="keyword">in</span> XTrain]</span><br><span class="line">	nearest = np.argsort(distances)</span><br><span class="line"></span><br><span class="line">	topKy = [yTrain[i] <span class="keyword">for</span> i <span class="keyword">in</span> nearest[:k]]</span><br><span class="line">	votes = Counter(topKy)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> votes.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>这样我们就在PyCharm中封装好了kNN算法的方法，我们再来看看如何在Jupyter Notebook中调用封装好的方法呢，这就需要使用<code>%run</code>这个命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">raw_data_X = [[<span class="number">3.393533211</span>, <span class="number">2.331273381</span>],</span><br><span class="line">			  [<span class="number">3.110073483</span>, <span class="number">1.781539638</span>],</span><br><span class="line">			  [<span class="number">1.343808831</span>, <span class="number">3.368360954</span>],</span><br><span class="line">			  [<span class="number">3.582294042</span>, <span class="number">4.679179110</span>],</span><br><span class="line">			  [<span class="number">2.280362439</span>, <span class="number">2.866990263</span>],</span><br><span class="line">			  [<span class="number">7.423436942</span>, <span class="number">4.696522875</span>],</span><br><span class="line">			  [<span class="number">5.745051997</span>, <span class="number">3.533989803</span>],</span><br><span class="line">			  [<span class="number">9.172168622</span>, <span class="number">2.511101045</span>],</span><br><span class="line">			  [<span class="number">7.792783481</span>, <span class="number">3.424088941</span>],</span><br><span class="line">			  [<span class="number">7.939820817</span>, <span class="number">0.791637231</span>]</span><br><span class="line">			 ]</span><br><span class="line">raw_data_y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">XTrain = np.array(raw_data_X)</span><br><span class="line">yTrain = np.array(raw_data_y)</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">8.093607318</span>, <span class="number">3.365731514</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用%run命令可以引入Python文件，并可使用该Python文件中定义的属性和方法</span></span><br><span class="line">%run ../pycharm/kNN.py</span><br><span class="line">predicty = kNNClassify(<span class="number">6</span>, XTrain, yTrain, x)</span><br><span class="line">predicty</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="机器学习" scheme="http://www.devtalking.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习笔记三之NumPy、Matplotlib、kNN算法]]></title>
    <link href="http://www.devtalking.com//articles/machine-learning-3/"/>
    <id>http://www.devtalking.com//articles/machine-learning-3/</id>
    <published>2018-01-19T16:00:00.000Z</published>
    <updated>2018-07-10T12:04:15.550Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><p>NumPy是Python中的一个类库，它支持高阶维度数组（矩阵）的创建及各种操作、运算，是我们在机器学习中经常会使用的一个类库。这一节再看一些NumPy的矩阵用法。</p>
<h3 id="numpy-random"><a href="#numpy-random" class="headerlink" title="numpy.random"></a>numpy.random</h3><p>NumPy也提供了生成随机数和随机元素数组的方法，我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成从0到10之间的随机数</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成元素从0到10，一共4个随机元素的数组</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成元素随机从0到10，3行5列的矩阵</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>],</span><br><span class="line">	   [<span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">	   [<span class="number">4</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>如果我们希望每次使用随机方法生成的结果都是一样的，一般调试时候有这个需求，此时NumPy的<code>random()</code>方法也提供了方便简单的方式，既随机种子的概念：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成随机矩阵前给定一个种子</span></span><br><span class="line">np.random.seed(<span class="number">123</span>)</span><br><span class="line"><span class="comment"># 然后生成随机矩阵</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 再次生成随机矩阵时，只要传入相同的种子，就可以得到相同结果的矩阵</span></span><br><span class="line">np.random.seed(<span class="number">123</span>)</span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 默认范围是从0.0到1.0，返回值为float型</span></span><br><span class="line">np.random.random()</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0.18249173045349998</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入的参数是数组的大小</span></span><br><span class="line">np.random.random(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">0.17545176</span>,  <span class="number">0.53155137</span>,  <span class="number">0.53182759</span>,  <span class="number">0.63440096</span>,  <span class="number">0.84943179</span>,</span><br><span class="line">		<span class="number">0.72445532</span>,  <span class="number">0.61102351</span>,  <span class="number">0.72244338</span>,  <span class="number">0.32295891</span>,  <span class="number">0.36178866</span>])</span><br><span class="line">		</span><br><span class="line"><span class="comment"># 创建4行5列，元素值的范围从0.0到1.0的矩阵</span></span><br><span class="line">np.random.random((<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0.22826323</span>,  <span class="number">0.29371405</span>,  <span class="number">0.63097612</span>,  <span class="number">0.09210494</span>,  <span class="number">0.43370117</span>],</span><br><span class="line">	   [ <span class="number">0.43086276</span>,  <span class="number">0.4936851</span> ,  <span class="number">0.42583029</span>,  <span class="number">0.31226122</span>,  <span class="number">0.42635131</span>],</span><br><span class="line">	   [ <span class="number">0.89338916</span>,  <span class="number">0.94416002</span>,  <span class="number">0.50183668</span>,  <span class="number">0.62395295</span>,  <span class="number">0.1156184</span> ],</span><br><span class="line">	   [ <span class="number">0.31728548</span>,  <span class="number">0.41482621</span>,  <span class="number">0.86630916</span>,  <span class="number">0.25045537</span>,  <span class="number">0.48303426</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="u6307_u5B9A_u5747_u503C_u548C_u6807_u51C6_u5DEE_u751F_u6210_u968F_u673A_u6570_u6570_u7EC4_u6216_u77E9_u9635"><a href="#u6307_u5B9A_u5747_u503C_u548C_u6807_u51C6_u5DEE_u751F_u6210_u968F_u673A_u6570_u6570_u7EC4_u6216_u77E9_u9635" class="headerlink" title="指定均值和标准差生成随机数数组或矩阵"></a>指定均值和标准差生成随机数数组或矩阵</h3><p>我们先来看看均值、方差、标准差的概念。均值很好理解，就是所有样本数据的平均值，描述了样本集合的中间点：</p>
<p>$$ \overline X=\frac{\sum_{i=1}^nX_i}n $$</p>
<p>方差是衡量样本点和样本期望值相差的度量值：</p>
<p>$$ S^2 = \frac{\sum_{i=1}^n(X_i-\overline X)^2} n $$</p>
<p>标准差描述的是样本集合的各个样本点到均值的距离之平均：</p>
<p>$$ S = \sqrt {\frac{\sum_{i=1}^n(X_i-\overline X)^2} n } $$</p>
<p>标准差也就是对方差开根号。举个例子，<code>[0, 8, 12, 20]</code>和<code>[8, 9, 11, 12]</code>，两个集合的均值都是10，但显然两个集合的差别是很大的，计算两者的标准差，前者是8.3后者是1.8，显然后者较为集中，标准差描述的就是这种散布度或者叫做波动大小。综上，方差的意义在于描述随机变量稳定与波动、集中与分散的状况。标准差则体现随机变量取值与其期望值的偏差。</p>
<a id="more"></a>
<p>NumPy也提供了指定均值和标准差生成随机数的方法，我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个参数是均值，第二个参数是标准差</span></span><br><span class="line">np.random.normal(<span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">53.781947121910044</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建均值为10，方差为100的3行5列矩阵</span></span><br><span class="line">np.random.normal(<span class="number">10</span>, <span class="number">100</span>, size=(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">124.10915759</span>,   <span class="number">27.14517732</span>, -<span class="number">144.95788359</span>,  -<span class="number">87.40234817</span>,</span><br><span class="line">		 -<span class="number">94.91106048</span>],</span><br><span class="line">	   [ -<span class="number">36.4834381</span> ,  -<span class="number">39.05598871</span>,  <span class="number">110.07456975</span>,  <span class="number">224.85141913</span>,</span><br><span class="line">		 <span class="number">153.24092557</span>],</span><br><span class="line">	   [  -<span class="number">3.33533336</span>,   <span class="number">10.57740526</span>,  -<span class="number">56.76208107</span>,  -<span class="number">84.06189149</span>,</span><br><span class="line">		 <span class="number">103.08098119</span>]])</span><br><span class="line">		 </span><br><span class="line"><span class="comment"># 创建一个正态分布的3行5列矩阵，既均值为0，标准差为1</span></span><br><span class="line">np.random.normal(<span class="number">0</span>, <span class="number">1</span>, size=(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[-<span class="number">0.94574322</span>,  <span class="number">2.0742057</span> ,  <span class="number">0.34477911</span>,  <span class="number">0.1375712</span> ,  <span class="number">0.45385364</span>],</span><br><span class="line">	   [-<span class="number">2.07928914</span>,  <span class="number">1.26474497</span>,  <span class="number">1.56236822</span>, -<span class="number">1.0032234</span> , -<span class="number">0.14807477</span>],</span><br><span class="line">	   [ <span class="number">0.01992922</span>,  <span class="number">0.3924738</span> , -<span class="number">0.11268871</span>,  <span class="number">2.04509319</span>,  <span class="number">0.01095378</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="u67E5_u770B_u6570_u7EC4_u7EF4_u5EA6"><a href="#u67E5_u770B_u6570_u7EC4_u7EF4_u5EA6" class="headerlink" title="查看数组维度"></a>查看数组维度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成10个元素的一维数组和3行5列的矩阵</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">X = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">x</span><br><span class="line">X</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">	   [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">	   [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 查看x的维度</span></span><br><span class="line">x.ndim</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看X的维度</span></span><br><span class="line">X.ndim</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数组每个维度的具体信息</span></span><br><span class="line">x.shape</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="number">10</span>,)</span><br><span class="line"></span><br><span class="line">X.shape</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="numpy-array_u7684_u6570_u636E_u8BBF_u95EE"><a href="#numpy-array_u7684_u6570_u636E_u8BBF_u95EE" class="headerlink" title="numpy.array的数据访问"></a>numpy.array的数据访问</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一维数组访问第1个元素</span></span><br><span class="line">x[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一维数组访问最后一个元素</span></span><br><span class="line">x[-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组访问第3行，第4列的元素</span></span><br><span class="line">X[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure>
<h3 id="u5207_u7247"><a href="#u5207_u7247" class="headerlink" title="切片"></a>切片</h3><p>Python中，有一个获取数组片段非常方便的方法，叫做切片，<code>numpy.array</code>中同样支持切片，我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取x数组中从第1个元素到第5个元素的片段</span></span><br><span class="line">x[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果冒号前不指定位置，那么默认从第一个元素开始</span></span><br><span class="line">x[:<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果冒号后面不指定位置，那么默认取到最后一个元素</span></span><br><span class="line">x[<span class="number">3</span>:]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片也支持步长</span></span><br><span class="line">x[<span class="number">0</span>:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">x[::<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取X矩阵的前2行，前3列</span></span><br><span class="line">X[:<span class="number">2</span>, :<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">	   [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 对于每个维度都可以指定步长</span></span><br><span class="line">X[:<span class="number">2</span>, ::<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">	   [<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>
<p>一般将高维矩阵降为低维矩阵其实也是使用切片来处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取X矩阵所有行的第一列</span></span><br><span class="line">X[:, <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">5</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure>
<p>另外需要注意的是通过切片获取NumPy的数组或者矩阵的子数组，子矩阵是通过引用方式的，而Python中的数组通过切片获取的子数组是拷贝方式的。NumPy主要是考虑到性能效率问题。我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取X矩阵的前2行，前3列作为子矩阵</span></span><br><span class="line">subX = X[:<span class="number">2</span>, :<span class="number">3</span>]</span><br><span class="line">subX</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">	   [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 给subX矩阵的第1行，第1列的元素赋值</span></span><br><span class="line">subX[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">subX</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">100</span>,   <span class="number">1</span>,   <span class="number">2</span>],</span><br><span class="line">	   [  <span class="number">5</span>,   <span class="number">6</span>,   <span class="number">7</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 再看看X矩阵</span></span><br><span class="line">X</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">100</span>,   <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">3</span>,   <span class="number">4</span>],</span><br><span class="line">	   [  <span class="number">5</span>,   <span class="number">6</span>,   <span class="number">7</span>,   <span class="number">8</span>,   <span class="number">9</span>],</span><br><span class="line">	   [ <span class="number">10</span>,  <span class="number">11</span>,  <span class="number">12</span>,  <span class="number">13</span>,  <span class="number">14</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 复制子矩阵</span></span><br><span class="line">subX1 = X[:<span class="number">2</span>, :<span class="number">3</span>].copy()</span><br><span class="line">subX1</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">100</span>,   <span class="number">1</span>,   <span class="number">2</span>],</span><br><span class="line">	   [  <span class="number">5</span>,   <span class="number">6</span>,   <span class="number">7</span>]])</span><br><span class="line">	   </span><br><span class="line">subX1[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">subX1</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">	   [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line">	   </span><br><span class="line">X</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">100</span>,   <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">3</span>,   <span class="number">4</span>],</span><br><span class="line">	   [  <span class="number">5</span>,   <span class="number">6</span>,   <span class="number">7</span>,   <span class="number">8</span>,   <span class="number">9</span>],</span><br><span class="line">	   [ <span class="number">10</span>,  <span class="number">11</span>,  <span class="number">12</span>,  <span class="number">13</span>,  <span class="number">14</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="u6539_u53D8_u6570_u7EC4_u7EF4_u5EA6"><a href="#u6539_u53D8_u6570_u7EC4_u7EF4_u5EA6" class="headerlink" title="改变数组维度"></a>改变数组维度</h3><p>NumPy也提供了修改数组维度的方法，我们来看看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># x是一个一维数组</span></span><br><span class="line">x</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将x改为二维数组，既2行5列的矩阵</span></span><br><span class="line">x.reshape(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">x</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">	   [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 如果想让NumPy自动计算某个维度的数，比如我只想将x转换为只有2列的矩阵，有多少行交给NumPy处理</span></span><br><span class="line">x.reshape(-<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">	   [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">	   [<span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">	   [<span class="number">8</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="u6570_u7EC4_u5408_u5E76_u64CD_u4F5C"><a href="#u6570_u7EC4_u5408_u5E76_u64CD_u4F5C" class="headerlink" title="数组合并操作"></a>数组合并操作</h3><p>NumPy也提供两个数组合并的操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">5</span>)</span><br><span class="line">x</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">y = np.arange(<span class="number">5</span>)</span><br><span class="line">y</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将x，y这两个一维数组合并</span></span><br><span class="line">np.concatenate([x, y])</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">z = np.array([<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>])</span><br><span class="line">z</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将x，y，z三个一维数组合并</span></span><br><span class="line">np.concatenate([x, y, z])</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>
<p>多维数组也支持合并：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2行3列的矩阵</span></span><br><span class="line">V = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">V</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">	   [<span class="number">8</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 将两个V矩阵合并</span></span><br><span class="line">np.concatenate([V, V])</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">	   [<span class="number">8</span>, <span class="number">0</span>, <span class="number">2</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">	   [<span class="number">8</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 合并多维数组时，可以设置按照哪个维度合并，axis参数为0时按照行合并，axis参数为1时按照列合并，默认axis为0</span></span><br><span class="line">np.concatenate([V, V], axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">	   [<span class="number">8</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>上面的示例都是同维度的数组进行合并，那么不同维度的数组如何合并呢，我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># z为一个一维数组</span></span><br><span class="line">z = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">z</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># V为一个2行3列的矩阵</span></span><br><span class="line">V</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">	   [<span class="number">8</span>, <span class="number">0</span>, <span class="number">2</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 直接将V和z合并会抛异常</span></span><br><span class="line">np.concatenate([V, z])</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">ValueError: all the input arrays must have same number of dimensions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在合并时将一维数组z转变为二维数组</span></span><br><span class="line">np.concatenate([V, z.reshape(<span class="number">1</span>, -<span class="number">1</span>)])</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span>],</span><br><span class="line">	   [<span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>],</span><br><span class="line">	   [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br></pre></td></tr></table></figure>
<p>其实NumPy提供了更智能的不同维度数组合并的方法，我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按垂直方向合并</span></span><br><span class="line">np.vstack([V, z])</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">8</span>, <span class="number">2</span>, <span class="number">9</span>],</span><br><span class="line">	   [<span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>],</span><br><span class="line">	   [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 创建一个2行2列的矩阵</span></span><br><span class="line">V1 = np.full((<span class="number">2</span>, <span class="number">2</span>), <span class="number">10</span>)</span><br><span class="line">V1</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">10</span>, <span class="number">10</span>],</span><br><span class="line">	   [<span class="number">10</span>, <span class="number">10</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按水平方向合并</span></span><br><span class="line">np.hstack([V, V1])</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">8</span>,  <span class="number">2</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>],</span><br><span class="line">	   [ <span class="number">7</span>,  <span class="number">3</span>,  <span class="number">8</span>, <span class="number">10</span>, <span class="number">10</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="u6570_u7EC4_u5206_u5272_u64CD_u4F5C"><a href="#u6570_u7EC4_u5206_u5272_u64CD_u4F5C" class="headerlink" title="数组分割操作"></a>数组分割操作</h3><p>有合并自然就会有分割，我们来看看NumPy提供的分割方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">x</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对x进行分割，然后传入分割点，如下有两个分割点，所以将会把x分割为3个数组</span></span><br><span class="line">x1, x2, x3 = np.split(x, [<span class="number">3</span>, <span class="number">7</span>])</span><br><span class="line">x1</span><br><span class="line">x2</span><br><span class="line">x3</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">array([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">array([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于多维数组也是一样</span></span><br><span class="line">X = np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">X</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">	   [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">	   [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">	   [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 传入一个分割点，既将X矩阵分割为两个矩阵</span></span><br><span class="line">X1, X2 = np.split(X, [<span class="number">2</span>])</span><br><span class="line">X1</span><br><span class="line">X2</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line">array([[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">	   [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 分割多维数组同样可以设定按照哪个维度分割，axis默认为0，既按行分割</span></span><br><span class="line"><span class="comment"># axis为1时按列分割</span></span><br><span class="line">X3, X4 = np.split(X, [<span class="number">2</span>], axis=<span class="number">1</span>)</span><br><span class="line">X3</span><br><span class="line">X4</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>],</span><br><span class="line">	   [ <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">	   [ <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">	   [<span class="number">12</span>, <span class="number">13</span>]])</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">	   [ <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">	   [<span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">	   [<span class="number">14</span>, <span class="number">15</span>]])</span><br></pre></td></tr></table></figure>
<p>和合并一样，分割也有更快接的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按垂直方向分割，既按行分割</span></span><br><span class="line">X5, X6 = np.vsplit(X, [<span class="number">2</span>])</span><br><span class="line">X5</span><br><span class="line">X6</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br><span class="line">array([[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">	   [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 按水平方向分割，既按列分割</span></span><br><span class="line">X7, X8 = np.hsplit(X, [<span class="number">2</span>])</span><br><span class="line">X7</span><br><span class="line">X8</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>],</span><br><span class="line">	   [ <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">	   [ <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">	   [<span class="number">12</span>, <span class="number">13</span>]])</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">	   [ <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">	   [<span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">	   [<span class="number">14</span>, <span class="number">15</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="u77E9_u9635_u8FD0_u7B97"><a href="#u77E9_u9635_u8FD0_u7B97" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><p>NumPy中提供了完整的矩阵的运算，我们从加减法来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># A为一个2行5列的矩阵</span></span><br><span class="line">A = np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">A</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">	   [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># B也是一个2行5列的矩阵</span></span><br><span class="line">B = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">2</span>, <span class="number">5</span>))</span><br><span class="line">B</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 矩阵加常数</span></span><br><span class="line">A + <span class="number">1</span></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">	   [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵减常数</span></span><br><span class="line">A - <span class="number">1</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[-<span class="number">1</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">	   [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 矩阵加矩阵</span></span><br><span class="line">A + B</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">9</span>,  <span class="number">5</span>,  <span class="number">8</span>, <span class="number">11</span>],</span><br><span class="line">	   [<span class="number">14</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 矩阵减矩阵</span></span><br><span class="line">A - B</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[-<span class="number">4</span>, -<span class="number">7</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>],</span><br><span class="line">	   [-<span class="number">4</span>,  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>]])</span><br></pre></td></tr></table></figure>
<p>下面我们再来看看数乘：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 矩阵乘常数</span></span><br><span class="line"><span class="number">2</span>*A</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">2</span>,  <span class="number">4</span>,  <span class="number">6</span>,  <span class="number">8</span>],</span><br><span class="line">	   [<span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># C为5行3列的矩阵</span></span><br><span class="line">C = np.arange(<span class="number">15</span>).reshape(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">C</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">	   [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">	   [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">	   [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">	   [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 矩阵乘矩阵，真正的矩阵相乘</span></span><br><span class="line">A.dot(C)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">90</span>, <span class="number">100</span>, <span class="number">110</span>],</span><br><span class="line">	   [<span class="number">240</span>, <span class="number">275</span>, <span class="number">310</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 矩阵中每个对应元素相乘</span></span><br><span class="line">A*B</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">8</span>,  <span class="number">6</span>, <span class="number">15</span>, <span class="number">28</span>],</span><br><span class="line">	   [<span class="number">45</span>, <span class="number">36</span>, <span class="number">42</span>, <span class="number">48</span>, <span class="number">54</span>]])</span><br></pre></td></tr></table></figure>
<p>我们再来看看矩阵的转置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A.T</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">5</span>],</span><br><span class="line">	   [<span class="number">1</span>, <span class="number">6</span>],</span><br><span class="line">	   [<span class="number">2</span>, <span class="number">7</span>],</span><br><span class="line">	   [<span class="number">3</span>, <span class="number">8</span>],</span><br><span class="line">	   [<span class="number">4</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="u805A_u5408_u64CD_u4F5C"><a href="#u805A_u5408_u64CD_u4F5C" class="headerlink" title="聚合操作"></a>聚合操作</h3><p>NumPy中有很多对数组的聚合操作方法，我们先来看看一维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机取10个元素的 一维数组</span></span><br><span class="line">D = np.random.random(<span class="number">10</span>)</span><br><span class="line">D</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">0.70908471</span>,  <span class="number">0.29268356</span>,  <span class="number">0.69885019</span>,  <span class="number">0.28796429</span>,  <span class="number">0.04189265</span>,</span><br><span class="line">		<span class="number">0.36932107</span>,  <span class="number">0.0641322</span> ,  <span class="number">0.63989077</span>,  <span class="number">0.02753356</span>,  <span class="number">0.0605743</span> ])</span><br><span class="line">	 </span><br><span class="line"><span class="comment"># 求每个元素的和        </span></span><br><span class="line">np.sum(D)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">3.1919272951030706</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求元素的最小值</span></span><br><span class="line">np.min(D)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0.027533561561906672</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求元素最大值</span></span><br><span class="line">np.max(D)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0.70908470606410545</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求元素的均值</span></span><br><span class="line">np.mean(D)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0.31919272951030708</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求元素的标准差</span></span><br><span class="line">np.std(D)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0.26402525382852743</span></span><br></pre></td></tr></table></figure>
<p>我们再来看看矩阵的聚合操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># X为2行3列的矩阵</span></span><br><span class="line">X = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">X</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">	   [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 矩阵中所有元素的和       </span></span><br><span class="line">np.sum(X)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵中所有元素的乘积</span></span><br><span class="line">np.prod(X)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line">np.prod(X + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">720</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵元素的均值</span></span><br><span class="line">np.mean(X)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">2.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵元素的中位数，median可有效避免元素中出现极值，从而导致均值不准的问题</span></span><br><span class="line">np.median(X)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">2.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵元素的方差</span></span><br><span class="line">np.var(X)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">2.9166666666666665</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.std(X)</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">1.707825127659933</span></span><br></pre></td></tr></table></figure>
<h3 id="u7D22_u5F15_u548C_u6392_u5E8F_u7684_u76F8_u5173_u64CD_u4F5C"><a href="#u7D22_u5F15_u548C_u6392_u5E8F_u7684_u76F8_u5173_u64CD_u4F5C" class="headerlink" title="索引和排序的相关操作"></a>索引和排序的相关操作</h3><p>NumPy提供了一系列对数组索引操作的方法，我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 随机一维数组</span></span><br><span class="line">x = np.random.random(<span class="number">10</span>)</span><br><span class="line">x</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">0.17035458</span>,  <span class="number">0.8968506</span> ,  <span class="number">0.01007584</span>,  <span class="number">0.45925501</span>,  <span class="number">0.6838149</span> ,</span><br><span class="line">		<span class="number">0.32393039</span>,  <span class="number">0.53746647</span>,  <span class="number">0.68561243</span>,  <span class="number">0.66195346</span>,  <span class="number">0.32696068</span>])</span><br><span class="line">		</span><br><span class="line"><span class="comment"># x中元素最小值</span></span><br><span class="line">np.min(x)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0.010075835471876626</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x中最小值元素所在的索引位置</span></span><br><span class="line">np.argmin(x)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>我们再来看看排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对x进行排序</span></span><br><span class="line">np.sort(x)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">0.01007584</span>,  <span class="number">0.17035458</span>,  <span class="number">0.32393039</span>,  <span class="number">0.32696068</span>,  <span class="number">0.45925501</span>,</span><br><span class="line">		<span class="number">0.53746647</span>,  <span class="number">0.66195346</span>,  <span class="number">0.6838149</span> ,  <span class="number">0.68561243</span>,  <span class="number">0.8968506</span> ])</span><br><span class="line">		</span><br><span class="line"><span class="comment"># 获取排序后的索引，返回的数组中的元素是索引</span></span><br><span class="line">np.argsort(x)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对矩阵排序</span></span><br><span class="line">X1 = np.random.randint(<span class="number">0</span>, <span class="number">15</span>, size=(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">X1</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">8</span>,  <span class="number">1</span>,  <span class="number">8</span>, <span class="number">12</span>,  <span class="number">4</span>],</span><br><span class="line">	   [ <span class="number">8</span>,  <span class="number">6</span>,  <span class="number">6</span>,  <span class="number">6</span>, <span class="number">13</span>],</span><br><span class="line">	   [<span class="number">13</span>,  <span class="number">2</span>,  <span class="number">5</span>, <span class="number">11</span>,  <span class="number">4</span>]])</span><br><span class="line">	   </span><br><span class="line">np.sort(X1)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">4</span>,  <span class="number">8</span>,  <span class="number">8</span>, <span class="number">12</span>],</span><br><span class="line">	   [ <span class="number">6</span>,  <span class="number">6</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">13</span>],</span><br><span class="line">	   [ <span class="number">2</span>,  <span class="number">4</span>,  <span class="number">5</span>, <span class="number">11</span>, <span class="number">13</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 获取排序后的索引</span></span><br><span class="line">np.argsort(X1)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line">	   [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="NumPy_u7684Fancy_Indexing"><a href="#NumPy_u7684Fancy_Indexing" class="headerlink" title="NumPy的Fancy Indexing"></a>NumPy的Fancy Indexing</h3><p>一般情况下我们访问NumPy数组的数据，可以使用索引，甚至可以用步长来取：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.arange(<span class="number">16</span>)</span><br><span class="line">x</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取从0到6范围内，步长为2的元素</span></span><br><span class="line">x[<span class="number">0</span>:<span class="number">6</span>:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>但是有时候我们需要取数组中没有什么规律的元素，比如元素之间步长不等的，这就需要用到NumPy提供的Fancy Indexing机制来获取了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将我们需要访问的索引生产一个数组，然后将索引数组传入x数组</span></span><br><span class="line">ind = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line">x[ind]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵也是同样的，先生成索引矩阵</span></span><br><span class="line">ind1 = np.array([[<span class="number">0</span>, <span class="number">1</span>], </span><br><span class="line">				[<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">x[ind1]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">	   [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 将x转换为4行4列的矩阵X</span></span><br><span class="line">X = x.reshape(<span class="number">4</span>, -<span class="number">1</span>)</span><br><span class="line">X</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">	   [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">	   [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">	   [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成希望查询的行和列的索引矩阵，然后传入矩阵X</span></span><br><span class="line">row = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">col = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">X[row, col]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">1</span>,  <span class="number">6</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者指定前两行</span></span><br><span class="line">X[:<span class="number">2</span>, col]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]])</span><br></pre></td></tr></table></figure>
<p>除了使用指定索引以外，我们还可以使用布尔数组或者矩阵来使用Fancy Indexing，我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">	   [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">	   [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">	   [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个布尔数组，True表示感兴趣的索引，False表示不感兴趣的索引</span></span><br><span class="line">col = [<span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">True</span>]</span><br><span class="line"><span class="comment"># 然后传入矩阵X，比如我们要获取前三行，第1列，第3列，第4列的元素</span></span><br><span class="line">X[<span class="number">1</span>:<span class="number">3</span>, col]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">	   [ <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">	   </span><br><span class="line">x</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># x数组中的元素小于2的有几个</span></span><br><span class="line">np.sum(x &lt; <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x数组中的元素大于3小于10的有几个</span></span><br><span class="line">np.sum((x &gt; <span class="number">3</span>) &amp; (x &lt; <span class="number">10</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断x数组中的所有元素是否满足一个条件，若有一个满足返回True，若都不满足返回False</span></span><br><span class="line">np.any(x == <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">np.any(x &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断x数组中的所有元素是否满足一个条件，若有所有元素都满足返回True，若有一个元素不满足返回False</span></span><br><span class="line">np.all(X &gt; <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">np.all(X &gt;= <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取x数组中元素小于5的是哪几个元素</span></span><br><span class="line">x[x &lt; <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取x数组中元素是偶数的是哪几个元素</span></span><br><span class="line">x[x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">2</span>,  <span class="number">4</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>])</span><br><span class="line"></span><br><span class="line">X</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">	   [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">	   [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">	   [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br><span class="line">	   </span><br><span class="line">X[:, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">3</span>,  <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>])</span><br><span class="line"></span><br><span class="line">X[:, <span class="number">3</span>] % <span class="number">3</span> == <span class="number">0</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">False</span>,  <span class="keyword">True</span>], dtype=bool)</span><br><span class="line"></span><br><span class="line">X[X[:, <span class="number">3</span>] % <span class="number">3</span> == <span class="number">0</span>, :]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>在Python中，除了有NumPy这种对数组操作的类库，还有一个类一个在机器学习中使用比较广泛的类库是Matplotlib，这是一个绘制二维图像的类库，我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先导入matplotlib的类库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数组x，元素从0到10，一共100个元素</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line"><span class="comment"># 对x数组求sin，获得siny</span></span><br><span class="line">siny = np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用matplotlib将x数组和y数组中的元素绘制出来</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/27546352e3ae5661ec64447e1d79c987.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以同时绘制两条线</span></span><br><span class="line">cosy = np.cos(x)</span><br><span class="line">plt.plot(x, siny)</span><br><span class="line">plt.plot(x, cosy)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/2339610f3ab865f00c07ef4cbfbf38d8.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以指定某条线的颜色</span></span><br><span class="line">plt.plot(x, siny)</span><br><span class="line">plt.plot(x, cosy, color=<span class="string">"red"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/abda87e7c2568b71197b6444ab11cc18.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以指定线的样式</span></span><br><span class="line">plt.plot(x, siny)</span><br><span class="line">plt.plot(x, cosy, color=<span class="string">"red"</span>, linestyle=<span class="string">"--"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/66dcd44d1f15a884b3a95646db3171f6.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以指定x轴，y轴的区间</span></span><br><span class="line">plt.plot(x, siny)</span><br><span class="line">plt.plot(x, cosy, color=<span class="string">"red"</span>, linestyle=<span class="string">"--"</span>)</span><br><span class="line">plt.xlim(-<span class="number">5</span>, <span class="number">15</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">1.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/d2b019bfa3a5ce4f6a7513f644a53554.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 另一种指定x轴，y轴区间的方法</span></span><br><span class="line">plt.plot(x, siny)</span><br><span class="line">plt.plot(x, cosy, color=<span class="string">"red"</span>, linestyle=<span class="string">"--"</span>)</span><br><span class="line">plt.axis([-<span class="number">1</span>, <span class="number">11</span>, -<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/120a7176de45b5e6a0a4ec3ea2b3be64.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给x轴和y轴加说明</span></span><br><span class="line">plt.plot(x, siny)</span><br><span class="line">plt.plot(x, cosy, color=<span class="string">"red"</span>, linestyle=<span class="string">"--"</span>)</span><br><span class="line">plt.axis([-<span class="number">1</span>, <span class="number">11</span>, -<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">plt.xlabel(<span class="string">"x axis"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"y value"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/a8d6391854497052d4b1314fff71b1bf.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加图例</span></span><br><span class="line">plt.plot(x, siny, label=<span class="string">"sin(x)"</span>)</span><br><span class="line">plt.plot(x, cosy, color=<span class="string">"red"</span>, linestyle=<span class="string">"--"</span>, label=<span class="string">"cos(x)"</span>)</span><br><span class="line">plt.axis([-<span class="number">1</span>, <span class="number">11</span>, -<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">plt.xlabel(<span class="string">"x axis"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"y value"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/3a58abde79b6a6b05f124fccfd50bb5d.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加标题</span></span><br><span class="line">plt.plot(x, siny, label=<span class="string">"sin(x)"</span>)</span><br><span class="line">plt.plot(x, cosy, color=<span class="string">"red"</span>, linestyle=<span class="string">"--"</span>, label=<span class="string">"cos(x)"</span>)</span><br><span class="line">plt.axis([-<span class="number">1</span>, <span class="number">11</span>, -<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">plt.xlabel(<span class="string">"x axis"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"y value"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(<span class="string">"Welcome to ML!"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/06cfd0975eb93a74f9ce68f1e0d0bb2d.jpg" alt=""></p>
<p>以上都是利用matplotlib画折线图，下面来看看如何画散点图：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(x, siny)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/48690e5fe48a9928c6f205c349f72df7.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.scatter(x, siny)</span><br><span class="line">plt.scatter(x, cosy)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/c7bf4cd8614cbe1c530ed207299d6926.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">y = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">plt.scatter(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/f364d28c40938463ab9717ce2233b311.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置点的透明度</span></span><br><span class="line">plt.scatter(x, y, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/fecd3d8099c73f72d6f15e1f7746fbbb.jpg" alt=""></p>
<h2 id="u57FA_u4E8EScikit_Learn_u7684_u6570_u636E_u63A2_u7D22"><a href="#u57FA_u4E8EScikit_Learn_u7684_u6570_u636E_u63A2_u7D22" class="headerlink" title="基于Scikit Learn的数据探索"></a>基于Scikit Learn的数据探索</h2><p>Scikit-learn是Python语言中专门针对机器学习应用而发展起来的一款开源框架，其中有一个模块叫Datasets，它提供了机器学习的一些常用的数据集以及产生数据集的方法，比如波士顿房价数据集、乳腺癌数据集、糖尿病数据集、手写字体数据集、鸢尾花数据集等等。这一小节我们就通过Scikit Learn的Datasets来初步对机器学习的数据进行探索。</p>
<p>我们使用NumPy和Matplotlib对Scikit Learn Datasets中的鸢尾花这个数据集进行探索：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 我们只导入Scikit Learn中的datasets模块</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载鸢尾花数据集，获取到的iris的数据结构是一个字典</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"><span class="comment"># 看看字典的key都有什么</span></span><br><span class="line">iris.keys()</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">dict_keys([<span class="string">'data'</span>, <span class="string">'target'</span>, <span class="string">'target_names'</span>, <span class="string">'DESCR'</span>, <span class="string">'feature_names'</span>])</span><br></pre></td></tr></table></figure>
<p>从上面的示例可以看到鸢尾花这个字典一共包含五种信息，我们逐一来看看这五种信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 先看一下DESCR信息，该信息解释了鸢尾花这个数据集</span><br><span class="line">print(iris.DESCR)</span><br><span class="line"># 结果</span><br><span class="line">Iris Plants Database</span><br><span class="line">====================</span><br><span class="line"></span><br><span class="line">Notes</span><br><span class="line">-----</span><br><span class="line">Data Set Characteristics:</span><br><span class="line">	:Number of Instances: 150 (50 in each of three classes)</span><br><span class="line">	:Number of Attributes: 4 numeric, predictive attributes and the class</span><br><span class="line">	:Attribute Information:</span><br><span class="line">		- sepal length in cm</span><br><span class="line">		- sepal width in cm</span><br><span class="line">		- petal length in cm</span><br><span class="line">		- petal width in cm</span><br><span class="line">		- class:</span><br><span class="line">				- Iris-Setosa</span><br><span class="line">				- Iris-Versicolour</span><br><span class="line">				- Iris-Virginica</span><br><span class="line">	:Summary Statistics:</span><br><span class="line"></span><br><span class="line">	============== ==== ==== ======= ===== ====================</span><br><span class="line">					Min  Max   Mean    SD   Class Correlation</span><br><span class="line">	============== ==== ==== ======= ===== ====================</span><br><span class="line">	sepal length:   4.3  7.9   5.84   0.83    0.7826</span><br><span class="line">	sepal width:    2.0  4.4   3.05   0.43   -0.4194</span><br><span class="line">	petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)</span><br><span class="line">	petal width:    0.1  2.5   1.20  0.76     0.9565  (high!)</span><br><span class="line">	============== ==== ==== ======= ===== ====================</span><br><span class="line">.....</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p><code>DESCR</code>详细的描述了鸢尾花这个数据集一共有150组数据，每组数据有4个特征，分别是萼片的长度和厚度、花瓣的长度和厚度，还有3种鸢尾花的类别以及这些数据的统计信息和详细的解释说明。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 再来看看data</span></span><br><span class="line">iris.data</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">5.1</span>,  <span class="number">3.5</span>,  <span class="number">1.4</span>,  <span class="number">0.2</span>],</span><br><span class="line">	   [ <span class="number">4.9</span>,  <span class="number">3.</span> ,  <span class="number">1.4</span>,  <span class="number">0.2</span>],</span><br><span class="line">	   [ <span class="number">4.7</span>,  <span class="number">3.2</span>,  <span class="number">1.3</span>,  <span class="number">0.2</span>],</span><br><span class="line">	   [ <span class="number">4.6</span>,  <span class="number">3.1</span>,  <span class="number">1.5</span>,  <span class="number">0.2</span>],</span><br><span class="line">	   [ <span class="number">5.</span> ,  <span class="number">3.6</span>,  <span class="number">1.4</span>,  <span class="number">0.2</span>],</span><br><span class="line">	   [ <span class="number">5.4</span>,  <span class="number">3.9</span>,  <span class="number">1.7</span>,  <span class="number">0.4</span>],</span><br><span class="line">	   [ <span class="number">4.6</span>,  <span class="number">3.4</span>,  <span class="number">1.4</span>,  <span class="number">0.3</span>],</span><br><span class="line">	   [ <span class="number">5.</span> ,  <span class="number">3.4</span>,  <span class="number">1.5</span>,  <span class="number">0.2</span>],</span><br><span class="line">	   [ <span class="number">4.4</span>,  <span class="number">2.9</span>,  <span class="number">1.4</span>,  <span class="number">0.2</span>],</span><br><span class="line">	   [ <span class="number">4.9</span>,  <span class="number">3.1</span>,  <span class="number">1.5</span>,  <span class="number">0.1</span>],</span><br><span class="line">	   [ <span class="number">5.4</span>,  <span class="number">3.7</span>,  <span class="number">1.5</span>,  <span class="number">0.2</span>],</span><br><span class="line">	   [ <span class="number">4.8</span>,  <span class="number">3.4</span>,  <span class="number">1.6</span>,  <span class="number">0.2</span>],</span><br><span class="line">	   ...</span><br><span class="line">	   ...</span><br><span class="line">	   [ <span class="number">5.9</span>,  <span class="number">3.</span> ,  <span class="number">5.1</span>,  <span class="number">1.8</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 看看data这个数组的行列情况</span></span><br><span class="line">iris.data.shape</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="number">150</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到<code>data</code>中的数据就是萼片长度、厚度，花瓣长度、厚度的值。是一个150行，4列的矩阵。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># feature_names的值就是4个特征的说明</span></span><br><span class="line">iris.feature_names</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[<span class="string">'sepal length (cm)'</span>,</span><br><span class="line"> <span class="string">'sepal width (cm)'</span>,</span><br><span class="line"> <span class="string">'petal length (cm)'</span>,</span><br><span class="line"> <span class="string">'petal width (cm)'</span>]</span><br><span class="line"> </span><br><span class="line"> <span class="comment"># target描述了每一行鸢尾花的数据是哪个类别的</span></span><br><span class="line"> iris.target</span><br><span class="line"> <span class="comment"># 结果</span></span><br><span class="line"> array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">	   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">	   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">	   <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">	   <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">	   <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">	   <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># target是一个一维数组</span></span><br><span class="line">iris.target.shape</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">(<span class="number">150</span>,)</span><br><span class="line"></span><br><span class="line"><span class="comment"># target_names就是类别名称</span></span><br><span class="line">iris.target_names</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="string">'setosa'</span>, <span class="string">'versicolor'</span>, <span class="string">'virginica'</span>],</span><br><span class="line">	  dtype=<span class="string">'&lt;U10'</span>)</span><br></pre></td></tr></table></figure>
<p>下面我们用Matplotlib，用图将鸢尾花的数据展示出来，这样就能更直观的来分析这些数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 因为matplotlib只能绘制二维图像，所以我们先来看看鸢尾花萼片的数据，取data的所有行，前2列</span></span><br><span class="line">X = iris.data[:, :<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 将鸢尾花萼片的长度和宽度用散点图绘制出来</span></span><br><span class="line">plt.scatter(X[:, :<span class="number">1</span>], X[:, <span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/9a08dffcd0e8a7fdf3639f1d9f3d874b.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们再来看看这150组鸢尾花数据从萼片维度的类别分类情况</span></span><br><span class="line">y = iris.target</span><br><span class="line">plt.scatter(X[y == <span class="number">0</span>, <span class="number">0</span>], X[y == <span class="number">0</span>, <span class="number">1</span>], color=<span class="string">"red"</span>)</span><br><span class="line">plt.scatter(X[y == <span class="number">1</span>, <span class="number">0</span>], X[y == <span class="number">1</span>, <span class="number">1</span>], color=<span class="string">"blue"</span>)</span><br><span class="line">plt.scatter(X[y == <span class="number">2</span>, <span class="number">0</span>], X[y == <span class="number">2</span>, <span class="number">1</span>], color=<span class="string">"green"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/d0124866e86843c1dffb61149fa4635b.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取data矩阵的所有行，后2列的数据，既鸢尾花的花瓣长度和宽度信息</span></span><br><span class="line">X1 = iris.data[:, <span class="number">2</span>:]</span><br><span class="line">plt.scatter(X1[:, :<span class="number">1</span>], X1[:, <span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/99997a90dc85df95b77e4a5ab5abe444.jpg" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们再来看看这150组鸢尾花数据从花瓣维度的类别分类情况</span></span><br><span class="line">plt.scatter(X1[y == <span class="number">0</span>, <span class="number">0</span>], X1[y == <span class="number">0</span>, <span class="number">1</span>], color=<span class="string">"red"</span>)</span><br><span class="line">plt.scatter(X1[y == <span class="number">1</span>, <span class="number">0</span>], X1[y == <span class="number">1</span>, <span class="number">1</span>], color=<span class="string">"blue"</span>)</span><br><span class="line">plt.scatter(X1[y == <span class="number">2</span>, <span class="number">0</span>], X1[y == <span class="number">2</span>, <span class="number">1</span>], color=<span class="string">"green"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/8eee090275f82623f8794f8fc1dcf7af.jpg" alt=""></p>
<h2 id="kNN_u7B97_u6CD5"><a href="#kNN_u7B97_u6CD5" class="headerlink" title="kNN算法"></a>kNN算法</h2><p>kNN算法又称k近邻算法，是k-Nearest Neighbors的简称，该算法是监督学习中解决分类问题的算法，也是需要数据知识最少的一个算法，但是效果往往不差，能较好的解释机器学习算法使用过程中的很多细节问题，并且能很好的刻画机器学习应用的流程。</p>
<h3 id="kNN_u7B97_u6CD5_u89E3_u91CA"><a href="#kNN_u7B97_u6CD5_u89E3_u91CA" class="headerlink" title="kNN算法解释"></a>kNN算法解释</h3><p><img src="http://paxigrdp0.bkt.clouddn.com/8a94067b9758b0189df1881425d22ab5.jpg" alt=""></p>
<p>上图描述了肿瘤大小和时间的二维关系图，圆点的颜色表示肿瘤的性质是良性还是恶性。</p>
<p><img src="http://paxigrdp0.bkt.clouddn.com/1ba0838f5f698887a031814ce2655907.jpg" alt=""></p>
<p>此时又有一个病人的数据采集到，那么我们如何判断这个病人的肿瘤是良性还是恶性呢？</p>
<p>首先我们必须取一个<code>k</code>值，至于这个<code>k</code>值是该如何取后续会讲，这里比如我们取<code>k=3</code>，这个<code>k</code>值的作用就是基于新来的这个点，找到离它最近的<code>k</code>个点，这里也就是找到离绿色点最近的三个点：</p>
<p><img src="http://paxigrdp0.bkt.clouddn.com/28dadf5ffe30432c477b34876eb2a255.jpg" alt=""></p>
<p>然后根据这三个代表的特征进行投票，票数最多的特征就是这个绿色点的特征，这个示例中离绿色点最近的三个点都是蓝色点，既恶性肿瘤，那么可判定绿色点代表的肿瘤性质有很高的概率也是恶性。</p>
<h3 id="u6B27_u62C9_u8DDD_u79BB"><a href="#u6B27_u62C9_u8DDD_u79BB" class="headerlink" title="欧拉距离"></a>欧拉距离</h3><p>kNN算法中唯一用到的数学知识就是如何求点与点之间的距离，在这里我们先使用最普遍的欧拉距离来进行计算，欧拉距离的公式如下：</p>
<p>二维：<br>$$ \sqrt {(x^{(a)}-x^{(b)})^2+(y^{(a)}-y^{(b)})^2} $$</p>
<p>三维：<br>$$ \sqrt {(x^{(a)}-x^{(b)})^2+(y^{(a)}-y^{(b)})^2+(z^{(a)}-z^{(b)})^2} $$</p>
<p>N维(N个特征)：</p>
<p>$$ \sqrt {(x_1^{(a)}-x_1^{(b)})^2+(x_2^{(a)}-x_2^{(b)})^2+…+(x_n^{(a)}-x_n^{(b)})^2} =\sqrt {\sum_{i=1}^n(x_i^{(a)}-x_i^{(b)})^2} $$</p>
<p>用大白话解释就是两个点的所有相同维度之差求平方，然后全部相加再开方。有兴趣的话大家可以再深入研究一下点与点间距离的计算。</p>
<h3 id="u7F16_u7801_u5B9E_u73B0kNN_u7B97_u6CD5"><a href="#u7F16_u7801_u5B9E_u73B0kNN_u7B97_u6CD5" class="headerlink" title="编码实现kNN算法"></a>编码实现kNN算法</h3><p>首先我们来准备一下数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">raw_data_X = [[<span class="number">3.393533211</span>, <span class="number">2.331273381</span>],</span><br><span class="line">			  [<span class="number">3.110073483</span>, <span class="number">1.781539638</span>],</span><br><span class="line">			  [<span class="number">1.343808831</span>, <span class="number">3.368360954</span>],</span><br><span class="line">			  [<span class="number">3.582294042</span>, <span class="number">4.679179110</span>],</span><br><span class="line">			  [<span class="number">2.280362439</span>, <span class="number">2.866990263</span>],</span><br><span class="line">			  [<span class="number">7.423436942</span>, <span class="number">4.696522875</span>],</span><br><span class="line">			  [<span class="number">5.745051997</span>, <span class="number">3.533989803</span>],</span><br><span class="line">			  [<span class="number">9.172168622</span>, <span class="number">2.511101045</span>],</span><br><span class="line">			  [<span class="number">7.792783481</span>, <span class="number">3.424088941</span>],</span><br><span class="line">			  [<span class="number">7.939820817</span>, <span class="number">0.791637231</span>]</span><br><span class="line">			 ]</span><br><span class="line">raw_data_y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>我们将这些样本数据绘制出来看看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 和绘制鸢尾花的方式一样</span></span><br><span class="line">X_train = np.array(raw_data_X)</span><br><span class="line">y_train = np.array(raw_data_y)</span><br><span class="line">plt.scatter(X_train[y_train == <span class="number">0</span>, <span class="number">0</span>], X_train[y_train == <span class="number">0</span>, <span class="number">1</span>], color=<span class="string">"red"</span>)</span><br><span class="line">plt.scatter(X_train[y_train == <span class="number">1</span>, <span class="number">0</span>], X_train[y_train == <span class="number">1</span>, <span class="number">1</span>], color=<span class="string">"blue"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/da457209ab37d3c015afeb7ab4b3796f.jpg" alt=""></p>
<p>下面再创建一组数据，来模拟需要被分类的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.array([<span class="number">8.093607318</span>, <span class="number">3.365731514</span>])</span><br><span class="line">plt.scatter(X_train[y_train == <span class="number">0</span>, <span class="number">0</span>], X_train[y_train == <span class="number">0</span>, <span class="number">1</span>], color=<span class="string">"red"</span>)</span><br><span class="line">plt.scatter(X_train[y_train == <span class="number">1</span>, <span class="number">0</span>], X_train[y_train == <span class="number">1</span>, <span class="number">1</span>], color=<span class="string">"blue"</span>)</span><br><span class="line">plt.scatter(x[<span class="number">0</span>], x[<span class="number">1</span>], color=<span class="string">"green"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="http://paxigrdp0.bkt.clouddn.com/4dfa48281a765f4c476d1e7a16a91119.jpg" alt=""></p>
<p>我们现在就要通过kNN算法来分析这个绿点属于哪个类别，虽然从图上我们已经可以看得出。</p>
<p>我们先来通过欧拉距离公式求出所有点与绿点的距离：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入开方的类库</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">distances = []</span><br><span class="line"><span class="comment"># 通过for循环求出每一个点与绿点的距离</span></span><br><span class="line"><span class="keyword">for</span> x_train <span class="keyword">in</span> X_train:</span><br><span class="line">	d = sqrt(np.sum((x_train - x) ** <span class="number">2</span>))</span><br><span class="line">	distances.append(d)</span><br><span class="line">	</span><br><span class="line">distances</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[<span class="number">4.812566907609877</span>,</span><br><span class="line"> <span class="number">5.229270827235305</span>,</span><br><span class="line"> <span class="number">6.749798999160064</span>,</span><br><span class="line"> <span class="number">4.6986266144110695</span>,</span><br><span class="line"> <span class="number">5.83460014556857</span>,</span><br><span class="line"> <span class="number">1.4900114024329525</span>,</span><br><span class="line"> <span class="number">2.354574897431513</span>,</span><br><span class="line"> <span class="number">1.3761132675144652</span>,</span><br><span class="line"> <span class="number">0.3064319992975</span>,</span><br><span class="line"> <span class="number">2.5786840957478887</span>]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 其实还可以更简洁的使用行内表达式</span></span><br><span class="line"> distances = [sqrt(np.sum((x_train - x) ** <span class="number">2</span>)) <span class="keyword">for</span> x_train <span class="keyword">in</span> X_train]</span><br><span class="line"> distances</span><br><span class="line"> <span class="comment"># 结果是一样的</span></span><br><span class="line"> [<span class="number">4.812566907609877</span>,</span><br><span class="line"> <span class="number">5.229270827235305</span>,</span><br><span class="line"> <span class="number">6.749798999160064</span>,</span><br><span class="line"> <span class="number">4.6986266144110695</span>,</span><br><span class="line"> <span class="number">5.83460014556857</span>,</span><br><span class="line"> <span class="number">1.4900114024329525</span>,</span><br><span class="line"> <span class="number">2.354574897431513</span>,</span><br><span class="line"> <span class="number">1.3761132675144652</span>,</span><br><span class="line"> <span class="number">0.3064319992975</span>,</span><br><span class="line"> <span class="number">2.5786840957478887</span>]</span><br></pre></td></tr></table></figure>
<p>现在我们就求出了所有点与绿点的距离，但是求出距离并不能表示出每个距离对应点的类别，所以还需要知道这每个距离对应的是哪个点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此时上文中说过的argsort方法就派上用场了</span></span><br><span class="line"><span class="comment"># argsort方法可以将数组排序，但是返回数组中元素的索引</span></span><br><span class="line">nearest = np.argsort(distances)</span><br><span class="line">nearest</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>])</span><br><span class="line">In [ ]:</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看到，距离绿点最近的点是<code>X_train</code>中的第8行样本。那么接下来我们看看如何通过<code>k</code>值获取这些点的类别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先定义k的值为6</span></span><br><span class="line">k = <span class="number">6</span></span><br><span class="line"><span class="comment"># 离绿点距离最近的前6个点的类别</span></span><br><span class="line">topK_y = [y_train[i] <span class="keyword">for</span> i <span class="keyword">in</span> nearest[:k]]</span><br><span class="line">topK_y</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入collections的Counter类库用于计数计算</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">votes = Counter(topK_y)</span><br><span class="line">votes</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">Counter(&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">5</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过most_common方法获取最大的若干个结果，传入的参数为想要获取最大的几个结果，这里我们只需要最大的一个结果，既投票票数最多的那个结果</span></span><br><span class="line">votes.most_common(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">5</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更精准的获取投票票数最多的结果</span></span><br><span class="line">predict_y = votes.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">predict_y</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>到目前位置，我们就判断出了绿点有很大概率类别属于1，这个过程就是kNN算法的核心过程。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>在下一篇笔记中，将会介绍Scikit Learn中是如何封装kNN算法的，以及我们会自己封装一个kNN算法，以及对分类准确度评定，超参数，数据归一化等知识点的讲解。</p>
<blockquote>
<p>申明：本文为慕课网<a href="https://www.imooc.com/t/108955" target="_blank" rel="external">liuyubobobo</a>老师<a href="https://coding.imooc.com/learn/list/169.html" target="_blank" rel="external">《Python3入门机器学习 经典算法与应用》</a>课程的学习笔记，未经允许不得转载。</p>
</blockquote>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4115205380866695"
     data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><p>NumPy是Python中的一个类库，它支持高阶维度数组（矩阵）的创建及各种操作、运算，是我们在机器学习中经常会使用的一个类库。这一节再看一些NumPy的矩阵用法。</p>
<h3 id="numpy-random"><a href="#numpy-random" class="headerlink" title="numpy.random"></a>numpy.random</h3><p>NumPy也提供了生成随机数和随机元素数组的方法，我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成从0到10之间的随机数</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成元素从0到10，一共4个随机元素的数组</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成元素随机从0到10，3行5列的矩阵</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>],</span><br><span class="line">	   [<span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">	   [<span class="number">4</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>如果我们希望每次使用随机方法生成的结果都是一样的，一般调试时候有这个需求，此时NumPy的<code>random()</code>方法也提供了方便简单的方式，既随机种子的概念：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成随机矩阵前给定一个种子</span></span><br><span class="line">np.random.seed(<span class="number">123</span>)</span><br><span class="line"><span class="comment"># 然后生成随机矩阵</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 再次生成随机矩阵时，只要传入相同的种子，就可以得到相同结果的矩阵</span></span><br><span class="line">np.random.seed(<span class="number">123</span>)</span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 默认范围是从0.0到1.0，返回值为float型</span></span><br><span class="line">np.random.random()</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0.18249173045349998</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入的参数是数组的大小</span></span><br><span class="line">np.random.random(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">0.17545176</span>,  <span class="number">0.53155137</span>,  <span class="number">0.53182759</span>,  <span class="number">0.63440096</span>,  <span class="number">0.84943179</span>,</span><br><span class="line">		<span class="number">0.72445532</span>,  <span class="number">0.61102351</span>,  <span class="number">0.72244338</span>,  <span class="number">0.32295891</span>,  <span class="number">0.36178866</span>])</span><br><span class="line">		</span><br><span class="line"><span class="comment"># 创建4行5列，元素值的范围从0.0到1.0的矩阵</span></span><br><span class="line">np.random.random((<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0.22826323</span>,  <span class="number">0.29371405</span>,  <span class="number">0.63097612</span>,  <span class="number">0.09210494</span>,  <span class="number">0.43370117</span>],</span><br><span class="line">	   [ <span class="number">0.43086276</span>,  <span class="number">0.4936851</span> ,  <span class="number">0.42583029</span>,  <span class="number">0.31226122</span>,  <span class="number">0.42635131</span>],</span><br><span class="line">	   [ <span class="number">0.89338916</span>,  <span class="number">0.94416002</span>,  <span class="number">0.50183668</span>,  <span class="number">0.62395295</span>,  <span class="number">0.1156184</span> ],</span><br><span class="line">	   [ <span class="number">0.31728548</span>,  <span class="number">0.41482621</span>,  <span class="number">0.86630916</span>,  <span class="number">0.25045537</span>,  <span class="number">0.48303426</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="u6307_u5B9A_u5747_u503C_u548C_u6807_u51C6_u5DEE_u751F_u6210_u968F_u673A_u6570_u6570_u7EC4_u6216_u77E9_u9635"><a href="#u6307_u5B9A_u5747_u503C_u548C_u6807_u51C6_u5DEE_u751F_u6210_u968F_u673A_u6570_u6570_u7EC4_u6216_u77E9_u9635" class="headerlink" title="指定均值和标准差生成随机数数组或矩阵"></a>指定均值和标准差生成随机数数组或矩阵</h3><p>我们先来看看均值、方差、标准差的概念。均值很好理解，就是所有样本数据的平均值，描述了样本集合的中间点：</p>
<p>$$ \overline X=\frac{\sum_{i=1}^nX_i}n $$</p>
<p>方差是衡量样本点和样本期望值相差的度量值：</p>
<p>$$ S^2 = \frac{\sum_{i=1}^n(X_i-\overline X)^2} n $$</p>
<p>标准差描述的是样本集合的各个样本点到均值的距离之平均：</p>
<p>$$ S = \sqrt {\frac{\sum_{i=1}^n(X_i-\overline X)^2} n } $$</p>
<p>标准差也就是对方差开根号。举个例子，<code>[0, 8, 12, 20]</code>和<code>[8, 9, 11, 12]</code>，两个集合的均值都是10，但显然两个集合的差别是很大的，计算两者的标准差，前者是8.3后者是1.8，显然后者较为集中，标准差描述的就是这种散布度或者叫做波动大小。综上，方差的意义在于描述随机变量稳定与波动、集中与分散的状况。标准差则体现随机变量取值与其期望值的偏差。</p>]]>
    
    </summary>
    
      <category term="机器学习" scheme="http://www.devtalking.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习笔记二之矩阵、环境搭建、NumPy]]></title>
    <link href="http://www.devtalking.com//articles/machine-learning-2/"/>
    <id>http://www.devtalking.com//articles/machine-learning-2/</id>
    <published>2018-01-12T16:00:00.000Z</published>
    <updated>2018-07-10T12:04:18.340Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u77E9_u9635"><a href="#u77E9_u9635" class="headerlink" title="矩阵"></a>矩阵</h2><p>因为在机器学习中，一些概念、算法都涉及到矩阵的知识，比如训练数据集通常都是以矩阵的方式存在，所以在这里首先介绍一下矩阵的概念。</p>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><p>在数学概念中，一个$m \times n$的矩阵指的是一个由$m$行$n$列元素排列而成的矩形阵列。用大白话解释就是将一些元素排列成若干行，每行放上相同数量的元素，就是一个矩阵。矩阵里的元素可以是数字、符号或数学式，比如下面这个$A$矩阵就是一个四行两列的矩阵：<br>$$ A=\begin{bmatrix}<br> 1&amp;2\\<br> 3&amp;4\\<br> 5&amp;6\\<br> 7&amp;8\\<br>\end{bmatrix}$$</p>
<p>一个矩阵$A$从左上角数起的第$i$行第$j$列上的元素称为第$i$，$j$项，通常记为$A_{i,j}$、$A_{ij}$或者$A_{[i,j]}$，那么上面的$A$矩阵中$A_{3,2}=6$。如果我们不知道矩阵$A$的具体元素，通常将其表示为$A=[a_{ij}]_{m \times n}$，如果$A$的元素可以写成与行$i$和列$j$有关的统一函数$f$，那么也可以用$A=[f(i,j)]_{m \times n}$来表示。</p>
<h3 id="u77E9_u9635_u7684_u57FA_u672C_u8FD0_u7B97"><a href="#u77E9_u9635_u7684_u57FA_u672C_u8FD0_u7B97" class="headerlink" title="矩阵的基本运算"></a>矩阵的基本运算</h3><p>矩阵的最基本运算包括矩阵加（减）法、数乘、转置、矩阵乘法运算。</p>
<h4 id="u52A0_u51CF_u6CD5_u8FD0_u7B97"><a href="#u52A0_u51CF_u6CD5_u8FD0_u7B97" class="headerlink" title="加减法运算"></a>加减法运算</h4><p>$m \times n$矩阵$A$和$B$的和（差）$A \pm B$也是一个$m \times n$矩阵，其中每个元素是$A$和$B$相应元素的和（差），即$ (A \pm B)_{ij}=A_{ij} \pm B_{ij} $，其中$1 \le i \le m$，$1 \le j \le n$。举个例子：</p>
<p>$$ \begin{bmatrix}<br>1&amp;2&amp;3\\<br>4&amp;5&amp;6\\<br>\end{bmatrix} + \begin{bmatrix}<br>6&amp;5&amp;4\\<br>3&amp;2&amp;1\\<br>\end{bmatrix} = \begin{bmatrix}<br>1+6 &amp; 2+5 &amp; 3+4 \\<br>4+3 &amp; 5+2 &amp; 6+1 \\<br>\end{bmatrix}=\begin{bmatrix}<br>7&amp;7&amp;7\\<br>7&amp;7&amp;7\\<br>\end{bmatrix}<br> $$</p>
<h4 id="u6570_u4E58_u8FD0_u7B97"><a href="#u6570_u4E58_u8FD0_u7B97" class="headerlink" title="数乘运算"></a>数乘运算</h4><p> 标量$c$与$m \times n$的矩阵$A$的数乘也是一个$m \times n$的矩阵$cA$，它的每个元素是矩阵$A$的相应元素与$c$的乘积$(cA)_{ij}=c \cdot A_{ij}$，举个例子：</p>
<p> $$<br> 2 \cdot \begin{bmatrix}<br> 1&amp;2&amp;3\\<br> 4&amp;5&amp;6\\<br> \end{bmatrix}=\begin{bmatrix}<br> 2 \cdot 1 &amp; 2 \cdot 2 &amp; 2 \cdot 3 \\<br> 2 \cdot 4 &amp; 2 \cdot 5 &amp; 2 \cdot 6 \\<br> \end{bmatrix}=\begin{bmatrix}<br> 2&amp;4&amp;6\\<br> 8&amp;10&amp;12\\<br> \end{bmatrix}<br>  $$</p>
  <a id="more"></a>
<h4 id="u8F6C_u7F6E"><a href="#u8F6C_u7F6E" class="headerlink" title="转置"></a>转置</h4><p>$m \times n$的矩阵$A$的转置是一个$n \times m$的矩阵，记为$A^T$，其中的第$i$个行向量是原矩阵$A$的第$i$个列向量，或者说转置矩阵$A^T$第$i$行第$j$列的元素是原矩阵$A$的第$j$行第$i$列，即$(A^T)_{ij}=A_{ji}$，举个例子：</p>
<p>$$ \begin{bmatrix}<br>1&amp;2&amp;3\\<br>4&amp;5&amp;6\\<br>\end{bmatrix}^T=\begin{bmatrix}<br>1&amp;4\\<br>2&amp;5\\<br>3&amp;6\\<br>\end{bmatrix}<br> $$</p>
<h4 id="u77E9_u9635_u4E58_u6CD5"><a href="#u77E9_u9635_u4E58_u6CD5" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h4><p>两个矩阵的乘法仅当第一个矩阵$A$的列数和另一个矩阵$B$的行数相等时才能定义。比如$m \times n$的矩阵$A$与$n \times p$的矩阵$B$的乘积$AB$是一个$m \times p$的矩阵，即矩阵$AB$的元素为：</p>
<p>$$ [AB]_{ij}=A_{i1}B_{1j}+A_{i2}B_{2j}+…+A_{in}B_{nj}=\sum_{r=1}^n{A_{ir}B_{rj}} $$</p>
<p>举个例子：</p>
<p>$$ \begin{bmatrix}<br>1&amp;2&amp;3\\<br>4&amp;5&amp;6\\<br>\end{bmatrix} \times \begin{bmatrix}<br>6&amp;5\\<br>4&amp;3\\<br>2&amp;1\\<br>\end{bmatrix}=\\<br>\begin{bmatrix}<br>(1 \times 6 + 2 \times 4 + 3 \times 2) &amp; (1 \times 5 + 2 \times 3 + 3 \times 1)  \\<br>(4 \times 6 + 5 \times 4 + 6 \times 2) &amp; (4 \times 5 + 5 \times 3 + 6 \times 1) \\<br>\end{bmatrix} =\\<br>\begin{bmatrix}<br>20&amp;14\\<br>56&amp;41\\<br>\end{bmatrix}<br>$$</p>
<h2 id="u73AF_u5883_u642D_u5EFA"><a href="#u73AF_u5883_u642D_u5EFA" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>目前，Python语言是处理大数据量运算比较好的语言之一，大数据分析、计算，机器学习的主流语言和技术栈基本都是以Python为主，所以我们在搭建机器学习入门编程环境时同样使用Python3。在Python生态圈中，目前有非常丰富和健壮的机器学习的类库和框架，如果我们手动一点点配置，其实是非常繁琐的，而且容易出错。所幸，现在有很多集成工具能傻瓜式的帮我们搭建好机器学习的环境，其中就包括各种需要的类库、框架，以及他们之间的依赖关系等。那么在这里推荐著名的Anaconda。</p>
<h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p>Anaconda是一个Python包和Python相关工具安装的管理器。它的安装过程非常简单，只需要访问其<a href="https://anaconda.org" target="_blank" rel="external">官方网站</a>下载对应操作系统的安装包既可，这里要注意的是我们需要下载Python 3.6版本的Anaconda。安装好后，运行Anaconda，会显示如图所示的主界面：<br><img src="http://p07npm071.bkt.clouddn.com/2018-01-23-anaconda%E4%B8%BB%E7%95%8C%E9%9D%A2.png" alt=""></p>
<p>在界面左侧就会看到有Home、Environments、Projects等导航。Home中显示的就是由Anaconda提供好的一些工具，可以直接运行或者安装。Environments中就是用来管理各种Python包的地方。我们在机器学习入门阶段会使用名为Jupyter Notebook的工具。</p>
<h2 id="Jupyter_Notebook"><a href="#Jupyter_Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h2><p>我们在Anaconda的Home界面就可以看到Jupyter Notebook工具，该工具其实就是一个基于Web的Python编辑器，可以编写Python代码，然后实时编译运行得出结果，相比PyCharm这种完善的IDE工具，Jupyter Notebook显得非常轻量级，但是在进行算法演练和学习Python各种类库时非常方便，另外Jupyter Notebook在编辑器中除了支持Python语言外，还支持基于Markdown语法的文本编写。我们点击Jupyter Notebook工具界面中的Launch，就会由系统默认浏览器自动打开Jupyter Notebook界面：<br><img src="http://p07npm071.bkt.clouddn.com/2018-01-23-jupyternotebook%E4%B8%BB%E7%95%8C%E9%9D%A2.png" alt=""></p>
<p>大家运行Jupyter Notebook，把玩一会后就可以发现，它其实就是使用浏览器通过Web技术，将当前用户下的目录结构展示出来，并且可以新建目录、文件，然后在文件中进行编码的工具，整个运行环境依托于Anaconda。</p>
<h3 id="Jupyter_Notebook_u57FA_u672C_u6982_u5FF5_u548C_u64CD_u4F5C_u65B9_u5F0F"><a href="#Jupyter_Notebook_u57FA_u672C_u6982_u5FF5_u548C_u64CD_u4F5C_u65B9_u5F0F" class="headerlink" title="Jupyter Notebook基本概念和操作方式"></a>Jupyter Notebook基本概念和操作方式</h3><p>Jupyter Notebook中的核心概念是Cell，可以理解为输入最小单元行，每个Cell支持两种模式的输入，一种是Python代码，另一种的Markdown语法的文本。每行Cell编辑完成后按下ctrl+回车或者command+回车，就可以运行Cell里的内容，如果是Python代码就会运行代码，如果是基于Markdown语法的文本，那么就会按照一定格式渲染文本：<br><img src="http://p07npm071.bkt.clouddn.com/jupyternotebook%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<p>Jupyter Notebook还有很多的快捷键操作，这里就不再一一赘述。后续有相当一部分代码我都会在Jupyter Notebook中进行编码，一些使用技巧和知识点在讲述其他内容时一并讲解。所以不论是在学习机器学习的过程中还是学习Python的过程中，Jupyter Notebook都会是一个非常帮的工具。</p>
<h2 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h2><p>NumPy是Python中的一个类库，它支持高阶维度数组（矩阵）的创建及各种操作、运算，是我们在机器学习中经常会使用的一个类库。这一节主要讲一下如何使用NumPy。</p>
<h3 id="numpy-array"><a href="#numpy-array" class="headerlink" title="numpy.array"></a>numpy.array</h3><p>NumPy中的核心数据结构是数组，可以非常方便的创建、操作数组，并支持多维数组，多维数组就可以看作是矩阵。<code>numpy.array</code>与Python中的<code>List</code>的不同之处在于，前者的元素类型是有限定的，而后者的元素类型没有限定。我们先来看看Python的<code>List</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python的List</span></span><br><span class="line">l = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">l</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 取值</span></span><br><span class="line">l[<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值</span></span><br><span class="line">l[<span class="number">5</span>] = <span class="number">100</span></span><br><span class="line">l</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值其他类型</span></span><br><span class="line">l[<span class="number">6</span>] = <span class="string">"hello world!"</span></span><br><span class="line">l</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">100</span>, <span class="string">'hello world!'</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>Python中的<code>List</code>虽然灵活，但是由于每个元素的类型是不限定的，所以性能和效率会比较差。其实Python中也有元素类型限定的数组那就是<code>array</code>，我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python中的array</span></span><br><span class="line"><span class="keyword">import</span> array</span><br><span class="line">arr = array.array(<span class="string">'i'</span>, [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line">arr</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array(<span class="string">'i'</span>, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取值</span></span><br><span class="line">arr[<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值</span></span><br><span class="line">arr[<span class="number">6</span>] = <span class="string">"hello world!"</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">TypeError: an integer <span class="keyword">is</span> required (got type str)</span><br></pre></td></tr></table></figure>
<p>但是Python中的<code>array</code>并没有将一维数组当做向量、多维数组当做矩阵来看，自然也没有提供任何对多维数组的矩阵操作。所以NumPy类库就应运而生了。我们再来看看NumPy中的<code>array</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NumPy中的array</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">nparr = np.array([i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line">nparr</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取值</span></span><br><span class="line">nparr[<span class="number">5</span>]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值</span></span><br><span class="line">nparr[<span class="number">6</span>] = <span class="number">100</span></span><br><span class="line">nparr</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([  <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">2</span>,   <span class="number">3</span>,   <span class="number">4</span>,   <span class="number">5</span>, <span class="number">100</span>,   <span class="number">7</span>,   <span class="number">8</span>,   <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值其他类型</span></span><br><span class="line">nparr[<span class="number">7</span>] = <span class="string">"hello world!"</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'hello world!'</span></span><br></pre></td></tr></table></figure>
<h3 id="numpy-array_u4E2D_u7684_u5143_u7D20_u7C7B_u578B"><a href="#numpy-array_u4E2D_u7684_u5143_u7D20_u7C7B_u578B" class="headerlink" title="numpy.array中的元素类型"></a>numpy.array中的元素类型</h3><p>因为<code>numpy.array</code>中的元素类型是限定的，所以这一小节我们来看看和元素类型相关的方法和概念：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看数组中的元素类型</span></span><br><span class="line">nparr.dtype</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">dtype(<span class="string">'int32'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给元素类型是int的数组，赋值一个float类型的值，会强制转换为int</span></span><br><span class="line">nparr[<span class="number">2</span>] = <span class="number">3.1</span></span><br><span class="line">nparr</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([  <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">3</span>,   <span class="number">3</span>,   <span class="number">4</span>,   <span class="number">5</span>, <span class="number">100</span>,   <span class="number">7</span>,   <span class="number">8</span>,   <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果在创建数组时，有一个元素类型为float，那么该数组的所以元素类型会是float</span></span><br><span class="line">nparr2 = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.1</span>])</span><br><span class="line">nparr2</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">0.</span> ,  <span class="number">1.</span> ,  <span class="number">2.</span> ,  <span class="number">3.1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看nparr2的元素类型</span></span><br><span class="line">nparr2.dtype</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">dtype(<span class="string">'float64'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="u521B_u5EFAnumpy-array_u7684_u5176_u4ED6_u65B9_u6CD5"><a href="#u521B_u5EFAnumpy-array_u7684_u5176_u4ED6_u65B9_u6CD5" class="headerlink" title="创建numpy.array的其他方法"></a>创建numpy.array的其他方法</h3><p>NumPy还提供了丰富的能快捷创建数组的方法，我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建元素全部为0的数组，参数为数组元素的个数</span></span><br><span class="line">nparr3 = np.zeros(<span class="number">10</span>)</span><br><span class="line">nparr3</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用np.zeros创建的数组，元素类型默认为float</span></span><br><span class="line">nparr3.dtype</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">dtype(<span class="string">'float64'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想指定元素的类型，可以设置第二个参数</span></span><br><span class="line">nparr4 = np.zeros(<span class="number">10</span>, dtype=int)</span><br><span class="line">nparr4.dtype</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">dtype(<span class="string">'int32'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建元素全部为1的数组</span></span><br><span class="line">nparr5 = np.ones(<span class="number">10</span>)</span><br><span class="line">nparr5</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>])</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528numpy_u521B_u5EFA_u77E9_u9635"><a href="#u4F7F_u7528numpy_u521B_u5EFA_u77E9_u9635" class="headerlink" title="使用numpy创建矩阵"></a>使用numpy创建矩阵</h3><p>NumPy会把二维数组看作一个矩阵来处理，我们来看看如何创建二维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 传入二元元组参数，给定行数和列数</span></span><br><span class="line">nparr6 = np.zeros((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">nparr6</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">	   [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 如果要指定类型的话，需要显示使用shape这个参数，传入二元元组，给定行数和列数</span></span><br><span class="line">nparr6 = np.zeros(shape=(<span class="number">3</span>, <span class="number">4</span>), dtype=int)</span><br><span class="line">nparr6</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">	   [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">	   [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 创建两行四列，元素全部为1的矩阵    </span></span><br><span class="line">nparr7 = np.ones((<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">nparr7</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">	   [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 创建三行五列，元素为指定值的矩阵</span></span><br><span class="line">nparr8 = np.full(shape=(<span class="number">3</span>, <span class="number">5</span>), fill_value=<span class="number">100</span>)</span><br><span class="line">nparr8</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">	   [<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>],</span><br><span class="line">	   [<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="numpy-arange"><a href="#numpy-arange" class="headerlink" title="numpy.arange"></a>numpy.arange</h3><p>在上文中，我们使用了<code>[i for i in range(0, 20, 2)]</code>这种方式创建了Python的<code>List</code>，其中用到了<code>range()</code>这个方法，该方法有三个参数，用大白话解释就是通过<code>range()</code>创建一个池子，这个池子里的第一个元素大于等于第一个参数的值，最后一个元素小于等于第二个参数的值，元素之间的关系由第三个参数的值决定，第三个参数也称为步长：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个数组，其中的元素大于等于0，小于等于20，每个元素相差为2</span></span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">20</span>, <span class="number">2</span>)]</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]</span><br></pre></td></tr></table></figure>
<p>NumPy也提供了类似的方法<code>arange()</code>，它的优势是步长支持浮点型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建范围从0到1，步长为0.2的数组</span></span><br><span class="line">np.arange(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">0.</span> ,  <span class="number">0.2</span>,  <span class="number">0.4</span>,  <span class="number">0.6</span>,  <span class="number">0.8</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果只传入一个参数，那么表示默认元素从0开始，传入的参数为数组的大小</span></span><br><span class="line">np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure>
<h3 id="numpy-linspace"><a href="#numpy-linspace" class="headerlink" title="numpy.linspace"></a>numpy.linspace</h3><p>NumPy中的<code>linspace()</code>方法可以让我们不用考虑步长，只考虑希望从起始值到终止值的范围内，创建多少个元素，步长会自动进行计算，这里要注意的是linspace方法是包含起始值和终止值的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一个参数是起始值，第二个参数是终止值，第三参数是数组大小</span></span><br><span class="line">np.linspace(<span class="number">0</span>, <span class="number">20</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([  <span class="number">0.</span>        ,   <span class="number">2.22222222</span>,   <span class="number">4.44444444</span>,   <span class="number">6.66666667</span>,</span><br><span class="line">		 <span class="number">8.88888889</span>,  <span class="number">11.11111111</span>,  <span class="number">13.33333333</span>,  <span class="number">15.55555556</span>,</span><br><span class="line">		<span class="number">17.77777778</span>,  <span class="number">20.</span>        ])</span><br></pre></td></tr></table></figure>
<h3 id="numpy-random"><a href="#numpy-random" class="headerlink" title="numpy.random"></a>numpy.random</h3><p>NumPy也提供了生成随机数和随机元素数组的方法，我们来看一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成从0到10之间的随机数</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成元素从0到10，一共4个随机元素的数组</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([<span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成元素随机从0到10，3行5列的矩阵</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>],</span><br><span class="line">	   [<span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">	   [<span class="number">4</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<p>如果我们希望每次使用随机方法生成的结果都是一样的，一般调试时候有这个需求，此时NumPy的<code>random()</code>方法也提供了方便简单的方式，既随机种子的概念：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成随机矩阵前给定一个种子</span></span><br><span class="line">np.random.seed(<span class="number">123</span>)</span><br><span class="line"><span class="comment"># 然后生成随机矩阵</span></span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 再次生成随机矩阵时，只要传入相同的种子，就可以得到相同结果的矩阵</span></span><br><span class="line">np.random.seed(<span class="number">123</span>)</span><br><span class="line">np.random.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[<span class="number">2</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">	   [<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>],</span><br><span class="line">	   [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>]])</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 默认范围是从0.0到1.0，返回值为float型</span></span><br><span class="line">np.random.random()</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0.18249173045349998</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入的参数是数组的大小</span></span><br><span class="line">np.random.random(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([ <span class="number">0.17545176</span>,  <span class="number">0.53155137</span>,  <span class="number">0.53182759</span>,  <span class="number">0.63440096</span>,  <span class="number">0.84943179</span>,</span><br><span class="line">		<span class="number">0.72445532</span>,  <span class="number">0.61102351</span>,  <span class="number">0.72244338</span>,  <span class="number">0.32295891</span>,  <span class="number">0.36178866</span>])</span><br><span class="line">		</span><br><span class="line"><span class="comment"># 创建4行5列，元素值的范围从0.0到1.0的矩阵</span></span><br><span class="line">np.random.random((<span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">array([[ <span class="number">0.22826323</span>,  <span class="number">0.29371405</span>,  <span class="number">0.63097612</span>,  <span class="number">0.09210494</span>,  <span class="number">0.43370117</span>],</span><br><span class="line">	   [ <span class="number">0.43086276</span>,  <span class="number">0.4936851</span> ,  <span class="number">0.42583029</span>,  <span class="number">0.31226122</span>,  <span class="number">0.42635131</span>],</span><br><span class="line">	   [ <span class="number">0.89338916</span>,  <span class="number">0.94416002</span>,  <span class="number">0.50183668</span>,  <span class="number">0.62395295</span>,  <span class="number">0.1156184</span> ],</span><br><span class="line">	   [ <span class="number">0.31728548</span>,  <span class="number">0.41482621</span>,  <span class="number">0.86630916</span>,  <span class="number">0.25045537</span>,  <span class="number">0.48303426</span>]])</span><br></pre></td></tr></table></figure>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这篇笔记回顾了机器学习中会大量使用的矩阵的知识，以及在本地学习机器学习算法的最佳环境配置，最后介绍了Python中对矩阵封装最好的库NumPy的用法。下篇笔记会继续学习NumPy的用法以及绘图库Matplotlib库，以及机器学习的第一个算法KNN。</p>
<blockquote>
<p>申明：本文为慕课网<a href="https://www.imooc.com/t/108955" target="_blank" rel="external">liuyubobobo</a>老师<a href="https://coding.imooc.com/learn/list/169.html" target="_blank" rel="external">《Python3入门机器学习 经典算法与应用》</a>课程的学习笔记，未经过允许不得转载。</p>
</blockquote>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4115205380866695"
     data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u77E9_u9635"><a href="#u77E9_u9635" class="headerlink" title="矩阵"></a>矩阵</h2><p>因为在机器学习中，一些概念、算法都涉及到矩阵的知识，比如训练数据集通常都是以矩阵的方式存在，所以在这里首先介绍一下矩阵的概念。</p>
<h3 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h3><p>在数学概念中，一个$m \times n$的矩阵指的是一个由$m$行$n$列元素排列而成的矩形阵列。用大白话解释就是将一些元素排列成若干行，每行放上相同数量的元素，就是一个矩阵。矩阵里的元素可以是数字、符号或数学式，比如下面这个$A$矩阵就是一个四行两列的矩阵：<br>$$ A=\begin{bmatrix}<br> 1&amp;2\\<br> 3&amp;4\\<br> 5&amp;6\\<br> 7&amp;8\\<br>\end{bmatrix}$$</p>
<p>一个矩阵$A$从左上角数起的第$i$行第$j$列上的元素称为第$i$，$j$项，通常记为$A_{i,j}$、$A_{ij}$或者$A_{[i,j]}$，那么上面的$A$矩阵中$A_{3,2}=6$。如果我们不知道矩阵$A$的具体元素，通常将其表示为$A=[a_{ij}]_{m \times n}$，如果$A$的元素可以写成与行$i$和列$j$有关的统一函数$f$，那么也可以用$A=[f(i,j)]_{m \times n}$来表示。</p>
<h3 id="u77E9_u9635_u7684_u57FA_u672C_u8FD0_u7B97"><a href="#u77E9_u9635_u7684_u57FA_u672C_u8FD0_u7B97" class="headerlink" title="矩阵的基本运算"></a>矩阵的基本运算</h3><p>矩阵的最基本运算包括矩阵加（减）法、数乘、转置、矩阵乘法运算。</p>
<h4 id="u52A0_u51CF_u6CD5_u8FD0_u7B97"><a href="#u52A0_u51CF_u6CD5_u8FD0_u7B97" class="headerlink" title="加减法运算"></a>加减法运算</h4><p>$m \times n$矩阵$A$和$B$的和（差）$A \pm B$也是一个$m \times n$矩阵，其中每个元素是$A$和$B$相应元素的和（差），即$ (A \pm B)_{ij}=A_{ij} \pm B_{ij} $，其中$1 \le i \le m$，$1 \le j \le n$。举个例子：</p>
<p>$$ \begin{bmatrix}<br>1&amp;2&amp;3\\<br>4&amp;5&amp;6\\<br>\end{bmatrix} + \begin{bmatrix}<br>6&amp;5&amp;4\\<br>3&amp;2&amp;1\\<br>\end{bmatrix} = \begin{bmatrix}<br>1+6 &amp; 2+5 &amp; 3+4 \\<br>4+3 &amp; 5+2 &amp; 6+1 \\<br>\end{bmatrix}=\begin{bmatrix}<br>7&amp;7&amp;7\\<br>7&amp;7&amp;7\\<br>\end{bmatrix}<br> $$</p>
<h4 id="u6570_u4E58_u8FD0_u7B97"><a href="#u6570_u4E58_u8FD0_u7B97" class="headerlink" title="数乘运算"></a>数乘运算</h4><p> 标量$c$与$m \times n$的矩阵$A$的数乘也是一个$m \times n$的矩阵$cA$，它的每个元素是矩阵$A$的相应元素与$c$的乘积$(cA)_{ij}=c \cdot A_{ij}$，举个例子：</p>
<p> $$<br> 2 \cdot \begin{bmatrix}<br> 1&amp;2&amp;3\\<br> 4&amp;5&amp;6\\<br> \end{bmatrix}=\begin{bmatrix}<br> 2 \cdot 1 &amp; 2 \cdot 2 &amp; 2 \cdot 3 \\<br> 2 \cdot 4 &amp; 2 \cdot 5 &amp; 2 \cdot 6 \\<br> \end{bmatrix}=\begin{bmatrix}<br> 2&amp;4&amp;6\\<br> 8&amp;10&amp;12\\<br> \end{bmatrix}<br>  $$</p>]]>
    
    </summary>
    
      <category term="机器学习" scheme="http://www.devtalking.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习笔记一之机器学习定义、导数、最小二乘]]></title>
    <link href="http://www.devtalking.com//articles/machine-learning-1/"/>
    <id>http://www.devtalking.com//articles/machine-learning-1/</id>
    <published>2018-01-05T16:00:00.000Z</published>
    <updated>2018-07-08T05:14:29.340Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u673A_u5668_u5B66_u4E60_u7684_u5B9A_u4E49"><a href="#u673A_u5668_u5B66_u4E60_u7684_u5B9A_u4E49" class="headerlink" title="机器学习的定义"></a>机器学习的定义</h2><ul>
<li>非正式定义：在不直接针对问题进行编程的情况下，赋予计算机学习能力的一个研究领域。</li>
<li>正式定义：对于一个计算机程序来讲，给他一个任务T和一个性能测量方法P，如果在经验E的影响下P对T的测量结果得到了改进，那么就说该程序从E中得到了学习。</li>
</ul>
<p>举个机器下棋的例子，经验E对应着程序不断和自己下棋的经历，任务T是下棋，性能测量方法P可以是它在和人类棋手对弈的胜率。如果说机器与人类棋手对应的胜率不断提高，那说明机器从自己和自己下棋的过程中得到了学习。</p>
<h2 id="u673A_u5668_u5B66_u4E60_u56DB_u5927_u5185_u5BB9_u7B80_u8FF0"><a href="#u673A_u5668_u5B66_u4E60_u56DB_u5927_u5185_u5BB9_u7B80_u8FF0" class="headerlink" title="机器学习四大内容简述"></a>机器学习四大内容简述</h2><ul>
<li>监督学习（Supervised Learning）</li>
<li>学习理论（Learning Theory）</li>
<li>无监督学习（Unsupervised Learning）</li>
<li>强化学习（Reinforcement Learning）</li>
</ul>
<h3 id="u76D1_u7763_u5B66_u4E60_uFF08Supervised_Learning_uFF09"><a href="#u76D1_u7763_u5B66_u4E60_uFF08Supervised_Learning_uFF09" class="headerlink" title="监督学习（Supervised Learning）"></a>监督学习（Supervised Learning）</h3><p><img src="http://paxigrdp0.bkt.clouddn.com/34576cd0bbd2b3d3905c4c9f5a4db346.jpg" alt=""><br>如上图所示，描述了假定城市区域的房屋面积与售价的关系。横坐标是房屋面积，纵坐标是售价。如果我想在横轴随意取一个面积，就希望知道它的售价，那么就需要一个方法通过面积确定售价。图中的方法是通过一条标准线来找到对应的售价。那么这条线要如何得来呢？</p>
<p>在这个示例中，我们已经给出了若干房屋面积和售价的数据集，即已经告知了机器若干问题和答案。机器通过这些数据集中面积和售价的关系，自我学习从而得出这条线，这种学习类型就属于监督学习类型。</p>
<p>因为这种场景中的数据集取值都是连续的，所以这类问题都可以归为线性回归的问题。<br><img src="http://paxigrdp0.bkt.clouddn.com/da9d63e45fa11a781128bc64bb78ae92.jpg" alt=""></p>
<p>如上图所示，描述了肿瘤大小与恶性良性的关系。横坐标是肿瘤的大小，纵坐标表示恶性或良性，与连续的房屋售价不同的是，这里的纵坐标只有两个值0或1。</p>
<p>这个示例中，我们同样给出了一组肿瘤大小与恶性良性的数据集，我们希望机器通过这组答案数据集自我学习然后有能力通过肿瘤大小判断出恶性或良性。当然这里只是示例，实际中会有很多其他的横轴指标值用于判断学习。</p>
<p>该示例中这种离散的数值问题可以归为分类的问题。</p>
<h3 id="u5B66_u4E60_u7406_u8BBA_uFF08Learning_Theory_uFF09"><a href="#u5B66_u4E60_u7406_u8BBA_uFF08Learning_Theory_uFF09" class="headerlink" title="学习理论（Learning Theory）"></a>学习理论（Learning Theory）</h3><p>任何具体的方式方法背后都有一个或多个理论进行支撑，机器学习也不例外。</p>
<p>这一大块的内容贯穿整个机器学习，包括人工智能和机器学习正式诞生之前的定理证明，理解为什么学习型算法是有效的。每种学习型算法需要多少训练数据，比如上面的房屋售价示例到底需要多少房屋的样本。以及机器学习渗透在我们生活中的真实应用场景等等。</p>
<h3 id="u65E0_u76D1_u7763_u5B66_u4E60_uFF08Unsupervised_Learning_uFF09"><a href="#u65E0_u76D1_u7763_u5B66_u4E60_uFF08Unsupervised_Learning_uFF09" class="headerlink" title="无监督学习（Unsupervised Learning）"></a>无监督学习（Unsupervised Learning）</h3><p>如果我现在有一组不知道任何信息的数据集，然后需要机器进行分析然后给出这组数据集中的几种共性或者相似的结构，将其聚类，这个方式就称之为无监督学习。即我们不会提供机器问题和答案，只提供数据，需要机器自我学习和分析找出共性进行聚类。</p>
<p>无监督学习的应用场景很多，当下流行的各种P图软件都或多或少的用到了这类算法，比如图的修复功能，抠图功能，像素化等一些滤镜都是对像素的聚类。还有声音驳杂功能，从嘈杂的声音中提取出有用的声音等。</p>
<h3 id="u5F3A_u5316_u5B66_u4E60_uFF08Reinforcement_Learning_uFF09"><a href="#u5F3A_u5316_u5B66_u4E60_uFF08Reinforcement_Learning_uFF09" class="headerlink" title="强化学习（Reinforcement Learning）"></a>强化学习（Reinforcement Learning）</h3><p>强化学习是机器学习的精髓，更贴近机器的自我学习，用在不能通过一次决策下定论的情形中，比如分析病人肿瘤病情的例子，通过监督学习，我们给定了确切的答案，不是良性就是恶性，即我们做的决策要么对，要么错。但在强化学习中，在一段时间内会机器做出一系列决策。比如我们编写一个程序让一架无人机做出一系列特技表演动作，这种场景就不是一次决策能实现的了的。</p>
<p>那么强化学习究竟是什么？在它背后有一个称为回报函数的概念。比如我们训练宠物狗坐下、握手等行为，每当小狗做出的正确的行为，我们都会给小狗奖励，比如摸摸头进行鼓励或者给一块小骨头。渐渐的小狗就知道做出怎样的行为有奖励，怎样的行为没有奖励，即学会了坐下和握手的行为。这就很类似强化学习的理论，我们需要找到一种方式，来定义我们想要什么，如何定义一个好的行为和一个坏的行为，然后就需要一个合适的学习型算法来获得更多的回报和更少的惩罚。</p>
<a id="more"></a>
<h2 id="u76D1_u7763_u5B66_u4E60"><a href="#u76D1_u7763_u5B66_u4E60" class="headerlink" title="监督学习"></a>监督学习</h2><h3 id="u7EBF_u6027_u56DE_u5F52"><a href="#u7EBF_u6027_u56DE_u5F52" class="headerlink" title="线性回归"></a>线性回归</h3><p>线性回归是监督学习中相对简单也但很实用的一个数学方法，它是用于确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。我们先从一元线性回归看起。</p>
<p>一元线性回归顾名思义只包括一个自变量和一个因变量，且二者的关系可用一条直线来近似表示，比如上文中的卖房示例，假设我们的分析数据如下表所示：<br><img src="http://paxigrdp0.bkt.clouddn.com/f2e2dafd1795cd2c9560c996e10b4dc2.jpg" alt=""></p>
<p>这组数据是链家网站望京二手房的数据，如果把这些数据画在二维坐标内，就可以得到一个散点图，就像上文图一所示，如果我们想得知房屋面积和售价的关系，就可以利用一元线性回归来画出一条拟合直线。</p>
<h4 id="u5982_u4F55_u753B_u51FA_u62DF_u5408_u76F4_u7EBF"><a href="#u5982_u4F55_u753B_u51FA_u62DF_u5408_u76F4_u7EBF" class="headerlink" title="如何画出拟合直线"></a>如何画出拟合直线</h4><p>首先我们知道一元线性函数的表达式为$ f(y) = ax + b $，该函数可以在二维坐标系内画出一条直线，并且$y$的值随$x$的值变化而变化，既$x$是自变量，$y$是因变量。假设上面给出的数据房屋面积为$x$，售价为$y$，那么每一个实际的$x$值都会有一个实际的$y$值。那么对于我们要画出的拟合直线来讲，每一个实际的$x$值都有会有一个通过拟合直线预测而来的$y$值，我们期望的结果是每个$y$的实际值与预测值的平方和最小，那么我们画出的这条拟合直线称为回归线。用公式表达为：</p>
<p>$$ (y _ {1实际} - y_{1预测})^2 + (y_{2实际}- y_{2预测})^2 + … + (y_{n实际} - y_{n预测})^2 $$</p>
<p>因为$y$的预测值可以由函数$ ax + b $求得，所以代入上面的公式可得：</p>
<p>$$ F(a,b) = \sum_{i=1}^n(y_i-(ax_i + b))^2 $$</p>
<p>所以监督学习中的线性回归方法就是通过大量的数据样本由机器求得$a$和$b$的值，使得函数$F$的值最小，那么回归线也就求出来了，既称为算法收敛。</p>
<h4 id="u5982_u4F55_u6C42_u51FD_u6570_u7684_u6700_u5C0F_u503C"><a href="#u5982_u4F55_u6C42_u51FD_u6570_u7684_u6700_u5C0F_u503C" class="headerlink" title="如何求函数的最小值"></a>如何求函数的最小值</h4><p>说到函数的最小值，那就要引入导数这个数学工具了，下面我从几何角度来解释什么是导数，它和函数的最小值有什么关系。</p>
<h5 id="u5BFC_u6570_u4E0E_u659C_u7387"><a href="#u5BFC_u6570_u4E0E_u659C_u7387" class="headerlink" title="导数与斜率"></a>导数与斜率</h5><p><img src="http://paxigrdp0.bkt.clouddn.com/7dfb137e5166d380c5194ef704b5af2e.jpg" alt=""></p>
<p>如上图所示，在图中的二维坐标系中，有一条曲线，一条直线，该直线为曲线的切线，相交于点$P$，该点的$x$轴坐标值为$x_0$。<br><img src="http://paxigrdp0.bkt.clouddn.com/2c37a842a7fd93c8a3afdc84999c0b05.jpg" alt=""></p>
<p>如上图所示，我们再画一条直线$B$，使其经过曲线上的点$P$和点$Q$，直线$B$称为曲线的割线。当点$Q$逐渐接近点$P$时，直线$B$就会逐渐接近直线$A$，所以说切线其实是割线的极值。<br><img src="http://paxigrdp0.bkt.clouddn.com/193d3633a71b48d7b9fc262296fab1b7.jpg" alt=""></p>
<p>如上图所示，$\Delta x$表示$x$的变化量，并且我们假设直线$B$的函数为$f(x)$，那么$\Delta f$表示函数$f$的变化量。在几何学中，一条直线关于横坐标轴倾斜程度的量，称为斜率，并且定义对于两个已知点$(x_1,y_1)$和$(x_2,y_2)$，如果$x_1$不等于$x_2$，则经过这两点直线的斜率为$k=(y_1-y_2)/(x_1-x_2)$。</p>
<p>所以直线$B$的斜率为$k=\Delta f / \Delta x$。因为点$P$和$Q$的坐标分别为$(x_0,f(x_0))$和$(x_0+\Delta x,f(x_0+\Delta x))$，所以我们代入可得：</p>
<p>$$ k=\frac {f(x_0+\Delta x) - f(x_0)} {(x_0+\Delta x)-x_0}=\frac {f(x_0+\Delta x) - f(x_0)} {\Delta x}$$ </p>
<p>上文中说到切线其实是割线的极值，那么切线$A$的斜率就是当$\Delta x$趋向于0时的值：</p>
<p>$$ k=\lim_{\Delta x-&gt;0}\frac {f(x_0+\Delta x) - f(x_0)} {\Delta x}$$</p>
<p>接下来我们再来看导数，导数是微积分中重要的基础概念，它描述了一个函数在某一点附近的变化率，如果函数的自变量和因变量都是实数的话，那么函数在某一点的导数就是该函数所代表的曲线在这一点上的切线斜率：</p>
<p>$$ k=df=\lim_{\Delta x-&gt;0} \frac {f(x_0+\Delta x) - f(x_0)} {\Delta x} $$</p>
<h5 id="u6781_u503C"><a href="#u6781_u503C" class="headerlink" title="极值"></a>极值</h5><p>在数学中，极大值与极小值是指在一个域上函数取得最大值或最小值的点的函数值。这个域可以是整个函数域，也可以是整个函数域中的局部域。所以一个函数有局部极大极小值，也有全局极大极小值。</p>
<p>说到极值，又不得不说到微积分中的另外一个概念，驻点。<br><img src="http://paxigrdp0.bkt.clouddn.com/0cdd7f555855ce50d285e0a1b1377b7f.jpg" alt=""></p>
<p>如上图所示，在二维坐标中展示了一个一元函数的曲线，点$A$、$B$、$C$、$D$、$E$都是该曲线上的局部极大值或局部极小值，这些点就称为驻点。在每个驻点，函数在该域的输出值停止增加或减少，即变化率为零。每个驻点其实就是局部域曲线的切点。结合上文中提到的导数是描述函数在某一点附近的变化率，所以可得一元函数的局部极值点的导数为零。</p>
<p>假设有一个一元函数$f(x)=x^2$，该函数的导数通过上面的导数公式可得$f’(x)=2x$，并且该函数代表的曲线为下凹曲线，所以该函数的最小值为$f’(x)=0$，即当$x$等于0时$f(x)$的值最小。</p>
<h4 id="u4E8C_u5143_u51FD_u6570_u7684_u6700_u5C0F_u503C"><a href="#u4E8C_u5143_u51FD_u6570_u7684_u6700_u5C0F_u503C" class="headerlink" title="二元函数的最小值"></a>二元函数的最小值</h4><p>上文中$F(a,b)$是一个二元函数，实质上道理一样，我们可以把二元函数图像设想成一个像碗一样的曲面，那么最小值就是碗底，即曲面的最凹陷部，那么从360度任意方向上看，偏导数都是0。</p>
<h5 id="u504F_u5BFC_u6570"><a href="#u504F_u5BFC_u6570" class="headerlink" title="偏导数"></a>偏导数</h5><p>在数学中，一个多元函数的偏导数是它关于其中一个变量的导数，而保持其他变量恒定。全导数自然就是所有变量的导数。函数$f$关于变量$x$的偏导数写为$f’_x$或$\frac {\partial f}{\partial x}$，偏导数符号$\partial$是全导数符号$d$的变体。</p>
<p>因为曲面上的每一个点都有无穷多条切线，所以描述这种函数的导数非常困难，所以通常选择其中一条切线，并求出它的斜率，将其他变量视为常量，这就是偏导数。</p>
<p>所以$ F(a,b) = \sum_{i=1}^n(y_i-(ax_i + b))^2 $的最小值就是分别求$a$和$b$的偏导数，然后可以得到一个关于$a$和$b$的二元方程组，就可以求出$a$和$b$了，这个方法被称为最小二乘法。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h4 id="24F_28a_2Cb_29_24_u7684_u6700_u5C0F_u503C"><a href="#24F_28a_2Cb_29_24_u7684_u6700_u5C0F_u503C" class="headerlink" title="$F(a,b)$的最小值"></a>$F(a,b)$的最小值</h4><p>首先我们把$F(a,b)$展开：</p>
<p>$$ F(a,b) = \sum_{i=1}^n(y_i-(ax_i + b))^2 \\<br>=(y_1-(ax_1 + b))^2+(y_2-(ax_2 + b))^2+…+(y_n-(ax_n + b))^2 \\<br>=(y_1^2-2y_1(ax_1+b)+(ax_1+b)^2)+(y_2^2-2y_2(ax_2+b)+(ax_2+b)^2) \\<br>+…+(y_n^2-2y_n(ax_n+b)+(ax_n+b)^2) \\<br>=y_1^2-2ay_1x_1-2by_1+a^2x_1^2+2abx_1+b^2+y_2^2-2ay_2x_2-2by_2+a^2x_2^2+2abx_2+b^2 \\<br>+…+y_n^2-2ay_nx_n-2by_n+a^2x_n^2+2abx_n+b^2 \\<br>=(y_1^2+..+y_n^2)-2a(x_1y_1+..+x_ny_n)-2b(y_1+..+y_n) \\<br>+a^2(x_1^2+..+x_n^2)+2ab(x_1+..+x_n)+nb^2 $$</p>
<p>然后利用平均数，把上面式子中每个括号里的内容进一步简化，比如：</p>
<p>$$\frac {(y_1^2+..+y_n^2)} n=\overline {y^2}$$</p>
<p>则：</p>
<p>$$(y_1^2+..+y_n^2)=n\overline{y^2}$$</p>
<p>所以$F(a,b)$可以继续简化为：</p>
<p>$$F(a,b)=n\overline{y^2}-2an\overline{xy}-2bn\overline y+a^2n\overline{x^2}+2abn\overline x+nb^2$$</p>
<p>然后我们分别对$a$和$b$求偏导数，并且令偏导等于0：</p>
<p>$$\frac {\partial F}{\partial a}=-2n\overline xy+2an\overline {x^2}+2bn\overline x=0$$</p>
<p>$$\frac {\partial F}{\partial b}=-2n\overline y+2an\overline x+2nb=0$$</p>
<p>消掉$2n$最后得到关于$a$，$b$的二元方程组为：</p>
<p>$$-\overline {xy}+a\overline {x^2}+b\overline x=0$$</p>
<p>$$-\overline y+a\overline x+b=0$$</p>
<p>最后得出a和b的求解公式：</p>
<p>$$a=\frac {\overline x \overline y-\overline {xy}} {(\overline x)^2-\overline {x^2}}$$</p>
<p>$$b=\overline y-a\overline x$$</p>
<p>将上文中的那组数据带入后可算的$a$和$b$的值：<br><img src="http://paxigrdp0.bkt.clouddn.com/4431a672dc9198ae16fc7a9b223f9f22.jpg" alt=""></p>
<p>从带入结果来看，这条回归线的函数为$f(x)=14.93x-360.88$，现在我们就可以通过回归线来做一些预测，比如上图中计算了面积为35.5平方米和55.26平方米房子的售价，分别为169.29万和464.4万。</p>
<h4 id="u8BC4_u4EF7_u56DE_u5F52_u7EBF_u7684_u62DF_u5408_u7A0B_u5EA6"><a href="#u8BC4_u4EF7_u56DE_u5F52_u7EBF_u7684_u62DF_u5408_u7A0B_u5EA6" class="headerlink" title="评价回归线的拟合程度"></a>评价回归线的拟合程度</h4><p>因为我们画出的拟合直线只是一个近似值，所以需要有一个标准来评判回归线拟合程度的好坏，即算法收敛情况。我们来看几个概念：</p>
<h5 id="u603B_u504F_u5DEE_u5E73_u65B9_u548C"><a href="#u603B_u504F_u5DEE_u5E73_u65B9_u548C" class="headerlink" title="总偏差平方和"></a>总偏差平方和</h5><p>总偏差平方和又称总平方和（SST，Sum of Squares for Total），是每个因变量的实际值与因变量的平均值的差的平方和，即反映了因变量取值的总体波动情况：</p>
<p>$$SST=\sum_{i=1}^n(y_i-\overline y)^2$$</p>
<h5 id="u56DE_u5F52_u5E73_u65B9_u548C"><a href="#u56DE_u5F52_u5E73_u65B9_u548C" class="headerlink" title="回归平方和"></a>回归平方和</h5><p>回归平方和（SSR，Sum of Squares for Regression）是因变量的回归值（回归线上的$y$值）与其平均值的差的平方和。它是由于自变量$x$的变化引起的$y$的变化，反映了$y$的总偏差中由于$x$与$y$之间的线性关系引起的$y$的变化部分：</p>
<p>$$SSR=\sum_{i=1}^n(\hat y_i-\overline y)^2$$                                                                                                         </p>
<h5 id="u8BEF_u5DEE_u5E73_u65B9_u548C"><a href="#u8BEF_u5DEE_u5E73_u65B9_u548C" class="headerlink" title="误差平方和"></a>误差平方和</h5><p>误差平方和（SSE，Sum of Squares for Error）是因变量的各实际值与回归值的差的平方和，反映了除$x$对$y$的线性影响之外的其他因素对$y$变化的作用：</p>
<p>$$SSE=SST-SSR$$</p>
<p>因为总偏差是包含了所有可能对$y$值有影响的因素，比如房子的售价不可能只有面积来决定，还包括地域、户型、楼层、楼龄等等因素。回归平方和只包含$x$对$y$变化的影响，即只是面积对售价的影响。</p>
<p>所以拟合优度$R^2=SSR/SST$或者$R^2=1-SSE/SST$，$R^2$的取值范围在0到1之间，越接近1说明拟合程度越好，说明$x$对$y$值的影响权重越大。</p>
<p>比如如果所有的点都在回归线上，那说明$SSE$等于0，则$R^2=1$，说明$y$的变化100%由$x$的变化引起，没有其他因素会影响$y$，则回归线能够完全解释$y$的变化，如果$R^2$的值很低，则说明$x$和$y$之间可能根本就不存在线性关系。<br><img src="http://paxigrdp0.bkt.clouddn.com/cc38ffff2a4ff78ca4772dcddbe4262b.jpg" alt=""></p>
<p>将数据带入计算得出最拟合优度为0.92，拟合程度还不错，说明在特定的望京区域内房屋面积是主要影响价格的因素。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>我认为从线性回归开始学习机器学习是最好的切入点，而且线性回归也是监督学习最根本的支撑，比如梯度下降等算法都需要基于线性回归的知识来理解。另外在我看来人工智能（AI）并不是要造一个机器人脑，这是伪科学。人工智能只是利用机器强大的计算能力，用数学工具，通过对大量数据的统计分析从而得出近似最优答案。所以说，人类和AlphaGO下棋，不是输在智力，而是输在身体机能。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4115205380866695"
     data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u673A_u5668_u5B66_u4E60_u7684_u5B9A_u4E49"><a href="#u673A_u5668_u5B66_u4E60_u7684_u5B9A_u4E49" class="headerlink" title="机器学习的定义"></a>机器学习的定义</h2><ul>
<li>非正式定义：在不直接针对问题进行编程的情况下，赋予计算机学习能力的一个研究领域。</li>
<li>正式定义：对于一个计算机程序来讲，给他一个任务T和一个性能测量方法P，如果在经验E的影响下P对T的测量结果得到了改进，那么就说该程序从E中得到了学习。</li>
</ul>
<p>举个机器下棋的例子，经验E对应着程序不断和自己下棋的经历，任务T是下棋，性能测量方法P可以是它在和人类棋手对弈的胜率。如果说机器与人类棋手对应的胜率不断提高，那说明机器从自己和自己下棋的过程中得到了学习。</p>
<h2 id="u673A_u5668_u5B66_u4E60_u56DB_u5927_u5185_u5BB9_u7B80_u8FF0"><a href="#u673A_u5668_u5B66_u4E60_u56DB_u5927_u5185_u5BB9_u7B80_u8FF0" class="headerlink" title="机器学习四大内容简述"></a>机器学习四大内容简述</h2><ul>
<li>监督学习（Supervised Learning）</li>
<li>学习理论（Learning Theory）</li>
<li>无监督学习（Unsupervised Learning）</li>
<li>强化学习（Reinforcement Learning）</li>
</ul>
<h3 id="u76D1_u7763_u5B66_u4E60_uFF08Supervised_Learning_uFF09"><a href="#u76D1_u7763_u5B66_u4E60_uFF08Supervised_Learning_uFF09" class="headerlink" title="监督学习（Supervised Learning）"></a>监督学习（Supervised Learning）</h3><p><img src="http://paxigrdp0.bkt.clouddn.com/34576cd0bbd2b3d3905c4c9f5a4db346.jpg" alt=""><br>如上图所示，描述了假定城市区域的房屋面积与售价的关系。横坐标是房屋面积，纵坐标是售价。如果我想在横轴随意取一个面积，就希望知道它的售价，那么就需要一个方法通过面积确定售价。图中的方法是通过一条标准线来找到对应的售价。那么这条线要如何得来呢？</p>
<p>在这个示例中，我们已经给出了若干房屋面积和售价的数据集，即已经告知了机器若干问题和答案。机器通过这些数据集中面积和售价的关系，自我学习从而得出这条线，这种学习类型就属于监督学习类型。</p>
<p>因为这种场景中的数据集取值都是连续的，所以这类问题都可以归为线性回归的问题。<br><img src="http://paxigrdp0.bkt.clouddn.com/da9d63e45fa11a781128bc64bb78ae92.jpg" alt=""></p>
<p>如上图所示，描述了肿瘤大小与恶性良性的关系。横坐标是肿瘤的大小，纵坐标表示恶性或良性，与连续的房屋售价不同的是，这里的纵坐标只有两个值0或1。</p>
<p>这个示例中，我们同样给出了一组肿瘤大小与恶性良性的数据集，我们希望机器通过这组答案数据集自我学习然后有能力通过肿瘤大小判断出恶性或良性。当然这里只是示例，实际中会有很多其他的横轴指标值用于判断学习。</p>
<p>该示例中这种离散的数值问题可以归为分类的问题。</p>
<h3 id="u5B66_u4E60_u7406_u8BBA_uFF08Learning_Theory_uFF09"><a href="#u5B66_u4E60_u7406_u8BBA_uFF08Learning_Theory_uFF09" class="headerlink" title="学习理论（Learning Theory）"></a>学习理论（Learning Theory）</h3><p>任何具体的方式方法背后都有一个或多个理论进行支撑，机器学习也不例外。</p>
<p>这一大块的内容贯穿整个机器学习，包括人工智能和机器学习正式诞生之前的定理证明，理解为什么学习型算法是有效的。每种学习型算法需要多少训练数据，比如上面的房屋售价示例到底需要多少房屋的样本。以及机器学习渗透在我们生活中的真实应用场景等等。</p>
<h3 id="u65E0_u76D1_u7763_u5B66_u4E60_uFF08Unsupervised_Learning_uFF09"><a href="#u65E0_u76D1_u7763_u5B66_u4E60_uFF08Unsupervised_Learning_uFF09" class="headerlink" title="无监督学习（Unsupervised Learning）"></a>无监督学习（Unsupervised Learning）</h3><p>如果我现在有一组不知道任何信息的数据集，然后需要机器进行分析然后给出这组数据集中的几种共性或者相似的结构，将其聚类，这个方式就称之为无监督学习。即我们不会提供机器问题和答案，只提供数据，需要机器自我学习和分析找出共性进行聚类。</p>
<p>无监督学习的应用场景很多，当下流行的各种P图软件都或多或少的用到了这类算法，比如图的修复功能，抠图功能，像素化等一些滤镜都是对像素的聚类。还有声音驳杂功能，从嘈杂的声音中提取出有用的声音等。</p>
<h3 id="u5F3A_u5316_u5B66_u4E60_uFF08Reinforcement_Learning_uFF09"><a href="#u5F3A_u5316_u5B66_u4E60_uFF08Reinforcement_Learning_uFF09" class="headerlink" title="强化学习（Reinforcement Learning）"></a>强化学习（Reinforcement Learning）</h3><p>强化学习是机器学习的精髓，更贴近机器的自我学习，用在不能通过一次决策下定论的情形中，比如分析病人肿瘤病情的例子，通过监督学习，我们给定了确切的答案，不是良性就是恶性，即我们做的决策要么对，要么错。但在强化学习中，在一段时间内会机器做出一系列决策。比如我们编写一个程序让一架无人机做出一系列特技表演动作，这种场景就不是一次决策能实现的了的。</p>
<p>那么强化学习究竟是什么？在它背后有一个称为回报函数的概念。比如我们训练宠物狗坐下、握手等行为，每当小狗做出的正确的行为，我们都会给小狗奖励，比如摸摸头进行鼓励或者给一块小骨头。渐渐的小狗就知道做出怎样的行为有奖励，怎样的行为没有奖励，即学会了坐下和握手的行为。这就很类似强化学习的理论，我们需要找到一种方式，来定义我们想要什么，如何定义一个好的行为和一个坏的行为，然后就需要一个合适的学习型算法来获得更多的回报和更少的惩罚。</p>]]>
    
    </summary>
    
      <category term="机器学习" scheme="http://www.devtalking.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于TestNG和PowerMock的单元测试指南]]></title>
    <link href="http://www.devtalking.com//articles/testng-powermock/"/>
    <id>http://www.devtalking.com//articles/testng-powermock/</id>
    <published>2017-01-18T16:00:00.000Z</published>
    <updated>2018-06-11T14:48:42.835Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u4EC0_u4E48_u662FTestNG"><a href="#u4EC0_u4E48_u662FTestNG" class="headerlink" title="什么是TestNG"></a>什么是TestNG</h2><p>TestNG是一套开源测试框架，是从JUnit继承而来，TestNG意为test next generation。它的优势如下：</p>
<ul>
<li>支持注解。</li>
<li>可以在任意的大线程池中，使用各种策略运行测试（所有方法都可以拥有自己的线程或者每个测试类拥有一个线程等等）。</li>
<li>代码多线程安全测试。</li>
<li>灵活的测试配置。</li>
<li>支持数据驱动测试(@DataProvider)。</li>
<li>支持参数。</li>
<li>强大的执行模型（不再用TestSuite）。</li>
<li>支持各种工具和插件（Eclipse、IDEA、Maven等）。</li>
<li>可以更灵活地嵌入BeanShell。</li>
<li>默认JDK运行时功能和日志记录（无依赖关系）。</li>
<li>依赖应用服务测试的方式。</li>
</ul>
<h2 id="TestNG_u7684_u6700_u7B80_u5355_u793A_u4F8B"><a href="#TestNG_u7684_u6700_u7B80_u5355_u793A_u4F8B" class="headerlink" title="TestNG的最简单示例"></a>TestNG的最简单示例</h2><p>我们先来看一个TestNG最简单的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.AfterClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.BeforeClass;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="annotation">@BeforeClass</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">"this is before class"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="annotation">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">"this is HelloWorld test case"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="annotation">@AfterClass</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">"this is after class"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从面上的简单示例中可以看出TestNG的生命周期，并且可以看到TestNG是使用注解来控制生命周期的。下面我们来看看TestNG支持的各种注解。</p>
<h2 id="TestNG_u7684_u6CE8_u89E3"><a href="#TestNG_u7684_u6CE8_u89E3" class="headerlink" title="TestNG的注解"></a>TestNG的注解</h2><p>TestNG的注解大部分用在方法级别上，一共有六大类注解。</p>
<h3 id="Before_u7C7B_u522B_u548CAfter_u7C7B_u522B_u6CE8_u89E3"><a href="#Before_u7C7B_u522B_u548CAfter_u7C7B_u522B_u6CE8_u89E3" class="headerlink" title="Before类别和After类别注解"></a>Before类别和After类别注解</h3><ul>
<li>@BeforeSuite：被注解的方法将会在所有测试类执行之前运行。</li>
<li>@AfterSuite：被注解的方法将会在所有测试类执行之后运行。</li>
<li>@BeforeTest：被注解的方法将会在当前测试类中的所有测试方法执行之前运行。</li>
<li>@AfterTest：被注解的方法将会在当前测试类中的所有测试方法执行之后运行。</li>
<li>@BeforeClass：被注解的方法将会在当前测试类中的第一个测试方法执行之前运行。</li>
<li>@AfterClass：被注解的方法将会在当前测试类中的最后一个测试方法执行之后运行。</li>
<li>@BeforeMethod：被注解的方法将会在当前测试类中的每个测试方法执行之前运行。</li>
<li>@AfterMethod：被注解的方法将会在当前测试类中的每个测试方法执行之后运行。<br>我们可以根据不同的场景来使用不同的注解。</li>
</ul>
<a id="more"></a>
<h3 id="@Test_u6CE8_u89E3"><a href="#@Test_u6CE8_u89E3" class="headerlink" title="@Test注解"></a>@Test注解</h3><p>@Test注解是TestNG的核心注解，被打上该注解的方法，表示为一个测试方法，这个注解有多个配置属性，用法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@Test</span>(param1 = ..., param2 = ...)</span><br></pre></td></tr></table></figure>
<ul>
<li>alwaysRun：如果=true，表示即使该测试方法所依赖的前置测试有失败的情况，也要执行。</li>
<li>dataProvider：选定传入参数的构造器。（后面会讲到@DataProvider注解）</li>
<li>dataProviderClass：确定参数构造器的Class类。(参数构造器首先会在当前测试类里面查找，如果参数构造器不在当前测试类定义，那么必须使用该属性来执行它所在的Class类)</li>
<li>dependsOnGroups：确定依赖的前置测试组别。</li>
<li>dependsOnMethods：确定依赖的前置测试方法。</li>
<li>description：测试方法描述信息。(建议为每个测试方法添加有意义的描述信息，这将会在最后的报告中展示出来)</li>
<li>enabled：默认为true，如果指定为false，表示不执行该测试方法。</li>
<li>expectedExceptions：指定期待测试方法抛出的异常，多个异常以逗号隔开。</li>
<li>groups：指定该测试方法所属的组，可以指定多个组，以逗号隔开。</li>
<li>invocationCount：指定测试方法需要被调用的次数。</li>
<li>invocationTimeOut：每一次调用的超时时间，如果invocationCount没有指定，该参数会被忽略。应用场景可以为测试获取数据库连接，超时就认定为失败。单位是毫秒。</li>
<li>priority：指定测试方法的优先级，数值越低，优先级越高，将会优先与其他数值高的测试方法被调用。(注意是针对一个测试类的优先级)</li>
<li>timeout：指定整个测试方法的超时时间。单位是毫秒。</li>
</ul>
<p>下面我们写一个简单的测试类，说明@Test注解的使用以及属性的配置方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnotationPropertiesTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="annotation">@Test</span>(priority = <span class="number">1</span>, invocationCount = <span class="number">3</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">"invoke test1"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="annotation">@Test</span>(priority = <span class="number">2</span>, invocationCount = <span class="number">2</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">"invoke test2"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>testng.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd" &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">suite</span> <span class="attribute">name</span>=<span class="value">"Suite1"</span> <span class="attribute">verbose</span>=<span class="value">"1"</span> &gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">test</span> <span class="attribute">name</span>=<span class="value">"test1"</span> &gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">classes</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"com.testngdemo.TestAnnotationPropertiesTest"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">classes</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">suite</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invoke test1&#10;invoke test1&#10;invoke test1&#10;invoke test2&#10;invoke test2</span><br></pre></td></tr></table></figure>
<h3 id="@Parameters_u6CE8_u89E3"><a href="#@Parameters_u6CE8_u89E3" class="headerlink" title="@Parameters注解"></a>@Parameters注解</h3><p>@Parameters 注解用于为测试方法传递参数， 用法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationParametersTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="annotation">@Parameters</span>(value = &#123;<span class="string">"param1"</span>, <span class="string">"param2"</span>&#125;)</span><br><span class="line"> <span class="annotation">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String arg1, String arg2)</span> </span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">"use @Parameters to fill method arguments : arg 1 = "</span> + arg1 + <span class="string">", arg2 = "</span> + arg2);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>testng.xml配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">test</span> <span class="attribute">name</span>=<span class="value">"testAnnotationParameters"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">parameter</span> <span class="attribute">name</span>=<span class="value">"param1"</span> <span class="attribute">value</span>=<span class="value">"value1"</span>&gt;</span><span class="tag">&lt;/<span class="title">parameter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">parameter</span> <span class="attribute">name</span>=<span class="value">"param2"</span> <span class="attribute">value</span>=<span class="value">"value2"</span>&gt;</span><span class="tag">&lt;/<span class="title">parameter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">classes</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"com.testngdemo.AnnotationParametersTest"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">classes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">test</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">use @Parameters to fill method arguments : arg 1 = value1, arg2 = value2</span><br></pre></td></tr></table></figure>
<h3 id="@DataProvider_u6CE8_u89E3"><a href="#@DataProvider_u6CE8_u89E3" class="headerlink" title="@DataProvider注解"></a>@DataProvider注解</h3><p>上面提到@Parameters注解可以为测试方法传递参数，但是这种方式参数值需要配置在testng.xml里面，灵活性不高。而@DataProvider注解同样可以为测试方法传递参数值，并且，它是真正意义上的参数构造器，可以传入多组测试数据对测试方法进行测试。被@DataProvider注解的方法，方法返回值必须为Object[][]或者Iterator<object[]>，用法如下所示：</object[]></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationDataProviderTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="annotation">@DataProvider</span>(name=<span class="string">"testMethodDataProvider"</span>)</span><br><span class="line"> <span class="keyword">public</span> Object[][] testMethodDataProvider() &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">new</span> Object[][]&#123;&#123;<span class="string">"value1-1"</span>, <span class="string">"value2-1"</span>&#125;, &#123;<span class="string">"value1-2"</span>, <span class="string">"value2-2"</span>&#125;, &#123;<span class="string">"value1-3"</span>, <span class="string">"value2-3"</span>&#125;&#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="annotation">@Test</span>(dataProvider=<span class="string">"testMethodDataProvider"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String arg1, String arg2)</span> </span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">"use @DataProvider to fill method argument : arg1 = "</span> + arg1 + <span class="string">" , arg2 = "</span> + arg2);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>testng.xml：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">test</span> <span class="attribute">name</span>=<span class="value">"testDataProvider"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">classes</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"com.testngdemo.AnnotationDataProviderTest"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">classes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">test</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">use @DataProvider to fill method argument : arg1 = value1-1 , arg2 = value2-1</span><br><span class="line">use @DataProvider to fill method argument : arg1 = value1-2 , arg2 = value2-2</span><br><span class="line">use @DataProvider to fill method argument : arg1 = value1-3 , arg2 = value2-3</span><br></pre></td></tr></table></figure>
<h3 id="@Factory__u6CE8_u89E3"><a href="#@Factory__u6CE8_u89E3" class="headerlink" title="@Factory 注解"></a>@Factory 注解</h3><p>在一个方法上面打上@Factory注解，表示该方法将返回能够被TestNG测试的测试类。利用了设计模式中的工厂模式，用法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationFactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="annotation">@Factory</span></span><br><span class="line"> <span class="keyword">public</span> Object[] getSimpleTest() &#123;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="keyword">new</span> Object[]&#123; <span class="keyword">new</span> SimpleTest(<span class="string">"one"</span>), <span class="keyword">new</span> SimpleTest(<span class="string">"two"</span>)&#125;;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> String param;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">SimpleTest</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">this</span>.param = param;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="annotation">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">"SimpleTest.param = "</span> + param);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>testng.xml配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">test</span> <span class="attribute">name</span>=<span class="value">"testFactory"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">classes</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"com.crazypig.testngdemo.AnnotationFactoryTest"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">classes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">test</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">SimpleTest.param = one</span><br><span class="line">SimpleTest.param = two</span><br></pre></td></tr></table></figure>
<h3 id="@Listeners__u6CE8_u89E3"><a href="#@Listeners__u6CE8_u89E3" class="headerlink" title="@Listeners 注解"></a>@Listeners 注解</h3><p>一般我们写测试类不会涉及到这种类型的注解，这个注解必须定义在类、接口或者枚举类级别。实用的Listener包括ISuiteListener、ITestListener和IInvokedMethodListener，他们可以在suite级别、test级别和test method一些执行点执行一些自定义操作，如打印日志等。</p>
<h2 id="TestNG_u7684_u914D_u7F6E_u6587_u4EF6"><a href="#TestNG_u7684_u914D_u7F6E_u6587_u4EF6" class="headerlink" title="TestNG的配置文件"></a>TestNG的配置文件</h2><p>在上文的示例中，出现了testng.xml这种东西，这一节就来看看TestNG的配置文件。和JUnit一样，TestNG也可以直接在测试类中针对某个测试方法运行，或者运行整个测试类。此外TestNG还提供了更强大和灵活的配置文件方式，比如在配置文件中控制测试类的执行策略，是并行还是串行，在配置文件里进行传参以及对测试类进行分组测试等。这样能让运行测试方法和测试类更有逻辑性，能灵活的应对不同的测试场景，最大化的覆盖业务场景。</p>
<p>当下，Java开发基本都使用Maven来进行依赖管理，TestNG也同样支持Maven，这样我们只需要在POM文件中将TestNG的配置文件配置进去，就可以使用mvn test来跑单元测试了。示例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>2.16<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">suiteXmlFiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">suiteXmlFile</span>&gt;</span>src/test/resources/testng.xml<span class="tag">&lt;/<span class="title">suiteXmlFile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">suiteXmlFiles</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="testng-xml_u7684_u57FA_u672C_u683C_u5F0F"><a href="#testng-xml_u7684_u57FA_u672C_u683C_u5F0F" class="headerlink" title="testng.xml的基本格式"></a>testng.xml的基本格式</h3><h4 id="u6807_u7B7E"><a href="#u6807_u7B7E" class="headerlink" title="标签"></a><suite>标签</suite></h4><p><suite>元素是testng.xml文件的根元素。从DTD文件（如下所示）可以看出，<suite>可以包含一个<groups>元素，用以定义全局的组，该组对所有的测试可见。<suite>可以包含多个<test>元素，一个<test>就定义了一个测试用例（其中可能包含多个测试方法）。</test></test></suite></groups></suite></suite></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">!ELEMENT</span> <span class="attribute">suite</span> (<span class="attribute">groups</span>?,(<span class="attribute">listeners</span>|<span class="attribute">packages</span>|<span class="attribute">test</span>|<span class="attribute">parameter</span>|<span class="attribute">method-selectors</span>|<span class="attribute">suite-files</span>)*) &gt;</span></span><br></pre></td></tr></table></figure>
<p>示例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd" &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">suite</span> <span class="attribute">name</span>=<span class="value">"Suite1"</span> <span class="attribute">verbose</span>=<span class="value">"1"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groups</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">run</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">include</span> <span class="attribute">name</span>=<span class="value">"..."</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">exclude</span> <span class="attribute">name</span>=<span class="value">"..."</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">run</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">groups</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="title">test</span> <span class="attribute">name</span>=<span class="value">"HelloWorld1"</span>&gt;</span></span><br><span class="line">       ...</span><br><span class="line">  <span class="tag">&lt;/<span class="title">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">suite</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><suite>标签中有一个重要的属性是parallel，通过该属性可以配置测试用例的线程运行策略，该属性的具体值如下：</suite></p>
<ul>
<li>methods：针对每个测试方法启独立线程运行。</li>
<li>classes：针对每个测试类启独立线程运行，该测试类中的所有测试方法均在一个线程中运行。</li>
<li>instances：针对测试类实例启独立线程运行，不同实例的相同测试方法在不同的线程中运行。</li>
</ul>
<h4 id="u6807_u7B7E-1"><a href="#u6807_u7B7E-1" class="headerlink" title="标签"></a><test>标签</test></h4><p><test>元素是<suite>的子元素，用以定义一个测试用例。定义测试用例可以通过<classes>或<packages>。</packages></classes></suite></test></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">!ELEMENT</span> <span class="attribute">test</span> (<span class="attribute">method-selectors</span>?,<span class="attribute">parameter</span>*,<span class="attribute">groups</span>?,<span class="attribute">packages</span>?,<span class="attribute">classes</span>?) &gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><classes>表示以测试类的方式定义测试用例，粒度较小。示例如下：</classes></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd" &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">suite</span> <span class="attribute">name</span>=<span class="value">"Suite1"</span> <span class="attribute">verbose</span>=<span class="value">"1"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">test</span> <span class="attribute">name</span>=<span class="value">"HelloWorld1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">classes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"test.sample.ParameterSample"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"test.sample.ParameterTest"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">classes</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">suite</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><packages>表示以测试类所在的包的方式定义测试用例，包中的所有测试类都被涉及，粒度较大。示例如下：</packages></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd" &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">suite</span> <span class="attribute">name</span>=<span class="value">"Suite1"</span> <span class="attribute">verbose</span>=<span class="value">"1"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">test</span> <span class="attribute">name</span>=<span class="value">"HelloWorld1"</span>   &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">packages</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"test.sample"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">packages</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">suite</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><test>元素中也有<groups>元素，上文中提到，<suite>中可以定义一个全局的<groups>。而这里<test>元素中也可以定义一个自己的<groups>，其中定义的组仅对当前所在的测试用例可见。示例如下：</groups></test></groups></suite></groups></test></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">test</span> <span class="attribute">name</span>=<span class="value">"HelloWorld1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">groups</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">run</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">exclude</span> <span class="attribute">name</span>=<span class="value">"brokenTests"</span>  /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">include</span> <span class="attribute">name</span>=<span class="value">"checkinTests"</span>  /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">run</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">groups</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="title">classes</span>&gt;</span></span><br><span class="line">     ...</span><br><span class="line">  <span class="tag">&lt;/<span class="title">classes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">test</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><parameters>元素可以用于在配置文件中给测试方法传递参数，在上文中的@Parameters注解一节中有示例。</parameters></li>
</ul>
<blockquote>
<p>注意：在testng.xml配置文件中，<suite>中可以定义多个<test>，那么这些<test>的执行顺序默认按照其在<suite>中出现的先后顺序。当然，也可以提供<test>的preserve-order=’false’改变默认顺序。  </test></suite></test></test></suite></p>
</blockquote>
<h4 id="u6807_u7B7E-2"><a href="#u6807_u7B7E-2" class="headerlink" title="标签"></a><classes>标签</classes></h4><p><test>可以通过<classes>或<packages>定义测试用例，但只是在测试类或类包的层次上，那么能不能具体到测试类的某个方法呢？<br>对于<classes>中的一个<class>，可以提供<methods>设置测试方法。示例如下：</methods></class></classes></packages></classes></test></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">test</span> <span class="attribute">name</span>=<span class="value">"HelloWorld1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">classes</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"test.Test1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">methods</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">include</span> <span class="attribute">name</span>=<span class="value">"m1"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">include</span> <span class="attribute">name</span>=<span class="value">"m2"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">methods</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">class</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"test.Test2"</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;/<span class="title">classes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">test</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="u4EC0_u4E48_u662FPowerMock"><a href="#u4EC0_u4E48_u662FPowerMock" class="headerlink" title="什么是PowerMock"></a>什么是PowerMock</h2><p>mock是模拟对象，用于模拟真实对象的行为。PowerMock可以支持EasyMock和Mockito，作为Mockito的扩展，使用PowerMock可以mock private方法，mock static方法，mock final方法，mock construction方法。PowerMock封装了部分Mockito的API，可以使用Mockito的语法来进行测试代码的编写。</p>
<h3 id="PowerMock_u6CE8_u89E3@PrepareForTest"><a href="#PowerMock_u6CE8_u89E3@PrepareForTest" class="headerlink" title="PowerMock注解@PrepareForTest"></a>PowerMock注解@PrepareForTest</h3><p>@PrepareForTest(Employee.class)语句告诉PowerMock准备Employee类进行测试。适用于模拟final类或有final, private, static, native方法的类 @PrepareForTest是当使用PowerMock强大的Mock静态、final、private方法时，需要添加的注解。 如果测试用例里没有使用注解@PrepareForTest，可以不加注解@RunWith(PowerMockRunner.class),反之亦然。</p>
<h3 id="PowerMockTestCase_u7236_u7C7B"><a href="#PowerMockTestCase_u7236_u7C7B" class="headerlink" title="PowerMockTestCase父类"></a>PowerMockTestCase父类</h3><p>如果想在TestNG框架下使用PowerMock，那么需要测试类继承PowerMockTestCase类，作用是告诉TestNG框架，在测试方法中会用到PowerMock的功能，比如mock static、final、private方法等。</p>
<h3 id="u6D4B_u8BD5static_u65B9_u6CD5"><a href="#u6D4B_u8BD5static_u65B9_u6CD5" class="headerlink" title="测试static方法"></a>测试static方法</h3><p>示例中的待测试类为Employee：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getEmployeeCount</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> Employee.count();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>对应的测试类为EmployeeServiceTest：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@PrepareForTest</span>(Employee.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> <span class="keyword">extends</span> <span class="title">PowerMockTestCase</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldReturnTheCountOfEmployeesUsingTheDomainClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        PowerMockito.mockStatic(Employee.class);</span><br><span class="line">        PowerMockito.when(Employee.count()).thenReturn(<span class="number">900</span>);</span><br><span class="line"></span><br><span class="line">        EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">        assertEquals(<span class="number">900</span>, employeeService.getEmployeeCount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的示例中可以看到，如果要mock静态方法，需要使用<code>mockStatic()</code>方法来mock该静态方法所属的类，然后通过PowerMock的链式语法对方法进行mock，即当调用某个方法时，我期望返回什么值，所以<code>PowerMockito.when(Employee.count()).thenReturn(900);</code>这句用大白话来翻译的话就是当调用Employee的<code>count()</code>方法时期望返回900。然后再调用要测试的方法，使用断言对结果进行验证。</p>
<h3 id="u6D4B_u8BD5_u8FD4_u56DEvoid_u7684_u9759_u6001_u65B9_u6CD5"><a href="#u6D4B_u8BD5_u8FD4_u56DEvoid_u7684_u9759_u6001_u65B9_u6CD5" class="headerlink" title="测试返回void的静态方法"></a>测试返回void的静态方法</h3><p>示例中的待测试类为EmployeeService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">giveIncrementOf</span><span class="params">(<span class="keyword">int</span> percentage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">giveIncrementToAllEmployeesOf</span><span class="params">(<span class="keyword">int</span> percentage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Employee.giveIncrementOf(percentage);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的测试类为EmployeeServiceTest：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@PrepareForTest</span>(Employee.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> <span class="keyword">extends</span> <span class="title">PowerMockTestCase</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldReturnTrueWhenIncrementOf10PercentageIsGivenSuccessfully</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        PowerMockito.mockStatic(Employee.class);</span><br><span class="line">        PowerMockito.doNothing().when(Employee.class);</span><br><span class="line">        Employee.giveIncrementOf(<span class="number">10</span>);</span><br><span class="line">        EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">        assertTrue(employeeService.giveIncrementToAllEmployeesOf(<span class="number">10</span>));    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldReturnFalseWhenIncrementOf10PercentageIsNotGivenSuccessfully</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        PowerMockito.mockStatic(Employee.class);</span><br><span class="line">        PowerMockito.doThrow(<span class="keyword">new</span> IllegalStateException()).when(Employee.class);</span><br><span class="line">        Employee.giveIncrementOf(<span class="number">10</span>);</span><br><span class="line">        EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">        assertFalse(employeeService.giveIncrementToAllEmployeesOf(<span class="number">10</span>));</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例中展示了调用方法不触发实现逻辑及抛异常的PowerMock方法<code>doNothing()</code>和<code>doThrow()</code>。</p>
<ul>
<li><code>doNothing()</code>：该方法告诉PowerMock下一个方法调用时什么也不做。</li>
<li><code>doThrow()</code>：该方法告诉PowerMock下一个方法调用时产生给定异常。</li>
</ul>
<h3 id="u9A8C_u8BC1_u65B9_u6CD5_u662F_u5426_u8C03_u7528"><a href="#u9A8C_u8BC1_u65B9_u6CD5_u662F_u5426_u8C03_u7528" class="headerlink" title="验证方法是否调用"></a>验证方法是否调用</h3><p>示例中的待测试类为EmployeeService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(employee.isNew()) &#123;</span><br><span class="line">            employee.create();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        employee.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">giveIncrementOf</span><span class="params">(<span class="keyword">int</span> percentage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>对应的测试类为EmployeeServiceTest：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> <span class="keyword">extends</span> <span class="title">PowerMockTestCase</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldCreateNewEmployeeIfEmployeeIsNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Employee mock = PowerMockito.mock(Employee.class);</span><br><span class="line">        PowerMockito.when(mock.isNew()).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">        EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">        employeeService.saveEmployee(mock);</span><br><span class="line">        Mockito.verify(mock).create();</span><br><span class="line">        Mockito.verify(mock, Mockito.never()).update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的示例中看到，首先使用了<code>PowerMockito.mock()</code>而不是<code>PowerMockito.mockStaic()</code>，因为我们要测试的不是静态方法。<code>Mockito.verify(mock).create()</code>验证调用了<code>create()</code>方法。 <code>Mockito.verify(mock, Mockito.never()).update()</code>验证没有调用<code>update()</code>方法。</p>
<p>我们再来看看如何验证静态方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">giveIncrementOf</span><span class="params">(<span class="keyword">int</span> percentage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">giveIncrementToAllEmployeesOf</span><span class="params">(<span class="keyword">int</span> percentage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Employee.giveIncrementOf(percentage);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> <span class="keyword">extends</span> <span class="title">PowerMockTestCase</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldInvoke_giveIncrementOfMethodOnEmployeeWhileGivingIncrement</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        PowerMockito.mockStatic(Employee.class);</span><br><span class="line">        PowerMockito.doNothing().when(Employee.class);</span><br><span class="line">        Employee.giveIncrementOf(<span class="number">9</span>);</span><br><span class="line">        EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">        employeeService.giveIncrementToAllEmployeesOf(<span class="number">9</span>);</span><br><span class="line">        PowerMockito.verifyStatic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先还是使用<code>PowerMockito.mockStatic()</code>方法进行mock，然后使用<code>PowerMockito.verifyStatic()</code>验证静态方法是否调用。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h3 id="u9A8C_u8BC1_u65B9_u6CD5_u7684_u8C03_u7528_u6B21_u6570_u53CA_u8C03_u7528_u987A_u5E8F"><a href="#u9A8C_u8BC1_u65B9_u6CD5_u7684_u8C03_u7528_u6B21_u6570_u53CA_u8C03_u7528_u987A_u5E8F" class="headerlink" title="验证方法的调用次数及调用顺序"></a>验证方法的调用次数及调用顺序</h3><p>示例中的待测试类为EmployeeService：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(employee.isNew()) &#123;</span><br><span class="line">            employee.create();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        employee.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">giveIncrementOf</span><span class="params">(<span class="keyword">int</span> percentage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>对应的测试类为EmployeeServiceTest：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldInvokeIsNewBeforeInvokingCreate</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">       Employee mock = PowerMockito.mock(Employee.class);</span><br><span class="line">       PowerMockito.when(mock.isNew()).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">       EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">       employeeService.saveEmployee(mock);</span><br><span class="line">       InOrder inOrder = Mockito.inOrder(mock);</span><br><span class="line">       inOrder.verify(mock).isNew();</span><br><span class="line">       inOrder.verify(mock).create();</span><br><span class="line">       Mockito.verify(mock, Mockito.never()).update();</span><br><span class="line">	  Mockito.verify(mock, Mockito.times(<span class="number">1</span>)).isNew();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例中，通过<code>Mockito.inOrder()</code>方法通过mock的对象构造了<code>InOrder</code>对象，然后按期望的顺序验证方法的调用顺序。<code>Mockito.verify(mock, Mockito.times(1)).isNew()</code>这句的意思是验证<code>Employee</code>类的<code>isNew()</code>方法调用了一次，除此之外，还能验证一些其他的调用次数策略：</p>
<ul>
<li><code>Mockito.times(int n)</code>： 准确的验证方法调用的次数。</li>
<li><code>Mockito.atLeastOnce()</code>： 验证方法至少调用一次 。</li>
<li><code>Mockito.atLeast(int n)</code>： 验证方法最少调用次数 。</li>
<li><code>Mockito.atMost(int n)</code>： 验证方法最多调用次数。</li>
</ul>
<h3 id="u6D4B_u8BD5final_u7C7B_u6216_u65B9_u6CD5"><a href="#u6D4B_u8BD5final_u7C7B_u6216_u65B9_u6CD5" class="headerlink" title="测试final类或方法"></a>测试final类或方法</h3><p>示例中的待测试类为<code>EmployeeGenerator</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeIdGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmployeeId</span><span class="params">(<span class="keyword">int</span> nextId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(employee.isNew()) &#123;</span><br><span class="line">            employee.setEmployeeId(EmployeeIdGenerator.getNextId());</span><br><span class="line">            employee.create();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        employee.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类为<code>EmployeeServiceTest</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@PrepareForTest</span>(EmployeeIdGenerator.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> <span class="keyword">extends</span> <span class="title">PowerMockTestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldGenerateEmployeeIdIfEmployeeIsNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Employee mock = PowerMockito.mock(Employee.class);</span><br><span class="line">        PowerMockito.when(mock.isNew()).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">        PowerMockito.mockStatic(EmployeeIdGenerator.class);</span><br><span class="line">        PowerMockito.when(EmployeeIdGenerator.getNextId()).thenReturn(<span class="number">90</span>);</span><br><span class="line">        EmployeeService employeeService = <span class="keyword">new</span></span><br><span class="line">        EmployeeService();</span><br><span class="line">        employeeService.saveEmployee(mock);</span><br><span class="line">        PowerMockito.verifyStatic();</span><br><span class="line">        EmployeeIdGenerator.getNextId();</span><br><span class="line">        Mockito.verify(mock).setEmployeeId(<span class="number">90</span>);</span><br><span class="line">        Mockito.verify(mock).create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从示例中看到，测试方法体中并没有什么特殊的存在，只是在<code>EmployeeServiceTest</code>类上使用了<code>@PrepareForTest</code>注解来申明将要用到PowerMock的能力。</p>
<h3 id="u6D4B_u8BD5_u6784_u9020_u65B9_u6CD5"><a href="#u6D4B_u8BD5_u6784_u9020_u65B9_u6CD5" class="headerlink" title="测试构造方法"></a>测试构造方法</h3><p>示例中的待测试类为<code>WelcomeEmail</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeEmail</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WelcomeEmail</span><span class="params">(<span class="keyword">final</span> Employee employee, <span class="keyword">final</span> String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(employee.isNew()) &#123;</span><br><span class="line">            employee.setEmployeeId(EmployeeIdGenerator.getNextId());</span><br><span class="line">            employee.create();</span><br><span class="line">            WelcomeEmail emailSender = <span class="keyword">new</span> WelcomeEmail(employee,</span><br><span class="line">            <span class="string">"Welcome to Mocking with PowerMock How-to!"</span>);</span><br><span class="line">            emailSender.send();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        employee.update();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类为<code>WelcomeEmailTest</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">WelcomeEmailTest</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@PrepareForTest</span>(&#123;EmployeeIdGenerator.class, EmployeeService.class&#125;)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> <span class="keyword">extends</span> <span class="title">PowerMockTestCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Test</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldSendWelcomeEmailToNewEmployees</span><span class="params">()</span><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Employee employeeMock = PowerMockito.mock(Employee.class);</span><br><span class="line">            PowerMockito.when(employeeMock.isNew()).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">            PowerMockito.mockStatic(EmployeeIdGenerator.class);</span><br><span class="line">            WelcomeEmail welcomeEmailMock = PowerMockito.mock(WelcomeEmail.class);</span><br><span class="line">            PowerMockito.whenNew(WelcomeEmail.class).withArguments(employeeMock, <span class="string">"Welcome"</span>).thenReturn(welcomeEmailMock);</span><br><span class="line">            EmployeeService employeeService = <span class="keyword">new</span> EmployeeService();</span><br><span class="line">            employeeService.saveEmployee(employeeMock);</span><br><span class="line"></span><br><span class="line">            PowerMockito.verifyNew(WelcomeEmail.class).withArguments(employeeMock, <span class="string">"Welcome"</span>);</span><br><span class="line">            Mockito.verify(welcomeEmailMock).send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面示例中可以看到，通过PowerMock的链式语法<code>PowerMockito.whenNew().withArguments().thenReturn()</code><br>可以mock类的构造函数，通过<code>PowerMockito.verifyNew().withArguments()</code>验证类的构造函数。</p>
<h3 id="Answer_u6A21_u5F0F"><a href="#Answer_u6A21_u5F0F" class="headerlink" title="Answer模式"></a>Answer模式</h3><p>在某些边缘的情况下不可能通过简单地通过<code>PowerMockito.when().thenReturn()</code>对方法进行模拟，这时可以使用Answer接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldReturnCountOfEmployeesFromTheServiceWithDefaultAnswer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			Employee employeeMock = PowerMockito.mock(Employee.class);</span><br><span class="line">         	PowerMockito.when(employeeMock.isNew()).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">       	EmployeeService mock = PowerMockito.mock(EmployeeService.class, <span class="keyword">new</span> Answer() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">answer</span><span class="params">(InvocationOnMock invocation)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        	&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例中，被mock的<code>EmployeeService</code>类调用任何方法都会返回10，因为都会响应Answer接口的<code>answewr</code>方法。此时我们就需要<code>InbocationOnMock</code>类提供的方法进行响应分流，它支持的方法如下：</p>
<ul>
<li><code>callRealMethod()</code>：调用真正的方法 。</li>
<li><code>getArguments()</code>：获取所有参数。</li>
<li><code>getMethod()</code>：返回mock实例调用的方法。</li>
<li><code>getMock()</code>：获取mock实例。</li>
</ul>
<h3 id="u4F7F_u7528spy_u8FDB_u884C_u90E8_u5206_u6A21_u62DF"><a href="#u4F7F_u7528spy_u8FDB_u884C_u90E8_u5206_u6A21_u62DF" class="headerlink" title="使用spy进行部分模拟"></a>使用spy进行部分模拟</h3><p>示例中的待测试类<code>EmployeeService</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(employee.isNew()) &#123;</span><br><span class="line">            createEmployee(employee);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        employee.update();</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        employee.setEmployeeId(EmployeeIdGenerator.getNextId());</span><br><span class="line">        employee.create();</span><br><span class="line">        WelcomeEmail emailSender = <span class="keyword">new</span> WelcomeEmail(employee,</span><br><span class="line">        <span class="string">"Welcome"</span>);</span><br><span class="line">        emailSender.send();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>测试类<code>EmployeeServiceTest</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> <span class="keyword">extends</span> <span class="title">PowerMockTestCase</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldInvokeTheCreateEmployeeMethodWhileSavingANewEmployee</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> EmployeeService spy = PowerMockito.spy(<span class="keyword">new</span> EmployeeService());</span><br><span class="line">        <span class="keyword">final</span> Employee employeeMock = PowerMockito.mock(Employee.class);</span><br><span class="line">        PowerMockito.when(employeeMock.isNew()).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">        PowerMockito.doNothing().when(spy).createEmployee(employeeMock);</span><br><span class="line">        spy.saveEmployee(employeeMock);</span><br><span class="line">        Mockito.verify(spy).createEmployee(employeeMock);      </span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>被<code>PowerMockito.spy()</code>的类，它的方法只能使用<code>PowerMockito.doNothing()</code>、<code>PowerMockito.doReturn()</code>、<code>PowerMockito.doThrow()</code>来模拟，否则调用方法时都是真实调用。也就是说被mock的类，里面的方法全都是被mock的，如果想真实调用某个方法，需要用callRealMethod方法。被spy的类，里面的方法是没有被mock的，调用时候是真实调用，除非单独mock里面的某个方法。</p>
<h3 id="u6A21_u62DF_u79C1_u6709_u65B9_u6CD5"><a href="#u6A21_u62DF_u79C1_u6709_u65B9_u6CD5" class="headerlink" title="模拟私有方法"></a>模拟私有方法</h3><p>示例中待测试的类为<code>EmployeeService</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createEmployee</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        employee.setEmployeeId(EmployeeIdGenerator.getNextId());</span><br><span class="line">        employee.create();</span><br><span class="line">        WelcomeEmail emailSender = <span class="keyword">new</span> WelcomeEmail(employee, <span class="string">"Welcome"</span>);</span><br><span class="line">        emailSender.send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类为<code>EmployeeServiceTest</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>   <span class="title">EmployeeServiceTest</span></span>&#123;</span><br><span class="line"><span class="annotation">@PrepareForTest</span>(&#123;EmployeeIdGenerator.class, EmployeeService.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceTest</span> <span class="keyword">extends</span> <span class="title">PowerMockTestCase</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldInvokeTheCreateEmployeeMethodWhileSavingANewEmployee</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> EmployeeService spy = PowerMockito.spy(<span class="keyword">new</span> EmployeeService());</span><br><span class="line">        <span class="keyword">final</span> Employee employeeMock = PowerMockito.mock(Employee.class);</span><br><span class="line">        PowerMockito.when(employeeMock.isNew()).thenReturn(<span class="keyword">true</span>);</span><br><span class="line">        PowerMockito.doNothing().when(spy, <span class="string">"createEmployee"</span>, employeeMock);</span><br><span class="line">        spy.saveEmployee(employeeMock);</span><br><span class="line">        PowerMockito.verifyPrivate(spy).invoke(<span class="string">"createEmployee"</span>, employeeMock);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从示例中看到，测试方法体中同样没有什么特殊的存在，只是在<code>EmployeeServiceTest</code>类上使用了两个注解来申明将要用到PowerMock的能力。</p>
<h3 id="TestNG_u548CPowerMock_u7684Maven_u914D_u7F6E"><a href="#TestNG_u548CPowerMock_u7684Maven_u914D_u7F6E" class="headerlink" title="TestNG和PowerMock的Maven配置"></a>TestNG和PowerMock的Maven配置</h3><p>在Maven的pom文件中需要配置如下信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.powermock<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>powermock-api-mockito<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.powermock<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>powermock-api-support<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.powermock<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>powermock-module-testng<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.powermock<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>powermock-module-testng-common<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.testng<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>testng<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">version</span>&gt;</span>6.10<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="title">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="u5355_u5143_u6D4B_u8BD5_u89C4_u8303"><a href="#u5355_u5143_u6D4B_u8BD5_u89C4_u8303" class="headerlink" title="单元测试规范"></a>单元测试规范</h2><p>我们后端Java开发需要使用上述的TestNG和PowerMock两个工具进行单元测试编写，以下是我们应该遵循的一些规范：</p>
<ul>
<li>Team Leader在将PRD拆分为开发任务时，对任务的估时要包含单元测试的编写时间。</li>
<li>Team Leader在Review时，单元测试是否编写和功能性是否开发完成同等重要，即一个任务的交付不只是功能按需开发完毕，同时要包含完整的单元测试。</li>
<li>我们现在开发实体时都是基于标准自定义实体的流程进行开发，即每个实体都会有一个XXXBusinessService，那么对应的测试类应该是XXXBusinessServiceTest。</li>
<li>在SaaS层做单元测试，只对业务逻辑进行验证，所有用到的Paas层的服务及SaaS层的其他服务都需要进行mock，即我们这层的单元测试不会真正的对DAO进行操作。</li>
<li>测试中需要用的mock类和参数应该在前置方法中统一处理，测试方法中按需使用即可，如有特别需要的，可以在测试方法中单独处理。</li>
<li>每个XXXBusinessService中的方法应该对应多个测试方法，即方法体里的每个分支对应一个测试方法，这里的分支指<code>if else</code>、<code>try catch</code>、<code>switch case</code>。</li>
<li>每个待测方法至少应该有对应的三个测试方法：<ul>
<li>对入参健壮性校验的测试方法。</li>
<li>正向主业务逻辑的测试方法。</li>
<li>反向主业务逻辑的测试方法。 </li>
</ul>
</li>
<li>测试方法中要进行方法是否调用的验证、方法调用次数的验证、返回结果的预期验证。</li>
<li>如果被测试的public方法中用了private方法，那么需要对private方法进行mock。然后单独对该private方法写单元测试进行验证。</li>
<li>单元测试写完后，之后只要对方法进行修改，在提交前必须要全局跑一遍单元测试，保证没有问题后再提交代码。</li>
<li>测试方法的命名使用驼峰形式，并且要尽可能表达测试目的，比如<code>public void shouldInvokeTheCreateEmployeeMethodWhileSavingANewEmployee()</code>。</li>
<li>测试方法除了命名以外，重要逻辑需要有注释进行补充说明。</li>
</ul>
<h2 id="u5355_u5143_u6D4B_u8BD5_u793A_u4F8B"><a href="#u5355_u5143_u6D4B_u8BD5_u793A_u4F8B" class="headerlink" title="单元测试示例"></a>单元测试示例</h2><p>下面以派工的一个方法为例，待测试类为<code>FieldJobBusinessServiceImpl</code>，待测试的方法为<code>querySupportStaff</code>，测试类为<code>FieldJobBusinessServiceImplTest</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待测方法</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProcessorResult <span class="title">querySupportStaff</span><span class="params">(String operation, Long referEntityId, BusinessWebContext businessWebContext)</span> </span>&#123;</span><br><span class="line">        ProcessorResult processorResult = <span class="keyword">new</span> ProcessorResult();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(operation))&#123;</span><br><span class="line">            processorResult.setStatusCode(CodeMessage.PARAM_NULL_ERR.getCode());</span><br><span class="line">            processorResult.setMessage(CodeMessage.PARAM_NULL_ERR.getMsg());</span><br><span class="line">            <span class="keyword">return</span> processorResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!operation.equals(create) &amp;&amp; !operation.equals(assign) &amp;&amp; !operation.equals(transfer))&#123;</span><br><span class="line">            processorResult.setStatusCode(CodeMessage.PARAM_FORMAT_ERR.getCode());</span><br><span class="line">            processorResult.setMessage(CodeMessage.PARAM_FORMAT_ERR.getMsg());</span><br><span class="line">            <span class="keyword">return</span> processorResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(operation.equals(create))&#123;</span><br><span class="line">            processorResult = queryStaff4Create(referEntityId, businessWebContext);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(operation.equals(assign) || operation.equals(transfer))&#123;</span><br><span class="line">            processorResult = queryStaff4AssignOrTransfer(businessWebContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> processorResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面的待测方法一共有四个分支，方法实现时用到了两个私有方法<code>queryStaff4Create</code>和<code>queryStaff4AssignOrTransfer</code>。测试类中对该方法的测试方法有五个，分别为：</p>
<ul>
<li>参数为空时的测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * 测试参数为空时的逻辑</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">querySupportStaffWithNullParameters</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String operation = <span class="keyword">null</span>;</span><br><span class="line">        Long referEntityId = <span class="keyword">null</span>;</span><br><span class="line">        ProcessorResult processorResult = fieldJobBusinessServiceImpl.querySupportStaff(operation, referEntityId, businessWebContext);</span><br><span class="line">        Assert.assertTrue(processorResult.getStatusCode() == CodeMessage.PARAM_NULL_ERR.getCode());</span><br><span class="line">        Assert.assertTrue(processorResult.getMessage().equals(CodeMessage.PARAM_NULL_ERR.getMsg()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数格式不正确时的测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * 测试参数格式不正确时的逻辑</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">querySupportStaffWithWrongParameters</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String operation = <span class="string">"wrong operation"</span>;</span><br><span class="line">        Long referEntityId = <span class="keyword">null</span>;</span><br><span class="line">        ProcessorResult processorResult = fieldJobBusinessServiceImpl.querySupportStaff(operation, referEntityId, businessWebContext);</span><br><span class="line">        Assert.assertTrue(processorResult.getStatusCode() == CodeMessage.PARAM_FORMAT_ERR.getCode());</span><br><span class="line">        Assert.assertTrue(processorResult.getMessage().equals(CodeMessage.PARAM_FORMAT_ERR.getMsg()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建派工单时，获取所有人场景的测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * 测试操作参数为create时的逻辑，即创建派工单时，获取所有人调用</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">querySupportStaffWithCreateOperation</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String operation = <span class="string">"create"</span>;</span><br><span class="line">        Long referEntityId = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        ProcessorResult mockSuccessProcessorResult = <span class="keyword">new</span> ProcessorResult();</span><br><span class="line">        mockSuccessProcessorResult.setStatusCode(CodeMessage.SUCCESS.getCode());</span><br><span class="line">        mockSuccessProcessorResult.setMessage(CodeMessage.SUCCESS.getMsg());</span><br><span class="line"></span><br><span class="line">        FieldJobBusinessServiceImpl spyFieldJobBusinessServiceImpl = PowerMockito.spy(<span class="keyword">new</span> FieldJobBusinessServiceImpl());</span><br><span class="line">        <span class="comment">// 在public方法中mock掉private方法，后面会对private方法写单独的单元测试，这里当调用queryStaff4Create方法时什么也不做，并直接返回上面构造好的成功的ProcessorResult</span></span><br><span class="line">        PowerMockito.doReturn(mockSuccessProcessorResult).when(spyFieldJobBusinessServiceImpl,<span class="string">"queryStaff4Create"</span>, Mockito.any(Long.class), Mockito.any(BusinessWebContext.class));</span><br><span class="line"></span><br><span class="line">        ProcessorResult processorResult = spyFieldJobBusinessServiceImpl.querySupportStaff(operation, referEntityId, businessWebContext);</span><br><span class="line">        <span class="comment">// 验证queryStaff4Create方法被调用，并且只被调用过一次</span></span><br><span class="line">        PowerMockito.verifyPrivate(spyFieldJobBusinessServiceImpl, Mockito.times(<span class="number">1</span>)).invoke(<span class="string">"queryStaff4Create"</span>, referEntityId, businessWebContext);</span><br><span class="line">        <span class="comment">// 验证queryStaff4AssignOrTransfer方法没有被调用过</span></span><br><span class="line">        PowerMockito.verifyPrivate(spyFieldJobBusinessServiceImpl, Mockito.never()).invoke(<span class="string">"queryStaff4AssignOrTransfer"</span>, businessWebContext);</span><br><span class="line">        Assert.assertTrue(processorResult.getStatusCode() == CodeMessage.SUCCESS.getCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分配派工单时，获取所有人场景的测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * 测试操作参数为assign时的逻辑，即分配派工单时，获取所有人调用</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">querySupportStaffWithAssignOperation</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String operation = <span class="string">"assign"</span>;</span><br><span class="line">        Long referEntityId = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        ProcessorResult mockSuccessProcessorResult = <span class="keyword">new</span> ProcessorResult();</span><br><span class="line">        mockSuccessProcessorResult.setStatusCode(CodeMessage.SUCCESS.getCode());</span><br><span class="line">        mockSuccessProcessorResult.setMessage(CodeMessage.SUCCESS.getMsg());</span><br><span class="line"></span><br><span class="line">        FieldJobBusinessServiceImpl spyFieldJobBusinessServiceImpl = PowerMockito.spy(<span class="keyword">new</span> FieldJobBusinessServiceImpl());</span><br><span class="line">        <span class="comment">// 在public方法中mock掉private方法，后面会对private方法写单独的单元测试，这里当调用queryStaff4AssignOrTransfer方法时什么也不做，并直接返回上面构造好的成功的ProcessorResult</span></span><br><span class="line">        PowerMockito.doReturn(mockSuccessProcessorResult).when(spyFieldJobBusinessServiceImpl,<span class="string">"queryStaff4AssignOrTransfer"</span>, Mockito.any(BusinessWebContext.class));</span><br><span class="line"></span><br><span class="line">        ProcessorResult processorResult = spyFieldJobBusinessServiceImpl.querySupportStaff(operation, referEntityId, businessWebContext);</span><br><span class="line">        <span class="comment">// 验证queryStaff4AssignOrTransfer方法被调用，并且只被调用过一次</span></span><br><span class="line">        PowerMockito.verifyPrivate(spyFieldJobBusinessServiceImpl, Mockito.times(<span class="number">1</span>)).invoke(<span class="string">"queryStaff4AssignOrTransfer"</span>, businessWebContext);</span><br><span class="line">        <span class="comment">// 验证queryStaff4Create方法没有被调用过</span></span><br><span class="line">        PowerMockito.verifyPrivate(spyFieldJobBusinessServiceImpl, Mockito.never()).invoke(<span class="string">"queryStaff4Create"</span>, referEntityId, businessWebContext);</span><br><span class="line">        Assert.assertTrue(processorResult.getStatusCode() == CodeMessage.SUCCESS.getCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>转移派工单时，获取所有人场景的测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * 测试操作参数为transfer时的逻辑，即转移派工单时，获取所有人调用</span><br><span class="line">     * <span class="doctag">@throws</span> Exception</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">querySupportStaffWithTransferOperation</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String operation = <span class="string">"transfer"</span>;</span><br><span class="line">        Long referEntityId = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        ProcessorResult mockSuccessProcessorResult = <span class="keyword">new</span> ProcessorResult();</span><br><span class="line">        mockSuccessProcessorResult.setStatusCode(CodeMessage.SUCCESS.getCode());</span><br><span class="line">        mockSuccessProcessorResult.setMessage(CodeMessage.SUCCESS.getMsg());</span><br><span class="line"></span><br><span class="line">        FieldJobBusinessServiceImpl spyFieldJobBusinessServiceImpl = PowerMockito.spy(<span class="keyword">new</span> FieldJobBusinessServiceImpl());</span><br><span class="line">        <span class="comment">// 在public方法中mock掉private方法，后面会对private方法写单独的单元测试，这里当调用queryStaff4AssignOrTransfer方法时什么也不做，并直接返回上面构造好的成功的ProcessorResult</span></span><br><span class="line">        PowerMockito.doReturn(mockSuccessProcessorResult).when(spyFieldJobBusinessServiceImpl,<span class="string">"queryStaff4AssignOrTransfer"</span>, Mockito.any(BusinessWebContext.class));</span><br><span class="line"></span><br><span class="line">        ProcessorResult processorResult = spyFieldJobBusinessServiceImpl.querySupportStaff(operation, referEntityId, businessWebContext);</span><br><span class="line">        <span class="comment">// 验证queryStaff4AssignOrTransfer方法被调用，并且只被调用过一次</span></span><br><span class="line">        PowerMockito.verifyPrivate(spyFieldJobBusinessServiceImpl, Mockito.times(<span class="number">1</span>)).invoke(<span class="string">"queryStaff4AssignOrTransfer"</span>, businessWebContext);</span><br><span class="line">        <span class="comment">// 验证queryStaff4Create方法没有被调用过</span></span><br><span class="line">        PowerMockito.verifyPrivate(spyFieldJobBusinessServiceImpl, Mockito.never()).invoke(<span class="string">"queryStaff4Create"</span>, referEntityId, businessWebContext);</span><br><span class="line">        Assert.assertTrue(processorResult.getStatusCode() == CodeMessage.SUCCESS.getCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的测试方法中可以看到，对用到的私有方法进行了mock，并且对方法的调用进行了验证。代码中都有注释，这里不再累赘。测试方法写完后，将其配置在TestNG的配置文件中<code>/scr/test/resources/testng.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE suite SYSTEM "http://testng.org/testng-1.0.dtd" &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">suite</span> <span class="attribute">name</span>=<span class="value">"Field Service Cloud"</span> <span class="attribute">verbose</span>=<span class="value">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">test</span> <span class="attribute">name</span>=<span class="value">"FieldJobBusinessService"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">classes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"com.rkhd.business.fsc.fieldjob.FieldJobBusinessServiceTest"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">methods</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">name</span>=<span class="value">"querySupportStaffWithNullParameters"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">name</span>=<span class="value">"querySupportStaffWithWrongParameters"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">name</span>=<span class="value">"querySupportStaffWithCreateOperation"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">name</span>=<span class="value">"querySupportStaffWithAssignOperation"</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="title">include</span> <span class="attribute">name</span>=<span class="value">"querySupportStaffWithTransferOperation"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="title">methods</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">classes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">suite</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以后有可能整个manager-service会共用一个配置文件，所以使用<code>&lt;suite&gt;</code>作为产品线的区分，使用<code>&lt;test&gt;</code>作为实体的区分，鼠标右键点击该配置文件，即可看到执行测试的选项。</p>
<p>针对<code>querySupportStaff</code>方法，以上这个五个测试方法可以完全覆盖该方法承载的业务逻辑和场景，并且达到了该方法内百分百的代码覆盖率。使用IDEA的Coverage插件，可以计算测试方法对代码的覆盖率，并可以生成HTML文档。</p>
<p>虽然<code>querySupportStaff</code>测试完了，但是其中的两个私有方法是被mock掉的，并且是都是待测类中的方法，所以接下来就需要对这两个私有方法单独再写单元测试进行验证，写单元测试的规则与规范和<code>querySupportStaff</code>方法的单元测试一致。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>希望该文档能作为后端Java开发保证代码质量的指导手册，养成良好的单元测试编写习惯，最终让我们具备认为完成功能开发只是完成了一半任务的优秀素养。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4115205380866695"
     data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u4EC0_u4E48_u662FTestNG"><a href="#u4EC0_u4E48_u662FTestNG" class="headerlink" title="什么是TestNG"></a>什么是TestNG</h2><p>TestNG是一套开源测试框架，是从JUnit继承而来，TestNG意为test next generation。它的优势如下：</p>
<ul>
<li>支持注解。</li>
<li>可以在任意的大线程池中，使用各种策略运行测试（所有方法都可以拥有自己的线程或者每个测试类拥有一个线程等等）。</li>
<li>代码多线程安全测试。</li>
<li>灵活的测试配置。</li>
<li>支持数据驱动测试(@DataProvider)。</li>
<li>支持参数。</li>
<li>强大的执行模型（不再用TestSuite）。</li>
<li>支持各种工具和插件（Eclipse、IDEA、Maven等）。</li>
<li>可以更灵活地嵌入BeanShell。</li>
<li>默认JDK运行时功能和日志记录（无依赖关系）。</li>
<li>依赖应用服务测试的方式。</li>
</ul>
<h2 id="TestNG_u7684_u6700_u7B80_u5355_u793A_u4F8B"><a href="#TestNG_u7684_u6700_u7B80_u5355_u793A_u4F8B" class="headerlink" title="TestNG的最简单示例"></a>TestNG的最简单示例</h2><p>我们先来看一个TestNG最简单的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.AfterClass;</span><br><span class="line"><span class="keyword">import</span> org.junit.BeforeClass;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="annotation">@BeforeClass</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">"this is before class"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="annotation">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">"this is HelloWorld test case"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="annotation">@AfterClass</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	System.out.println(<span class="string">"this is after class"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从面上的简单示例中可以看出TestNG的生命周期，并且可以看到TestNG是使用注解来控制生命周期的。下面我们来看看TestNG支持的各种注解。</p>
<h2 id="TestNG_u7684_u6CE8_u89E3"><a href="#TestNG_u7684_u6CE8_u89E3" class="headerlink" title="TestNG的注解"></a>TestNG的注解</h2><p>TestNG的注解大部分用在方法级别上，一共有六大类注解。</p>
<h3 id="Before_u7C7B_u522B_u548CAfter_u7C7B_u522B_u6CE8_u89E3"><a href="#Before_u7C7B_u522B_u548CAfter_u7C7B_u522B_u6CE8_u89E3" class="headerlink" title="Before类别和After类别注解"></a>Before类别和After类别注解</h3><ul>
<li>@BeforeSuite：被注解的方法将会在所有测试类执行之前运行。</li>
<li>@AfterSuite：被注解的方法将会在所有测试类执行之后运行。</li>
<li>@BeforeTest：被注解的方法将会在当前测试类中的所有测试方法执行之前运行。</li>
<li>@AfterTest：被注解的方法将会在当前测试类中的所有测试方法执行之后运行。</li>
<li>@BeforeClass：被注解的方法将会在当前测试类中的第一个测试方法执行之前运行。</li>
<li>@AfterClass：被注解的方法将会在当前测试类中的最后一个测试方法执行之后运行。</li>
<li>@BeforeMethod：被注解的方法将会在当前测试类中的每个测试方法执行之前运行。</li>
<li>@AfterMethod：被注解的方法将会在当前测试类中的每个测试方法执行之后运行。<br>我们可以根据不同的场景来使用不同的注解。</li>
</ul>]]>
    
    </summary>
    
      <category term="TestNG" scheme="http://www.devtalking.com/tags/TestNG/"/>
    
      <category term="Unit Test" scheme="http://www.devtalking.com/tags/Unit-Test/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Google力推的那些前端技术，最近有何进展？》笔记]]></title>
    <link href="http://www.devtalking.com//articles/google-web-tech/"/>
    <id>http://www.devtalking.com//articles/google-web-tech/</id>
    <published>2017-01-08T16:00:00.000Z</published>
    <updated>2018-06-01T17:22:58.513Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>Google是一个伟大的公司，有很多伟大的产品。从Google一直不做桌面系统和对Chrome的大力发展来看，Google对前端事业是非常热衷的。</p>
<h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><p>Angular、React、Vue是目前前端框架的三驾马车。我在16年9月写过一篇文章<a href="http://www.devtalking.com/articles/angularjs1x-guide/">《温故而知新-AngularJS 1.x 小记》</a>，当时还叫AngularJS，版本是1.X，那时已经很惊艳了，把前端解释性的脚本语言封装成了面向对象的编程模式，另外对HTML的元素维护提供了便利的方式方法。当时我负责的BPM产品，Process Builder的前端架构果断更新为了AngularJS。时隔两年多，Angular 6都已经发布了，如果我还有机会做前端产品的话，我应该还是会果断选择Angular。</p>
<blockquote>
<p>Angular 6 添加了ng update和ng add这样的新功能，让你的应用程序保持最新的状态，帮助Angular开发者加快创新的步伐。渲染器Project Ivy也有很大的改进，它能使Angular调试更容易，以更快地速度编译和运行，它还可以与现有的应用程序一起使用，Angular团队还在小型Hello World应用程序做了演示，不使用的Angular功能将自动从应用的JavaScript bundle自动删除。</p>
</blockquote>
<h2 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h2><p>在移动的世界里，Application是重中之重，是构建移动生态的核心。那么构建Mobile App的方式的问题就来了。</p>
<ul>
<li>Native App：既用iOS的原生语言OC、Swift或Android原生语言Java构建的App。</li>
<li>Web App：既使用前端框架和技术（Angular、React、Vue，HTML 5，CSS 3等）构建的，在移动设备上运行展现的App。</li>
<li>Native &amp; Web App：原生语言和Web技术混搭构建的App。这类App还孕育出了像React Native这种使用前端语言解析为原生语言的框架。</li>
</ul>
<p>以上三种类型各有利弊：</p>
<ul>
<li>Native App给用户的体验是最好的，交互动画效果平滑，可以基于硬件的性能做优化等。但是研发周期比较长，并且因为iOS和Android应用的审核机制，导致版本更新周期比较长，修复完问题或有新需求增加后无法做到及时更系用户设备上的App。</li>
<li>Web App可以做到版本的热更新，研发周期短，Web端和移动端可共享研发资源。但是用户体验比较差，一些需要使用到硬件功能不好实现。</li>
<li>Native &amp; Web App则致力于综合他们的优点，规避他们的缺点。</li>
</ul>
<p>Progressive Web App（<a href="https://lavas.baidu.com/pwa" target="_blank" rel="external">PWA</a>）就是Google推出的提升Web App体验，给用户原生应用体验的框架。主要特点包括：</p>
<ul>
<li>可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现。</li>
<li>体验 - 快速响应，并且有平滑的动画响应用户的操作</li>
<li>粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面<br>目前已支持Android，iOS 11.3以后版本，Safari，Chrome，MS Edge。</li>
</ul>
<a id="more"></a>
<h2 id="Service_Worker"><a href="#Service_Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><p><a href="https://developers.google.com/web/fundamentals/primers/service-workers/?hl=zh-cn" target="_blank" rel="external">Service Worker</a>是Chrome团队力推的一个Web API，它将开发人员从页面的生命周期中解放出来，运行于浏览器后台，可以控制打开作用范围下的所有页面请求，使Web应用程序能够脱机工作，打开了通向不需要网页或用户交互的功能的大门。目前，它们已包括如推送通知和后台同步等功能。将来，还会支持如定期同步或地理围栏等其他功能。</p>
<p>服务工作线程相关注意事项：</p>
<ul>
<li>它是一种 JavaScript 工作线程，无法直接访问 DOM。 服务工作线程通过响应 postMessage 接口发送的消息来与其控制的页面通信，页面可在必要时对 DOM 执行操作。</li>
<li>服务工作线程是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式。</li>
<li>它在不用时会被中止，并在下次有需要时重启，因此，您不能依赖于服务工作线程的 onfetch 和 onmessage 处理程序中的全局状态。如果存在您需要持续保存并在重启后加以重用的信息，服务工作线程可以访问 IndexedDB API。</li>
<li>服务工作线程广泛地利用了 promise，因此如果您不熟悉 promise，则应停下阅读此内容，看一看 Promise 简介。</li>
</ul>
<h2 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h2><p><a href="http://webassembly.org.cn/" target="_blank" rel="external">WebAssembly</a>是由主浏览器厂商组成的W3C社区团体制定的一个新的规范。是一个字节码技术的底层编程语言，是一种编译性语言，它能使网站能够运行用C或C ++等语言编写的高性能低级代码，为Web打开了新世界，今年3月，来自Autodesk的AutoCAD就采用了35年前的代码库，并用WebAssembly编译让其直接在浏览器中运行，这意味着，无论你的设备或操作系统如何，你都可以直接在浏览器中用CAD绘图。</p>
<p>同样是增强Web交互和承载内容的工具。</p>
<h2 id="Polymer"><a href="#Polymer" class="headerlink" title="Polymer"></a>Polymer</h2><p><a href="https://www.ibm.com/developerworks/cn/web/wa-polymer/index.html" target="_blank" rel="external">Polymer</a> 是Google主推的一个 JavaScript 库，它可帮助你创建自定义的可重用 HTML 元素，并使用它们来构建高性能、可维护的 App。它的目的就是使用可重用的、可组合的、可视的功能组件组装现代的移动 Web 应用程序。</p>
<h2 id="AMP"><a href="#AMP" class="headerlink" title="AMP"></a>AMP</h2><p><a href="https://www.ampproject.org/zh_cn/learn/overview/" target="_blank" rel="external">Accelerated Mobile Pages（AMP）</a>是Google带领开发的开源项目，目的是为提升移动设备对网站的访问速度。主要分为AMP HTML、AMP JS、AMP Cache三部分：</p>
<ul>
<li>AMP HTML是描述网页所用的标记语言，相当于普通网页使用的HTML之亚种。AMP HTML在图像显示等方面使用与HTML不同的专用标签，另外还限制了HTML部分功能的使用。</li>
<li>AMP JS是一套JavaScript库，保证AMP HTML的正确和快速显示。除此之外，AMP JS还负责在只支持普通HTML的浏览器中担任桥梁，使其能正确支持AMP HTML的专用功能。AMP HTML中可以调用该函数库。</li>
<li>AMP Cache是缓存并传输AMP页面的CDN，进一步提高AMP网页的性能。用户在搜索引擎中点击AMP网页时，实际上访问的是优化后的缓存页面。Google的AMP Cache名为Google AMP Cache。</li>
</ul>
<h2 id="Lighthouse"><a href="#Lighthouse" class="headerlink" title="Lighthouse"></a>Lighthouse</h2><p>Lighthouse是一个分析网络质量的工具，为你提供网站性能衡量指标和指导，它可以直接从Chrome DevTools内部进行访问，从命令行运行或与其他开发产品集成，仅在2018年，就有50万开发人员在他们的网站上运行Lighthouse。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>以上技术几乎是一套构建高性能高质量Web App的组合套装。Angular作为构建Web App的总框架，使用Polymer和AMP保证性能，使用PWA和Service Worker使Web App达到原生的体验，使用WebAssembly进一步增加Web App的交互和展示内容，最后使用Lighthouse对性能质量监控护航。</p>
<p>阅读文章：<a href="http://www.infoq.com/cn/news/2018/05/Google-arch-development" target="_blank" rel="external">《Google力推的那些前端技术，最近有何进展？》</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4115205380866695"
     data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>Google是一个伟大的公司，有很多伟大的产品。从Google一直不做桌面系统和对Chrome的大力发展来看，Google对前端事业是非常热衷的。</p>
<h2 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h2><p>Angular、React、Vue是目前前端框架的三驾马车。我在16年9月写过一篇文章<a href="http://www.devtalking.com/articles/angularjs1x-guide/">《温故而知新-AngularJS 1.x 小记》</a>，当时还叫AngularJS，版本是1.X，那时已经很惊艳了，把前端解释性的脚本语言封装成了面向对象的编程模式，另外对HTML的元素维护提供了便利的方式方法。当时我负责的BPM产品，Process Builder的前端架构果断更新为了AngularJS。时隔两年多，Angular 6都已经发布了，如果我还有机会做前端产品的话，我应该还是会果断选择Angular。</p>
<blockquote>
<p>Angular 6 添加了ng update和ng add这样的新功能，让你的应用程序保持最新的状态，帮助Angular开发者加快创新的步伐。渲染器Project Ivy也有很大的改进，它能使Angular调试更容易，以更快地速度编译和运行，它还可以与现有的应用程序一起使用，Angular团队还在小型Hello World应用程序做了演示，不使用的Angular功能将自动从应用的JavaScript bundle自动删除。</p>
</blockquote>
<h2 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h2><p>在移动的世界里，Application是重中之重，是构建移动生态的核心。那么构建Mobile App的方式的问题就来了。</p>
<ul>
<li>Native App：既用iOS的原生语言OC、Swift或Android原生语言Java构建的App。</li>
<li>Web App：既使用前端框架和技术（Angular、React、Vue，HTML 5，CSS 3等）构建的，在移动设备上运行展现的App。</li>
<li>Native &amp; Web App：原生语言和Web技术混搭构建的App。这类App还孕育出了像React Native这种使用前端语言解析为原生语言的框架。</li>
</ul>
<p>以上三种类型各有利弊：</p>
<ul>
<li>Native App给用户的体验是最好的，交互动画效果平滑，可以基于硬件的性能做优化等。但是研发周期比较长，并且因为iOS和Android应用的审核机制，导致版本更新周期比较长，修复完问题或有新需求增加后无法做到及时更系用户设备上的App。</li>
<li>Web App可以做到版本的热更新，研发周期短，Web端和移动端可共享研发资源。但是用户体验比较差，一些需要使用到硬件功能不好实现。</li>
<li>Native &amp; Web App则致力于综合他们的优点，规避他们的缺点。</li>
</ul>
<p>Progressive Web App（<a href="https://lavas.baidu.com/pwa">PWA</a>）就是Google推出的提升Web App体验，给用户原生应用体验的框架。主要特点包括：</p>
<ul>
<li>可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现。</li>
<li>体验 - 快速响应，并且有平滑的动画响应用户的操作</li>
<li>粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面<br>目前已支持Android，iOS 11.3以后版本，Safari，Chrome，MS Edge。</li>
</ul>]]>
    
    </summary>
    
      <category term="Technology" scheme="http://www.devtalking.com/tags/Technology/"/>
    
      <category term="技术" scheme="http://www.devtalking.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《当我们聊技术实力的时候，我们到底在聊什么》笔记]]></title>
    <link href="http://www.devtalking.com//articles/talk-about-tech/"/>
    <id>http://www.devtalking.com//articles/talk-about-tech/</id>
    <published>2017-01-01T16:00:00.000Z</published>
    <updated>2018-06-01T15:41:40.968Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>技术实力的本质和基本原则：</p>
<ul>
<li>不存在放之四海皆准的技术</li>
<li>技术要能解决具体问题才有价值</li>
<li>问题的复杂度决定技术实力的高度</li>
</ul>
<p>在技术实力的基本原则前提下，将技术实力分为两大类，六个小分类。</p>
<h2 id="u786C_u5B9E_u529B"><a href="#u786C_u5B9E_u529B" class="headerlink" title="硬实力"></a>硬实力</h2><p>硬实力有四个等级，从低到高为点、线、面、体，对应的解决问题的复杂度也越来越高。</p>
<h3 id="u6280_u672F_u70B9"><a href="#u6280_u672F_u70B9" class="headerlink" title="技术点"></a>技术点</h3><p>技术点是一个个颗粒性小，且相互较为独立的技术的使用方式和其原理认知。比如使用Java多线程的方式方法和解决的具体问题，使用Java进行I/O操作的方式方法和解决的具体问题。<strong>掌握了技术点，就可以开始基本的业务能力开发了</strong>。</p>
<h3 id="u6280_u672F_u7EBF"><a href="#u6280_u672F_u7EBF" class="headerlink" title="技术线"></a>技术线</h3><p>技术线是由若干个技术点串联起来的，该条技术线能解决某一类相关问题。比如一个常规的Web应用流程，用户发起请求，经过负载均衡路由，到达业务Controller进行业务逻辑处理，过程中对数据库的操作，对缓存的操作，然后返回结果给用户等。这就是由若干个技术点组成的一条技术线，这条技术线能支撑起来Web应用开发中实现业务功能的全过程。<strong>掌握了技术线，就能完成业务功能的全流程设计和开发了</strong>。</p>
<h3 id="u6280_u672F_u9762"><a href="#u6280_u672F_u9762" class="headerlink" title="技术面"></a>技术面</h3><p>技术面是由若干技术线排列交织而成。比如Web应用开发，性能优化，数据库维护等都属于技术面。<strong>掌握技术面，表明已经是某个领域的专家了</strong>。</p>
<h3 id="u6280_u672F_u4F53"><a href="#u6280_u672F_u4F53" class="headerlink" title="技术体"></a>技术体</h3><p>技术体既多个技术面的综合。最小的技术体也得有三个技术面组成。最常见的就是架构师，对于一个大型业务系统的架构师而言，需要掌握多个技术面，然后站在全局的角度进行系统，架构的设计和取舍，比如一个后端的架构师需要掌握Java开发的技术面，数据的技术面，网络的技术面，包括专业业务领域的技术面。<strong>掌握了技术面，表明已经是某个领域的资深架构师或专家了，可以解决领域级的复杂问题</strong>。</p>
<h2 id="u8F6F_u5B9E_u529B"><a href="#u8F6F_u5B9E_u529B" class="headerlink" title="软实力"></a>软实力</h2><p>软实力既不是很容易量化的一种能力，但是更能体现技术实力。</p>
<h3 id="u53D1_u73B0_u95EE_u9898"><a href="#u53D1_u73B0_u95EE_u9898" class="headerlink" title="发现问题"></a>发现问题</h3><p>发现问题是一个很重要的软实力，当系统出现问题后，大多数问题可以很容易的定位，但是就有个别问题找不出是因为哪个环节引起的问题，而往往这些找不出原因的问题都是优先级比较高或者比较严重的问题。还有一种场景是系统三天两头出问题，出一个问题解决一个问题，但是都是治标不治本，找不出反复引起问题的根本原因。所以发现隐藏很深很细节的问题和发现根源问题是彰显技术实力的一个软实力，这个能力主要来源于经验，有成功的经验，也有踩坑的经验，也有参考别人的经验。所以需要多思考、多总结、多学习、多交流。</p>
<h3 id="u6280_u672F_u521B_u65B0"><a href="#u6280_u672F_u521B_u65B0" class="headerlink" title="技术创新"></a>技术创新</h3><p>要达到这一项软实力其实比较难，比如在Google开创出大数据的大神，亚马逊开创出云计算的大神。但是这是我们为之努力的目标之一。</p>
<p>阅读文章：<a href="http://www.infoq.com/cn/articles/talk-about-technology" target="_blank" rel="external">《当我们聊技术实力的时候，我们到底在聊什么》</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" ]]>
    </summary>
    
      <category term="Technology" scheme="http://www.devtalking.com/tags/Technology/"/>
    
      <category term="技术" scheme="http://www.devtalking.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[产品经理的DevOps自我修养]]></title>
    <link href="http://www.devtalking.com//articles/devops-guide/"/>
    <id>http://www.devtalking.com//articles/devops-guide/</id>
    <published>2016-11-15T16:00:00.000Z</published>
    <updated>2018-06-01T16:10:30.276Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/122666" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>作为一名产品经理，首先要知道产品对于所属公司来说意味着什么，要探寻这个问题，我们又得知道和公司息息相关的是什么，在我的理解来看，与公司状况相关的因素有以下这些：</p>
<ul>
<li>市场份额</li>
<li>平均订单金额</li>
<li>盈利能力</li>
<li>资产回报率</li>
<li>从订单转化为现金的周期</li>
<li>应收账款</li>
<li>借贷成本</li>
</ul>
<p>从这些因素体现出来的最直接的就是公司收入，公司的财务状况，进而可以得出公司的经营状况，如果这些指标一塌糊涂，那么这个公司离倒闭也就不远了。那么现在我们再来看产品对公司意味着什么，应该不难发现上面这些指标都离不开产品，产品的市场份额、产品的平均订单金额、产品的盈利能力、产品的回报率、产品订单转化为现金的周期、产品的应收账款、投入产品时的借贷成本。好的产品就能创造出好的这些指标，反之亦然，所以往大了说，产品经理在某种程度上对公司的生存有着一定决定因素，尤其规模不是很大的公司。那么作为产品管理者，如何能帮公司打造出好的产品呢？</p>
<h1 id="u6B66_u88C5_u81EA_u5DF1"><a href="#u6B66_u88C5_u81EA_u5DF1" class="headerlink" title="武装自己"></a>武装自己</h1><p>首先我们需要能让我们打造出好产品的方法论来武装自己，所谓方法论，就是一门学问所采用的方法、规则与公理，放在软件工程中，它便指一系列编撰好的建议方法、训练方法及材料、使用的各种工具。在当今的IT领域，这种方法论莫过于DevOps了，我用它武装为自己的铠甲。</p>
<p>我不打算就DevOps做概念上的解释，我要说的是为什么我要选择DevOps，它能给公司和产品带来哪些好处，概括来说有以下五点：</p>
<ul>
<li>它能使产品更快的投入市场。</li>
<li>它能提升客户满意度。</li>
<li>它能提升产品的市场份额。</li>
<li>它能提升员工生产力及工作成就感和幸福感。</li>
<li>它能给公司在市场中创造出巨大的竞争优势。</li>
</ul>
<h2 id="u6253_u9020_u5229_u5251"><a href="#u6253_u9020_u5229_u5251" class="headerlink" title="打造利剑"></a>打造利剑</h2><p>产品的产出过程就是开发过程，在开发方法上我选择敏捷开发作为我的利剑，虽然这不是什么新鲜东西，但是它却是经过长期千锤百炼，经得起考验的开发方法，就像使用千锻、万锻后的精钢打造的利剑一般，首先在材质上就不会轻易损坏，只是你能否耍好剑的问题。</p>
<p>从理论上来说，敏捷开发在当今湍流的IT领域中好处不言而喻，积极甚至激进的个体互动、时刻有可交付的成果、紧密的客户合作、快速的响应变化都完胜传统瀑布式开发那套冗长的过程、冗余的事无巨细的文档、漫长的合同谈判和循规蹈矩的拖沓计划。</p>
<p>有了利剑，我门要学习剑术，敏捷开发有若干方法可供我们使用，比如Scrum、特性驱动开发（FDD）、测试驱动该开发（TDD）、行为驱动开发（BDD）、精益开发等，但是敏捷开发不存在官方的方法，没有完整的方法列表，也不存在最好的方法一说，只有最合适的方法。我选择了Scrum，理由很简单，它同样经历了多年的历练，已去其糟粕。<br><a id="more"></a></p>
<h3 id="u4E2A_u4F53_u4E92_u52A8"><a href="#u4E2A_u4F53_u4E92_u52A8" class="headerlink" title="个体互动"></a>个体互动</h3><p>我们先来看看个体互动，首先要明确的是你的组员，不论是开发人员、测试人员还是运维人员，他们绝对不是你的工具，不是你的枪，更不是你枪里的子弹，他们是你的伙伴，一起战斗的伙伴，只是分工不同而已。所以我们要了解他们，和他们建立互信互助的关系，建立团队沟通习惯，围绕斗志高昂的团队成员开展工作，这也是敏捷开发的原则和成功要素之一。那么我们该如何做到这些呢？这就需要使用Scrum剑术中的这几个技能：</p>
<ul>
<li>每日立会：每天不论早晚，抽15分钟时间，团队每人都要发言，汇报工作完成情况以及遇到的问题，让大家都彼此了解对方的工作内容和进度。</li>
<li>每周代码评审会：团队成员之间互相对代码质量进行评审，提出意见和建议。但是要确保的是每个人都要放下自尊，虚心接受和诚恳的评价。</li>
<li>每月畅谈会：团队成员之间勇于互相展现出自己脆弱的一面，可促使团队达成互相信任。每人发言，说说自己遇到的最困难的事，或觉得自己做的比较差劲的事，虽然这种方式一开始会有点残忍，但一旦团队成员彼此之间成为了倾诉对象，那么团队的团结互信将达到另一个境界。</li>
<li>每月回顾会议：也称为总结会议，每月进行总结并讨论在各方面需要改进的地方。</li>
<li>不定期技术交流会：我们鼓励团队中的每个人都向着专家的目标去努力，尽可能去专精自己擅长的技术，有一定积累后，无私的与大家分享交流，我很乐于看到团队成员彼此都称为对方老师。这有利于促进团队整体实力的提升。</li>
</ul>
<h3 id="u65F6_u523B_u6709_u53EF_u4EA4_u4ED8_u7684_u6210_u679C"><a href="#u65F6_u523B_u6709_u53EF_u4EA4_u4ED8_u7684_u6210_u679C" class="headerlink" title="时刻有可交付的成果"></a>时刻有可交付的成果</h3><p>何为可交付的成果，这里的成果指的不仅是产品，每一个开发人员完成的功能模块甚至与一个功能都算是是成果。那么可交付的成果既对功能模块有用的功能、对产品有用的功能模块、对客户有用的产品。那么所谓有用又如何定义呢，它在这里指的不仅是代码逻辑无误并测试通过这么简单，而是让客户买账。那么我们要如何从源头就做到有用呢？这里需要用到Scrum剑术中的几个技能以及另外一个剑术，我们先来看看这个剑术。</p>
<h4 id="u533A_u5206_u201C_u76F8_u5173_u201D_u4E0E_u201C_u65E0_u5173_u201D_u7684_u5DE5_u4F5C"><a href="#u533A_u5206_u201C_u76F8_u5173_u201D_u4E0E_u201C_u65E0_u5173_u201D_u7684_u5DE5_u4F5C" class="headerlink" title="区分“相关”与“无关”的工作"></a>区分“相关”与“无关”的工作</h4><p>这个剑术用一句话来概括就是弄清楚与实现公司目标息息相关的是什么。具体的技能以下三个：</p>
<ul>
<li>把公司上层的评估指标作为前提条件与具体的业务部门和开发部门的任务关联起来。只要能说明IT风险会对业务绩效指标产生多大的影响，就能着手指定更好的业务决策。</li>
<li>与各指标对应的业务流程负责人进行访谈，理解客户的需求与期望、产品系列、上市时间、销售渠道等分出项目优先级。</li>
<li>冻结低优先级的产品，保留高优先级的产品，形成相对单一的工作流。</li>
</ul>
<p>从这个剑术可以看出，它不仅适用于产品层面的管理，也适用于公司层面的运营。但不管是作为产品经理还是作为公司运营者，我们都得有一个列表，那就是公司的远期目标，也就是公司上层的评估指标：</p>
<ul>
<li>我们要创建什么？</li>
<li>我们有正确的产品吗？</li>
<li>我们能有效的创建产品吗？</li>
<li>我们能尽快把产品推向市场占有一席之地吗？</li>
<li>我的产品能带来感兴趣的潜在客户吗？</li>
<li>我们遵守了对客户的承诺吗？</li>
<li>我们是在获得客户还是在流失客户？</li>
<li>我们的销售预测准确率靠谱吗？</li>
</ul>
<p>与此对应的是：</p>
<ul>
<li>了解客户的需求和期望。</li>
<li>根据市场和客户确定产品系列。</li>
<li>提高研发效能。</li>
<li>缩短产品交付周期。</li>
<li>研究销售时机和销售渠道。</li>
<li>保证按时交货。</li>
<li>提高客户留存率。</li>
<li>保证市场和销售报告数据的精准性。</li>
</ul>
<p>以上八点其实是环环相扣的。当把这些问题都搞清楚后，自然而然就可以区分出哪些工作是“相关”的，哪些是“无关”的。</p>
<h4 id="u7EC6_u5206_u4EFB_u52A1"><a href="#u7EC6_u5206_u4EFB_u52A1" class="headerlink" title="细分任务"></a>细分任务</h4><p>当我们确定了一堆相关的工作后，需要使用Scrum中的另外几个技能将这些工作根据优先级进一步的细分：</p>
<ul>
<li>确定产品需求列表（Product Backlog）。</li>
<li>开发团队根据产品需求列表作出整体工作量的预估。</li>
<li>通过迭代计划会议（Sprint Planning Meeting）根据优先级及资源情况从产品需求列表中筛选出用户故事（User Story），作为本次迭代要完成的目标，一般周期在1-4个星期内。</li>
<li>将用户故事再进行细化，形成迭代需求列表（Sprint Backlog），通过看板将其可视化。</li>
</ul>
<p>我们通过确定出的“相关”工作，根据优先级进一步确定产品需求列表，这要注意的是，<strong>现在的产品需求列表中的内容已经是和公司的评估指标相关链的任务</strong>，所以都是极有价值的，现将这个需求列表评估出整体的大致工作量，然后通过迭代计划会议从中筛选出用户故事，也就是确定团队的短期目标，最后再将用户故事细化为更小的简单任务，一般周期保证在2天以内，分配给每个团队成员，在必要的时候还可以使用计划纸牌工具进行周期确认。Scrum中的这4个技能干的事就是能让整个团队清楚我们的最终目标和每一个短期目标，以及对整个目标的时间把控，在不断分解的过程中消除团队对庞大目标的恐惧感，并建立信心。</p>
<blockquote>
<p>计划纸牌工具的作用是确认探讨最小任务的具体周期。比如A程序员开发一个功能要5个小时，而B程序员认为只需要2个小时，那么他们各自取出有相应时间的牌藏在手中，最后摊牌，如果时间差距很大，那么A和B就可以对这两个时间进行讨论，最后确定最合适的任务周期。</p>
</blockquote>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h4 id="u6301_u7EED_u96C6_u6210"><a href="#u6301_u7EED_u96C6_u6210" class="headerlink" title="持续集成"></a>持续集成</h4><p>持续集成也是Scrum剑术中的技能之一，持续集成也就是每日集成部署，保证每天都要有一个可以成功编译，并可以演示的版本，要做到这一点，传统的集成部署方式显然是无法实现的，所以我们需要使用自动化集成部署方案。</p>
<p>持续集成一般分为四个阶段，也是通过不断摸索实践，从历史长河演化而来，但这四个阶段的方式没有谁好谁坏，只有我们的现状适合哪个阶段。</p>
<ul>
<li>代码级别的集成：这个阶段不依赖独立的集成工具，一般使用IDE内置的编译工具。同时代码风格检查、单元测试、测试覆盖率都有开发人员在本机人工执行。接下来的交付准备环境、运行测试、备份旧版本、新版本打标签以及反馈机制等其他重复的事情都由手工完成。</li>
<li>集成工作流：这个阶段整个开发流程的重心从代码级别的集成转移到了更自动化地编译和更完善的测试验证，致力于在最短时间内发现问题，缩短开发周期，提高软件质量。具体的形式是先进行代码编译，触发单元测试，集成测试，打包测试，自动部署到测试环境。循环往复，形成编译-构建-测试-集成-部署的工作流。</li>
<li>持续交付与部署：在上个阶段，自动部署只是最终部署在测试环境，还需要手动部署到生产环境，因为产品从需求到部署的过程中会经历若干个不同的环境，如开发环境、QA环境、自动化测试环境、生产环境等。所以在这个阶段要建立标准化的环境部署顺序，在工作流中增加部署预生产环境，并执行灰度集成测试，做好线上环境部署后的回归测试。持续交付并不是指软件每一个改动都要尽快部署的产品环境中，而是指任何的代码修改都可以在任何时候实施部署。而持续部署，指的是自动部署到生产环境中。</li>
<li>基于Docker的持续集成：这个阶段是上个阶段的进化，主要解决的问题是通过Docker统一部署环境。具体形式是开发者提交代码，触发单元测试，集成测试，打包测试，产品构建，触发Docker镜像构建，构建镜像上传至私有仓库，镜像下载至执行机器，镜像运行。</li>
</ul>
<p>通过持续集成我们就可以大幅缩短成果的交付周期，从而达到不断交付有价值的成果以满足客户需求的先决条件。</p>
<p>至此，我们有互相高度信任的团队，有条不紊的做着正确的事，不过我们只完成了计划内工作流的第一步，既<strong>优化工作优先级</strong>。目前我们只是有了让产品更快的投入市场的先决条件，想要真正实现，那么还需要提高计划内工作流的流量吞吐率及流速。</p>
<h2 id="u5BFB_u89C5_u5750_u9A91"><a href="#u5BFB_u89C5_u5750_u9A91" class="headerlink" title="寻觅坐骑"></a>寻觅坐骑</h2><p>首先我们要明确在我们的所有工作中一共有四种类型的工作：</p>
<ul>
<li>业务工作：也就是我们需要完成的和产品相关的工作。</li>
<li>内部工作：团队内部做的一些改进工作，比如搭建自动化部署框架等。</li>
<li>变更工作：由上面两种工作引起的工作，比如开发向测试交接时引起的问题，业务工作的需求改变引起的问题，内部的改进工作引起的问题等。</li>
<li>计划外工作：一般都由上面三种工作导致，尤其是变更工作引起的需要补救的工作，而且往往优先级都相对较高。</li>
</ul>
<p>业务工作和内部工作我们又称之为计划内工作，变更工作往往也是我们无法避免的，而计划外工作是最为可怕的，如恶魔一般，我们要以牺牲计划内工作为代价去消灭它。</p>
<p>所以我们知道了影响计划内工作流流速的其中一个因素就是计划外工作，那么影响流量吞吐率的因素是什么呢？那就是<strong>约束点</strong>。</p>
<p>我们将产品从需求到交付的过程想象为一个加工工厂的加工流水线过程，产品需求看作是加工原料，开发、测试、运维等看作是工厂流水线上每一环节的机器，原料从流水线起始位置流入，经过一个个加工机器，最终加工为一个成品。但是当其中的某个机器工作效率很低的时候，在该机器处就会堆积越来越多从上游传来的半成品，而下游的机器则闲置着，或者使用率极低，这种情况下这个工厂的生产效率可想而知。那么这个效率很低的机器就是整个工厂流水线的约束点，不但影响了流速也影响了吞吐率。那么这个机器相当于我们产品开发中的什么呢？是不同分工的个人还是不同分工的团队呢？</p>
<p>带着这个问题我们继续回到这个工厂，仔细观察可以我们可以看出加工流水线上的每个加工环节都有四个部分组成，那就是机器、人员、方法、测评。机器是工具，人员按照方法操作工具，然后根据测评细则检查加工的半成品在这一环节是否合格。这四部分组成的就叫工作中心，工作中心就是产品开发中不同分工的团队，所以某个团队的效率低下就会称为整个工作流的约束点。</p>
<p>那么团队为什么会成为约束点呢？因为团队里也有约束点。我们来继续看这个工厂，如果操作某个机器的人操作不熟练，或者一个人要兼顾好几个机器的话，那么这个人员就可能成为这个工作中心的约束点，甚至是多个工作中心的约束点。所以，解决约束点的问题是至关重要的，所有在非约束点所做的改进都是假象。</p>
<h3 id="u6D88_u9664_u6216_u4FDD_u62A4_u7EA6_u675F_u70B9"><a href="#u6D88_u9664_u6216_u4FDD_u62A4_u7EA6_u675F_u70B9" class="headerlink" title="消除或保护约束点"></a>消除或保护约束点</h3><p>有些约束点是因为自身能力问题导致的，这种情况下我们可以先调整他的任务，将优先级相对低的任务分配给他，同时通过技术交流会或者师带徒快速提升他的能力，从而消除约束点。另一种情况的约束点恰恰是因为这个人能力很强或者他的工作牵连着别的工作中心，从而参与了多个工作中心，反而使他自己的工作中心效率低下，这种情况我们就要采取保护约束点的措施：</p>
<ul>
<li>永远不要让这种约束点迁就别的工作中心，我们的做法应该完善每个工作中心的方法，使之标准化和自动化，我们的持续集成技能就能改善这一点。</li>
<li>将这种约束点着力于完成优先级相对比较高的任务。</li>
</ul>
<p>所以我们要善于识别约束点，然后消除或保护约束点，最后寻找下一个约束点，以此反复。</p>
<h3 id="u675C_u7EDD_u8BA1_u5212_u5916_u5DE5_u4F5C"><a href="#u675C_u7EDD_u8BA1_u5212_u5916_u5DE5_u4F5C" class="headerlink" title="杜绝计划外工作"></a>杜绝计划外工作</h3><p>为什么计划外工作会影响工作流流速呢？因为它增大了工作流中的某个工作中心，或者工作中心里某个人员的等待执行计划内工作的时间。等待时间怎么算的呢？等待时间等于忙碌百分比除以空闲百分比。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">等待时间 = 忙碌百分比 / 空闲百分比</span><br></pre></td></tr></table></figure>
<p>因为计划内工作，在前期都指定好了合理的周期，所以团队成员的忙碌百分比一般不会超过50%，所以空闲百分比也是50%，那么等待时间就是1。如果有大量的计划外工作涌进来，那团队成员的忙碌百分比就有可能达到70%或80%，甚至更高，假如忙碌百分比达到了80%，那么空闲百分比为20%，等待时间将增加到4。所以从这个公式可以看到，超负荷的工作任务其实是产生约束点的罪魁祸首，而计划外工作又是超负荷工作的始作俑者。</p>
<p>那么我们该如何杜绝计划外工作呢？我们知道计划外工作一般都是有变更工作引起的补救工作，因为80%的计划外工作都是由20%的变更工作造成的。既然变更工作是不可避免的，那么就尽量做到不引起补救工作，也就是要干净利落的完成变更工作，防止因变更工作导致其他问题发生。所以要想有效的杜绝加化外工作，那就需要建立起<strong>变更管理系统</strong>。</p>
<p>变更管理系统的主要作用是确保能正确实施变更确认、分析、评估、计划、实施、检查的过程。它的相关干系人可分为三个角色：</p>
<ul>
<li>客户：发起变更工作的源头，这个客户指的不仅是用我们产品的真实客户，在产品生命周期中，测试团队可能是开发团队的客户，开发团队可能是运维团队的客户，因为他们都有可能给上游或下游发起变更。</li>
<li>变更委员会委员：既对变更进行分析、评估、计划及决定变更优先级和变更实施者的人。</li>
<li>变更实施者：既具体实施变更的人或团队。</li>
</ul>
<p>这三种角色的人参与整个变更流程，基本的变更流程如下：</p>
<ul>
<li>产生变更：客户有新的需求或者更改原有需求。产品生命周期中，上下游的工作中心发起变更，比如发现Bug，或者修改部署环境配置等。</li>
<li>分析变更：变更委员会确定变更请求的技术可行性以及变更成本和变更收益，暂时过滤涉及约束点的变更。</li>
<li>评估变更：评估变更影响范围，既实施了变更后会对产品的哪些地方产生什么样的影响，明确变更影响和确定防范措施。</li>
<li>计划变更：根据分析变更和评估变更的结果，确定可实施的变更，既变更优先级，然后分配变更实施者。最后将所有状态的变更使用看板将其可视化。</li>
<li>实施变更：变更实施者根据计划变更的结果，按计划执行变更、测试变更、完备变更文档、发布变更。</li>
<li>检查和关闭变更：对已完成的变更进行检查，根据变更文档和测试变更的结果决定是否认定变更成果完成并关闭变更。</li>
</ul>
<p>有了完善的变更管理系统，通过严格的变更流程，我们首先可以筛选变更，其次可以对变更了如指掌，可以通过计划内工作看板和变更工作看板分析出如何安排变更工作，安排给谁最为合适，最后我们可以确保更变工作在掌控中安全的完成，不会产生额外的需要补救的计划外工作。</p>
<p>所以消除或保护约束点以及变更管理系统可以帮助我们提高工作流吞吐量和流速，是提升我们速度的最好坐骑。</p>
<p>至此，我们就完成了计划内工作流的第二步<strong>识别保护约束点</strong>，并且基本实现了<strong>第一工作法</strong>，既帮助我们在工作到来时如何建立快速工作流，使需求-开发-测试-运维-客户整个自左向右的工作流流量最大化，不让缺陷流向下游工作中心，为了整体目标不断对工作流进行优化。在第一工作法的帮助下，我们似乎可以使产品更快的投入市场了。</p>
<h2 id="u88C5_u5907_u76FE_u724C"><a href="#u88C5_u5907_u76FE_u724C" class="headerlink" title="装备盾牌"></a>装备盾牌</h2><p>当拿着利剑乘骑着坐骑冲进战场后，其实战争才刚刚开始。根据我的经验，绝大多数产品在投入市场后依然会存在一些Bug，而且会被客户发现，哪怕之前已经经过了测试系统的测试，所以当产品快速投入市场后，客户的的各种新需求和Bug反馈会如猛兽一般砸向我们，我们要做的就是一边盾挡洪水般的新需求一边斩杀客户发现的Bug，但仍会让我们措手不及。然而客户的需求和要求是无穷无尽的，像填不满的沟壑，如果我们能及时进行预判，那么我们就能自如许多，逐渐和客户形成良性循环。</p>
<h3 id="u4E2A_u4F53_u4E4B_u95F4_u7684_u53CD_u9988_u56DE_u8DEF"><a href="#u4E2A_u4F53_u4E4B_u95F4_u7684_u53CD_u9988_u56DE_u8DEF" class="headerlink" title="个体之间的反馈回路"></a>个体之间的反馈回路</h3><p>我们在开发过程中，经常会遇到这种情况，A开发人员开发的某个功能流转到B开发人员使用，但是B开发人员发现这个功能开发的不完善，不能满足B的需求，于是B按照自己的需求修改了A开发的功能，而不会去考虑这个变更是否会影响到C的使用，于是这个功能在工作流上一直流转下去就有可能已经远悖与原始需求了，如果这个功能看作是工厂生产线中产品的一个零部件，那么这个四不像的零部件在组装成品时会带来什么呢？必然是零件不合规，于是20%的变更引起了80%的计划外工作，眼看交付日期降至，开发人员又开始奔命与修补工作，即使最后完成了成品的组装，或许还是会留下不可预知的隐患及Bug。解决这类问题的最好办法就是建立起个体之间的问题反馈回路，它能避免不必要的变更工作。</p>
<p>一般变更工作都是在事物相对成型的状态下动其内部细节的工作，这种变更工作往往能牵一发而动全身，一个不好就会像釜底抽薪一般，让整体摧枯拉朽的坍塌，所以我们要有变更系统来加以管理和约束。上面那个例子中，如果当B发现A开发的功能不合规时，能立即反馈给A，经商榷探讨后由A及时修正了这个功能，并且A的这个修正行为并不属于变更行为，那么也许后面一系列的问题都不会发生了。这就是个体与个体之间的反馈回路，这种反馈回路要尽可能的短，回路两头要能快速响应，工作流中的每个个体都应该要建立这种反馈回路，而且尽量不要跨个体建立。</p>
<h3 id="u5DE5_u4F5C_u4E2D_u5FC3_u4E4B_u95F4_u7684_u53CD_u9988_u56DE_u8DEF"><a href="#u5DE5_u4F5C_u4E2D_u5FC3_u4E4B_u95F4_u7684_u53CD_u9988_u56DE_u8DEF" class="headerlink" title="工作中心之间的反馈回路"></a>工作中心之间的反馈回路</h3><p>个体之间建立反馈回路，能有效保证单个工作中心能按照它的规格产出合格的成果，但也许这个成果与整个工作流对产品的规格来说还有差异，所以工作中心和工作中心之间也要建立反馈回路，开发团队和测试团队之间，开发团队和运维团队之间，每个工作中心要指定一个个人作为反馈信息接口人，这样从细节到整体都能有效降低变更工作的发生率，从而大大减少计划外工作的发生率。</p>
<p>然而，反馈回路反馈的不仅仅是各种问题，还有其他更重要的信息，那就是市场团队和产品团队之间的反馈回路承载的信息。我们能预判市场和客户的需求呢？市场团队通过反馈回路不断提供的各种销售统计和市场报告是良药，能使产品团队知道做哪些事能让公司利益最大化，做到对市场需求和客户需求的预判，从而能抢占先机的将迎合市场的新功能推向市场。</p>
<p>反馈机制就是我们的盾牌，有了这面盾牌，我们就能很好的完成计划内工作流的第三步<strong>按时高质量交付成果</strong>，做到不欠技术债务，减少变更工作，进一步杜绝计划外工作。同时这也是<strong>第二工作法</strong>的核心内容，那就是建立尽可能短的个体之间和工作中心之间的不间断反馈回路，在个体之间、工作中心之间建立共同的目标和共同的解决问题的机制，这使我们能在产品初始阶段就能筹划并保证产品质量问题，避免返工，并且能及时获取到市场数据，做到市场需求和客户需求的预判，从而提升客户满意度和提升产品在市场的份额。</p>
<h2 id="u8425_u9020_u73AF_u5883"><a href="#u8425_u9020_u73AF_u5883" class="headerlink" title="营造环境"></a>营造环境</h2><p><strong>第三工作法</strong>的核心是在团队或公司建立鼓励探索、不断从失败中吸取教训、理解反复的实践是精通工作的先决条件的文化。让团队形成敢于创新、敢于冒险以及高度信任彼此的文化，同时要让所有人知道非功能性需求对于产品同等重要，合理安排功能性需求实现和非功能性需求实现的计划。第三工作法精髓在于不断尝试和理解重复练习是熟练掌握的前提。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>我们以DevOps方法论为基础，以三步工作法为指导思想，使用敏捷开发、区分“相关”与“无关”工作法、变更管理系统、保护约束点、建立反馈机制等具体方法，经过不断的实践和优化最后形成的工作流称之为价值流，它是从需求获取到代码签入再到产品投产整个工作流中的关键路径。我们要将价值流上的所有东西进行版本控制，使价值流中的每个个体都共享一种文化，这种文化不仅重视彼此的时间和贡献，而且为了实现整体的持续改进，要勇于不断向自己的工作注入压力，同时使每个个体都要像重视功能性需求一样重视非功能性需求，比如产品质量、可扩展性、可维护性、可操作性、安全性等。</p>
<p>如果我们能建立起这种价值流，那么就能提升员的工生产力以及工作成就感和幸福感，让公司重塑生产能力，从库存型生产转变为订单型生产，从给公司在市场中创造出巨大的竞争优势。</p>
<h2 id="u53C2_u8003_u6587_u732E_uFF1A"><a href="#u53C2_u8003_u6587_u732E_uFF1A" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://www.amazon.cn/凤凰项目-一个IT运维的传奇故事-基恩·金/dp/B016VW1I6U/ref=sr_1_1?ie=UTF8&amp;qid=1479266484&amp;sr=8-1&amp;keywords=凤凰项目" target="_blank" rel="external">《凤凰项目》</a><br><a href="http://blog.fir.im/ci_advancedguide/" target="_blank" rel="external">不可错过的「持续集成」</a></p>
<h2 id="u63A8_u8350_u4E66_u5355_uFF1A"><a href="#u63A8_u8350_u4E66_u5355_uFF1A" class="headerlink" title="推荐书单："></a>推荐书单：</h2><p><a href="https://www.amazon.cn/凤凰项目-一个IT运维的传奇故事-基恩·金/dp/B016VW1I6U/ref=sr_1_1?ie=UTF8&amp;qid=1479266484&amp;sr=8-1&amp;keywords=凤凰项目" target="_blank" rel="external">《凤凰项目》</a><br><a href="https://www.amazon.cn/目标-艾利•高德拉特/dp/B007RZRNAQ/ref=sr_1_1?ie=UTF8&amp;qid=1479266518&amp;sr=8-1&amp;keywords=目标" target="_blank" rel="external">《目标》</a><br><a href="https://www.amazon.cn/持续交付-发布可靠软件的系统方法-Jez-Humble%E3%80%80David-Farley/dp/B005V9BB1M/ref=sr_1_1?ie=UTF8&amp;qid=1479266535&amp;sr=8-1&amp;keywords=持续交付" target="_blank" rel="external">《持续交付》</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4115205380866695"
     data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/122666">CSDN</a>，如需转载请与CSDN联系。</p>
<p>作为一名产品经理，首先要知道产品对于所属公司来说意味着什么，要探寻这个问题，我们又得知道和公司息息相关的是什么，在我的理解来看，与公司状况相关的因素有以下这些：</p>
<ul>
<li>市场份额</li>
<li>平均订单金额</li>
<li>盈利能力</li>
<li>资产回报率</li>
<li>从订单转化为现金的周期</li>
<li>应收账款</li>
<li>借贷成本</li>
</ul>
<p>从这些因素体现出来的最直接的就是公司收入，公司的财务状况，进而可以得出公司的经营状况，如果这些指标一塌糊涂，那么这个公司离倒闭也就不远了。那么现在我们再来看产品对公司意味着什么，应该不难发现上面这些指标都离不开产品，产品的市场份额、产品的平均订单金额、产品的盈利能力、产品的回报率、产品订单转化为现金的周期、产品的应收账款、投入产品时的借贷成本。好的产品就能创造出好的这些指标，反之亦然，所以往大了说，产品经理在某种程度上对公司的生存有着一定决定因素，尤其规模不是很大的公司。那么作为产品管理者，如何能帮公司打造出好的产品呢？</p>
<h1 id="u6B66_u88C5_u81EA_u5DF1"><a href="#u6B66_u88C5_u81EA_u5DF1" class="headerlink" title="武装自己"></a>武装自己</h1><p>首先我们需要能让我们打造出好产品的方法论来武装自己，所谓方法论，就是一门学问所采用的方法、规则与公理，放在软件工程中，它便指一系列编撰好的建议方法、训练方法及材料、使用的各种工具。在当今的IT领域，这种方法论莫过于DevOps了，我用它武装为自己的铠甲。</p>
<p>我不打算就DevOps做概念上的解释，我要说的是为什么我要选择DevOps，它能给公司和产品带来哪些好处，概括来说有以下五点：</p>
<ul>
<li>它能使产品更快的投入市场。</li>
<li>它能提升客户满意度。</li>
<li>它能提升产品的市场份额。</li>
<li>它能提升员工生产力及工作成就感和幸福感。</li>
<li>它能给公司在市场中创造出巨大的竞争优势。</li>
</ul>
<h2 id="u6253_u9020_u5229_u5251"><a href="#u6253_u9020_u5229_u5251" class="headerlink" title="打造利剑"></a>打造利剑</h2><p>产品的产出过程就是开发过程，在开发方法上我选择敏捷开发作为我的利剑，虽然这不是什么新鲜东西，但是它却是经过长期千锤百炼，经得起考验的开发方法，就像使用千锻、万锻后的精钢打造的利剑一般，首先在材质上就不会轻易损坏，只是你能否耍好剑的问题。</p>
<p>从理论上来说，敏捷开发在当今湍流的IT领域中好处不言而喻，积极甚至激进的个体互动、时刻有可交付的成果、紧密的客户合作、快速的响应变化都完胜传统瀑布式开发那套冗长的过程、冗余的事无巨细的文档、漫长的合同谈判和循规蹈矩的拖沓计划。</p>
<p>有了利剑，我门要学习剑术，敏捷开发有若干方法可供我们使用，比如Scrum、特性驱动开发（FDD）、测试驱动该开发（TDD）、行为驱动开发（BDD）、精益开发等，但是敏捷开发不存在官方的方法，没有完整的方法列表，也不存在最好的方法一说，只有最合适的方法。我选择了Scrum，理由很简单，它同样经历了多年的历练，已去其糟粕。<br>]]>
    
    </summary>
    
      <category term="DevOps" scheme="http://www.devtalking.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[温故而知新-AngularJS 1.x 小记]]></title>
    <link href="http://www.devtalking.com//articles/angularjs1x-guide/"/>
    <id>http://www.devtalking.com//articles/angularjs1x-guide/</id>
    <published>2016-09-18T16:00:00.000Z</published>
    <updated>2018-06-01T16:17:59.451Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>本文首发<a href="http://geek.csdn.net/news/detail/102405" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h1 id="AngularJS_u662F_u4EC0_u4E48"><a href="#AngularJS_u662F_u4EC0_u4E48" class="headerlink" title="AngularJS是什么"></a>AngularJS是什么</h1><p>我们知道HTML是一种创建网页的静态标记语言，它很基础，但不失灵活，然而它自身并不提供对灵活性的具体实现，所以我们要创建具有可用性及赏心悦目的Web应用就需要使用其他语言与之结合去操控它的DOM、标签、标签属性、标签层级结构实现样式变换、动态数据变换、动态元素变换等，比如结合CSS和JavaScript语言。</p>
<p>但是越多的结合就意味着功能实现越复杂，我们需要写大量的代码去实现类似数据绑定、动态展现、远程服务请求等功能，所以jQuery这类的JS库、ember这类的框架应用而生。前者让我们在完成某些单一功能时调用它封装好的方法，从而减少代码量。后者让我们可以遵循它的规范去填充它设计好的代码结构，从而逐步完成完整的应用功能。</p>
<p>而AngularJS是JS库和框架的结合，它诞生于2009年，由Misko Hevery 等人创建，后为Google所收购并发扬光大。AngularJS通过为开发者呈现一个更高层次的抽象来简化应用的开发，提供了构建一个CRUD应用可能用到的全部内容包括：自定义HTML标签、事件绑定、数据绑定、基本模板标识符、表单验证、路由、深度链接、组件重用、依赖注入等。</p>
<blockquote>
<p>文章中的所有示例均可在<a href="https://github.com/DevTalking/AngularJS1.x-guide.git" target="_blank" rel="external">这里</a>下载。</p>
</blockquote>
<h1 id="AngularJS_u7684_u7279_u6027"><a href="#AngularJS_u7684_u7279_u6027" class="headerlink" title="AngularJS的特性"></a>AngularJS的特性</h1><p>AngularJS有着诸多的特性，但最为核心的是其Scope概念、MVC模式、路由、模块化、依赖注入、指令系统、双向数据绑定、Service、Provider等。</p>
<h2 id="u6A21_u5757_u5316"><a href="#u6A21_u5757_u5316" class="headerlink" title="模块化"></a>模块化</h2><p>我们先从AngularJS的模块化特性说起。什么是模块？既应用程序中不同功能的容器。在AngularJS中，我们可以按业务功能的不同将实现划分为不同的模块，这些模块可以在一个JS文件中，也可以将它们放在不同的JS文件中，既一个JS文件为一个模块。</p>
<h3 id="u6A21_u5757_u5316_u7684_u4F18_u52BF"><a href="#u6A21_u5757_u5316_u7684_u4F18_u52BF" class="headerlink" title="模块化的优势"></a>模块化的优势</h3><p>使用模块化在我们的编程阶段有着诸多的好处：</p>
<ul>
<li>可以使我们的代码结构非常清晰，有较好的可读性。</li>
<li>可以使我们复用代码。</li>
<li>在前端编程中，我们都知道JS的引用顺序是很重要的，但使用AngularJS的模块时我们不需要关系每个模块之间的顺序。</li>
<li>可以很好的实现单元测试。</li>
</ul>
<h3 id="u5B9A_u4E49_u6A21_u5757"><a href="#u5B9A_u4E49_u6A21_u5757" class="headerlink" title="定义模块"></a>定义模块</h3><p>定义一个模块很简单，在JS文件中申明一个模块：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mianModule = angular.module(<span class="string">"mianModule"</span>, []);</span><br></pre></td></tr></table></figure>
<p>使用AngularJS的<code>module</code>方法申明一个模块，该方法有两个参数：</p>
<ul>
<li>第一个参数为模块名称。</li>
<li>第二个参数为一个数组，该参数的含义为当前定义的模块所依赖的模块，如果有依赖模块则传入包含模块名称的数组，若无依赖则传入空数组。</li>
</ul>
<a id="more"></a>
<h3 id="u4F7F_u7528_u6A21_u5757"><a href="#u4F7F_u7528_u6A21_u5757" class="headerlink" title="使用模块"></a>使用模块</h3><p>在了解如何使用定义好的模块之前，需要先清楚在AngularJS中，模块与模块之间可以是相互独立，老死不相往来的关系，也可以是依赖关系，并且可以是嵌套依赖关系：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="comment">// 互相独立的模块</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"><span class="keyword">var</span> anotherModule = angular.module(<span class="string">"anotherModule"</span>, []);</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="comment">// 有依赖关系的模块</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, [<span class="string">"secondModule"</span>]);</span><br><span class="line"><span class="keyword">var</span> secondModule = angular.module(<span class="string">"secondModule"</span>, [<span class="string">"thirdModule"</span>]);</span><br><span class="line"><span class="keyword">var</span> thirdModule = angular.module(<span class="string">"thirdModule"</span>, []);</span><br></pre></td></tr></table></figure>
<p>在AngularJS中使用定义好的模块也有两种方式，对应两种不同的应用场景。</p>
<h4 id="ngApp_u65B9_u5F0F"><a href="#ngApp_u65B9_u5F0F" class="headerlink" title="ngApp方式"></a>ngApp方式</h4><p>这种方式是AngularJS团队比较推荐的使用方法，只需要在HTML标签中使用AngularJS的<code>ng-app</code>指令指定要使用的模块既可，一般指定的是应用的主模块，或者说是应用入口模块：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Module<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>ng-app</code>指令的含义类似Java中的<code>main</code>方法，是当前页面中应用的唯一主入口，所以<strong>一个页面中只能使用一次<code>np-app</code>指令</strong>。将<code>ng-app</code>指令定义在哪个HTML的标签中就表示该标签及它的所有子标签就会被AngularJS接管，这一部分HTML代码将可以使用AngularJS所有的功能和特性，也就是使用AngularJS开发的Web应用的主入口。通常情况下都会在<code>body</code>标签中使用<code>ng-app</code>指令。</p>
<p>因为使用这种方式只能指定一个应用入口模块，所以为了能使用多模块的特性，就需要抽象出一个主模块，然后将其他所有模块加入主模块的依赖关系中，这里要注意的是因为AngularJS中的模块依赖可以向下穿透，类似类的继承，所以加入主模块依赖关系中的模块并不是所有的模块，而只是处于依赖层级顶层的模块。<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-1.png" alt="主模块依赖关系"><br>如上图所示，在主模块中只需要添加<code>DataHandleModule</code>和<code>NetworkModule</code>两个模块既可。但是这种方式的弊端是在HTML页面中并不能直观的表现出页面的哪些部分使用了何种模块，而且本身提供了模块化的特性，但最终又要抽象到一个模块中去使用，始终有点不是很舒服。</p>
<h4 id="u624B_u52A8_u52A0_u8F7D_u65B9_u5F0F"><a href="#u624B_u52A8_u52A0_u8F7D_u65B9_u5F0F" class="headerlink" title="手动加载方式"></a>手动加载方式</h4><p>虽然使用<code>ng-app</code>的形式可以满足需求，但是还要考虑想抽象出主模块，然后依赖一大堆模块，如果更希望可以在HTML标签中指定使用的模块，此时就需要手动的加载模块了:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="comment">// 互相独立的模块</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"><span class="keyword">var</span> anotherModule = angular.module(<span class="string">"anotherModule"</span>, []);</span><br><span class="line"></span><br><span class="line">angular.element(document).ready(function() &#123;</span><br><span class="line">  <span class="keyword">var</span> myDiv1 = document.getElementById(<span class="string">"myDiv1"</span>);</span><br><span class="line">  angular.bootstrap(myDiv1, [<span class="string">"mainModule"</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> myDiv2 = document.getElementById(<span class="string">"myDiv2"</span>);</span><br><span class="line">  angular.bootstrap(myDiv2, [<span class="string">"anotherModule"</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Module<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"myDiv1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"myDiv2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过上述代码可以看到，我们可以使用AngularJS的<code>bootstrap</code>方法给HTML元素指定模块。这样感觉和模块化特性更加切合，模块的隔离性也比较好，但是这种方式依然有显著的弊端。首先从HTML页面中依然不能直观的看到模块在页面中使用和分布情况，再次这种方式将视图层的HTML代码与JS代码耦合在了一起，也有点违背了AngularJS的MVC设计模式，也许这也是AngularJS不推荐该方式的原因之一吧。</p>
<h3 id="u6A21_u5757_u7684_u751F_u547D_u5468_u671F"><a href="#u6A21_u5757_u7684_u751F_u547D_u5468_u671F" class="headerlink" title="模块的生命周期"></a>模块的生命周期</h3><p>在AngularJS中，模块有两个主要的生命周期方法，那就是<code>.config()</code>和<code>.run()</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module('mainModule', []);</span><br><span class="line">mainModule.config(function(injectables) &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.run(function(injectables) &#123; </span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>.config()</code>方法的作用是在模块运行加载之前对模块进行配置，比如创建各种服务、创建自定义指令、注册过滤器等。<code>.run()</code>方法相当于AngularJS应用的<code>main</code>方法，在该方法里进行的配置都是运行时态的，比如对已经创建好的服务实例在应用运行期进行修改。</p>
<blockquote>
<p><code>.config()</code>方法在后文还会涉及，服务、指令、过滤器也会在后文有详细的讲解。</p>
</blockquote>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC是软件工程中的一种设计模式，既把应用系统分为模型（Model）、视图（View）和控制器（Controller）三个基本部分，并且模型层与视图层之间是相互隔离的。简单的描述每个部分的职能：</p>
<ul>
<li>模型层：管理数据模型。</li>
<li>视图层：控制UI的展现更新等。</li>
<li>控制层：负责具体业务逻辑处理、请求处理转发等，是模型层和视图之间的桥梁。</li>
</ul>
<p>AngularJS是为数不多实现了MVC设计模式的前端框架，为前端应用在开发时期的功能职责切分、代码复用及后期的维护提供了极大的便利。</p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>在AngularJS中，模块是万源之本，所以AngularJS中的所有东西都是通过模块创建的，Controller也不例外。我们可以使用模块对象的<code>.controller()</code>方法创建控制器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"GreetingController"</span>, [<span class="string">"$scope"</span>, function($scope) &#123;</span><br><span class="line">  $scope.greeting = <span class="string">"Hello!"</span>;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看到，<code>.controller()</code>方法有两个参数：</p>
<ul>
<li>第一个参数类型为字符串，为Controller的名称。</li>
<li>第二个参数类型为数组，该数组用于注入当前Controller要用到的服务及实现业务逻辑的函数，这里要注意的是实现逻辑的函数始终是作为数组的最后一个元素，并且要将前面注入的服务作为该函数的参数传入。</li>
</ul>
<p>这里先简单描述一下<code>$scope</code>，在AngularJS中有一个重要的概念是服务，而<code>$scope</code>就是一个AngularJS内置的服务，在后面的章节中会详细讲解服务。那么<code>$scope</code>服务从字面理解是作用域的意思，其实也差不太多，如果用OO的思想将AngularJS的Controller看作是一个类，那么<code>$scope</code>服务就代表了这个类的作用域，那么就可以通过<code>$scope</code>服务给这个类添加属性或者方法，上面的代码示例中通过<code>$scope</code>服务给<code>GreetingController</code>控制器添加了字符串属性<code>greeting</code>及对象属性<code>person</code>。</p>
<p>所以上面代码的含义是，首先创建了名为<code>mainModule</code>的模块，然后在<code>mainModule</code>模块中创建了名为<code>GreetingController</code>的控制器，并使用<code>$scope</code>服务给该控制器添加了名为<code>greeting</code>和<code>person</code>的属性。</p>
<p>创建好Controller后，来看看如何使用它：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Controller<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"GreetingController"</span>&gt;</span></span><br><span class="line">      &#123;&#123; greeting &#125;&#125; &#123;&#123; person.name &#125;&#125; !</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>前文中介绍过在HTML页面中，通过使用<code>ng-app</code>指令给标签绑定模块。同理，我们可以使用<code>ng-controller</code>指令给标签及它的子标签绑定Controller，绑定了Controller的标签及它的子标签都可以使用Controller中的属性或者方法。我们可以使用双花括号语法访问Controller的属性或调用方法。运行效果很简单，就是将这两个属性的值输出到页面。</p>
<p>我们再来看看如何在Controller中添加方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"GreetingController"</span>, [<span class="string">"$scope"</span>, function($scope) &#123;</span><br><span class="line">  $scope.personName = <span class="string">"Everyone"</span>;</span><br><span class="line"></span><br><span class="line">  $scope.welcomeJason = function() &#123;</span><br><span class="line">    $scope.personName = <span class="string">"Jason"</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  $scope.welcomeGreen = function() &#123;</span><br><span class="line">    $scope.personName = <span class="string">"Green"</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们给<code>GreetingController</code>添加了<code>personName</code>属性和<code>welcomeJason()</code>、<code>welcomeGreen()</code>两个方法，并在这两个方法中分别对<code>personName</code>属性的值进行修改。再来看看HTML的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Controller<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"GreetingController"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"welcomeJason()"</span>&gt;</span>Jason<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"welcomeGreen()"</span>&gt;</span>Green<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">        Welcome &#123;&#123; personName &#125;&#125; !</span><br><span class="line">      <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在HTML代码中，添加了两个按钮，此时我们又看到了一个新的AngularJS指令<code>ng-click</code>，这个指令很好理解，就是给按钮绑定点击事件，当点击按钮时调用<code>GreetingController</code>中对应的方法，然后在<code>p</code>标签中显示<code>personName</code>属性。所以Controller中的方法不仅可以通过双花括号语法调用，也可以通过<code>ng-click</code>指令调用。我们来看看运行的效果：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-2.gif" alt="Demo for Controller"></p>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>Model指的是数据模型，在AngularJS中使用<code>$scope</code>服务给Controller添加的属性就是数据模型:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"GreetingController"</span>, [<span class="string">"$scope"</span>, function($scope) &#123;</span><br><span class="line">  $scope.person = &#123;</span><br><span class="line">    name: <span class="string">"Jason"</span>,</span><br><span class="line">    job: <span class="string">"Developer"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>上述代码示例中的<code>person</code>属性就是数据模型，下面看看如何使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Model<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"GreetingController"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">ng-model</span>=<span class="value">"person.name"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">ng-model</span>=<span class="value">"person.job"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">        Welcome &#123;&#123; person.name &#125;&#125;, He is a &#123;&#123; person.job &#125;&#125;!</span><br><span class="line">      <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述HTML代码示例中，我们又看到了新的指令<code>ng-model</code>，顾名思义，该指令就是用来将数据模型与HTML标签元素进行绑定的。上面的代码中分别将两个输入框与<code>person</code>对象的<code>name</code>和<code>job</code>属性进行了绑定，然后在<code>p</code>标签中输出，我们来看看运行效果：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-3.gif" alt="Demo for Model"></p>
<p>不难看出，当我们将<code>person</code>对象的属性与输入框绑定后，<code>person</code>对象属性的默认值就会显示在输入框里了，当我们修改输入框里的内容时会自动将数据通过Controller同步到<code>person</code>对象的相应属性上，所以<code>p</code>标签中的内容会实时跟着输入框的内容进行变化。</p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View层自然就是HTML中的DOM元素了，通过AngularJS提供的各个指令将DOM元素与Controller和Model进行绑定。由Controller负责将数据模型的内容通过双花括号语法或<code>ng-model</code>指令展现在DOM元素上，而当DOM元素中的值发生变化时会由Controller捕获到，并更新对应的数据模型。</p>
<h2 id="u6570_u636E_u53CC_u5411_u7ED1_u5B9A"><a href="#u6570_u636E_u53CC_u5411_u7ED1_u5B9A" class="headerlink" title="数据双向绑定"></a>数据双向绑定</h2><p>在MVC一节中，通过几个示例介绍了如何创建和使用Controller、Model，如何与View层交互，其实也引出了AngularJS的一个重要特性。在Controller小节的例子中，通过点击按钮由Controller更改数据模型并将其展示在页面中，这是通过数据模型的变化从而影响视图层的显示。在Model小节的例子中，通过修改输入框中的值，由Controller捕获并更新对应的数据模型，这是通过视图层的变化从而影响数据模型的值。这就是AngularJS的数据双向绑定特性。</p>
<h2 id="u670D_u52A1_uFF08Services_uFF09"><a href="#u670D_u52A1_uFF08Services_uFF09" class="headerlink" title="服务（Services）"></a>服务（Services）</h2><p>AngularJS中一个重要的概念是服务，这个服务的概念比较宽泛，比如一个常量值也算做一个服务，既提供一个不可变值的服务。变量、对象、函数都算做是服务。在AngularJS中内置了好几十个服务，这些内置的服务都以<strong>$</strong>符号开头，比如<code>$scope</code>、<code>$http</code>、<code>$log</code>、<code>$timeout</code>、<code>$interval</code>等等，从字面意思都不难理解它们的作用，更多的内置服务可以去AngularJS官网查看<a href="https://docs.angularjs.org/api" target="_blank" rel="external">API文档</a>。</p>
<h3 id="u670D_u52A1_u7279_u5F81"><a href="#u670D_u52A1_u7279_u5F81" class="headerlink" title="服务特征"></a>服务特征</h3><p>AngularJS中的服务有两个主要特点：</p>
<ul>
<li>延迟加载，当应用中的其他组建使用服务时才会实例化。</li>
<li>单例，在应用的整个生命周期中，一个服务只存在一份实例，所以服务一般用来共享可复用的代码逻辑或者数据。</li>
</ul>
<h3 id="u81EA_u5B9A_u4E49_u670D_u52A1"><a href="#u81EA_u5B9A_u4E49_u670D_u52A1" class="headerlink" title="自定义服务"></a>自定义服务</h3><p>除了内置的服务，我们还可以创建自己的服务，在AngularJS中我们可以通过<code>$provide</code>这个内置的服务来创建我们的自定义服务，<code>$provide</code>服务提供了五个方法供我们创建不同应用场景的自定义服务，这五个方法分别是<code>provider(name, provider)</code>、<code>factory(name, $getFn)</code>、<code>service(name, constructor)</code>、<code>value(name, value)</code>、<code>constant(name, value)</code>。</p>
<h4 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h4><p>我们先从<code>value(name, value)</code>这个方法看起，该方法有两个参数：</p>
<ul>
<li>第一个参数为服务的名称，类型为字符串。</li>
<li>第二个参数可以是字符串、数字、数组、对象或者函数。</li>
</ul>
<p>假设在我们的应用中，多个Controller中都使用了相同的属性，比如都需要用到客户端ID这个属性，那么我们可以将其抽象为一个服务，该服务就专门用来获取客户端ID，来看看如何创建这个服务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.value(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的示例代码创建了名为<code>clientId</code>的服务，该服务其实就是一个字符串。不过这和<code>$provide</code>服务有什么关系呢？其实上面这种写法并不是完整的写法，只是一个语法糖而已，真正完整的写法是在模块的<code>.config()</code>方法中通过<code>$provide</code>服务去创建：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.config(function($provide) &#123;</span><br><span class="line">    $provide.value(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>创建好服务后通过AngularJS的注入机制将其注入到Controller中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, [<span class="string">"$scope"</span>, <span class="string">"clientId"</span>, function($scope, clientId) &#123;</span><br><span class="line">  $scope.clientId = clientId;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"SecondController"</span>, [<span class="string">"$scope"</span>, <span class="string">"clientId"</span>, function($scope, clientId) &#123;</span><br><span class="line">  $scope.clientId = clientId;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>然后在HTML页面中正常使用Controller就可以了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Value Service<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"FirstController"</span>&gt;</span></span><br><span class="line">      Client ID in FirstController: &#123;&#123; clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"SecondController"</span>&gt;</span></span><br><span class="line">      Client ID in SecondController: &#123;&#123; clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上文中说过<code>$scope</code>服务的其中一个作用就是给Controller添加属性和方法，然后可以在绑定Controller的DOM中使用双花括号语法直接访问添加的属性或调用方法。然而就<code>$scope</code>服务的这一功能而言，AngularJS还提供了另一种方式，我们先来看看Controller的写法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, [<span class="string">"clientId"</span>, function(clientId) &#123;</span><br><span class="line">  this.clientId = clientId;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"SecondController"</span>, [<span class="string">"clientId"</span>, function(clientId) &#123;</span><br><span class="line">  this.clientId = clientId;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>上述代码中我们并没有将<code>$scope</code>服务注入到这两个Controller中，而是使用<code>this</code>创建了<code>clientId</code>属性，<code>this</code>代表Controller的实例。使用这种方式后在HTML页面中使用Controller也有点变化：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Value Service<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"FirstController as first"</span>&gt;</span></span><br><span class="line">      Client ID in FirstController: &#123;&#123; first.clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"SecondController as second"</span>&gt;</span></span><br><span class="line">      Client ID in SecondController: &#123;&#123; second.clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们看到在<code>ng-conroller</code>标签中不再是直接写Controller名称了，而是使用<code>as</code>关键字声明了Controller的实例，然后在双花括号中使用Controller的实例去访问属性或者调用方法。</p>
<blockquote>
<p>使用<code>$scope</code>服务和<code>this</code>给Controller添加属性或方法的效果是一样的，所以不存在谁好谁坏的概念，只不过使用<code>this</code>的方式更贴合OO的思想，而且在HTML代码中对使用的属性或方法有更直观的可读性，能一眼看到使用了哪个Controller的属性或方法，所以使用哪种方式按个人喜好，但是不建议混用这两种方式。</p>
</blockquote>
<p>这里在介绍另外一个语法糖，那就是在注入服务的时候不用繁复的在数组中和函数参数中都声明，只需要在函数的参数里声明就可以了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function($scope, clientId) &#123;</span><br><span class="line">  $scope.clientId = clientId;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function(clientId) &#123;</span><br><span class="line">  this.clientId = clientId;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant</h4><p>我们再来看看<code>constant(name, value)</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.constant(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br></pre></td></tr></table></figure>
<p>该方法和<code>value(name, value)</code>在创建的服务内容形式上来说是一样的，但是两者创建的服务在功能性上还是有区别的：</p>
<ul>
<li>从名称就可以看出用<code>constant(name, value)</code>方法创建的服务是不可修改的。</li>
<li>使用<code>constant(name, value)</code>创建的服务可以在模块的<code>.config()</code>方法中注入，也就是可以在创建其他服务时使用，而使用<code>value(name, value)</code>创建的服务不可以。</li>
</ul>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>现在又有一个需求，希望能获取到当前时间添加在客户端ID后面，那么我们可以使用<code>service(name, constructor)</code>方法来创建获取当前时间的服务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.value(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line"></span><br><span class="line">mainModule.service(<span class="string">"currentDate"</span>, <span class="type">Date</span>);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function(clientId, currentDate) &#123;</span><br><span class="line">  this.clientId = clientId + <span class="string">"-"</span> + currentDate;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Service Service<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"FirstController as first"</span>&gt;</span></span><br><span class="line">      Client ID in FirstController: &#123;&#123; first.clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出结果：<br><code>Client ID in FirstController: qazxsw123456-Thu Sep 08 2016 17:05:30 GMT+0800 (CST)</code></p>
<p><code>service(name, constructor)</code>方法的第二个参数是函数构造器，也就是函数的实例，所以<code>currentDate</code>服务的实体其实就是<code>new Date()</code>。</p>
<h4 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h4><p>现在，我们希望通过一个服务就可以完成客户端ID和当前时间的拼接，不需要给Controller注入两个服务，来看看如何用<code>factory(name, $getFn)</code>方法来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.constant(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line"></span><br><span class="line">mainModule.factory(<span class="string">"clientIdAndCurrentDate"</span>, function(clientId) &#123;</span><br><span class="line">  <span class="keyword">return</span> clientId + <span class="string">"-"</span> + new <span class="type">Date</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function(clientIdAndCurrentDate) &#123;</span><br><span class="line">  this.clientId = clientIdAndCurrentDate;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先我们需要用<code>constant(name, value)</code>方法创建<code>clientId</code>服务，因为需要将它注入到新的服务中，前文也介绍过<code>constant(name, value)</code>和<code>value(name, value)</code>方法的区别。然后使用<code>factory(name, $getFn)</code>方法创建<code>clientIdAndCurrentDate</code>服务，该函数的第二个参数类型是函数，我们在该函数中将<code>clientId</code>服务返回的客户端ID与<code>Date</code>构造器返回的时间进行拼接然后返回，当然运行结果还是一样的：<br><code>Client ID in FirstController: qazxsw123456-Thu Sep 08 2016 17:05:30 GMT+0800 (CST)</code></p>
<p>其实这个服务还可以写成这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.constant(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line"></span><br><span class="line">mainModule.service(<span class="string">"currentDate"</span>, <span class="type">Date</span>);</span><br><span class="line"></span><br><span class="line">mainModule.factory(<span class="string">"clientIdAndCurrentDate"</span>, function(clientId, currentDate) &#123;</span><br><span class="line">  <span class="keyword">return</span> clientId + <span class="string">"-"</span> + currentDate;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这相当于<code>clientIdAndCurrentDate</code>服务对<code>currentDate</code>服务进行了进一步的配置或者说增加了功能，那么也就是说<code>factory(name, $getFn)</code>方法相比<code>service(name, constructor)</code>方法可以创建更复杂一些的服务。</p>
<h4 id="Povider"><a href="#Povider" class="headerlink" title="Povider"></a>Povider</h4><p>现在又有新的需求，希望对<code>clientId</code>后面的时间进行格式化，但假设我们没有权限去更改<code>clientIdAndCurrentDate</code>服务，那么这时我们需要使用<code>provider(name, provider)</code>方法创建另外一个服务，然后对<code>clientIdAndCurrentDate</code>服务进行配置，来看看如何实现这个服务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.constant(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line"></span><br><span class="line">mainModule.service(<span class="string">"currentDate"</span>, <span class="type">Date</span>);</span><br><span class="line"></span><br><span class="line">mainModule.factory(<span class="string">"clientIdAndCurrentDate"</span>, function(clientId, currentDate) &#123;</span><br><span class="line">  <span class="keyword">return</span> clientId + <span class="string">"-"</span> + currentDate;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.provider(<span class="string">"clientIdAndCurrentDateByFormat"</span>, function() &#123;</span><br><span class="line">  this.formatFunc = function(str) &#123;</span><br><span class="line">    <span class="keyword">var</span> clientId = str.substring(<span class="number">0</span>, str.indexOf(<span class="string">"-"</span>));</span><br><span class="line">    <span class="keyword">var</span> dateStr = str.substring(str.indexOf(<span class="string">"-"</span>), str.length);</span><br><span class="line">    <span class="keyword">var</span> dateObj = new <span class="type">Date</span>(dateStr);</span><br><span class="line">    <span class="keyword">var</span> year = dateObj.getFullYear().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> month = (dateObj.getMonth() + <span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> day = dateObj.getDate().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> hour = dateObj.getHours().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> minute = dateObj.getMinutes().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> second = dateObj.getSeconds().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">return</span> clientId + <span class="string">"-"</span> + [year, (month &gt;= <span class="number">10</span> ? month : <span class="number">0</span> + month), (day &gt; <span class="number">10</span> ? day : <span class="number">0</span> + day), hour, minute, second].<span class="built_in">join</span>(<span class="string">""</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  this.$<span class="keyword">get</span> = function(clientIdAndCurrentDate) &#123;</span><br><span class="line">    <span class="keyword">return</span> this.formatFunc(clientIdAndCurrentDate);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function(clientIdAndCurrentDateByFormat) &#123;</span><br><span class="line">  this.clientId = clientIdAndCurrentDateByFormat;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先我们创建了<code>formatFunc()</code>辅助配置函数，然后实现了<code>$get</code>方法，通过<code>formatFunc()</code>辅助函数配置<code>clientIdAndCurrentDate</code>服务，我们来看运行结果：<br><code>Client ID in FirstController: qazxsw123456-20160909113523</code></p>
<p>要注意的一点是，通过<code>provider(name, provider)</code>方法创建服务时必须要<strong>显式</strong>的实现<code>$get</code>方法，并且只有在<code>$get</code>方法中才能注入其他服务。在AngularJS中服务仅指<code>$get</code>返回的东西，所以前四种创建服务的方法其实都是<code>provider(name, provider)</code>方法根据不同应用场景实现的语法糖，比如<code>factory</code>方法其实就是把一个函数当作了<code>$get</code>方法，<code>service</code>方法其实是将一个函数构造方法或者说函数实例当作了<code>$get</code>方法，<code>value</code>和<code>constant</code>方法其实又是对<code>factory</code>方法的语法糖实现。所以在自定义服务时可按需选择不同的方法创建服务。</p>
<h2 id="u6307_u4EE4_uFF08Directive_uFF09"><a href="#u6307_u4EE4_uFF08Directive_uFF09" class="headerlink" title="指令（Directive）"></a>指令（Directive）</h2><p>指令是AngularJS中另一个主要的特性，指令的作用可以用一句话描述，就是可以给HTML元素赋予特殊或自定义的行为，比如监听事件、视图模板代理等。在上文中我们使用过的<code>ng-app</code>、<code>ng-controller</code>、<code>ng-model</code>就是AngularJS中的指令。</p>
<h3 id="u6307_u4EE4_u7684_u547D_u540D"><a href="#u6307_u4EE4_u7684_u547D_u540D" class="headerlink" title="指令的命名"></a>指令的命名</h3><p>指令的命名和使用写法比较有意思，一般情况下在定义指令时推荐使用驼峰命名法，比如<code>ngModel</code>、<code>ngApp</code>，但是在HTML中大小写是不敏感的，所以在HTML中使用指令时推荐使用小写字母加破折号的形式，比如<code>ng-model</code>、<code>ng-app</code>。除了使用小写破折号这种方式，还有以下几种使用写法：</p>
<ul>
<li><code>ng:model</code></li>
<li><code>ng_model</code></li>
<li><code>data-ng-bind</code></li>
<li><code>x-ng-bind</code></li>
</ul>
<p>大家可以根据自己喜好选择使用写法，但是尽量保持写法统一。</p>
<h3 id="u6307_u4EE4_u7684_u5F62_u5F0F"><a href="#u6307_u4EE4_u7684_u5F62_u5F0F" class="headerlink" title="指令的形式"></a>指令的形式</h3><p>在AngularJS中，指令有四种表现形式，既标签形式、标签属性形式、标签class名称形式、注释形式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">my-dir</span>&gt;</span><span class="tag">&lt;/<span class="title">my-dir</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">my-dir</span>=<span class="value">"exp"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- directive: my-dir exp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"my-dir: exp;"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般情况下，推荐使用标签形式和标签属性形式。</p>
<h3 id="u4F7F_u7528_u6307_u4EE4"><a href="#u4F7F_u7528_u6307_u4EE4" class="headerlink" title="使用指令"></a>使用指令</h3><p>与Controller一样，指令也是通过AngularJS的Model创建的，使用<code>directive(name, directiveFactory)</code>方法创建指令，该方法有两个参数：</p>
<ul>
<li>第一个参数为指令名称，命名规范在上文中已经说过了。</li>
<li>第二个参数是一个工厂函数，该函数需要返回一个对象，我们通过配置该对象中的不同属性从而告诉AngularJS内置的<code>$compile</code>服务实现指令的不同功能。</li>
</ul>
<h4 id="u6307_u4EE4_u7C7B_u578B"><a href="#u6307_u4EE4_u7C7B_u578B" class="headerlink" title="指令类型"></a>指令类型</h4><p>上文中说过指令的实现是通过工厂函数返回对象，然后通过配置对象的不同属性实现不同功能，所以设置指令的类型也是通过配置属性对象完成的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"A"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective1"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective2"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"AE"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">my-directive1</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">my-directive2</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;div my-directive2&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看出，可以通过配置返回对象的<code>restrict</code>属性设置指令的类型，可配置的值分别为：</p>
<ul>
<li><code>&quot;A&quot;</code>：代表且仅可代表标签属性类型的指令。</li>
<li><code>&quot;E&quot;</code>：代表且仅可代表标签类型的指令。</li>
<li><code>&quot;C&quot;</code>：代表且仅可代表class名称类型的指令。</li>
<li><code>&quot;M&quot;</code>：代表且仅可代表注释类型的指令。</li>
</ul>
<p>如果想设置一个多类型的指令，那么可以将类型标识写在一起，比如<code>&quot;AEC&quot;</code>代表既是标签属性类型，又是标签类型，还是class名称类型。如果不配置<code>restrict</code>属性，那么表示指令的类型为默认的<code>&quot;AE&quot;</code>类型。</p>
<h4 id="u901A_u8FC7_u6307_u4EE4_u5C01_u88C5UI_u6A21_u677F"><a href="#u901A_u8FC7_u6307_u4EE4_u5C01_u88C5UI_u6A21_u677F" class="headerlink" title="通过指令封装UI模板"></a>通过指令封装UI模板</h4><p>在前端应用的开发过程中，不同的页面常有很多一样的UI元素，如果每个页面都写一遍，那么在维护时就常会牵一发而动全身，AngularJS中的指令可以很好的解决这个问题，它可以将UI片段封装为一个指令，从而可以在不同的页面中复用，那么在维护时就是四两拨千斤的效果。下面来看看如何实现模板指令：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function() &#123;</span><br><span class="line">  this.name = <span class="string">"Jason"</span>;</span><br><span class="line">  this.job = <span class="string">"Developer"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    template: <span class="string">"Name: &#123;&#123;mc.name&#125;&#125;, Job: &#123;&#123;mc.job&#125;&#125;"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController as mc"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;div my-directive&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码示例中，我们将本该写在HTML中的展示代码设置给了返回对象的<code>template</code>属性。为了能更好的管理UI模板，我们还可以将UI展示代码提炼成单独的HTML模板文件，并可以使用指令的<code>templateUrl</code>属性设置HTML模板文件名称，这样便可以大大降低指令和UI模板的耦合度：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    templateUrl: <span class="string">"myTemplate.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- myTemplate.html --&gt;</span></span><br><span class="line">Name: &#123;&#123;mc.name&#125;&#125;, Job: &#123;&#123;mc.job&#125;&#125;</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>那么问题来了，如果UI模板文件很多的话，按上面的方法就要写很多个对应的指令，而且只是UI模板文件名称不一样而已，实在有点冗余。AngularJS提供了另外一种解决方法，那就是可以通过给模板指令设置相关属性，从而动态的加载UI模板文件，我们来看看如何实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function() &#123;</span><br><span class="line">  this.name = <span class="string">"Jason"</span>;</span><br><span class="line">  this.job = <span class="string">"Developer"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    templateUrl: function(elem, attr) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"myTemplate-"</span> + attr.type + <span class="string">".html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController as mc"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">type</span>=<span class="value">"name"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">type</span>=<span class="value">"job"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;div my-directive type="name"&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;div my-directive type="job"&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- myTemplate-name.html --&gt;</span></span><br><span class="line">Name: &#123;&#123;mc.name&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- myTemplate-job.html --&gt;</span></span><br><span class="line">Job: &#123;&#123;mc.job&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看出，<code>template</code>和<code>templateUrl</code>两个属性的值不只是接受字符串，还接受函数。要注意的是该函数默认带两个参数：</p>
<ul>
<li>第一个参数代表当前的HTML DOM元素。</li>
<li>第二个参数代表当前HTML DOM元素的属性对象，在函数体内可以为该对象设置任何属性。</li>
</ul>
<p>在上面的示例中，我们给代表当前DOM元素的属性对象设置了<code>type</code>属性，用于标识UI模板文件名称，这样我们就可以通过一个专有的模板指令来控制所有的UI模板文件了。</p>
<h4 id="u6307_u4EE4_u7684_u4F5C_u7528_u57DF"><a href="#u6307_u4EE4_u7684_u4F5C_u7528_u57DF" class="headerlink" title="指令的作用域"></a>指令的作用域</h4><p>上面的示例中，我们通过配置可以实现动态加载UI模板文件，但是我们无法动态指定UI模板文件中显示的内容。这一节我们来了解一下如何通过指令的隔离域达到在同一个指令中动态指定UI模板文件中要显示的内容，先看看代码示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function() &#123;</span><br><span class="line">  this.jason = &#123; name: <span class="string">"Jason"</span>, job: <span class="string">"Developer"</span> &#125;;</span><br><span class="line">  this.green = &#123; name: <span class="string">"Green"</span>, job: <span class="string">"Doctor"</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span>,</span><br><span class="line">    scope: &#123;</span><br><span class="line">      personInfo: <span class="string">"=person"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    templateUrl: <span class="string">"myTemplate.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController as mc"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">person</span>=<span class="value">"mc.jason"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">hr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">person</span>=<span class="value">"mc.green"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- myTemplate.html --&gt;</span></span><br><span class="line">Name: &#123;&#123;personInfo.name&#125;&#125;, Job: &#123;&#123;personInfo.job&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>从示例中可以看到，我们给指令的返回对象又添加了一个属性<code>scope</code>，这就是指令的作用域属性，<code>scope</code>属性有三种可设置的值：</p>
<ul>
<li><code>false</code>：默认值，这表示指令共享它父节点的Controller的作用域，也就是可以使用双花括号语法直接访问父节点Controller作用域中的属性。</li>
<li><code>true</code>：创建指令自己的作用域，但是该作用域继承父节点Controller的作用域。</li>
<li><code>{}</code>：第三种是设置一个对象，表示创建了指令自己独立的作用域，与父节点Controller的作用是完全隔离的。</li>
</ul>
<p>如果我们希望指令的隔离作用域和父节点Controller的作用域之间进行交互，那么就需要将两者进行绑定，这里有三种绑定方式：</p>
<ul>
<li>使用<code>@</code>实现单向数据绑定，但是只限于绑定Controller作用域中值为字符串的属性，因为是单向绑定，所以父节点Controller修改绑定的属性可影响到指令作用域中对应的属性，反之则不可以。在HTML中使用双花括号语法取值，比如<code>person=&quot;&quot;</code>。</li>
<li>使用<code>=</code>实现双向数据绑定，在父节点Controller中修改属性和在指令中修改属性可相互影响。在HTML中直接使用属性名称，比如<code>person=&quot;jasonObj&quot;</code>。</li>
<li>使用<code>&amp;</code>实现函数绑定，用于绑定Controller中值为函数的属性，在HTML中直接调用函数，比如<code>action=&quot;click()&quot;</code>。</li>
</ul>
<p>上面的示例中我们给<code>myDirective</code>指令设置了隔离域并添加了名为<code>personInfo</code>的属性，并与父节点的<code>MyController</code>进行数据双向绑定，在HTML代码中，就可以通过<code>&lt;my-directive&gt;</code>指令标签的<code>person</code>属性与<code>MyController</code>的数据绑定了。另外，在进行绑定时还有一种简写的方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">scope: &#123;</span><br><span class="line">  personInfo: <span class="string">"="</span></span><br><span class="line">  <span class="comment">// personInfo: "@"</span></span><br><span class="line">  <span class="comment">// personInfo: "&amp;"</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">scope: &#123;</span><br><span class="line">  personInfo: <span class="string">"=personInfo"</span></span><br><span class="line">  <span class="comment">// personInfo: "@personInfo"</span></span><br><span class="line">  <span class="comment">// personInfo: "&amp;personInfo"</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="u6307_u4EE4_u7684Controller"><a href="#u6307_u4EE4_u7684Controller" class="headerlink" title="指令的Controller"></a>指令的Controller</h4><p>在指令中也可以创建Controller，和在Module中创建Controller很类似，既定义函数，在参数中注入需要的AngularJS服务既可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function($scope) &#123;</span><br><span class="line">  $scope.green = &#123; name: <span class="string">"Green"</span>, job: <span class="string">"Doctor"</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span>,</span><br><span class="line">    scope: &#123;</span><br><span class="line">      person: <span class="string">"="</span></span><br><span class="line">    &#125;,</span><br><span class="line">    controller: function($scope) &#123;</span><br><span class="line">      $scope.jason = &#123; name: <span class="string">"Jason"</span>, job: <span class="string">"Developer"</span> &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    templateUrl: <span class="string">"myTemplate.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">person</span>=<span class="value">"green"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- myTemplate.html --&gt;</span></span><br><span class="line">Name: &#123;&#123;jason.name&#125;&#125;, Job: &#123;&#123;jason.job&#125;&#125;</span><br><span class="line">Name: &#123;&#123;person.name&#125;&#125;, Job: &#123;&#123;person.job&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们给<code>myDirective</code>指令添加了Controller，有一点不同的是在添加Controller时不能设置名称，指令的Controller名称默认与指令名称一样，如果需要另外指定名称，需要配置<code>controllerAs</code>指定Controller的名称：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">controller: function($scope) &#123;</span><br><span class="line">  $scope.jason = &#123; name: <span class="string">"Jason"</span>, job: <span class="string">"Developer"</span> &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">controllerAs: <span class="string">"directiveController"</span>,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在上面示例的UI模板文件中可以看出，既可以使用指令隔离域中与父节点Controller绑定的属性，也可以使用在指令自己的Controller中定义在隔离域的属性。</p>
<h4 id="u6307_u4EE4_u4E4B_u95F4_u7684_u4EA4_u4E92"><a href="#u6307_u4EE4_u4E4B_u95F4_u7684_u4EA4_u4E92" class="headerlink" title="指令之间的交互"></a>指令之间的交互</h4><p>指令之间的交互主要是以指令的Controller为桥梁来实现的，这里的交互指的是子指令与父指令之间的交互，我们可以使用指令的<code>require</code>属性设置要引用的父指令的Controller，这里有几种配置方式：</p>
<ul>
<li><code>require: &quot;controllerName&quot;</code>：只查找指令自己的Controller。</li>
<li><code>require: &quot;^controllerName&quot;</code>：查找指令自己的Controller以及父指令的Controller。</li>
<li><code>require: &quot;^^controllerName&quot;</code>：只查找父指令的Controller。</li>
<li><code>require: [&quot;^controllerName1&quot;, &quot;^controllerName2&quot;]</code>：引用多个Controller。</li>
</ul>
<p>如果指令查找到引用的Controller后该如何使用呢，这就要使用指令的另一个重要的属性<code>link</code>函数了。<code>link</code>函数主要用来为DOM元素添加事件监听、监视模型属性变化、以及更新DOM，该函数共有五个参数：</p>
<ul>
<li><code>scope</code>：指令的作用域，默认是父节点Controller的作用域，如果指令有创建自己的作用域，那么则指指令自己的作用域。</li>
<li><code>element</code>：指令的jQLite(jQuery的子集)包装的DOM元素，可以通过该参数操作指令所在的DOM元素。</li>
<li><code>attrs</code>：指令所在DOM元素的属性对象，通过<code>.</code>语法可以获取到给DOM元素添加的属性。</li>
<li><code>controller</code>：指令通过<code>require</code>属性引用的Controller实例。</li>
<li><code>transcludeFn</code>：嵌入函数。</li>
</ul>
<p><code>link</code>函数的其他几个参数后面文章中都会讲到，当指令找到通过<code>require</code>属性引用的Controller后，我们就可以通过<code>link</code>函数的第四个参数访问引用的Controller了。来看一个示例：</p>
<h4 id="u901A_u8FC7_u6307_u4EE4_u64CD_u4F5CDOM_u5143_u7D20"><a href="#u901A_u8FC7_u6307_u4EE4_u64CD_u4F5CDOM_u5143_u7D20" class="headerlink" title="通过指令操作DOM元素"></a>通过指令操作DOM元素</h4><p>我们了解了<code>link</code>函数后就可以使用该函数实现各种有用的指令了，比如通过指令操作DOM元素：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function($interval) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"A"</span>,</span><br><span class="line">    link: function(scope, element, attrs) &#123;</span><br><span class="line">      $interval(function() &#123;</span><br><span class="line">        element.text(new <span class="type">Date</span>());</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">      Current Date is: <span class="tag">&lt;<span class="title">span</span> <span class="attribute">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例中，首先我们限定了<code>myDirective</code>指令只能以标签属性的形式使用，然后注入了AngularJS的内置服务<code>$interval</code>，通过<code>link</code>函数的第二个参数获取到指令所在的DOM元素，然后周期性更新DOM元素显示的内容。<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-4.gif" alt=""></p>
<h4 id="u6307_u4EE4_u7684_u5185_u5D4C_u673A_u5236"><a href="#u6307_u4EE4_u7684_u5185_u5D4C_u673A_u5236" class="headerlink" title="指令的内嵌机制"></a>指令的内嵌机制</h4><p>大家都知道HTML中的DOM元素是具有层级关系的，一般情况下我们使用指令封装的UI模板颗粒度都会比较小，所以就会出现指令嵌套的现象，这几需要用到指令的内嵌机制了，指令的<code>transclude</code>属性默认为<code>false</code>，如果将其设置为<code>true</code>，那么该指令就开启了内嵌机制，也就是说指令标签之间的内容可以被指定嵌入UI模板中被<code>ng-transclude</code>内置指令标记过的DOM元素中，结合之前说过的父子指令交互的内容来实现一个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myTabs"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span>,</span><br><span class="line">    transclude: <span class="literal">true</span>,</span><br><span class="line">    controller: function($scope) &#123;</span><br><span class="line">      $scope.panes = [];</span><br><span class="line">      <span class="keyword">var</span> panes = $scope.panes;</span><br><span class="line">      this.addPane = function(pane) &#123;</span><br><span class="line">        <span class="keyword">if</span>(panes.length == <span class="number">0</span>) &#123;</span><br><span class="line">          $scope.select(pane);</span><br><span class="line">        &#125;;</span><br><span class="line">        panes.push(pane);</span><br><span class="line">      &#125;;</span><br><span class="line">      $scope.select = function(pane) &#123;</span><br><span class="line">        angular.forEach(panes, function(pane) &#123;</span><br><span class="line">          pane.selected = <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        pane.selected = <span class="literal">true</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    templateUrl: <span class="string">"myTabs.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myPane"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span>,</span><br><span class="line">    require: <span class="string">"^^myTabs"</span>,</span><br><span class="line">    scope: &#123;</span><br><span class="line">      name: <span class="string">"@"</span>,</span><br><span class="line">      job: <span class="string">"@"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    link: function(scope, element, attrs, controller) &#123;</span><br><span class="line">      controller.addPane(scope);</span><br><span class="line">    &#125;,</span><br><span class="line">    templateUrl: <span class="string">"myPane.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了两个指令，<code>myTabs</code>和<code>myPane</code>，在<code>myTabs</code>指令中，我们限定它只能以标签形式使用，开启了内嵌机制，并定义了它自己的Controller，在Controller中定义了<code>panes</code>变量和<code>addPane(pane)</code>，<code>select(pane)</code>两个方法，方法的具体实现内容这里就不解释了，都很简单，最后指定了UI模板文件<code>myTabs.html</code>。</p>
<p>在<code>myPane</code>指令中同样限定只能以标签形式使用，指定了要引用的父节点的Controller名称，后创建了自己的隔离域，定义了<code>name</code>，<code>job</code>两个属性，并进行了字符串的单向绑定，然后定义了<code>link</code>函数，通过第四个参数访问到了父节点的<code>myTabs</code>Controller，并调用<code>addPane(pane)</code>函数，将自己的隔离域作为参数传入，最后指定了UI模板文件<code>myPane.html</code>。</p>
<p>再来看看<code>index.html</code>和<code>myTabs.html</code>，<code>myPane.html</code>这两个模板文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">my-tabs</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-pane</span> <span class="attribute">name</span>=<span class="value">"Jason"</span> <span class="attribute">job</span>=<span class="value">"Developer"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-pane</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-pane</span> <span class="attribute">name</span>=<span class="value">"Green"</span> <span class="attribute">job</span>=<span class="value">"Doctor"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-pane</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">my-tabs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--myTabs.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"pane in panes"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">""</span> <span class="attribute">ng-click</span>=<span class="value">"select(pane)"</span>&gt;</span>&#123;&#123;pane.name&#125;&#125;<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"paneContainer"</span> <span class="attribute">ng-transclude</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--myPane.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-show</span>=<span class="value">"selected"</span>&gt;</span></span><br><span class="line">  I am &#123;&#123;name&#125;&#125;, my job is &#123;&#123;job&#125;&#125;!</span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>index.html</code>中，<code>myTabs</code>指令包含两个<code>myPane</code>指令，这两个<code>myPane</code>指令所显示的内容将嵌入在<code>myTabs.html</code>中id为<code>paneContainer</code>的DIV中，也就是<code>myPane.html</code>中的内容会被嵌入在这个DIV里。</p>
<p>上面这三个文件中有几个点需要注意：</p>
<ul>
<li>因为在<code>myPane</code>指令的隔离域中定义了<code>name</code>和<code>job</code>属性，并进行了字符串绑定，所以在<code>index.html</code>文件中，可以对<code>myPane</code>标签里的<code>name</code>，<code>job</code>属性直接进行字符串赋值。</li>
<li>因为在<code>myPane</code>指令中引用了<code>myTabs</code>指令的Controller，并在<code>link</code>函数中将隔离域作为参数传给了<code>myTabs</code>，既<code>myTabs</code>指令的Controller中的<code>select(pane)</code>和<code>addPane(pane)</code>函数的参数均为<code>myPane</code>指令的隔离域，所以在<code>myTabs.html</code>文件中可以直接使用<code>pane</code>访问<code>myPane</code>指令隔离域中定义的属性，比如<code></code>，并且也可以在<code>myTabs</code>指令在<code>myPane</code>的隔离域中定义属性，比如<code>pane.selected = true</code>，给隔离域定义了<code>selected</code>的属性，然后可以在<code>myPane</code>指令中使用。</li>
<li><code>ng-show</code>是AngularJS内置的指令，用于显示或隐藏指定的DOM元素。</li>
</ul>
<p>看看运行效果：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-5.gif" alt=""></p>
<p><code>link</code>函数的第五个参数<code>transcludeFn</code>是一个函数，该函数常用的有两个参数<code>scope</code>和<code>function(clone){}</code>，既<code>transcludeFn(scope, function(clone){})</code>。前者是嵌入内容的作用域，与指令的隔离作用域是平行的，后者函数的参数<code>clone</code>是嵌入的内容的jquery封装，可以通过它对嵌入的内容进行DOM操作。</p>
<h4 id="u6307_u4EE4_u7684_u5176_u4ED6_u5C5E_u6027"><a href="#u6307_u4EE4_u7684_u5176_u4ED6_u5C5E_u6027" class="headerlink" title="指令的其他属性"></a>指令的其他属性</h4><p><strong>priority</strong>用于指定指令的优先级，该属性的值从1开始。当有多个指令定义在同一个DOM元素中时就需要通过该属性明确它们的执行顺序。</p>
<p><strong>replace</strong>用于判定是否将UI模板的内容替换掉指令标签本身，该属性默认值为<code>false</code>，既保留指令标签本身，若设置为<code>true</code>则替换指令标签。</p>
<h2 id="u7EC4_u5EFA_uFF08Component_uFF09"><a href="#u7EC4_u5EFA_uFF08Component_uFF09" class="headerlink" title="组建（Component）"></a>组建（Component）</h2><p>在AngularJS 1.5中新加了组建的概念，它的意图是希望从AngularJS 1.x向AngularJS 2.0迁移时能更加平顺，AngularJS团队也提倡使用组建化模式开发Web应用。那么组建是什么呢？其实组建就是指令的一种特性形式，它规避了一些指令中晦涩难理解的东西，比如<code>compile</code>函数，<code>link</code>函数，<code>scope</code>，<code>restrict</code>等，所以组建的目的就是能让我们更为傻瓜式的创建指令，能更好的遵循组建化的开发模式，提高性能以及更容易向AngularJS 2.0迁移。</p>
<h3 id="u521B_u5EFA_u7EC4_u5EFA"><a href="#u521B_u5EFA_u7EC4_u5EFA" class="headerlink" title="创建组建"></a>创建组建</h3><p>我们可以使用Module的<code>component</code>方法创建组建：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    name: <span class="string">"="</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>component</code>方法的第一个参数是组建名称，命名规则和使用方法与指令一样，第二个参数和创建指令有点不同，它并不是一个函数，而是一个对象，在该对象中对组建的配置和在指令中的配置方式很类似。</p>
<p>我们先来看看组建和指令之间有哪些区别：</p>
<ul>
<li>组建中不提供手动配置作用域，默认的作用域就是隔离域。</li>
<li>组建中通过<code>bindings</code>属性进行数据绑定，除了<code>=</code>，<code>@</code>，<code>&amp;</code>三种绑定方式以外还增加了一种<code>&lt;</code>方式，既单向绑定，但不限于字符串。从而保证了组建有自己的清晰的输入输出API。并且通过<code>bindings</code>对象绑定的属性直接绑定在组建的Controller上。</li>
<li>组建的Controller默认名称为<code>$ctrl</code>，当然也可以使用<code>controllerAs</code>属性指定Controller的名称。</li>
<li>组建只能以标签形式使用。</li>
<li>组建中没有<code>link</code>函数，<code>compile</code>函数，<code>priority</code>属性，<code>restrict</code>属性。</li>
<li>组件只能控制自身的输入输出，组建不允许修改属于自己隔离域以外的任何数据和DOM元素。一般情况下，AngularJS通过作用域（Scope）继承的特性支持跨层级修改数据的能力，但是如果当修改数据职责不清晰或不恰当的时候就会导致各种问题，所以这也就是组建的作用域默认都是隔离域的原因。</li>
</ul>
<p>使用起来和指令比较类似：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function() &#123;</span><br><span class="line">  this.person = &#123;</span><br><span class="line">    name: <span class="string">"Jason"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    person: <span class="string">"="</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Component<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController as mc"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-component</span> <span class="attribute">person</span>=<span class="value">"mc.person"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--myTemplate.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">span</span>&gt;</span>Name: &#123;&#123;$ctrl.person.name&#125;&#125;<span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="u7EC4_u5EFA_u7684_u751F_u547D_u5468_u671F"><a href="#u7EC4_u5EFA_u7684_u751F_u547D_u5468_u671F" class="headerlink" title="组建的生命周期"></a>组建的生命周期</h3><p>在组建的整个生命周期里，AngularJS提供了五个关键点的方法，可供我们监听到组建的运行状态：</p>
<ul>
<li><code>$onInit()</code>：该方法在组件及其所有 binding 初始化之后被调用，从而我们就有了一个清晰的地方统一存放数据初始化的逻辑：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.name = <span class="string">"jason"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将初始化数据的逻辑放在onInit方法中</span></span><br><span class="line"></span><br><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.$onInit = function() &#123;</span><br><span class="line">      this.name = <span class="string">"jason"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$onChanges(changesObj)</code>：当组建中单向绑定的属性值发生变化时被调用，这里要注意的是只有绑定属性值的引用发生变化时才能监听到，如果只是在指令内对属性进行修改，该方法是无法监听到的。通过该方法的参数可以获取到被修改数据当前的值、修改之前的值、是否时第一次修改：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.$onChanges = function(changesObj) &#123;</span><br><span class="line">      <span class="keyword">if</span>(changesObj.name) &#123;</span><br><span class="line">        <span class="comment">// name当前的值</span></span><br><span class="line">        <span class="keyword">var</span> nameCurrentValue = changesObj.name.currentValue;</span><br><span class="line">        <span class="comment">// name修改前的值</span></span><br><span class="line">        <span class="keyword">var</span> namePreviousValue = changesObj.name.previousValue;</span><br><span class="line">        <span class="comment">// 是否是第一次修改</span></span><br><span class="line">        <span class="keyword">var</span> isFirstChange = changesObj.name.isFirstChange();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    name: <span class="string">"&lt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$doCheck()</code>：该方法和<code>$onChanges(changesObj)</code>作用类似，但是该方法可以监听到在指令内对属性进行修改的行为： </li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    <span class="comment">// 当name在指令内修改时</span></span><br><span class="line">    this.name = <span class="string">"Green"</span>;</span><br><span class="line">    this.$doCheck = function() &#123;</span><br><span class="line">      <span class="comment">// doCheck方法会被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    name: <span class="string">"&lt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$onDestroy()</code>：当作用域被销毁时调用该方法。</li>
<li><code>$postLink()</code>：当指令所在标签与子标签链接时调用该方法。</li>
</ul>
<h3 id="u7EC4_u5EFA_u5316_u5F00_u53D1"><a href="#u7EC4_u5EFA_u5316_u5F00_u53D1" class="headerlink" title="组建化开发"></a>组建化开发</h3><p>我们先来看看示例效果：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-6.gif" alt=""></p>
<p>既然是组建化开发，那么我们来看看上面这个示例有几个组建：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-7.png" alt=""><br>从上图可以看到，整个示例一共用了三个组建，其中有两个组建进行了复用，下面我们来看看每个组建是如何定义的。</p>
<h4 id="personList_u7EC4_u5EFA"><a href="#personList_u7EC4_u5EFA" class="headerlink" title="personList组建"></a>personList组建</h4><p>该组建主要用来初始化数据源，定义对数据源操作的函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"personList"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"personList.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.$onInit = function() &#123;</span><br><span class="line">      this.list = [&#123;</span><br><span class="line">        name: <span class="string">"Jason"</span>,</span><br><span class="line">        job: <span class="string">"Developer"</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        name: <span class="string">"Green"</span>,</span><br><span class="line">        job: <span class="string">"Doctor"</span></span><br><span class="line">      &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.updatePerson = function(person, job, value) &#123;</span><br><span class="line">      person[job] = value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.deletePerson = function(person) &#123;</span><br><span class="line">      <span class="keyword">var</span> idx = this.list.indexOf(person);</span><br><span class="line">      <span class="keyword">if</span>(idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        this.list.splice(idx, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先在<code>$onInit</code>函数中初始化数据源，定义了<code>Person</code>对象数组，然后定义了更新指定<code>Person</code>对象的方法<code>updatePerson</code>及删除指定<code>Person</code>对象的方法<code>deletePerson</code>。</p>
<p>再来看看它的UI模板文件<code>personList.html</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">b</span>&gt;</span>Person<span class="tag">&lt;/<span class="title">b</span>&gt;</span><span class="tag">&lt;<span class="title">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">person-detail</span> <span class="attribute">ng-repeat</span>=<span class="value">"person in $ctrl.list"</span> <span class="attribute">person</span>=<span class="value">"person"</span> <span class="attribute">on-update</span>=<span class="value">"$ctrl.updatePerson(person, job, value)"</span> <span class="attribute">on-delete</span>=<span class="value">"$ctrl.deletePerson(person)"</span>&gt;</span><span class="tag">&lt;/<span class="title">person-detail</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该文件共有两部分，第一部分是用原生HTML标签定义了标题，第二部分是使用了另外一个组建<code>personDetail</code>。<code>ng-repeat</code>指令是AngularJS内置的指令，作用不言而喻，就是循环数据源，同时组建也跟据循环次数增加。<code>person</code>，<code>on-update</code>，<code>on-delete</code>是在<code>personDetail</code>组建中定义的数据绑定属性，用大白话解释就是，<code>personDetail</code>组建中的<code>person</code>变量与<code>personList</code>组建中的<code>Person</code>对象进行了绑定，<code>personDetail</code>组建中的<code>onUpdate</code>和<code>onDelete</code>方法分别与<code>personList</code>组建中的<code>updatePerson</code>和<code>deletePerson</code>方法进行了绑定。</p>
<h4 id="personDetail_u7EC4_u5EFA"><a href="#personDetail_u7EC4_u5EFA" class="headerlink" title="personDetail组建"></a>personDetail组建</h4><p>该组建主要用于展示Person对象的具体内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"personDetail"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"personDetail.html"</span>,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    person: <span class="string">"&lt;"</span>,</span><br><span class="line">    onUpdate: <span class="string">"&amp;"</span>,</span><br><span class="line">    onDelete: <span class="string">"&amp;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.update = function(job, value) &#123;</span><br><span class="line">      this.onUpdate(&#123;person: this.person, job: job, value: value&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.delete = function() &#123;</span><br><span class="line">      this.onDelete(this.person);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">  Name: &#123;&#123;$ctrl.person.name&#125;&#125;<span class="tag">&lt;<span class="title">br</span>&gt;</span></span><br><span class="line">  Job: <span class="tag">&lt;<span class="title">editable-field</span> <span class="attribute">field-value</span>=<span class="value">"$ctrl.person.job"</span> <span class="attribute">on-update</span>=<span class="value">"$ctrl.update('job', value)"</span>&gt;</span><span class="tag">&lt;/<span class="title">editable-field</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"$ctrl.delete()"</span>&gt;</span>Delete<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>personDetail.html</code>文件里，首先访问了<code>person</code>对象的<code>name</code>属性，将其展示出来，注意，这里由<code>$ctrl.preson</code>访问到的其实是单向绑定的<code>personList</code>组建中的<code>person</code>对象。而且在<code>update</code>函数中调用了与<code>personList</code>组建的<code>updatePerson</code>函数绑定的<code>onUpdate</code>函数，也就是子组建调用了父组建的方法。然后使用了第三个组建<code>editableField</code>，该组建同样有一些属性和方法和<code>personDetail</code>组建中对应的属性和方法进行了绑定。最后增加了一个按钮，并使用<code>ng-click</code>指令指定了按钮的点击事件。 </p>
<h4 id="editableField_u7EC4_u5EFA"><a href="#editableField_u7EC4_u5EFA" class="headerlink" title="editableField组建"></a>editableField组建</h4><p>该组建的主要作用是展示并修改<code>person</code>对象中的<code>job</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"editableField"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"editableField.html"</span>,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    fieldValue: <span class="string">"&lt;"</span>,</span><br><span class="line">    onUpdate: <span class="string">"&amp;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.$onInit = function() &#123;</span><br><span class="line">      this.editMode = <span class="literal">false</span>;</span><br><span class="line">      this.fieldValueCopy = this.fieldValue;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.handModelChange = function() &#123;</span><br><span class="line">      <span class="keyword">if</span>(this.editMode) &#123;</span><br><span class="line">        this.onUpdate(&#123;job: <span class="string">"job"</span>, value: this.fieldValue&#125;);</span><br><span class="line">        this.fieldValueCopy = this.fieldValue;</span><br><span class="line">      &#125;</span><br><span class="line">      this.editMode = !this.editMode;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.reset = function() &#123;</span><br><span class="line">      this.fieldValue = this.fieldValueCopy;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从最开始的运行效果中可以看到<code>editableField</code>是有形态变化的，所以在<code>$onInit</code>函数中定义了是否为编辑模式的标识符<code>editMode</code>以及代表输入框内容的<code>fieldValue</code>变量，因为有<code>reset</code>功能，所以还定义存储修改之前值的变量<code>fieldValueCopy</code>。然后定义了点击<code>Edit</code>或<code>Save</code>按钮触发的函数<code>handModelChange</code>，并在该函数中调用了和<code>personDetail</code>组建的<code>update</code>函数绑定的<code>onUpdate</code>函数，同样由子组建调用了父组建的方法。还定义了点击<code>Reset</code>按钮触发的函数<code>reset</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&lt;span ng-<span class="keyword">switch</span>=<span class="string">"$ctrl.editMode"</span>&gt;</span><br><span class="line">  &lt;input ng-<span class="keyword">switch</span>-when=<span class="string">"true"</span> type=<span class="string">"text"</span> ng-model=<span class="string">"$ctrl.fieldValue"</span>&gt;</span><br><span class="line">  &lt;span ng-<span class="keyword">switch</span>-<span class="keyword">default</span>&gt;&#123;&#123;$ctrl.fieldValue&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;button ng-click=<span class="string">"$ctrl.handModelChange()"</span>&gt;&#123;&#123;$ctrl.editMode ? <span class="string">"Save"</span> : <span class="string">"Edit"</span>&#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;button ng-<span class="keyword">if</span>=<span class="string">"$ctrl.editMode"</span> ng-click=<span class="string">"$ctrl.reset()"</span>&gt;<span class="type">Reset</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>在<code>editableField.html</code>文件中展示了<code>person</code>对象的<code>job</code>属性，定义了修改<code>job</code>属性的输入框以及两个按钮。这里出现了一组之前没见过的AngularJS内置指令，<code>ng-switch</code>、<code>ng-switch-when</code>、<code>ng-switch-default</code>，这三个指令一般组合使用，作用类似<code>if else</code>语句，通过这组指令和<code>deitMode</code>变量就可以达到动态变换DOM元素的功能。</p>
<p>最后来看看简单的<code>index.html</code>文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">person-list</span>&gt;</span><span class="tag">&lt;/<span class="title">person-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的这个示例中可以看出在<code>editableField</code>和<code>personDetail</code>组建中都没有真正意义上去修改数据源，而是通过函数绑定一路将修改数据源的行为传递到了定义数据源的组建<code>personList</code>中，由它最后真正完成对数据源的修改，这也遵循了组建不允许修改属于自己隔离域以外的任何数据和DOM元素的原则。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这篇文章是对AngularJS 1.x的入门学习小记，对一些基本概念的介绍，如果想要深入了解AngularJS可以去读官方的<a href="https://docs.angularjs.org/guide" target="_blank" rel="external">文档</a>和<a href="https://docs.angularjs.org/api" target="_blank" rel="external">API</a>。此刻AngularJS 2.0已正式发布，掌握AngularJS 1.x的基本知识能更快的帮助我们迈入AngularJS 2.0的怀抱，让我们不忘AngularJS 1.x初心，去拥抱AngularJS 2.0的美好未来。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4115205380866695"
     data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>本文首发<a href="http://geek.csdn.net/news/detail/102405">CSDN</a>，如需转载请与CSDN联系。</p>
<h1 id="AngularJS_u662F_u4EC0_u4E48"><a href="#AngularJS_u662F_u4EC0_u4E48" class="headerlink" title="AngularJS是什么"></a>AngularJS是什么</h1><p>我们知道HTML是一种创建网页的静态标记语言，它很基础，但不失灵活，然而它自身并不提供对灵活性的具体实现，所以我们要创建具有可用性及赏心悦目的Web应用就需要使用其他语言与之结合去操控它的DOM、标签、标签属性、标签层级结构实现样式变换、动态数据变换、动态元素变换等，比如结合CSS和JavaScript语言。</p>
<p>但是越多的结合就意味着功能实现越复杂，我们需要写大量的代码去实现类似数据绑定、动态展现、远程服务请求等功能，所以jQuery这类的JS库、ember这类的框架应用而生。前者让我们在完成某些单一功能时调用它封装好的方法，从而减少代码量。后者让我们可以遵循它的规范去填充它设计好的代码结构，从而逐步完成完整的应用功能。</p>
<p>而AngularJS是JS库和框架的结合，它诞生于2009年，由Misko Hevery 等人创建，后为Google所收购并发扬光大。AngularJS通过为开发者呈现一个更高层次的抽象来简化应用的开发，提供了构建一个CRUD应用可能用到的全部内容包括：自定义HTML标签、事件绑定、数据绑定、基本模板标识符、表单验证、路由、深度链接、组件重用、依赖注入等。</p>
<blockquote>
<p>文章中的所有示例均可在<a href="https://github.com/DevTalking/AngularJS1.x-guide.git">这里</a>下载。</p>
</blockquote>
<h1 id="AngularJS_u7684_u7279_u6027"><a href="#AngularJS_u7684_u7279_u6027" class="headerlink" title="AngularJS的特性"></a>AngularJS的特性</h1><p>AngularJS有着诸多的特性，但最为核心的是其Scope概念、MVC模式、路由、模块化、依赖注入、指令系统、双向数据绑定、Service、Provider等。</p>
<h2 id="u6A21_u5757_u5316"><a href="#u6A21_u5757_u5316" class="headerlink" title="模块化"></a>模块化</h2><p>我们先从AngularJS的模块化特性说起。什么是模块？既应用程序中不同功能的容器。在AngularJS中，我们可以按业务功能的不同将实现划分为不同的模块，这些模块可以在一个JS文件中，也可以将它们放在不同的JS文件中，既一个JS文件为一个模块。</p>
<h3 id="u6A21_u5757_u5316_u7684_u4F18_u52BF"><a href="#u6A21_u5757_u5316_u7684_u4F18_u52BF" class="headerlink" title="模块化的优势"></a>模块化的优势</h3><p>使用模块化在我们的编程阶段有着诸多的好处：</p>
<ul>
<li>可以使我们的代码结构非常清晰，有较好的可读性。</li>
<li>可以使我们复用代码。</li>
<li>在前端编程中，我们都知道JS的引用顺序是很重要的，但使用AngularJS的模块时我们不需要关系每个模块之间的顺序。</li>
<li>可以很好的实现单元测试。</li>
</ul>
<h3 id="u5B9A_u4E49_u6A21_u5757"><a href="#u5B9A_u4E49_u6A21_u5757" class="headerlink" title="定义模块"></a>定义模块</h3><p>定义一个模块很简单，在JS文件中申明一个模块：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mianModule = angular.module(<span class="string">"mianModule"</span>, []);</span><br></pre></td></tr></table></figure>
<p>使用AngularJS的<code>module</code>方法申明一个模块，该方法有两个参数：</p>
<ul>
<li>第一个参数为模块名称。</li>
<li>第二个参数为一个数组，该参数的含义为当前定义的模块所依赖的模块，如果有依赖模块则传入包含模块名称的数组，若无依赖则传入空数组。</li>
</ul>]]>
    
    </summary>
    
      <category term="AngularJS" scheme="http://www.devtalking.com/tags/AngularJS/"/>
    
      <category term="Javascript" scheme="http://www.devtalking.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ShadowSocks科学上网及突破公司内网]]></title>
    <link href="http://www.devtalking.com//articles/shadowsocks-guide/"/>
    <id>http://www.devtalking.com//articles/shadowsocks-guide/</id>
    <published>2016-08-18T16:00:00.000Z</published>
    <updated>2018-06-01T16:19:01.473Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h1 id="u4EC0_u4E48_u662FShadowSocks"><a href="#u4EC0_u4E48_u662FShadowSocks" class="headerlink" title="什么是ShadowSocks"></a>什么是ShadowSocks</h1><p>ShadowSocks是基于Socks5协议，使用类似SSH隧道的方式收发网络请求的一款开源软件，该软件由<a href="https://twitter.com/clowwindy" title="clowwindy" target="_blank" rel="external"> @clowwindy </a>开发，最初只有Python版本，随后出现C++、C#、Go等多语言版本。ShadowSocks最大的特点是可以保护网络流量、加密数据传输，可有效防止GFW（Great Firewall of China）封杀网络请求。</p>
<h1 id="u7528ShadowSocks_u79D1_u5B66_u4E0A_u7F51_u7684_u6982_u5FF5"><a href="#u7528ShadowSocks_u79D1_u5B66_u4E0A_u7F51_u7684_u6982_u5FF5" class="headerlink" title="用ShadowSocks科学上网的概念"></a>用ShadowSocks科学上网的概念</h1><p>在以前，我们访问互联网的资源都是简单而直接的，用户的请求发送到资源服务方，比如Google、Facebook等，然后资源服务方直接将内容响应给用户，世界多么美好。</p>
<p> <img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-9.png" alt=""></p>
<p>但是，在1998年时候，中国创建了互联网边界审查系统，称之为中国国家防火墙（GFW），这堵墙横在了用户和互联网资源服务方之间，用于监控和过滤互联网国际出口上的内容，监控国际网关的通讯，对认为不匹配国家官方要求的传输内容，进行干扰、阻断、屏蔽。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shaodwsocksss-10.png" alt=""></p>
<p>从此之后好多有价值的网站就被堵在了墙后。</p>
<p>但是由于对知识的渴望，人们想到了绕过GFW的办法，那就是在境外搭建一个国内用户的代理，国内用户与代理之间建立加密的通道，由境外代理请求被墙的网络资源，再通过加密通道返回给国内用户。代理的类型也有多种，像HTTP、Socks、VPN、SSH等。以SSH隧道为例：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-11.png" alt=""></p>
<p>因为SSH本身基于RSA加密技术，所以GFW就无法对数据传输过程加密的数据进行分析，从而避免被重置链接、阻断、屏蔽等问题。</p>
<p>但是GFW也不会懵B一世，人家也会学习，由于在创建SSH隧道的过程中有较为明显的特性，所以GFW还是可以通过分析连接的特性进行干扰。此时ShadowSocks横空出世，先看看图示：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-12.png" alt=""></p>
<p>简单来说，ShadowSocks分为客户端和服务端，用户发出的请求基于Socks5协议与ShadowSocks客户端进行通信，一般情况下SS客户端都在本机，通过ShadowSocksX、GoAgentX等应用启动，所以这一步是不会经过GFW的，然后ShadowSocks提供了多种加密方式供客户端和服务端之间进行通信，并且在经过GFW时是普通的TCP协议数据包，没有明显的特征，而且GFW也无法解密分析，从而实现绕墙访问资源。</p>
<a id="more"></a>
<h1 id="u642D_u5EFAShadowSocks_u670D_u52A1_u5668"><a href="#u642D_u5EFAShadowSocks_u670D_u52A1_u5668" class="headerlink" title="搭建ShadowSocks服务器"></a>搭建ShadowSocks服务器</h1><p>根据上文描述的ShadowSocks的实现原理，我们首先需要搭建一个境外的ShadowSocks服务器，这部分也是唯一需要我们花点小钱的地方。</p>
<blockquote>
<p>以下文章内容均在MacOS下实践。</p>
</blockquote>
<h2 id="u8D2D_u4E70VPS"><a href="#u8D2D_u4E70VPS" class="headerlink" title="购买VPS"></a>购买VPS</h2><p>我使用的是<a href="http://www.vultr.com" target="_blank" rel="external">Vultr</a>的VPS，他家的VPS可选的地域较为丰富，而且有日本东京，这对于家里是联通网络的比较亲和，速度较好：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-1.png" alt="" title="Server Location"><br>在系统和应用方面Vultr提供的种类也比较丰富：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-2.png" alt="" title="Server Type"><br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-3.png" alt="" title="Application"><br>在价格方面，Vultr提供的最低价格为每月5美元，对应的性能足够满足ShadowSocks服务端的需求：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-4.png" alt="" title="Server Price"><br>注册Vultr账号，绑定信用卡，选择自己中意的系统和价格后立即就会为你部署好VPS：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-5.png" alt=""><br>当VPS的状态为Running后，就表示VPS已经启动了，然后为该VPS配置我们的SSH公钥：<br> <img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-6.png" alt=""><br>大家可以看看北京联通ping东京VPS的速度，还是很给力的：<br> <img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-7.png" alt=""></p>
<blockquote>
<p>使用该<a href="http://www.vultr.com/?ref=6955175-3B" target="_blank" rel="external">链接</a>注册可获得20美元的优惠卷。</p>
</blockquote>
<h2 id="u5B89_u88C5ShadowSocks"><a href="#u5B89_u88C5ShadowSocks" class="headerlink" title="安装ShadowSocks"></a>安装ShadowSocks</h2><p>我们使用Python版的ShadowSocks进行安装，首先需要下载<a href="https://pypi.python.org/pypi/pip#downloads" target="_blank" rel="external">pip-8.1.2.tar.gz</a>，然后使用工具将其上传至VPS，我使用的是Commander One，通过SFTP连接VPS：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-8.png" alt=""><br>使用Terminal连接VPS，一步一步输入以下命令解压安装pip：</p>
<pre><code>tar -xzvf pip-8.1.2.tar.gz
cd pip-8.1.2
python setup.py install
</code></pre><p>然后通过pip安装ShadowSocks：</p>
<pre><code>pip install shadowsocks
</code></pre><p>成功后可以看到如下信息：</p>
<pre><code>Collecting shadowsocks
  Downloading shadowsocks-2.8.2.tar.gz
Installing collected packages: shadowsocks
  Running setup.py install for shadowsocks ... done
Successfully installed shadowsocks-2.8.2
</code></pre><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h2 id="u914D_u7F6EShadowSocks"><a href="#u914D_u7F6EShadowSocks" class="headerlink" title="配置ShadowSocks"></a>配置ShadowSocks</h2><p>进入到etc目录下，创建shadowsocks.json文件，并添加如下内容：</p>
<pre><code>{
    &quot;server&quot;:&quot;你的VPS的IP&quot;,
    &quot;server_port&quot;:8388,
    &quot;local_port&quot;:1080,
    &quot;password&quot;:&quot;设置一个连接密码&quot;,
    &quot;timeout&quot;:600,
    &quot;method&quot;:&quot;aes-256-cfb&quot;,
    &quot;auth&quot;: true
}
</code></pre><p>该文件就是ShadowSocks的配置文件。<br>然后输入如下命令启动ShadowSocks服务：</p>
<pre><code>ssserver -c /etc/shadowsocks.json -d start
</code></pre><p>最后清空防火墙规则：</p>
<pre><code>iptables -F
</code></pre><p>至此ShadowSocks服务端就配置完成并可以使用了。</p>
<h1 id="ShadowSocks_u5BA2_u6237_u7AEF"><a href="#ShadowSocks_u5BA2_u6237_u7AEF" class="headerlink" title="ShadowSocks客户端"></a>ShadowSocks客户端</h1><p>Mac上ShadowSocks客户端的选择无非就是ShadowSocksX、GoAgentX、Surge这三个，前两者配置起来都大同小异，ShadowSocksX本身就是专门开启SS客户端服务的应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-14.png" alt=""></p>
<p>GoAgentX提供的服务类型更多，包括SS服务：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-13.png" alt=""></p>
<p>配置项都是一样的，把ShadowSocks服务端的配置信息一一对应就可以了。</p>
<p>Surge启SS服务的方式有点不同，因为应用在界面操作上没有提供创建SS服务的选项，但其实它是支持SS服务的，可能因为怕被请喝茶吧。所以需要在Surge的配置文件里添加SS服务相关的信息，如何配置网上有很多，这里就不再累赘了。</p>
<p>至此就打通了ShadowSocks客户端与服务端的通道，可以畅游墙外的世界了。</p>
<h1 id="u7A81_u7834_u516C_u53F8_u5185_u7F51"><a href="#u7A81_u7834_u516C_u53F8_u5185_u7F51" class="headerlink" title="突破公司内网"></a>突破公司内网</h1><p>一般情况在家我们在本机启着ShadowSocks客户端就可以了，但是如果在公司上外网需要走HTTP代理的话就不行了，因为ShadowSocks客户端需要走公司提供的代理才能连接到服务端，而上文中的客户端应用统统不支持额外代理功能，所以此时就需要用到另外一个工具<a href="https://www.proxifier.com" target="_blank" rel="external">Proxifier</a>，该工具的作用就是接管运行中的所有应用发出的所有请求，然后通过代理进行转发，这样就可以让不支持代理的应用也可以走代理了。</p>
<p>打开Proxifier，选择Proxies选项卡设置公司的HTTP代理以及本地Socks5代理：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-15.png" alt=""><br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-16.png" alt=""></p>
<p>然后启动ShadowSocks客户端，比如启动GoAgentX，此时选择Proxifier的Rules选项卡，就会发现Proxifier自动捕获到了名为ss-local的应用，就是由GoAgentX开启的SS客户端，将其的代理规则设置为之前创建好的公司代理：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-17.png" alt=""></p>
<p>然后将Default的代理规则设置为之前创建好的本地Socks5代理：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-18.png" alt=""></p>
<p>这样就可以让ShadowSocks客户端通过公司代理连接服务端了：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-19.png" alt=""></p>
<p>你还可以设置其他的规则，让特定的应用走特定的代理，比如我让Git还是走了公司代理，这样Git服务就会从Default规则里剔除掉，相当于加了走SS服务的例外。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p><link rel="stylesheet" href="http://7xpp8a.com1.z0.glb.clouddn.com/tomorrow.css"></p>
<script src="http://7xpp8a.com1.z0.glb.clouddn.com/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4115205380866695"
     data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h1 id="u4EC0_u4E48_u662FShadowSocks"><a href="#u4EC0_u4E48_u662FShadowSocks" class="headerlink" title="什么是ShadowSocks"></a>什么是ShadowSocks</h1><p>ShadowSocks是基于Socks5协议，使用类似SSH隧道的方式收发网络请求的一款开源软件，该软件由<a href="https://twitter.com/clowwindy" title="clowwindy"> @clowwindy </a>开发，最初只有Python版本，随后出现C++、C#、Go等多语言版本。ShadowSocks最大的特点是可以保护网络流量、加密数据传输，可有效防止GFW（Great Firewall of China）封杀网络请求。</p>
<h1 id="u7528ShadowSocks_u79D1_u5B66_u4E0A_u7F51_u7684_u6982_u5FF5"><a href="#u7528ShadowSocks_u79D1_u5B66_u4E0A_u7F51_u7684_u6982_u5FF5" class="headerlink" title="用ShadowSocks科学上网的概念"></a>用ShadowSocks科学上网的概念</h1><p>在以前，我们访问互联网的资源都是简单而直接的，用户的请求发送到资源服务方，比如Google、Facebook等，然后资源服务方直接将内容响应给用户，世界多么美好。</p>
<p> <img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-9.png" alt=""></p>
<p>但是，在1998年时候，中国创建了互联网边界审查系统，称之为中国国家防火墙（GFW），这堵墙横在了用户和互联网资源服务方之间，用于监控和过滤互联网国际出口上的内容，监控国际网关的通讯，对认为不匹配国家官方要求的传输内容，进行干扰、阻断、屏蔽。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shaodwsocksss-10.png" alt=""></p>
<p>从此之后好多有价值的网站就被堵在了墙后。</p>
<p>但是由于对知识的渴望，人们想到了绕过GFW的办法，那就是在境外搭建一个国内用户的代理，国内用户与代理之间建立加密的通道，由境外代理请求被墙的网络资源，再通过加密通道返回给国内用户。代理的类型也有多种，像HTTP、Socks、VPN、SSH等。以SSH隧道为例：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-11.png" alt=""></p>
<p>因为SSH本身基于RSA加密技术，所以GFW就无法对数据传输过程加密的数据进行分析，从而避免被重置链接、阻断、屏蔽等问题。</p>
<p>但是GFW也不会懵B一世，人家也会学习，由于在创建SSH隧道的过程中有较为明显的特性，所以GFW还是可以通过分析连接的特性进行干扰。此时ShadowSocks横空出世，先看看图示：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-12.png" alt=""></p>
<p>简单来说，ShadowSocks分为客户端和服务端，用户发出的请求基于Socks5协议与ShadowSocks客户端进行通信，一般情况下SS客户端都在本机，通过ShadowSocksX、GoAgentX等应用启动，所以这一步是不会经过GFW的，然后ShadowSocks提供了多种加密方式供客户端和服务端之间进行通信，并且在经过GFW时是普通的TCP协议数据包，没有明显的特征，而且GFW也无法解密分析，从而实现绕墙访问资源。</p>]]>
    
    </summary>
    
      <category term="ShadowSocks" scheme="http://www.devtalking.com/tags/ShadowSocks/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Concurrency Programming Guide 笔记（三）]]></title>
    <link href="http://www.devtalking.com//articles/read-concurrency-programming-guide-3/"/>
    <id>http://www.devtalking.com//articles/read-concurrency-programming-guide-3/</id>
    <published>2016-04-20T16:00:00.000Z</published>
    <updated>2018-06-01T16:19:45.377Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/69122" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="u901A_u8FC7Dispatch_Queue_u6267_u884C_u4EFB_u52A1"><a href="#u901A_u8FC7Dispatch_Queue_u6267_u884C_u4EFB_u52A1" class="headerlink" title="通过Dispatch Queue执行任务"></a>通过Dispatch Queue执行任务</h2><p>如果想让Dispatch Queue执行任务，首先就是得将任务放入队列中，我们可以异步的将任务加入队列，也可以同步的将任务加入队列，可以一个任务一个任务的加，也可以一组一组的加。这节我们就来看看将任务加入队列的那些事。</p>
<h3 id="u5411_u961F_u5217_u6DFB_u52A0_u4EFB_u52A1"><a href="#u5411_u961F_u5217_u6DFB_u52A0_u4EFB_u52A1" class="headerlink" title="向队列添加任务"></a>向队列添加任务</h3><p>我们可以使用<code>dispatch_async</code>或者<code>dispatch_async_f</code>函数异步的向队列中添加任务，也就是说当我们添加完任务后该函数会立即返回，我们不需要等待任务执行完成，而且我们也不会知道队列到底何时开始执行任务。<code>dispatch_async</code>函数有两个参数，一个是目标队列，类型为<code>dispatch_queue_t</code>，另一个是闭包，类型为<code>dispatch_block_t</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_async(serialQueue, &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task in the queue..."</span>)</span><br><span class="line">        </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>dispatch_async_f</code>函数有三个参数，第一个是类型为<code>dispatch_queue_t</code>的目标队列，第二个是队列上下文指针，第三个是类型为<code>dispatch_function_t</code>的任务函数，队列上下文指针为该函数的唯一参数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTaskToQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in the queue..."</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async_f(serialQueue, <span class="built_in">unsafeBitCast</span>(<span class="number">0</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>), taskFunction())</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">taskFunction</span><span class="params">()</span></span> -&gt; dispatch_function_t &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123; context <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Do some work with context..."</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addTaskToQueue = <span class="type">AddTaskToQueue</span>()</span><br><span class="line">addTaskToQueue.launch()</span><br></pre></td></tr></table></figure>
<p>除了这两个函数，我们还可以使用<code>dispatch_sync</code>和<code>dispatch_sync_f</code>函数同步的向队列中添加任务，并且我们要等待直到任务执行完成。这两个函数和上面的异步添加任务函数用法完全一致。</p>
<p>那么什么时候用异步什么时候用同步呢，大多数情况下我们都是在主线程中使用GCD分派任务，为了避免阻塞主线程，影响用户体验，所以通常情况下我们都使用异步添加任务的方式。当然为了避免任务与主线程中产生资源竞争的问题，有时候酌情也会使用同步添加任务的方式。</p>
<h3 id="Dispatch_Queue_u7684Completion_Block"><a href="#Dispatch_Queue_u7684Completion_Block" class="headerlink" title="Dispatch Queue的Completion Block"></a>Dispatch Queue的Completion Block</h3><p>还记得<code>NSOperation</code>的<code>completionBlock</code>属性吗，这个回调函数在任务执行完成后调用，用于处理有些后续工作或者消息通知。在Dispatch Queue中并没有类似的属性，但是我们可以通过其他方式来实现。举一个很常见的应用场景，我们在主线程中分派一个下载图片的任务，让其在二级线程中执行，当图片下载完成后通知主线程，并由主线程将图片显示出来，我们看看简单的代码片段：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadImage</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dispatchTaskInMainThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), downloadImage())</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">downloadImage</span><span class="params">()</span></span> -&gt; (() -&gt; ()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Downloading image in <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">            dispatch_async(dispatch_get_main_queue()) &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Handle image and display in <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看上面代码都做了些什么，首先在<code>dispatchTaskInMainThread</code>方法中，我们使用<code>dispatch_get_global_queue</code>函数获取到全局并发队列，然后将<code>downloadImage</code>下载图片的方法作为任务添加到该全局队列中。在<code>downloadImage</code>方法里，当图片下载完成后通过<code>dispatch_get_main_queue</code>函数获取到主队列，也就是在主线程中对图片进行处理，这样我们就达到了Completion Block的效果。</p>
<a id="more"></a>
<h3 id="u5728_u961F_u5217_u4E2D_u5FAA_u73AF_u6267_u884C_u4EFB_u52A1"><a href="#u5728_u961F_u5217_u4E2D_u5FAA_u73AF_u6267_u884C_u4EFB_u52A1" class="headerlink" title="在队列中循环执行任务"></a>在队列中循环执行任务</h3><p>在我们的日常开发中，经常会使用到for循环来处理一些任务，而且这些任务之间也并没有先后顺序的关联，每个任务相对比较独立。遇到这种情况，我们可以用<code>dispatch_apply</code>或<code>dispatch_apply_f</code>函数让任务在队列中循环执行，并且可以是并发执行，这样相比for循环的串行执行要更加效率：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>, <span class="string">"Java"</span>, <span class="string">"Delphi"</span>, <span class="string">"C++"</span>]</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> arr &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Handle element. the element is <span class="subst">\(element)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dispatch_apply</span></span><br><span class="line">dispatch_apply(arr.<span class="built_in">count</span>, dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>))&#123; index <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Handle element. the element is <span class="subst">\(arr[index])</span>. Current thread is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面示例代码片段中可以看到，<code>dispatch_apply</code>函数有三个参数，第一个参数是循环次数，第二个参数是目标队列，第三个则是要执行的闭包任务，循环次数是该闭包的唯一参数。</p>
<h3 id="u6682_u505C_u548C_u91CD_u542F_u961F_u5217"><a href="#u6682_u505C_u548C_u91CD_u542F_u961F_u5217" class="headerlink" title="暂停和重启队列"></a>暂停和重启队列</h3><p>在Dispatch Queue执行任务时，如果我们想暂停队列，可以使用<code>dispatch_suspend</code>函数，重新让队列执行任务可以使用<code>dispatch_resume</code>。这里要注意的是暂停队列只是让队列暂时停止执行下一个任务，而不是中断当前正在执行的任务。</p>
<h3 id="Dispatch_Group_u7684_u4F7F_u7528"><a href="#Dispatch_Group_u7684_u4F7F_u7528" class="headerlink" title="Dispatch Group的使用"></a>Dispatch Group的使用</h3><p>在实际开发中，为了提升性能我们或许会经常使用<code>dispatch_async</code>异步的将任务添加进队列去执行，但有些时候需要之前队列中的多个任务都执行完成之后，才能获取到正确的或者说想要的结果供后续逻辑代码使用，遇到这种情况，就可以使用Dispatch Group，将多个任务在队列中归为一个组，并可以使用<code>dispatch_group_wait</code>函数让之后的逻辑代码等待，直到该组的任务都执行完成后再执行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> concurrentQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_async(concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task1 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_async(concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task2 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_async(concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task3 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"I expect the count is 3, and the factual count is <span class="subst">\(<span class="built_in">count</span>)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码片段就是我刚才描述的场景，因为使用的是并发队列，也不好在每个任务里进行回调处理，所以我们永远不会得到正确的<code>count</code>。如果我们使用Dispatch Group事情就简单多了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> concurrentQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dispatchGroup = dispatch_group_create()</span><br><span class="line">        </span><br><span class="line">dispatch_group_async(dispatchGroup, concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task1 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_group_async(dispatchGroup, concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task2 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_group_async(dispatchGroup, concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task3 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_group_wait(dispatchGroup, <span class="type">DISPATCH_TIME_FOREVER</span>)</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"I expect the count is 3, and the factual count is <span class="subst">\(<span class="built_in">count</span>)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码中，先使用<code>dispatch_group_create</code>函数创建Dispatch Group，然后使用<code>dispatch_group_async</code>函数将任务分进组里，然后再添加进队列中。该函数有三个参数，分别是Dispatch Group、Dispatch Queue和要执行任务的闭包。当添加完任务后使用<code>dispatch_group_wait</code>函数等待，直到指定组的任务全部完成，才会继续执行后面的打印语句，该函数有两个参数，第一个是目标组，第二个是等待时间<code>DISPATCH_TIME_NOW</code>或<code>DISPATCH_TIME_FOREVER</code>。</p>
<h2 id="Dispatch_Source"><a href="#Dispatch_Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h2><p>前面的文章中介绍过Dispatch Source：</p>
<blockquote>
<p>Dispatch Source是GCD中的一个基本类型，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。我们来看看它都有哪些类型：</p>
<ul>
<li>Timer Dispatch Source：定时调度源。</li>
<li>Signal Dispatch Source：监听UNIX信号调度源，比如监听代表挂起指令的SIGSTOP信号。</li>
<li>Descriptor Dispatch Source：监听文件相关操作和Socket相关操作的调度源。</li>
<li>Process Dispatch Source：监听进程相关状态的调度源。</li>
<li>Mach port Dispatch Source：监听Mach相关事件的调度源。</li>
<li>Custom Dispatch Source：监听自定义事件的调度源。</li>
</ul>
</blockquote>
<p>这一节就来看看如何使用Dispatch Source。</p>
<p>用通俗一点的话说就是用GCD的函数指定一个希望监听的系统事件类型，再指定一个捕获到事件后进行逻辑处理的闭包或者函数作为回调函数，然后再指定一个该回调函数执行的Dispatch Queue即可，当监听到指定的系统事件发生时会调用回调函数，将该回调函数作为一个任务放入指定的队列中执行。也就是说当监听到系统事件后就会触发一个任务，并自动将其加入队列执行，这里与之前手动添加任务的模式不同，一旦将Diaptach Source与Dispatch Queue关联后，只要监听到系统事件，Dispatch Source就会自动将任务（回调函数）添加到关联的队列中。</p>
<p>有些时候回调函数执行的时间较长，在这段时间内Dispatch Source又监听到多个系统事件，理论上就会形成事件积压，但好在Dispatch Source有很好的机制解决这个问题，当有多个事件积压时会根据事件类型，将它们进行关联和结合，形成一个新的事件。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u76D1_u542C_u4E8B_u4EF6_u7C7B_u578B"><a href="#u76D1_u542C_u4E8B_u4EF6_u7C7B_u578B" class="headerlink" title="监听事件类型"></a>监听事件类型</h3><p>Dispatch Source一共可以监听六类事件，分为11个类型，我们来看看都是什么：</p>
<ul>
<li><code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>：属于自定义事件，可以通过<code>dispatch_source_get_data</code>函数获取事件变量数据，在我们自定义的方法中可以调用<code>dispatch_source_merge_data</code>函数向Dispatch Source设置数据，下文中会有详细的演示。</li>
<li><code>DISPATCH_SOURCE_TYPE_DATA_OR</code>：属于自定义事件，用法同上面的类型一样。</li>
<li><code>DISPATCH_SOURCE_TYPE_MACH_SEND</code>：Mach端口发送事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_MACH_RECV</code>：Mach端口接收事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_PROC</code>：与进程相关的事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_READ</code>：读文件事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_WRITE</code>：写文件事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_VNODE</code>：文件属性更改事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_SIGNAL</code>：接收信号事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_TIMER</code>：定时器事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_MEMORYPRESSURE</code>：内存压力事件。</li>
</ul>
<h3 id="u521B_u5EFADispatch_Source"><a href="#u521B_u5EFADispatch_Source" class="headerlink" title="创建Dispatch Source"></a>创建Dispatch Source</h3><p>我们可以使用<code>dispatch_source_create</code>函数创建Dispatch Source，该函数有四个参数：</p>
<ul>
<li><code>type</code>：第一个参数用于标识Dispatch Source要监听的事件类型，共有11个类型。</li>
<li><code>handle</code>：第二个参数是取决于要监听的事件类型，比如如果是监听Mach端口相关的事件，那么该参数就是<code>mach_port_t</code>类型的Mach端口号，如果是监听事件变量数据类型的事件那么该参数就不需要，设置为0就可以了。</li>
<li><code>mask</code>：第三个参数同样取决于要监听的事件类型，比如如果是监听文件属性更改的事件，那么该参数就标识文件的哪个属性，比如<code>DISPATCH_VNODE_RENAME</code>。</li>
<li><code>queue</code>：第四个参数设置回调函数所在的队列。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatchQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dispatchSource = dispatch_source_create(<span class="type">DISPATCH_SOURCE_TYPE_DATA_ADD</span>, <span class="number">0</span>, <span class="number">0</span>, dispatchQueue)</span><br></pre></td></tr></table></figure>
<p>上面的代码就是创建Dispatch Source的简单示例。</p>
<h3 id="u8BBE_u7F6E_u4E8B_u4EF6_u5904_u7406_u5668"><a href="#u8BBE_u7F6E_u4E8B_u4EF6_u5904_u7406_u5668" class="headerlink" title="设置事件处理器"></a>设置事件处理器</h3><p>前文中提到过，当Dispatch Source监听到事件时会调用指定的回调函数或闭包，该回调函数或闭包就是Dispatch Source的事件处理器。我们可以使用<code>dispatch_source_set_event_handler</code>或<code>dispatch_source_set_event_handler_f</code>函数给创建好的Dispatch Source设置处理器，前者是设置闭包形式的处理器，后者是设置函数形式的处理器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dispatch_source_set_event_handler(dispatchSource, &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Dispatch Source 事件处理器..."</span>)</span><br><span class="line">        </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据闭包尾随的特性，还可以有下面的写法</span></span><br><span class="line"></span><br><span class="line">dispatch_source_set_event_handler(dispatchSource) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Dispatch Source 事件处理器..."</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面示例代码中可以看到，该函数有两个参数，第一个是设置目标Dispatch Source，第二个参数就是设置处理器了。</p>
<p>既然是事件处理器，那么肯定需要获取一些Dispatch Source的信息，GCD提供了三个在处理器中获取Dispatch Source相关信息的函数，比如<code>handle</code>、<code>mask</code>。而且针对不同类型的Dispatch Source，这三个函数返回数据的值和类型都会不一样，下面来看看这三个函数：</p>
<ul>
<li><code>dispatch_source_get_handle</code>：这个函数用于获取在创建Dispatch Source时设置的第二个参数<code>handle</code>。<ul>
<li>如果是读写文件的Dispatch Source，返回的就是描述符。</li>
<li>如果是信号类型的Dispatch Source，返回的是<code>int</code>类型的信号数。</li>
<li>如果是进程类型的Dispatch Source，返回的是<code>pid_t</code>类型的进程id。</li>
<li>如果是Mach端口类型的Dispatch Source，返回的是<code>mach_port_t</code>类型的Mach端口。</li>
</ul>
</li>
<li><code>dispatch_source_get_data</code>：该函数用于获取Dispatch Source监听到事件的相关数据。<ul>
<li>如果是读文件类型的Dispatch Source，返回的是读到文件内容的字节数。</li>
<li>如果是写文件类型的Dispatch Source，返回的是文件是否可写的标识符，正数表示可写，负数表示不可写。</li>
<li>如果是监听文件属性更改类型的Dispatch Source，返回的是监听到的有更改的文件属性，用常量表示，比如<code>DISPATCH_VNODE_RENAME</code>等。</li>
<li>如果是进程类型的Dispatch Source，返回监听到的进程状态，用常量表示，比如<code>DISPATCH_PROC_EXIT</code>等。</li>
<li>如果是Mach端口类型的Dispatch Source，返回Mach端口的状态，用常量表示，比如<code>DISPATCH_MACH_SEND_DEAD</code>等。</li>
<li>如果是自定义事件类型的Dispatch Source，返回使用<code>dispatch_source_merge_data</code>函数设置的数据。</li>
</ul>
</li>
<li><code>dispatch_source_get_mask</code>：该函数用于获取在创建Dispatch Source时设置的第三个参数<code>mask</code>。在进程类型，文件属性更改类型，Mach端口类型的Dispatch Source下该函数返回的结果与<code>dispatch_source_get_data</code>一样。</li>
</ul>
<h3 id="u6CE8_u518CCancellation_Handler"><a href="#u6CE8_u518CCancellation_Handler" class="headerlink" title="注册Cancellation Handler"></a>注册Cancellation Handler</h3><p>Cancellation Handler就是当Dispatch Source被释放时用来处理一些后续事情，比如关闭文件描述符或者释放Mach端口等。我们可以使用<code>dispatch_source_set_cancel_handler</code>函数或者<code>dispatch_source_set_cancel_handler_f</code>函数给Dispatch Source注册Cancellation Handler：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dispatch_source_set_cancel_handler(dispatchSource) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"进行善后处理..."</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数有两个参数，第一个参数是目标Dispatch Source，第二个参数就是要进行善后处理的闭包或者函数。</p>
<h3 id="u66F4_u6539Dispatch_Source_u7684_u76EE_u6807_u961F_u5217"><a href="#u66F4_u6539Dispatch_Source_u7684_u76EE_u6807_u961F_u5217" class="headerlink" title="更改Dispatch Source的目标队列"></a>更改Dispatch Source的目标队列</h3><p>在上文中，我们说过可以使用<code>dispatch_source_create</code>函数创建Dispatch Source，并且在创建时会指定回调函数执行的队列，那么如果事后想更改队列，比如说想更改队列的优先级，这时我们可以使用<code>dispatch_set_target_queue</code>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatchQueueDefaultPriority = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dispatchSource = dispatch_source_create(<span class="type">DISPATCH_SOURCE_TYPE_DATA_ADD</span>, <span class="number">0</span>, <span class="number">0</span>, dispatchQueueDefaultPriority)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dispatchQueueLowPriority = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_LOW</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_set_target_queue(dispatchSource, dispatchQueueLowPriority)</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，如果在更改目标队列时，Dispatch Source已经监听到相关事件，并且回调函数已经在之前的队列中执行了，那么会一直在旧的队列中执行完成，不会转移到新的队列中去。</p>
<h3 id="u6682_u505C_u6062_u590DDispatch_Source"><a href="#u6682_u505C_u6062_u590DDispatch_Source" class="headerlink" title="暂停恢复Dispatch Source"></a>暂停恢复Dispatch Source</h3><p>暂停和恢复Dispatch Source与Dispatch Queue一样，都适用<code>dispatch_suspend</code>和<code>dispatch_resume</code>函数。这里需要注意的是刚创建好的Dispatch Source是处于暂停状态的，所以使用时需要用<code>dispatch_resume</code>函数将其启动。</p>
<h3 id="u5E9F_u9664Dispatch_Source"><a href="#u5E9F_u9664Dispatch_Source" class="headerlink" title="废除Dispatch Source"></a>废除Dispatch Source</h3><p>如果我们不再需要使用某个Dispatch Source时，可以使用<code>dispatch_source_cancel</code>函数废除，该函数只有一个参数，那就是目标Dispatch Source。</p>
<h3 id="Dispatch_Source_u5B9E_u8DF5"><a href="#Dispatch_Source_u5B9E_u8DF5" class="headerlink" title="Dispatch Source实践"></a>Dispatch Source实践</h3><p>说了这么多，这一节来看看Dispatch Source到底怎么用。</p>
<h4 id="u7528Dispatch_Source_u76D1_u542C_u5B9A_u65F6_u5668"><a href="#u7528Dispatch_Source_u76D1_u542C_u5B9A_u65F6_u5668" class="headerlink" title="用Dispatch Source监听定时器"></a>用Dispatch Source监听定时器</h4><p>Dispatch Source能监听的事件中有一个类型就是定时器，我们来看看如何实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchSource</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> dispatchQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> timer = createTimerDispatchSource(dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="number">0</span>), interval: <span class="type">NSEC_PER_SEC</span> * <span class="number">5</span>, leeway: <span class="number">0</span>, queue: dispatchQueue) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"处理定时任务，该任务每5秒执行一次..."</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch_resume(timer)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">30</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">createTimerDispatchSource</span><span class="params">(startTime: dispatch_time_t, interval: UInt64, leeway: UInt64, queue: dispatch_queue_t, handler: dispatch_block_t)</span></span> -&gt; dispatch_source_t &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> timerDispatchSource = dispatch_source_create(<span class="type">DISPATCH_SOURCE_TYPE_TIMER</span>, <span class="number">0</span>, <span class="number">0</span>, queue)</span><br><span class="line">        </span><br><span class="line">        dispatch_source_set_timer(timerDispatchSource, startTime, interval, leeway)</span><br><span class="line">        </span><br><span class="line">        dispatch_source_set_event_handler(timerDispatchSource, handler)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> timerDispatchSource</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码示例中一个新的函数<code>dispatch_source_set_timer</code>，该函数的作用就是给监听事件类型为<code>DISPATCH_SOURCE_TYPE_TIMER</code>的Dispatch Source设置相关属性，该函数有四个参数：</p>
<ul>
<li><code>source</code>：该参数为目标Dispatch Source，类型为<code>dispatch_source_t</code>.</li>
<li><code>start</code>：该参数为定时器的起始时间，类型为<code>dispatch_time_t</code>。</li>
<li><code>interval</code>：该参数为定时器的间隔时间，类型为<code>UInt64</code>，间隔时间的单位是纳秒。</li>
<li><code>leeway</code>：该参数为间隔时间的精度，类型为<code>UInt64</code>，时间单位也是纳秒。</li>
</ul>
<h4 id="u7528Dispatch_Source_u76D1_u542C_u81EA_u5B9A_u4E49_u4E8B_u4EF6"><a href="#u7528Dispatch_Source_u76D1_u542C_u81EA_u5B9A_u4E49_u4E8B_u4EF6" class="headerlink" title="用Dispatch Source监听自定义事件"></a>用Dispatch Source监听自定义事件</h4><p>Dispatch Source能监听的事件中有一个类型是自定义事件，下面我们来看看如何使用:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchSource</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> totalProcess = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> dispatchSource = dispatch_source_create(<span class="type">DISPATCH_SOURCE_TYPE_DATA_ADD</span>, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue())</span><br><span class="line">        </span><br><span class="line">        dispatch_source_set_event_handler(dispatchSource) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> process = dispatch_source_get_data(dispatchSource)</span><br><span class="line">            </span><br><span class="line">            totalProcess += <span class="type">Int</span>(process)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"这里可以在主线程更新UI，显示进度条...进度为<span class="subst">\(totalProcess)</span>%"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch_resume(dispatchSource)</span><br><span class="line">        </span><br><span class="line">        generateCustomEvent(dispatchSource)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">generateCustomEvent</span><span class="params">(dispatchSource: dispatch_source_t)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>...<span class="number">100</span> &#123;</span><br><span class="line">            </span><br><span class="line">            dispatch_sync(queue) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"模拟自定义事件...进度为<span class="subst">\(index)</span>%"</span>)</span><br><span class="line">                </span><br><span class="line">                dispatch_source_merge_data(dispatchSource, <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                sleep(<span class="number">2</span>)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看<code>generateCustomEvent(dispatchSource: dispatch_source_t)</code>方法，该方法的作用的是模拟自定义事件，首先创建一个全局并发队列，然后循环让其执行任务，在执行的任务里调用<code>dispatch_source_merge_data</code>函数，就可以触发监听类型为<code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>或者<code>DISPATCH_SOURCE_TYPE_DATA_OR</code>的Dispatch Source。该函数有两个参数，第一个参数是目标Dispatch Source，第二个参数的类型是无符号长整型，用于向目标Dispatch Source中的对应变量追加指定的数。</p>
<p>我们再来看看如何监听自定义时间，首先创建类型为<code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>的Dispatch Source，然后设置回调闭包，在闭包中使用<code>dispatch_source_get_data</code>获取追加的变量值，该函数只有一个参数，就是目标Dispatch Source，这里需要注意的是通过<code>dispatch_source_get_data</code>函数获取的变量值并不是累加值，而是每次调用<code>dispatch_source_merge_data</code>函数时设置的值，所以在上面的示例中用<code>totalProcess</code>变量累加每次获取到的值。</p>
<p>上面的示例可以用来模拟后台进行下载，根据下载的数据量使用<code>dispatch_source_merge_data</code>函数给目标Dispatch Source设置相应的变量值，然后在主线程中监听到Dispatch Source的自定义事件，通过<code>dispatch_source_get_data</code>函数获取到变量，用于更新显示进度条的UI。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-4115205380866695"
     data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/69122">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="u901A_u8FC7Dispatch_Queue_u6267_u884C_u4EFB_u52A1"><a href="#u901A_u8FC7Dispatch_Queue_u6267_u884C_u4EFB_u52A1" class="headerlink" title="通过Dispatch Queue执行任务"></a>通过Dispatch Queue执行任务</h2><p>如果想让Dispatch Queue执行任务，首先就是得将任务放入队列中，我们可以异步的将任务加入队列，也可以同步的将任务加入队列，可以一个任务一个任务的加，也可以一组一组的加。这节我们就来看看将任务加入队列的那些事。</p>
<h3 id="u5411_u961F_u5217_u6DFB_u52A0_u4EFB_u52A1"><a href="#u5411_u961F_u5217_u6DFB_u52A0_u4EFB_u52A1" class="headerlink" title="向队列添加任务"></a>向队列添加任务</h3><p>我们可以使用<code>dispatch_async</code>或者<code>dispatch_async_f</code>函数异步的向队列中添加任务，也就是说当我们添加完任务后该函数会立即返回，我们不需要等待任务执行完成，而且我们也不会知道队列到底何时开始执行任务。<code>dispatch_async</code>函数有两个参数，一个是目标队列，类型为<code>dispatch_queue_t</code>，另一个是闭包，类型为<code>dispatch_block_t</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_async(serialQueue, &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task in the queue..."</span>)</span><br><span class="line">        </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>dispatch_async_f</code>函数有三个参数，第一个是类型为<code>dispatch_queue_t</code>的目标队列，第二个是队列上下文指针，第三个是类型为<code>dispatch_function_t</code>的任务函数，队列上下文指针为该函数的唯一参数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTaskToQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in the queue..."</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async_f(serialQueue, <span class="built_in">unsafeBitCast</span>(<span class="number">0</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>), taskFunction())</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">taskFunction</span><span class="params">()</span></span> -&gt; dispatch_function_t &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123; context <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Do some work with context..."</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addTaskToQueue = <span class="type">AddTaskToQueue</span>()</span><br><span class="line">addTaskToQueue.launch()</span><br></pre></td></tr></table></figure>
<p>除了这两个函数，我们还可以使用<code>dispatch_sync</code>和<code>dispatch_sync_f</code>函数同步的向队列中添加任务，并且我们要等待直到任务执行完成。这两个函数和上面的异步添加任务函数用法完全一致。</p>
<p>那么什么时候用异步什么时候用同步呢，大多数情况下我们都是在主线程中使用GCD分派任务，为了避免阻塞主线程，影响用户体验，所以通常情况下我们都使用异步添加任务的方式。当然为了避免任务与主线程中产生资源竞争的问题，有时候酌情也会使用同步添加任务的方式。</p>
<h3 id="Dispatch_Queue_u7684Completion_Block"><a href="#Dispatch_Queue_u7684Completion_Block" class="headerlink" title="Dispatch Queue的Completion Block"></a>Dispatch Queue的Completion Block</h3><p>还记得<code>NSOperation</code>的<code>completionBlock</code>属性吗，这个回调函数在任务执行完成后调用，用于处理有些后续工作或者消息通知。在Dispatch Queue中并没有类似的属性，但是我们可以通过其他方式来实现。举一个很常见的应用场景，我们在主线程中分派一个下载图片的任务，让其在二级线程中执行，当图片下载完成后通知主线程，并由主线程将图片显示出来，我们看看简单的代码片段：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadImage</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dispatchTaskInMainThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), downloadImage())</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">downloadImage</span><span class="params">()</span></span> -&gt; (() -&gt; ()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Downloading image in <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">            dispatch_async(dispatch_get_main_queue()) &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Handle image and display in <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看上面代码都做了些什么，首先在<code>dispatchTaskInMainThread</code>方法中，我们使用<code>dispatch_get_global_queue</code>函数获取到全局并发队列，然后将<code>downloadImage</code>下载图片的方法作为任务添加到该全局队列中。在<code>downloadImage</code>方法里，当图片下载完成后通过<code>dispatch_get_main_queue</code>函数获取到主队列，也就是在主线程中对图片进行处理，这样我们就达到了Completion Block的效果。</p>]]>
    
    </summary>
    
      <category term="Concurrency" scheme="http://www.devtalking.com/tags/Concurrency/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Concurrency Programming Guide 笔记（二）]]></title>
    <link href="http://www.devtalking.com//articles/read-concurrency-programming-guide-2/"/>
    <id>http://www.devtalking.com//articles/read-concurrency-programming-guide-2/</id>
    <published>2016-03-22T16:00:00.000Z</published>
    <updated>2016-08-19T00:59:42.000Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/63001" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="Operation_u5BF9_u8C61_u7684_u76F8_u5173_u8BBE_u7F6E"><a href="#Operation_u5BF9_u8C61_u7684_u76F8_u5173_u8BBE_u7F6E" class="headerlink" title="Operation对象的相关设置"></a>Operation对象的相关设置</h2><p>Operation对象除了上文中讲到到基本使用方法外还有一些其他的特性，这些特性需要根据我们的应用场景去设置，设置的时机在创建Operation对象之后和运行它或者将其放入操作队列之前，下面让我们来看看Operation对象还有哪些特性。</p>
<h3 id="Operation_u5BF9_u8C61_u4E4B_u95F4_u7684_u4F9D_u8D56"><a href="#Operation_u5BF9_u8C61_u4E4B_u95F4_u7684_u4F9D_u8D56" class="headerlink" title="Operation对象之间的依赖"></a>Operation对象之间的依赖</h3><p>与GCD不同，Operation Queue不遵循先进先出的原则，而且Operation Queue始终是并发执行Operation对象的，所以想让Operation对象串行执行就需要用它的Operation对象依赖特性，该特性可以让Operation对象将自己与另外一个Operation对象进行关联，并且当关联的Operation对象执行完成后才可以执行，这样就达到了串行执行Operation对象的目的。</p>
<p>我们可以用<code>NSOperation</code>的<code>addDependency</code>方法添加依赖的Operation对象，而且产生依赖的这两个Operation对象并不要求必须在相同的操作队列中，但是这种依赖只能是单向的，不能相互依赖。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestOperationDependency</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> blockOperationA = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in blockOperationA..."</span>)</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> blockOperationB = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in blockOperationB..."</span>)</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        blockOperationA.addDependency(blockOperationB)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> operationQueue = <span class="type">NSOperationQueue</span>()</span><br><span class="line">        </span><br><span class="line">        operationQueue.addOperation(blockOperationA)</span><br><span class="line">        </span><br><span class="line">        operationQueue.addOperation(blockOperationB)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testOperationDependency = <span class="type">TestOperationDependency</span>()</span><br><span class="line"></span><br><span class="line">testOperationDependency.launch()</span><br></pre></td></tr></table></figure>
<p>上面的示例代码展示了如何给Operation对象添加依赖，大家可以注释掉<code>blockOperationA.addDependency(blockOperationB)</code>这一行看看打印结果有什么区别。</p>
<h3 id="Operation_u5BF9_u8C61_u7684_u4F18_u5148_u7EA7"><a href="#Operation_u5BF9_u8C61_u7684_u4F18_u5148_u7EA7" class="headerlink" title="Operation对象的优先级"></a>Operation对象的优先级</h3><p>上文中说了，操作队列里的Operation对象都是并发执行的，如果一个操作队列中有多个Operation对象，那么谁先执行谁后执行取决于Operation对象的依赖Operation对象是否已执行完成，也就是是否处于准备执行的状态。其实Operation对象自身也有优先级的属性，如果有两个都处于准备执行状态的Operation对象，那么优先级高的会先执行，优先级低的后执行。每个Operation对象默认的优先级是<code>NSOperationQueuePriority.Normal</code>级别，我们可以通过设置<code>queuePriority</code>属性更改Operation的在队列中执行的优先级，优先级别有以下五种：</p>
<ul>
<li><code>NSOperationQueuePriority.Normal</code>：正常优先级</li>
<li><code>NSOperationQueuePriority.Low</code>：低优先级</li>
<li><code>NSOperationQueuePriority.VeryLow</code>：非常低优先级</li>
<li><code>NSOperationQueuePriority.High</code>：高优先级</li>
<li><code>NSOperationQueuePriority.VeryHigh</code>：非常高优先级</li>
</ul>
<p>这里我们需要注意一下Operation对象优先级的作用域，它只能作用于相同的操作队列中，不同操作队列中的Operation对象是不受优先级影响的。另外需要注意的是，如果有两个Operation对象，一个处于准备执行状态，但优先级比较低，另一个处于等待状态，但优先级比较高，那么此时仍然是处于准备执行状态的低优先级Operation对象先执行。可见Operation对象的优先级相互影响需要满足两个条件，一是必须处在同一个操作队列中，另一个是Operation对象都处于准备执行状态。</p>
<h3 id="u901A_u8FC7Operation_u5BF9_u8C61_u4FEE_u6539_u7EBF_u7A0B_u4F18_u5148_u7EA7"><a href="#u901A_u8FC7Operation_u5BF9_u8C61_u4FEE_u6539_u7EBF_u7A0B_u4F18_u5148_u7EA7" class="headerlink" title="通过Operation对象修改线程优先级"></a>通过Operation对象修改线程优先级</h3><p>通常情况下，线程的优先级由内核自己管理，不过在OS X v10.6及以后的版本和iOS4到iOS7期间，<code>NSOperation</code>多了一个<code>threadPriority</code>属性，我们可以通过该属性设置Operation对象运行所在线程的优先级，数值范围为0.0到1.0，数字越高优先级越高。不过可能是出于线程安全等方面的考虑，Apple从iOS8开始废除了该属性。</p>
<h3 id="u8BBE_u7F6ECompletion_Block"><a href="#u8BBE_u7F6ECompletion_Block" class="headerlink" title="设置Completion Block"></a>设置Completion Block</h3><p>上篇文章中说过，Operation对象其中的一个特别好的特性就是完成时回调闭包Completion Block。它的作用不言而喻，就是当主要任务执行完成之后做一些收尾的处理工作，我们可以设置<code>completionBlock</code>属性给Operation对象添加完成时回调闭包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">blockOperationA.completionBlock = &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"blockOperationA has finished..."</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6267_u884COperation_u5BF9_u8C61"><a href="#u6267_u884COperation_u5BF9_u8C61" class="headerlink" title="执行Operation对象"></a>执行Operation对象</h2><p>虽然前面文章的示例中已经包含了对Operation对象的执行，但是并没详细说明，这节就说说Operation对象的执行。</p>
<h3 id="u4F7F_u7528Operation_Queue"><a href="#u4F7F_u7528Operation_Queue" class="headerlink" title="使用Operation Queue"></a>使用Operation Queue</h3><p>使用Operation Queue操作队列执行Operation对象已然是标配选项了，操作队列在Cocoa框架中对应的类是<code>NSOperationQueue</code>，一个操作队列中可以添加多个Operation对象，但一次到底添加多少Operation对象得根据实际情况而定，比如应用程序对内存的消耗情况、内核的空闲情况等，所以说凡事得有度，不然反而会适得其反。另外需要注意的一点是不论有多少个操作队列，它们都受制于系统的负载、内核空闲等运行情况，所以说并不是说再创建一个操作队列就能执行更多的Operation对象。</p>
<p>在使用操作队列时，我们首先要创建<code>NSOperationQueue</code>的实例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> operationQueue = <span class="type">NSOperationQueue</span>()</span><br></pre></td></tr></table></figure>
<p>然后通过<code>NSOperationQueue</code>的<code>addOperation</code>方法添加Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operationQueue.addOperation(blockOperationA)</span><br><span class="line">        </span><br><span class="line">operationQueue.addOperation(blockOperationB)</span><br></pre></td></tr></table></figure>
<p>在OS X v10.6之后和iOS4之后，我们还可以用<code>addOperations:waitUntilFinished:</code>方法添加一组Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operationQueue.addOperations([blockOperationA, blockOperationB], waitUntilFinished: <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>该方法有两个参数：</p>
<ul>
<li><code>ops: [NSOperation]</code>：Operation对象数组。</li>
<li><code>waitUntilFinished wait: Bool</code>：该参数标示这个操作队列在执行Operation对象时是否会阻塞当前线程。</li>
</ul>
<p>我们还可以通过<code>addOperationWithBlock</code>方法向操作队列中直接添加闭包，而不需要去创建Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operationQueue.addOperationWithBlock(&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The block is running in Operation Queue..."</span>)</span><br><span class="line">            </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>除了以上这几种添加Operation对象的方法外，还可以通过<code>NSOperationQueue</code>的<code>maxConcurrentOperationCount</code>属性设置同时执行Operation对象的最大数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operationQueue.maxConcurrentOperationCount = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果设置为1，那么不管该操作队列中添加了多少Operation对象，每次都只运行一个，而且会按照添加Operation对象的顺序去执行。所以如果遇到添加到操作的队列的Operation对象延迟执行了，那么通常会有两个原因：</p>
<ul>
<li>添加的Operation对象数超过了操作队列设置的同时执行Operation对象的最大数。</li>
<li>延迟执行的Operation对象在等待它依赖的Operation对象执行完成。</li>
</ul>
<p>另外需要的注意的是当Operation对象添加到操作队列中后，不要再更改它任务中涉及到的任何属性或者它的依赖，因为到操作队列中的Operation对象随时会被执行，所以如果你自以为它还没有被执行而去修改它，可能并不会达到你想要的结果。</p>
<h3 id="u624B_u52A8_u6267_u884COperation_u5BF9_u8C61"><a href="#u624B_u52A8_u6267_u884COperation_u5BF9_u8C61" class="headerlink" title="手动执行Operation对象"></a>手动执行Operation对象</h3><p>除了用操作队列来执行Operation对象以外，我们还可以手动执行某个Operation对象，但是这需要我们注意更多的细节问题，也要写更多的代码去确保Operation对象能正确执行。在上篇文章中，我们创建过自定义的Operation对象，其中我们知道有几个属性特别需要我们注意，那就是<code>ready</code>、<code>concurrent</code>、<code>executing</code>、<code>finished</code>、<code>cancelled</code>，对应Operation对象是否出于准备执行状态、是否为异步并发执行的、是否正在执行、是否已经执行完成、是否已被终止。这些状态在我们使用操作队列时都不需要理会，都有操作队列帮我们把控判断，确保Operation对象的正确执行，我们只需要在必要的时候获取状态信息查看而已。但是如果手动执行Operation对象，那么这些状态都需要我们来把控，因为你手动执行一个Operation对象时要判断它的依赖对象是否执行完成，是否被终止了等等，所以并不是简单的调用<code>start</code>方法，下面来看看如果正确的手动执行Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performOperation</span><span class="params">(operation: NSOperation)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> operation.ready &amp;&amp; !operation.cancelled &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> operation.concurrent &#123;</span><br><span class="line">                </span><br><span class="line">            operation.start()</span><br><span class="line">                </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">            <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"start"</span>, toTarget: operation, withObject: <span class="literal">nil</span>)</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        result = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u7EC8_u6B62Operation_u5BF9_u8C61_u6267_u884C"><a href="#u7EC8_u6B62Operation_u5BF9_u8C61_u6267_u884C" class="headerlink" title="终止Operation对象执行"></a>终止Operation对象执行</h3><p>一旦Operation对象被添加到操作队列中，这个Operation对象就属于这个操作队列了，并且不能被移除，唯一能让Operation对象失效的方法就是通过<code>NSOperation</code>的<code>cancel</code>方法终止它执行，或者也可以通过<code>NSOperationQueue</code>的<code>cancelAllOperations</code>方法终止在队列中的所有Operation对象。</p>
<h3 id="u6682_u505C_u548C_u6062_u590D_u64CD_u4F5C_u961F_u5217"><a href="#u6682_u505C_u548C_u6062_u590D_u64CD_u4F5C_u961F_u5217" class="headerlink" title="暂停和恢复操作队列"></a>暂停和恢复操作队列</h3><p>在实际运用中，如果我们希望暂停操作队列执行Operation对象，可以通过设置<code>NSOperationQueue</code>的<code>suspended</code>属性为<code>false</code>来实现，不过这里要注意的是暂停操作队列只是暂停执行下一个Operation对象，而不是暂停当前正在执行的Operation对象，将<code>suspended</code>属性设置为<code>true</code>后，操作队列则恢复执行。</p>
<h2 id="Dispatch_Queues"><a href="#Dispatch_Queues" class="headerlink" title="Dispatch Queues"></a>Dispatch Queues</h2><p>Dispatch Queue是GCD中的核心功能，它能让我们很方便的异步或同步执行任何被封装为闭包的任务，它的运作模式与Operation Queue很相似，但是有一点不同的是Dispatch Queue是一种先进先出的数据结构，也就是执行任务的顺序永远等同于添加任务时的顺序。GCD中已经为我们提供了几种类型的Dispatch Queue，当然我们也可以根据需求自己创建Dispatch Queue，下面我们先来看看Dispatch Queue的类型：</p>
<ul>
<li>串行Dispatch Queue：该类型的队列一次只能执行一个任务，当前任务完成之后才能执行下一个任务，而且可依任务的不同而在不同的线程中执行，这类队列通常作为私有队列使用。这里需要注意的是虽然该类型的队列一次只能执行一个任务，但是可以让多个串行队列同时开始执行任务，达到并发执行的任务的目的。</li>
<li>并行Dispatch Queue：该类队列可同时执行多个任务，但是执行任务的顺序依然是遵循先进先出的原则，同样可依任务的不同而在不同的线程中执行，这类队列通常作为全局队列使用。</li>
<li>主Dispatch Queue：该类队列实质上也是一个串行队列，但是该队列是一个全局队列，在该队列中执行的任务都是在当前应用的主线程中执行的。通常情况下我们不需要自己创建此类队列。</li>
</ul>
<p>Dispatch Queue与Operation Queue相似，都能让我们更方便的实现并发任务的编程工作，并且能提供更优的性能，因为我们不再需要编写关于线程管理相关的一大堆代码，这些完全都有系统接管，我们只需要将注意力放在要执行的任务即可。举个简单的例子，如果有两个任务需要在不同的线程中执行，但是他们之间存在资源竞争的情况，所以需要保证执行的先后顺序，如果我们自己创建线程实现该场景，那么就务必要用的线程锁机制，确保任务有正确的执行顺序，这势必对系统资源的开销会非常大，如果使用Dispatch Queue，我们只需要将任务安正确的顺序添加到串行队列中即可，省时省力省资源。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u4EFB_u52A1_u7684_u8F7D_u4F53_u662F_u95ED_u5305"><a href="#u4EFB_u52A1_u7684_u8F7D_u4F53_u662F_u95ED_u5305" class="headerlink" title="任务的载体是闭包"></a>任务的载体是闭包</h3><p>在使用Dispatch Queue时，需要将任务封装为闭包。闭包就是一个函数，或者一个指向函数的指针，加上这个函数执行的非局部变量，闭包最大的一个特性就是可以访问父作用域中的局部变量。我们在将任务封装为闭包进行使用时要注意以下这几点：</p>
<ul>
<li>虽然在闭包中可以使用父作用域中的变量，但是尽可能少的使用父作用域中比较大的变量以及不要在闭包中做类似删除清空父作用域中变量的行为。</li>
<li>当将一个封装好任务的闭包添加至Dispatch Qeueu中，Dispatch Queue会自动复制该闭包，并且在执行完成后释放该闭包，所以不同担心闭包中一些值的变化问题，以及资源释放问题。</li>
<li>虽然使用Dispatch Queue执行并发异步任务很方便，但是创建和执行闭包还是有一定资源开销的，所以尽量不要使用Dispatch Queue执行一些很小的任务，要物有所值。如果确实有很小的任务需要并发异步执行，那么使用<code>NSThread</code>的<code>detachNewThreadSelector</code>方法或<code>NSObject</code>的<code>performSelectorInBackground</code>方法去执行也未必不可。</li>
<li>如果同一个队列中的多个任务之间需要共享数据，那么应该使用队列上下文去存储数据，供不同的任务访问。</li>
<li>如果闭包中的任务创建了不少对象，那么应该考虑将整个任务逻辑代码放在<code>autoreleasepool</code>中，虽然Dispatch Queue中也有自动释放池，但是你不能保证它每次释放的时间，所以咱们自己再加一个要来的更保险一些。</li>
</ul>
<h2 id="u521B_u5EFA_u4E0E_u7BA1_u7406Dispatch_Queues"><a href="#u521B_u5EFA_u4E0E_u7BA1_u7406Dispatch_Queues" class="headerlink" title="创建与管理Dispatch Queues"></a>创建与管理Dispatch Queues</h2><p>在使用Dispatch Queue之前，我们首先需要考虑应该创建什么类型的Dispatch Queue，如何进行配置等，这一节就来说一说如何创建和管理Dispatch Queue。</p>
<h3 id="u5168_u5C40_u5E76_u53D1Dispatch_Queue"><a href="#u5168_u5C40_u5E76_u53D1Dispatch_Queue" class="headerlink" title="全局并发Dispatch Queue"></a>全局并发Dispatch Queue</h3><p>并发队列的好处人人皆知，可以方便的同时处理多个任务，在GCD中并发Dispatch Queue同样遵循先进先出的原则，但这只是在运行时适用，如果有个任务在并发队列中还没轮到它执行，那么此时完全可以移除它，而不必等它前面的任务执行完成之后。至于并发队列中没次有多少个任务在执行，这个恐怖在每一秒都在变化，因为影响它的因素有很多，所以之前说过，尽量不要移除移除已经添加进队列的任务。</p>
<p>OS X和iOS系统为我们提供了四种全局并发Dispatch Queue，所谓全局队列，就是我们不需要理会它们的保留和释放问题，而且不需要专门创建它。与其说是四种不如说是一种全局并发队列的四种不同优先级，因为它们之间唯一的不同之处就是队列优先级不同。与Operation Queue不同，在GCD中，Dispatch Queue只有四种优先级：</p>
<ul>
<li><code>DISPATCH_QUEUE_PRIORITY_HIGH</code>：高优先级。</li>
<li><code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>：默认优先级，低于高优先级。</li>
<li><code>DISPATCH_QUEUE_PRIORITY_LOW</code>：低优先级，低于高优先级和默认优先级。</li>
<li><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>：后台优先级，低于高优先级和后台线程执行的任务。</li>
</ul>
<p>我们可以通过<code>dispatch_get_global_queue</code>函数再根据不同的优先级获取不同的全局并发队列，类型为<code>dispatch_queue_t</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> highPriorityQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_HIGH</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> defaultPriorityQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>我们在使用全局并发队列的时候不需要保留队列的引用，随时要用随时用该函数获取即可。当然我们也可以通过<code>dispatch_queue_create</code>函数自己创建队列：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.example.MyConcurrentQueue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，<code>dispatch_queue_create</code>函数有两个参数，第一个为队列的名称，第二个为队列类型，串行队列为<code>DISPATCH_QUEUE_SERIAL</code>，并发队列为<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>
<h3 id="u4E32_u884CDispatch_Queue"><a href="#u4E32_u884CDispatch_Queue" class="headerlink" title="串行Dispatch Queue"></a>串行Dispatch Queue</h3><p>串行队列可以让我们将任务按照一定顺序执行，能更优的处理多个任务之间的资源竞争问题，比线程锁机制有更小的资源开销和更好的性能，并且不会产生死锁的问题。</p>
<p>系统也为我们提供了一个串行队列，我们可以通过<code>dispatch_get_main_queue</code>函数获取：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mainQueue = dispatch_get_main_queue()</span><br></pre></td></tr></table></figure>
<p>该队列与当前应用的主线程相关联。当然我们也可以自己创建串行队列：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueueA = dispatch_queue_create(<span class="string">"com.example.MySerialQueueA"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> serialQueueB = dispatch_queue_create(<span class="string">"com.example.MySerialQueueB"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p><code>dispatch_queue_create</code>函数的第二个参数如果为<code>nil</code>则默认创建串行队列。当我们创建好串行队列后，系统会自动将创建好的队列与当前应用的主线程进行关联。</p>
<h3 id="u83B7_u53D6_u5F53_u524D_u961F_u5217"><a href="#u83B7_u53D6_u5F53_u524D_u961F_u5217" class="headerlink" title="获取当前队列"></a>获取当前队列</h3><p>如果需要验证或者测试当前队列，我们可以通过<code>dispatch_get_current_queue</code>函数获取当前队列。如果在闭包中调用，返回的是该闭包所在的队列，如果在闭包外调用，返回的则是默认的并发队列。不过该函数在OS X v10.10中和Swift中都不能使用了，取而代之的是通过<code>DISPATCH_CURRENT_QUEUE_LABEL</code>属性的<code>get</code>方法。</p>
<h3 id="u64C5_u7528_u961F_u5217_u4E0A_u4E0B_u6587"><a href="#u64C5_u7528_u961F_u5217_u4E0A_u4E0B_u6587" class="headerlink" title="擅用队列上下文"></a>擅用队列上下文</h3><p>很多情况下，同一个队列中的不同任务之间需要共享数据，尤其像串行队列中的任务，可能由多个任务对某个变量进行处理，或者都需要使用到某个对象，这时就要用到队列上下文:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">        </span><br><span class="line">        dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(<span class="number">0</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> taskCount = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            taskCount++</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"TaskA in the dispatch queue...and The number of task in queue is <span class="subst">\(taskCount)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(taskCount, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> taskCount = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            taskCount++</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"TaskB in the dispatch queue...and The number of task in queue is <span class="subst">\(taskCount)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(taskCount, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testDispatchQueue = <span class="type">TestDispatchQueue</span>()</span><br><span class="line">testDispatchQueue.launch()</span><br></pre></td></tr></table></figure>
<p>从上面的代码示例中可以看到，在执行代码点，我们用<code>dispatch_set_context</code>函数向<code>serialQueue</code>队列的上下文环境中设置了一个<code>Int</code>类型的变量，初始值为0。该函数有两个参数，第一个是目标队列，第二个参数是上下文数据的指针。然后在闭包中我们使用<code>dispatch_get_context</code>函数获取上下文数据进行进一步的处理。除了基本类型，我们也可以将自定义的类放入队列上下文中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"DevTalking"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> mobile = <span class="string">"10010"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> contact = <span class="type">Contact</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">        </span><br><span class="line">        dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(contact, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.name)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.mobile)</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testDispatchQueue = <span class="type">TestDispatchQueue</span>()</span><br><span class="line">testDispatchQueue.launch()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于<code>unsafeBitCast</code>函数和Swift中指针的用法在<a href="http://www.devtalking.com/articles/read-threading-programming-guide-3/">这里</a>可以有所参考。</p>
</blockquote>
<h3 id="u961F_u5217_u7684_u6536_u5C3E_u5DE5_u4F5C"><a href="#u961F_u5217_u7684_u6536_u5C3E_u5DE5_u4F5C" class="headerlink" title="队列的收尾工作"></a>队列的收尾工作</h3><p>虽然在ARC时代，资源释放的工作已经基本不需要我们手动去做了，但有些时候因为系统释放资源并不是很及时，也会造成内存移除等问题，所以在一些情况下我们还是需要进行手动释放资源的工作，必入添加<code>autoreleasepool</code>保证资源及时释放等。Dispatch Queue也给我们提供了这样的机会（机会针对于ARC时代，在MRC时代是必须要做的），那就是Clean Up  Function清理扫尾函数，当队列被释放时，或者说引用计数为0时会调用该函数，并且将上下文指针也传到了该函数，以便进行清理工作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"DevTalking"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> mobile = <span class="string">"10010"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> contact = <span class="type">Contact</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">testCleanUpFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        launch()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">15</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"></span><br><span class="line">        dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(contact, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">        </span><br><span class="line">        dispatch_set_finalizer_f(serialQueue, myFinalizerFunction())</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.name)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.mobile)</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">myFinalizerFunction</span><span class="params">()</span></span> -&gt; dispatch_function_t &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123; context <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(context, <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.name)</span> and the mobile is <span class="subst">\(contact.mobile)</span>, The serialQueue has been released and we need clean up context data."</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// TODO...</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testDispatchQueue = <span class="type">TestDispatchQueue</span>()</span><br><span class="line">testDispatchQueue.testCleanUpFunction()</span><br></pre></td></tr></table></figure>
<p>从上面的代码示例中可以看到当给队列设置完上下文时，我们使用了<code>dispatch_set_finalizer_f</code>函数给队列设置清理函数，<code>dispatch_set_finalizer_f</code>函数有两个参数，第一个是目标队列，第二个参数是类型为<code>dispatch_function_t</code>的函数指针，也就是清理函数，上下文数据指针是该函数唯一的参数。在上面代码中，我们添加了<code>myFinalizerFunction</code>函数作为清理函数，在该函数中获得上下文数据，然后进行后续的清理工作。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" ]]>
    </summary>
    
      <category term="Concurrency" scheme="http://www.devtalking.com/tags/Concurrency/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Concurrency Programming Guide 笔记（一）]]></title>
    <link href="http://www.devtalking.com//articles/read-concurrency-programming-guide-1/"/>
    <id>http://www.devtalking.com//articles/read-concurrency-programming-guide-1/</id>
    <published>2016-03-10T16:00:00.000Z</published>
    <updated>2016-08-19T01:00:24.000Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/60236" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>并发任务是指多个任务在某一时刻同时运行。在过去，一提到并发执行任务，首当其冲的解决方案就是在程序中创建多个线程来实现，但是线程本身较为底层，而且管理的难度比较大，如果想做倒最优的线程数量、最恰当的线程创建销毁时机是很难的，以至于虽然达到了并发执行任务的目的，但却以降低程序性能为代价，所以往往得不偿失。</p>
<p>鉴于上述的原因，于是一些实现并发任务的其他方案出现了。在OS X和iOS系统中采用了多种实现并发执行任务的方法，与直接创建线程不同，这些方法让开发者只需要关注要执行的任务，然后让系统执行它们即可，不需要关心线程管理的问题，为开发者提供了一个简单而高效的并发任务编程模式。</p>
<p>其中一种实现任务异步执行的技术就是Grand Central Dispatch（GCD），该技术封提供了系统级别的线程管理功能，我们在使用它时只需要定义我们希望执行的任务，然后将任务添加到对应的分派执行队列中即可。另外一个技术是Operation queues，具体的实现是Objective-C中的<code>NSOperationQueue</code>对象，它的作用和GCD很相似，同样只需要我们定义好任务，然后添加到对应的操作队列中即可，其他与线程管理相关的事都由<code>NSOperationQueue</code>帮我们完成。</p>
<h2 id="Dispatch_Queues_u7B80_u8FF0"><a href="#Dispatch_Queues_u7B80_u8FF0" class="headerlink" title="Dispatch Queues简述"></a>Dispatch Queues简述</h2><p>Dispatch Queues是基于C语言的，执行自定义任务的技术，从字面意思理解其实就是执行任务的队列，使用GCD执行的任务都是放在这个队列中执行的，当然队列的数量可以有多个，类型也不止一种。一个Dispatch queue可以串行的执行任务，也可以并行的执行任务，但不管哪种执行任务的方式，都遵循先进先出的原则。串行队列一次只能执行一个任务，当前任务执行完后才能执行下一个任务，并且执行任务的顺序和添加任务的顺序是一致的。并行队列自然是可同时执行多个任务，不需要等待上个任务完成后才执行下个任务。我们来看看Dispatch queue还有哪些好的特性：</p>
<ul>
<li>有简单宜用，通俗易懂的编程接口。</li>
<li>提供了自动管理的线程池。</li>
<li>可自动调节队列装载任务的速度。</li>
<li>更优的内存使用率。</li>
<li>使用户不用担心死锁的问题。</li>
<li>提供了比线程锁更优的同步机制。</li>
</ul>
<p>使用Dispatch Queue时，需要将任务封装为一个函数或者一个<code>block</code>，<code>block</code>是Objective-C中对闭包的实现，在OS X 10.6和iOS 4.0时引入的，在Swift中直接为闭包。</p>
<h2 id="Dispatch_Sources_u7B80_u8FF0"><a href="#Dispatch_Sources_u7B80_u8FF0" class="headerlink" title="Dispatch Sources简述"></a>Dispatch Sources简述</h2><p>Dispatch Source是GCD中的一个基本类型，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。我们来看看它都有哪些类型：</p>
<ul>
<li>Timer Dispatch Source：定时调度源。</li>
<li>Signal Dispatch Source：监听UNIX信号调度源，比如监听代表挂起指令的SIGSTOP信号。</li>
<li>Descriptor Dispatch Source：监听文件相关操作和Socket相关操作的调度源。</li>
<li>Process Dispatch Source：监听进程相关状态的调度源。</li>
<li>Mach port Dispatch Source：监听Mach相关事件的调度源。</li>
<li>Custom Dispatch Source：监听自定义事件的调度源。</li>
</ul>
<p>Dispatch Source是GCD中很有意思也很有用的一个特性，根据不同类型的调度源，我们可以监听较为底层的系统行为，不论在实现功能方面还是调试功能方面都非常游有用，后文中会再详细讲述。</p>
<h2 id="Operation_Queues_u7B80_u8FF0"><a href="#Operation_Queues_u7B80_u8FF0" class="headerlink" title="Operation Queues简述"></a>Operation Queues简述</h2><p>Operation Queue与Dispatch Queue很类似，都是有任务队列或操作队列的概念，只不过它是由Cocoa框架中的<code>NSOperationQueue</code>类实现的，它俩最主要的区别是任务的执行顺序，在Dispatch Queue中，任务永远都是遵循先进先出的原则，而Operation Queue加入了其他的任务执行顺序特性，使下一个任务的开始不再取决于上个任务是否已完成。</p>
<p>上文说过，使用Dispatch Queue时，需要将任务封装为一个函数或者闭包。而在Operation Queue中，需要将任务封装为一个<code>NSOpertaion</code>对象，然后放入操作队列执行。同时该对象还自带键值观察（KVO）通知特性，可以很方便的监听任务的执行进程。</p>
<h2 id="u8BBE_u8BA1_u5E76_u53D1_u4EFB_u52A1_u65F6_u5E94_u8BE5_u6CE8_u610F_u7684_u4E8B_u9879"><a href="#u8BBE_u8BA1_u5E76_u53D1_u4EFB_u52A1_u65F6_u5E94_u8BE5_u6CE8_u610F_u7684_u4E8B_u9879" class="headerlink" title="设计并发任务时应该注意的事项"></a>设计并发任务时应该注意的事项</h2><p>虽然并发执行任务可以提高程序对用户操作的响应速度，最大化使用内核，提升应用的效率，但是这些都是建立在正确合理使用并发任务技术，以及应用程序确实需要使用这类技术的前提下。如果使用不得当，或者对简单的应用程序画蛇添足，那么反而会因为使用了并发任务技术而导致应用程序性能下降，另一方面开发人员面对的代码复杂度也会增加，维护成本同样会上升。所以在准备使用这类技术前一定要三思而行，从性能、开发成本、维护成本等多个方面去考虑是否需要使用并发任务技术。</p>
<p>考虑是否需要用只是第一步，当确定使用后更不能盲目的就开始开发，因为并发任务技术的使用需要侵入应用程序的整个开发生命周期，所以在应用开发之初，就是考虑如何根据这类技术去设计并发任务，考虑应用中任务的类型、任务中使用的数据结构等等，否则亡羊补牢也为时已晚。这一节主要说说在设计并发任务时应该注意哪些事。</p>
<h3 id="u68B3_u7406_u5E94_u7528_u7A0B_u5E8F_u4E2D_u7684_u4EFB_u52A1"><a href="#u68B3_u7406_u5E94_u7528_u7A0B_u5E8F_u4E2D_u7684_u4EFB_u52A1" class="headerlink" title="梳理应用程序中的任务"></a>梳理应用程序中的任务</h3><p>在动手写代码前，尽量根据需求，穷举应用中的任务以及在任务中涉及到的对象何数据结构，然后分析这些任务的优先级和触发类型，比如罗列出哪些任务是由用户操作触发的，哪些是任务是无需用户参与触发的。</p>
<p>当把任务根据优先级梳理好后，就可以从高优先级的任务开始逐个分析，考虑任务在执行过程中涉及到哪些对象和数据结构，是否会修改变量，被修改的变量是否会对其他变量产生影响，以及任务的执行结果对整个程序产生什么影响等。举个简单的例子，如果一个任务中对某个变量进行了修改，并且这个变量不会对其他变量产生影响，而且任务的执行结果也相对比较独立，那么像这种任务就最合适让它异步去执行。</p>
<h3 id="u8FDB_u4E00_u6B65_u7EC6_u5206_u4EFB_u52A1_u4E2D_u7684_u6267_u884C_u5355_u5143"><a href="#u8FDB_u4E00_u6B65_u7EC6_u5206_u4EFB_u52A1_u4E2D_u7684_u6267_u884C_u5355_u5143" class="headerlink" title="进一步细分任务中的执行单元"></a>进一步细分任务中的执行单元</h3><p>任务可以是一个方法，也可以是一个方法中的一段逻辑，不论是一个方法还是一段逻辑，我们都可以从中拆分出若干个执行单元，然后进一步分析这些执行单元，如果多个执行单元必须得按照特定得顺序执行，而且这一组执行单元的执行结果想对独立，那么可以将这若干执行单元视为执行单元组，可以考虑让该执行单元组异步执行，其他不需要按照特定顺序的执行单元可以分别让它们异步执行。可以使用的技术可以用GCD或者Operation Queue。</p>
<p>在拆分执行单元时，尽量拆的细一点，不要担心执行单元的数量过多，因为GCD和Operation Queue有着高性能的线程管理机制，不需要担心过多的使用任务队列会造成性能损耗。</p>
<h3 id="u786E_u5B9A_u5408_u9002_u7684_u961F_u5217"><a href="#u786E_u5B9A_u5408_u9002_u7684_u961F_u5217" class="headerlink" title="确定合适的队列"></a>确定合适的队列</h3><p>当我们将任务分解为一个个执行单元并分析之后，下一步就是将这些执行单元封装在<code>block</code>中或者封装为<code>NSOperation</code>对象来使用GCD或Operation Queues，但在这之前还需要我们根据执行单元确定好适合的队列，不管是Dispatch queue还是Operation queue，都需要明确是使用串行队列还是并行队列，确定是将多个执行单元放入一个队列中还是分别放入多个队列中，以及使用正确优先级的队列。</p>
<h3 id="u63D0_u9AD8_u6548_u7387_u7684_u5176_u4ED6_u6280_u5DE7"><a href="#u63D0_u9AD8_u6548_u7387_u7684_u5176_u4ED6_u6280_u5DE7" class="headerlink" title="提高效率的其他技巧"></a>提高效率的其他技巧</h3><p>在使用任务队列时注意以下几点，可以有效的提高执行效率：</p>
<ul>
<li>如果应用比较吃内存，那么建议在任务中直接计算一些需要的值，这样比从主存中加载要来的快。</li>
<li>尽早确定顺序执行的任务，尽量将其改为并行任务，比如说有多个任务存在资源竞争问题，那么可以根据情况分别为每个任务拷贝一份该资源，从而避免顺序执行任务，以提高执行效率。</li>
<li>避免使用线程锁机制。在使用GCD或Operation Queues技术时基本不需要使用线程锁，因为有串行队列的存在。</li>
<li>尽量使用系统提供的框架达到并发任务的目的，一些系统提供的框架本身就有一些方法函数可以让任务并发执行，比如<code>UIView</code>提供的一系列动画的方法等。</li>
</ul>
<h2 id="Operation_Queues"><a href="#Operation_Queues" class="headerlink" title="Operation Queues"></a>Operation Queues</h2><p>Operation Queue技术由Cocoa框架提供，用于实现任务并发异步执行的技术，该技术基于面向对象概念。该技术中最主要的两个元素就是Operation对象和Operation队列，我们先来看看Operation对象。</p>
<h3 id="Operation_Objects"><a href="#Operation_Objects" class="headerlink" title="Operation Objects"></a>Operation Objects</h3><p>Operation对象的具体实现是Foundation框架中的<code>NSOperation</code>类，它的主要作用就是将我们希望执行的任务封装起来，然后去执行。<code>NSOperation</code>类本身是一个抽象类，在使用时需要我们创建子类去继承它，实现一些父类的方法，以达到我们使用的需求。同时Foundation框架也提供了两个已经实现好的<code>NSOperation</code>子类，供我们方便的使用：</p>
<ul>
<li><code>NSInvocationOperation</code>：当我们已经有一个方法需要异步去执行，此时显然没有必要为了这一个方法再去创建一个<code>NSOperation</code>的子类，所以我们就可以用<code>NSInvocationOperation</code>类来封装这个方法，然后放入操作队列去执行，以满足我们的需求。</li>
<li><code>NSBlockOperation</code>：该类可以让我们同时执行多个<code>block</code>对象或闭包。</li>
</ul>
<p>同时所有继承<code>NSOperation</code>的子类都会具有如下特性：</p>
<ul>
<li>可自动管理Operation对象之间的依赖关系，举个例子，当一个Operation对象执行之前发现它包含的任务中有依赖其他的Operation对象，并且该Operation对象还没有执行完成，那么当前的Operation对象会等待它的依赖执行完成后才会执行。</li>
<li>支持可选的完成时回调闭包，该闭包可以在Operation对象包含的主要任务执行完之后执行。</li>
<li>自带键值观察（KVO）通知特性，可以监听任务的执行状态。</li>
<li>可在运行时终止任务执行。</li>
</ul>
<p>虽然Operation Queues技术主要是通过将Operation对象放入队列中，实现并发异步的执行任务，但是我们也可以直接通过<code>NSOperation</code>类的<code>start</code>方法让其执行任务，但这样就属于同步执行任务了，我们还可以通过<code>NSOperation</code>类的<code>isConcurrent</code>方法来确定当前任务正在异步执行还是同步执行。</p>
<h3 id="u521B_u5EFANSInvocationOperation_u5BF9_u8C61"><a href="#u521B_u5EFANSInvocationOperation_u5BF9_u8C61" class="headerlink" title="创建NSInvocationOperation对象"></a>创建NSInvocationOperation对象</h3><p>上文中已经提到过，<code>NSInvocationOperation</code>对象是Foundation框架提供的<code>NSOperation</code>抽象类的实现，主要作用是方便我们将已有对象和方法封装为Operation对象，然后放入操作队列执行目标方法，同时该对象的好处是可以避免我们为已有的对象的方法逐个创建Operation对象，避免冗余代码。不过，由于<code>NSInvocationOperation</code>不是类型安全的，所以从Xcode 6.1开始，在Swift中就不能再使用该对象了。我们可以看看在Objective-c中如何创建该对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyCustomClass</span> </span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSOperation</span>*)taskWithData:(<span class="keyword">id</span>)data &#123; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInvocationOperation</span>* theOp = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(myTaskMethod:) object:data];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> theOp;</span><br><span class="line">    </span><br><span class="line">｝</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)myTaskMethod:(<span class="keyword">id</span>)data &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform the task. </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>当<code>NSInvocationOperation</code>对象创建好后，可以调用它父类<code>NSOperation</code>的<code>start</code>方法执行任务，但是这种不放在操作队列中的执行方式都是在当前线程，也就是主线程中同步执行的。</p>
<h3 id="u521B_u5EFANSBlockOperation_u5BF9_u8C61"><a href="#u521B_u5EFANSBlockOperation_u5BF9_u8C61" class="headerlink" title="创建NSBlockOperation对象"></a>创建NSBlockOperation对象</h3><p><code>NSBlockOperation</code>是另外一个由Foundation框架提供的<code>NSOperation</code>抽象类的实现类，该类的作用是将一个或多个block或闭包封装为一个Operation对象。在第一次创建<code>NSBlockOperation</code>时至少要添加一个block：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBlockOperation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">createBlockOperationObject</span><span class="params">()</span></span> -&gt; <span class="type">NSOperation</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The main thread num is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> nsBlockOperation = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in first closure. The thread num is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nsBlockOperation</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testBlockOperation = <span class="type">TestBlockOperation</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nsBlockOperation = testBlockOperation.createBlockOperationObject()</span><br><span class="line">nsBlockOperation.start()</span><br></pre></td></tr></table></figure>
<p>上面的代码中我们首先打印了主线程的线程号，然后通过<code>createBlockOperationObject</code>方法创建了一个<code>NSBlockOperation</code>对象，在初始化时的block中同样打印了当前线程的线程号，调用它父类的方法<code>start</code>后，可以看到这个block中的任务是在主线程中执行的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">The</span> main thread id <span class="keyword">is</span> &lt;<span class="type">NSThread</span>: <span class="number">0x101502e40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="type">Task</span> <span class="keyword">in</span> first closure. <span class="type">The</span> thread id <span class="keyword">is</span> &lt;<span class="type">NSThread</span>: <span class="number">0x101502e40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>然而我们也也可以通过<code>NSBlockOperation</code>对象的方法<code>addExecutionBlock</code>添加其他的block或者说任务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBlockOperation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">createBlockOperationObject</span><span class="params">()</span></span> -&gt; <span class="type">NSOperation</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The main thread num is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> nsBlockOperation = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in first closure. The thread num is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一种写法</span></span><br><span class="line">        nsBlockOperation.addExecutionBlock(&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in second closure. The thread num is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第二种写法</span></span><br><span class="line">        nsBlockOperation.addExecutionBlock&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in third closure. The thread num is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nsBlockOperation</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testBlockOperation = <span class="type">TestBlockOperation</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nsBlockOperation = testBlockOperation.createBlockOperationObject()</span><br><span class="line">nsBlockOperation.start()</span><br></pre></td></tr></table></figure>
<p>当我们再执行<code>NSBlockOperation</code>时，可以看到后面添加的两个任务都在不同的二级线程中执行，此时个任务为并发异步执行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">The</span> main thread id <span class="keyword">is</span> &lt;<span class="type">NSThread</span>: <span class="number">0x101502e40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="type">Task</span> <span class="keyword">in</span> first closure. <span class="type">The</span> thread id <span class="keyword">is</span> &lt;<span class="type">NSThread</span>: <span class="number">0x101502e40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="type">Task</span> <span class="keyword">in</span> third closure. <span class="type">The</span> thread id <span class="keyword">is</span> &lt;<span class="type">NSThread</span>: <span class="number">0x101009190</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line"><span class="type">Task</span> <span class="keyword">in</span> second closure. <span class="type">The</span> thread id <span class="keyword">is</span> &lt;<span class="type">NSThread</span>: <span class="number">0x101505110</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面两段代码可以观察到，当<code>NSBlockOperation</code>中只有一个block时，在调用<code>start</code>方法执行任务时不会为其另开线程，而是在当前线程中同步执行，只有当<code>NSBlockOperation</code>包含多个block时，才会为其另开二级线程，使任务并发异步执行。另外，当<code>NSBlockOperation</code>执行时，它会等待所有的block都执行完成后才会返回执行完成的状态，所以我们可以用<code>NSBloxkOperation</code>跟踪一组block的执行情况。</p>
<h3 id="u81EA_u5B9A_u4E49Operation_u5BF9_u8C61"><a href="#u81EA_u5B9A_u4E49Operation_u5BF9_u8C61" class="headerlink" title="自定义Operation对象"></a>自定义Operation对象</h3><p>如果<code>NSInvocationOperation</code>对象和<code>NSBlockOperation</code>对象都不能满足我们的需求，那么我们可以自己写一个类去继承<code>NSOperation</code>，然后实现我们的需求。在实现自定义Operation对象时，分并发执行任务的Operation对象和非并发执行任务的Operation对象。</p>
<h4 id="u81EA_u5B9A_u4E49_u975E_u5E76_u53D1Operation_u5BF9_u8C61"><a href="#u81EA_u5B9A_u4E49_u975E_u5E76_u53D1Operation_u5BF9_u8C61" class="headerlink" title="自定义非并发Operation对象"></a>自定义非并发Operation对象</h4><p>实现非并发Operation对象相对要简单一些，通常，我们最少要实现两个方法：</p>
<ul>
<li>自定义初始化方法：主要用于在初始化自定义Operation对象时传递必要的参数。</li>
<li><code>main</code>方法：该方法就是处理主要任务的地方，你需要执行的任务都在这个方法里。</li>
</ul>
<p>当然除了上面两个必须的方法外，也可以有被<code>main</code>方法调用的私有方法，或者属性的<code>get</code>、<code>set</code>方法。下面以一个网络请求的例子展示如何创建自定义的Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNonconcurrentOperation</span>: <span class="title">NSOperation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(withURL url: <span class="type">String</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.url = url</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> strURL = <span class="keyword">self</span>.url <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">var</span> nsurl = <span class="type">NSURL</span>(string: strURL)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.</span></span><br><span class="line">        <span class="keyword">var</span> session: <span class="type">NSURLSession</span>? = <span class="type">NSURLSession</span>.sharedSession()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.</span></span><br><span class="line">        <span class="keyword">var</span> dataTask: <span class="type">NSURLSessionDataTask</span>? = session!.dataTaskWithURL(nsurl!, completionHandler: &#123; (nsdata, nsurlrespond, nserror) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error = nserror &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"出现异常：<span class="subst">\(error.localizedDescription)</span>"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">let</span> dict = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(nsdata!, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">MutableContainers</span>)</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">print</span>(dict)</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"出现异常"</span>)</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5.</span></span><br><span class="line">        dataTask!.resume()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myNonconcurrentOperation = <span class="type">MyNonconcurrentOperation</span>(withURL: <span class="string">"http://www.baidu.com/s?wd=ios"</span>)</span><br><span class="line">myNonconcurrentOperation.start()</span><br></pre></td></tr></table></figure>
<p>我们创建了自定义的Operation类<code>MyNonconcurrentOperation</code>，让其继承<code>NSOperation</code>，在<code>MyNonconcurrentOperation</code>中可以看到只有两个方法<code>init</code>和<code>main</code>，前者是该类的初始化方法，主要作用是初始化<code>url</code>这个参数，后者包含了任务的主体逻辑代码，我们来分析一下代码：</p>
<ol>
<li>我们在初始化<code>MyNonconcurrentOperation</code>时，传入了我们希望请求的网络地址，改地址正确与否关系着我们这个任务是否还值得继续往下走，所以在<code>main</code>方法一开始先判断一下<code>url</code>的合法性，示例代码中判断的很简单，实际中应该使用正则表达式去判断一下。</li>
<li>将字符串URL转换为<code>NSURL</code>。</li>
<li>创建<code>NSURLSession</code>实例。</li>
<li>调用<code>NSURLSession</code>实例的<code>dataTaskWithURL</code>方法，创建<code>NSURLSessionDataTask</code>类的实例，用于请求网络。在<code>completionHandler</code>的闭包中去判断请求是否成功，返回数据是否正确以及解析数据等操作。</li>
<li>执行<code>NSURLSessionDataTask</code>请求网络。</li>
</ol>
<p>当我们调用<code>MyNonconcurrentOperation</code>的<code>start</code>方法时，就会执行<code>main</code>方法里的逻辑了，这就是一个简单的非并发自定义Operation对象，之所以说它是非并发，因为它一般都在当前线程中执行任务，既如果你在主线程中初始化它，调用它的<code>start</code>方法，那么它就在主线程中执行，如果在二级线程中进行这些操作，那么就在二级线程中执行。</p>
<blockquote>
<p>注：如果在二级线程中使用非并发自定义Operation对象，那么<code>main</code>方法中的内容应该使用<code>autoreleasepool{}</code>包起来。因为如果在二级线程中，没有主线程的自动释放池，一些资源没法被回收，所以需要加一个自动释放池，如果在主线程中就不需要了。</p>
</blockquote>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h4 id="u54CD_u5E94_u53D6_u6D88_u4E8B_u4EF6"><a href="#u54CD_u5E94_u53D6_u6D88_u4E8B_u4EF6" class="headerlink" title="响应取消事件"></a>响应取消事件</h4><p>一般情况下，当Operation对象开始执行时，就会一直执行任务，不会中断执行，但是有时需要在任务执行一半时终止任务，这时就需要Operation对象有响应任务终止命令的能力。理论上，在Operation对象执行任务的任何时间点都可以调用<code>NSOperation</code>类的<code>cancel</code>方法终止任务，那么在我们自定义的Operation对象中如何实现响应任务终止呢？我们看看下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNonconcurrentOperation</span>: <span class="title">NSOperation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(withURL url: <span class="type">String</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.url = url</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> strURL = <span class="keyword">self</span>.url <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> nsurl = <span class="type">NSURL</span>(string: strURL)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> session: <span class="type">NSURLSession</span>? = <span class="type">NSURLSession</span>.sharedSession()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">            </span><br><span class="line">            nsurl = <span class="literal">nil</span></span><br><span class="line">            </span><br><span class="line">            session = <span class="literal">nil</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> dataTask: <span class="type">NSURLSessionDataTask</span>? = session!.dataTaskWithURL(nsurl!, completionHandler: &#123; (nsdata, nsurlrespond, nserror) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error = nserror &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"出现异常：<span class="subst">\(error.localizedDescription)</span>"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 4.</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">                    </span><br><span class="line">                    nsurl = <span class="literal">nil</span></span><br><span class="line">                    </span><br><span class="line">                    session = <span class="literal">nil</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">let</span> dict = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(nsdata!, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">MutableContainers</span>)</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">print</span>(dict)</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"出现异常"</span>)</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">            </span><br><span class="line">            nsurl = <span class="literal">nil</span></span><br><span class="line">            </span><br><span class="line">            session = <span class="literal">nil</span></span><br><span class="line">            </span><br><span class="line">            dataTask = <span class="literal">nil</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dataTask!.resume()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myNonconcurrentOperation = <span class="type">MyNonconcurrentOperation</span>(withURL: <span class="string">"http://www.baidu.com/s?wd=ios"</span>)</span><br><span class="line">myNonconcurrentOperation.start()</span><br><span class="line">myNonconcurrentOperation.cancel()</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看到，在<code>main</code>方法里加了很多对<code>self.cancelled</code>值的判断，没错，这就是响应终止执行任务的关键，因为当调用了<code>NSOperation</code>的<code>cancel</code>方法后，<code>cancelled</code>属性就会被置为<code>flase</code>，当判断到该属性的值为<code>false</code>时，代表当前任务已经被取消，我们只需释放资源返回即可。我们只有在整个任务逻辑代码中尽可以细的去判断<code>cancelled</code>属性，才可以达到较为实时的终止效果。上面代码中我分别在四个地方判断了<code>cancelled</code>属性：</p>
<ol>
<li>在任务开始之前。</li>
<li>任务开始不久，这里刚创建了<code>NSURL</code>和<code>NSURLSession</code>，所以如果判断出任务已被取消，则要释放它们的内存地址。</li>
<li>开始请求网络之前，这里同样要释放已经创建的变量内存地址。</li>
<li>网络请求期间。</li>
</ol>
<h4 id="u81EA_u5B9A_u4E49_u5E76_u53D1Operation_u5BF9_u8C61"><a href="#u81EA_u5B9A_u4E49_u5E76_u53D1Operation_u5BF9_u8C61" class="headerlink" title="自定义并发Operation对象"></a>自定义并发Operation对象</h4><p>自定义并发Operation对象其主要实现的就是让任务在当前线程以外的线程执行，相对于非并发Operation对象注意的事项要更多一些，我们先来看要实现的两个方法：</p>
<ul>
<li><code>init</code>：该方法和非并发Operation对象中的作用一样，用于初始化一些属性。</li>
<li><code>start</code>：该方法是自定义并发Operation对象必须要重写父类的一个方法，通常就在这个方法里创建二级线程，让任务运行在当前线程以外的线程中，从而达到并发异步执行任务的目的，所以这个方法中绝对不能调用父类的<code>start</code>方法。</li>
<li><code>main</code>：该方法在非并发Operation对象中就说过，这里的作用的也是一样的，只不过在并发Operation对象中，该方法并不是必须要实现的方法，因为在<code>start</code>方法中就可以完成所有的事情，包括创建线程，配置执行环境以及任务逻辑，但我还是建议将任务相关的逻辑代码都写在该方法中，让<code>start</code>方法只负责执行环境的设置。</li>
</ul>
<p>除了上述这三个方法以外，还有三个属性需要我们重写，就是<code>NSOperation</code>类中的<code>executing</code>、<code>finished</code>、<code>concurrent</code>三个属性，这三个属性分别表示Operation对象是否在执行，是否执行完成以及是否是并发状态。因为并发异步执行的Operation对象并不会阻塞主线程，所以使用它的对象需要知道它的执行情况和状态，所以这三个状态是必须要设置的，下面来看看示例代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConcurrentOperation</span>: <span class="title">NSOperation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> ifFinished: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> ifExecuting: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> concurrent: <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> finished: <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.ifFinished &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> executing: <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.ifExecuting &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(withURL url: <span class="type">String</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.url = url</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.ifFinished = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.ifExecuting = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.willChangeValueForKey(<span class="string">"finished"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.ifFinished = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.didChangeValueForKey(<span class="string">"finished"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.willChangeValueForKey(<span class="string">"executing"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"main"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.ifExecuting = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.didChangeValueForKey(<span class="string">"executing"</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        autoreleasepool&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> strURL = <span class="keyword">self</span>.url <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> nsurl = <span class="type">NSURL</span>(string: strURL)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> session: <span class="type">NSURLSession</span>? = <span class="type">NSURLSession</span>.sharedSession()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">                </span><br><span class="line">                nsurl = <span class="literal">nil</span></span><br><span class="line">                </span><br><span class="line">                session = <span class="literal">nil</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">self</span>.completeOperation()</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> dataTask: <span class="type">NSURLSessionDataTask</span>? = session!.dataTaskWithURL(nsurl!, completionHandler: &#123; (nsdata, nsurlrespond, nserror) <span class="keyword">in</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> error = nserror &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"出现异常：<span class="subst">\(error.localizedDescription)</span>"</span>)</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">                        </span><br><span class="line">                        nsurl = <span class="literal">nil</span></span><br><span class="line">                        </span><br><span class="line">                        session = <span class="literal">nil</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">self</span>.completeOperation()</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">let</span> dict = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(nsdata!, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">MutableContainers</span>)</span><br><span class="line">                        </span><br><span class="line">                        <span class="built_in">print</span>(dict)</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">self</span>.completeOperation()</span><br><span class="line">                        </span><br><span class="line">                    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">"出现异常"</span>)</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">self</span>.completeOperation()</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">                </span><br><span class="line">                nsurl = <span class="literal">nil</span></span><br><span class="line">                </span><br><span class="line">                session = <span class="literal">nil</span></span><br><span class="line">                </span><br><span class="line">                dataTask = <span class="literal">nil</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">self</span>.completeOperation()</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dataTask!.resume()</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">completeOperation</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.willChangeValueForKey(<span class="string">"finished"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.willChangeValueForKey(<span class="string">"executing"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.ifFinished = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.ifExecuting = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.didChangeValueForKey(<span class="string">"finished"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.didChangeValueForKey(<span class="string">"executing"</span>)</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>NSOperation</code>的<code>finished</code>、<code>executing</code>、<code>concurrent</code>这三个属性都是只读的，我们无法重写它们的<code>setter</code>方法，所以我们只能靠新建的私有属性去重写它们的<code>getter</code>方法。为了自定义的Operation对象更像原生的<code>NSOperation</code>子类，我们需要通过<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>方法手动为<code>ifFinished</code>和<code>ifExecuting</code>这两个属性生成KVO通知，将<code>keyPath</code>设置为原生的<code>finished</code>和<code>executing</code>。</p>
<p>上面的代码示例中有几个关键点：</p>
<ul>
<li>在<code>start</code>方法开始之初就要判断一下Operation对象是否被终止任务。</li>
<li><code>main</code>方法中的内容要放在<code>autoreleasepool</code>中，解决在二级线程中的内存释放问题。</li>
<li>如果判断出Operation对象的任务已经被终止，要及时修改<code>ifFinished</code>和<code>ifExecuting</code>属性。</li>
</ul>
<p>我们可以测试一下这个自定义的Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> myContext = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> myConcurrentOperation = <span class="type">MyConcurrentOperation</span>(withURL: <span class="string">"http://www.baidu.com/s?wd=ios"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        myConcurrentOperation.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"finished"</span>, options: .<span class="type">New</span>, context: &amp;myContext)</span><br><span class="line">        myConcurrentOperation.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"executing"</span>, options: .<span class="type">New</span>, context: &amp;myContext)</span><br><span class="line">        </span><br><span class="line">        myConcurrentOperation.start()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(myConcurrentOperation.executing)</span><br><span class="line">        <span class="built_in">print</span>(myConcurrentOperation.finished)</span><br><span class="line">        <span class="built_in">print</span>(myConcurrentOperation.concurrent)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> change = change <span class="keyword">where</span> context == &amp;myContext &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> keyPath == <span class="string">"finished"</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Finish status has been changed, The new value is <span class="subst">\(change[NSKeyValueChangeNewKey]!)</span>"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> keyPath == <span class="string">"executing"</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Executing status has been changed, The new value is <span class="subst">\(change[NSKeyValueChangeNewKey]!)</span>"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        </span><br><span class="line">        myConcurrentOperation.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"finished"</span>, context: &amp;myContext)</span><br><span class="line">        </span><br><span class="line">        myConcurrentOperation.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"executing"</span>, context: &amp;myContext)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = <span class="type">Test</span>()</span><br><span class="line">test.launch()</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" ]]>
    </summary>
    
      <category term="Concurrency" scheme="http://www.devtalking.com/tags/Concurrency/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Threading Programming Guide 笔记（四）]]></title>
    <link href="http://www.devtalking.com//articles/read-threading-programming-guide-4/"/>
    <id>http://www.devtalking.com//articles/read-threading-programming-guide-4/</id>
    <published>2016-02-21T16:00:00.000Z</published>
    <updated>2016-08-19T01:01:57.000Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/56726" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文章中有对官方文档的翻译，也有自己的理解，官方文档中代码片段的示例在这篇文章中都进行了完整的重写，还有一些文档中没有的代码示例，并且都使用Swift完成，给大家一些Objc与Swift转换的参考。<br>官方文档地址：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></p>
</blockquote>
<h2 id="u914D_u7F6ETimer_u4E8B_u4EF6_u6E90"><a href="#u914D_u7F6ETimer_u4E8B_u4EF6_u6E90" class="headerlink" title="配置Timer事件源"></a>配置Timer事件源</h2><p>配置Timer事件源拢共分几步？很简单，大体只有两步，先创建Timer对象，然后将其添加至Run Loop中。在Cocoa框架和Core Foundation框架中都提供了相关的对象和接口，在Cocoa框架中，它为我们提供了<code>NSTimer</code>类，该类有两个类方法，可以让我们很方便的在当前线程的Run Loop中配置Timer事件源：</p>
<ul>
<li><code>scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</code>：该方法有五个参数分别是执行事件消息时间间隔、接收事件消息的目标对象、事件消息、发送给事件消息的参数、是否重复执行标识。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(<span class="number">0.5</span>, target: <span class="keyword">self</span>, selector: <span class="string">"fireTimer:"</span>, userInfo: <span class="string">"This is a arg"</span>, repeats: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fireTimer</span><span class="params">(sender: NSTimer)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Fire timer...<span class="subst">\(sender.userInfo <span class="keyword">as</span>! String)</span>"</span>)</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>scheduledTimerWithTimeInterval:invocation:repeats:</code>：该方法有三个参数，分别是执行事件消息事件间隔、<code>NSInvocation</code>对象、是否重复执行标识。这里说一下<code>NSInvocation</code>类，该类的作用是静态渲染消息，说的简单粗暴一点，那就是该类表示某个对象中的某个方法，以及该方法的一个或多个参数和返回值,当我们需要发送有多个参数或者有返回值的消息时就可以用这个类。但是在Swift中无法使用这个类，这里就不做过多说明了。</li>
</ul>
<p>以上两个类方法所添加的Timer事件源都只能添加在当前线程的Run Loop中，并且是在默认的Run Loop模式下(<code>NSDefaultRunLoopMode</code>)，如果我们想将Timer事件源添加至其他线程Run Loop的其他模式下，那么就需要创建<code>NSTimer</code>对象，并使用<code>NSRunLoop</code>的<code>addTimer:forMode:</code>方法添加创建好的<code>NSTimer</code>对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomThread</span>: <span class="title">NSThread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> myTimer: <span class="type">NSTimer</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(myTimer: <span class="type">NSTimer</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.myTimer = myTimer</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        autoreleasepool&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> runloop = <span class="type">NSRunLoop</span>.currentRunLoop()</span><br><span class="line">            </span><br><span class="line">            runloop.addTimer(<span class="keyword">self</span>.myTimer, forMode: <span class="type">NSRunLoopCommonModes</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="type">NSThread</span>.isMultiThreaded())</span><br><span class="line">            </span><br><span class="line">            runloop.runUntilDate(<span class="type">NSDate</span>(timeIntervalSinceNow: <span class="number">5</span>))</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">testTimerSource</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> fireTimer = <span class="type">NSDate</span>(timeIntervalSinceNow: <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> myTimer = <span class="type">NSTimer</span>(fireDate: fireTimer, interval: <span class="number">0.5</span>, target: <span class="keyword">self</span>, selector: <span class="string">"timerTask"</span>, userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> customThread = <span class="type">CustomThread</span>(myTimer: myTimer)</span><br><span class="line">        </span><br><span class="line">        customThread.start()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">timerTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Fire timer..."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.testTimerSource()</span><br></pre></td></tr></table></figure>
<p>在Core Foundation框架中，也为我们提供了一系列相关的类和方法为Run Loop添加Timer事件源，我们一起来看看：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">testCFTimerSource</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> cfRunloop = <span class="type">CFRunLoopGetCurrent</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> cfRunloopTimerContext = <span class="type">CFRunLoopTimerContext</span>(version: <span class="number">0</span>, info: <span class="built_in">unsafeBitCast</span>(<span class="keyword">self</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>), retain: <span class="literal">nil</span>, release: <span class="literal">nil</span>, copyDescription: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> cfRunloopTimer = <span class="type">CFRunLoopTimerCreate</span>(kCFAllocatorDefault, <span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>, cfRunloopTimerCallback(), &amp;cfRunloopTimerContext)</span><br><span class="line">        </span><br><span class="line">        <span class="type">CFRunLoopAddTimer</span>(cfRunloop, cfRunloopTimer, kCFRunLoopDefaultMode)</span><br><span class="line">        </span><br><span class="line">        <span class="type">CFRunLoopRun</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">cfRunloopTimerCallback</span><span class="params">()</span></span> -&gt; <span class="type">CFRunLoopTimerCallBack</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123; (cfRunloopTimer, info) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Fire timer..."</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.testCFTimerSource()</span><br></pre></td></tr></table></figure>
<h2 id="u914D_u7F6E_u57FA_u4E8E_u7AEF_u53E3_u7684_u4E8B_u4EF6_u6E90"><a href="#u914D_u7F6E_u57FA_u4E8E_u7AEF_u53E3_u7684_u4E8B_u4EF6_u6E90" class="headerlink" title="配置基于端口的事件源"></a>配置基于端口的事件源</h2><p>Cocoa框架和Core Foundation框架都提供了创建配置基于端口事件源的类和方法，下面我们来看看如何使用Cocoa框架创建基于端口的事件源以及配置使用该类事件源。</p>
<h3 id="u4F7F_u7528NSMachPort_u5BF9_u8C61"><a href="#u4F7F_u7528NSMachPort_u5BF9_u8C61" class="headerlink" title="使用NSMachPort对象"></a>使用NSMachPort对象</h3><p><code>NSMachPort</code>对象是什么呢？其实就是线程与线程之间通信的桥梁，我们创建一个<code>NSMachPort</code>对象，将其添加至主线程的Run Loop中，然后我们在二级线程执行的任务中就可以获取并使用该对象向主线程发送消息，也就是说这种方式是将<code>NSMachPort</code>对象在不同线程中相互传递从而进行消息传递的。</p>
<h4 id="u5728_u4E3B_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort"><a href="#u5728_u4E3B_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort" class="headerlink" title="在主线程中创建配置NSMachPort"></a>在主线程中创建配置NSMachPort</h4><p>因为<code>NSMachPort</code>只能在OS X系统中使用，所以我们需要创建一个OS X应用的工程我们先来看看代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Cocoa</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">NSViewController</span>, <span class="title">NSMachPortDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> printMessageId = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mainThreadPort = <span class="type">NSMachPort</span>()</span><br><span class="line">        </span><br><span class="line">        mainThreadPort.setDelegate(<span class="keyword">self</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSRunLoop</span>.currentRunLoop().addPort(mainThreadPort, forMode: <span class="type">NSDefaultRunLoopMode</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> workerClass = <span class="type">WorkerClass</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"launchThreadWithPort:"</span>, toTarget: workerClass, withObject: mainThreadPort)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: NSPortDelegate Method</span></span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">handlePortMessage</span><span class="params">(message: NSPortMessage)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看到<code>ViewController</code>类遵循了<code>NSMachPortDelegate</code>协议，因为它要作为<code>NSMachPort</code>的代理类，通过<code>NSMachPortDelegate</code>的<code>handlePortMessage:</code>方法处理来自二级线程的消息。</p>
<p>在<code>viewDidLoad</code>方法中我们先是创建了<code>NSMachPort</code>对象的实例，接着设置它的代理，然后使用<code>NSRunLoop</code>的<code>addPort:forMode:</code>方法将创建好的端口对象添加至主线程的Run Loop中，最后通过<code>NSThread</code>的<code>detachNewThreadSelector:toTarget:withObject:</code>方法创建二级线程，并让该二级线程执行<code>WorkerClass</code>类中的<code>launchThreadWithPort:</code>方法，同时将刚才创建好的端口对象作为参数传给该方法，也就是将主线程中的端口对象传到了二级线程中。下面来看看<code>handlePortMessage:</code>中应该如何处理接收到的消息：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">handlePortMessage</span><span class="params">(message: NSPortMessage)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> messageId = message.msgid</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> messageId == <span class="type">UInt32</span>(printMessageId) &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Receive the message that id is 1000 and this is a print task."</span>)</span><br><span class="line">            </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// Handle other messages</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过端口传递的消息可以根据消息编号判断该执行什么样的任务，所以该方法中通过<code>NSPortMessage</code>对象获取到消息id然后进行判断并执行相应的任务，消息id在二级线程通过端口向主线程发送消息时可以设置。</p>
<h4 id="u5728_u4E8C_u7EA7_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort"><a href="#u5728_u4E8C_u7EA7_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort" class="headerlink" title="在二级线程中创建配置NSMachPort"></a>在二级线程中创建配置NSMachPort</h4><p>首先二级线程中与主线程中一样，都需要创建端口对象、设置代理、将端口对象添加至当前线程的Run Loop中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Cocoa</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerClass</span>: <span class="title">NSObject</span>, <span class="title">NSMachPortDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launchThreadWithPort</span><span class="params">(port: NSMachPort)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        autoreleasepool&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> secondaryThreadPort = <span class="type">NSMachPort</span>()</span><br><span class="line">            </span><br><span class="line">            secondaryThreadPort.setDelegate(<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> runloop = <span class="type">NSRunLoop</span>.currentRunLoop()</span><br><span class="line">            </span><br><span class="line">            runloop.addPort(secondaryThreadPort, forMode: <span class="type">NSDefaultRunLoopMode</span>)</span><br><span class="line">            </span><br><span class="line">            sendPrintMessage(port, receivePort: secondaryThreadPort)</span><br><span class="line">            </span><br><span class="line">            runloop.runMode(<span class="type">NSDefaultRunLoopMode</span>, beforeDate: <span class="type">NSDate</span>(timeIntervalSinceNow: <span class="number">500</span>))</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">sendPrintMessage</span><span class="params">(sendPort: NSMachPort, receivePort: NSMachPort)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: NSPortDelegate Method</span></span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">handlePortMessage</span><span class="params">(message: NSPortMessage)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建并配置好端口后就需要向主线程发送消息了，下面我们来看看<code>sendPrintMessage:receivePort:</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sendPrintMessage</span><span class="params">(sendPort: NSMachPort, receivePort: NSMachPort)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> portMessage = <span class="type">NSPortMessage</span>(sendPort: sendPort, receivePort: receivePort, components: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">    portMessage.msgid = <span class="type">UInt32</span>(<span class="number">1000</span>)</span><br><span class="line">        </span><br><span class="line">    portMessage.sendBeforeDate(<span class="type">NSDate</span>(timeIntervalSinceNow: <span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要创建<code>NSPortMessage</code>对象，该对象就是端口之间相互传递的介质，初始化方法的第一个参数为主线程的端口对象，也就是发送消息的目标端口，第二个参数是二级线程的端口对象，第三个参数的作用是向主线程发送需要的数据，该参数的类型是<code>AnyObject</code>的数组。</p>
<p>创建完消息对象后，要给该消息设置消息id，以便主线程接收后进行判断，最后通过<code>sendBeforeDate:</code>方法发送消息。</p>
<h2 id="u7EBF_u7A0B_u5B89_u5168_u673A_u5236"><a href="#u7EBF_u7A0B_u5B89_u5168_u673A_u5236" class="headerlink" title="线程安全机制"></a>线程安全机制</h2><p>在前文中提到过，在应用中使用多线程势必会给增加我们编写代码的工作量，而且会带来一些潜在的问题，最大的问题就是资源竞争的问题，多个线程同时访问资源或者重复更改资源。如果我们足够幸运，这些问题会使应用产生比较明显的异常现象，那我们尚可发现并修复，但是如果这些问题产生的影响不那么明显，或者说只有在应用做一些特定操作才会发生异常，而我们又没测到时就会给我们带来大麻烦。</p>
<p>或许我们可以让每个线程之间都不进行交互，没个线程都有独有资源，从而避免资源竞争问题的发生，但是这并不是长远之计，很多情况下线程之间必须要进行交互，这时我们就需要更好的设计模式或者工具策略来避免这类问题的发生。所幸的是OS X和iOS系统已经提供了多种线程安全的方法，这一节让我们来看看如何使用它们。</p>
<h3 id="u539F_u5B50_u64CD_u4F5C_uFF08Atomic_Operations_uFF09"><a href="#u539F_u5B50_u64CD_u4F5C_uFF08Atomic_Operations_uFF09" class="headerlink" title="原子操作（Atomic Operations）"></a>原子操作（Atomic Operations）</h3><p>原子操作是最简单也是最基本的保证线程安全的方法，原子的本意是<strong>不能被分裂的最小粒子</strong>，故原子操作是<strong>不可被中断的一个或一系列操作</strong>。从处理器角度来说原子操作是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址，从应用层面来说就是当一个线程对共享变量进行操作时，其他线程不能对该变量进行操作，并且其他线程不会被阻塞。</p>
<p>举个简单的例子，有一个共享变量<code>i</code>，初始值是1，现在我们对它进行两次<code>i++</code>的操作，期望值是3，但是在多核CPU的情况下就有可能是CPU1对<code>i</code>进行了一次<code>i++</code>操作，CPU2对<code>i</code>进行了一次<code>i++</code>操作，所以结果就并不是我们期望的值3，而是2，因为CPU1和CPU2同时从各自的缓存中读取变量<code>i</code>，分别进行加一操作，然后分别写入系统内存当中。那么想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。在我们使用原子操作时首先应将变量申明为原子类型（<code>atomic_t</code>），然后根据内核提供的原子操作API对变量进行操作，比如给原子类型的变量<code>v</code>增加值<code>i</code>的函数<code>void atomic_add(int i, atomic_t *v);</code>等。OS X和iOS也提供了一些数学运算和逻辑运算的原子操作供我们使用，这里就不深入说明了，大家如果有兴趣可以去官方文档找找。</p>
<h3 id="u5185_u5B58_u5C4F_u969C_uFF08Memory_Barriers_uFF09_u548C_u53EF_u89C1_u53D8_u91CF_uFF08Volatile_Variables_uFF09"><a href="#u5185_u5B58_u5C4F_u969C_uFF08Memory_Barriers_uFF09_u548C_u53EF_u89C1_u53D8_u91CF_uFF08Volatile_Variables_uFF09" class="headerlink" title="内存屏障（Memory Barriers）和可见变量（Volatile Variables）"></a>内存屏障（Memory Barriers）和可见变量（Volatile Variables）</h3><p>CPU对内存的操作无非就是读和写，我们虽然知道CPU对内存进行了操作，但是我们无法决定在一系列CPU对内存的操作时单个操作指令的顺序，这些顺序完全由CPU随性而来。举个例子，在有两个CPU的情况下，现在有四个指令待操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">A</span> = <span class="number">1</span>; x = <span class="type">A</span>;</span><br><span class="line"><span class="type">B</span> = <span class="number">2</span>; y = <span class="type">B</span>;</span><br></pre></td></tr></table></figure>
<p>这四个指令的执行顺序就可能有24种不同的组合。所以内存屏障就是一个帮助CPU规定操作指令顺序的手段，它将内存操作隔开，给屏障两侧的内存操作强加一个顺序关系，比如所有该屏障之前的写操作和读操作必须在该屏障之后的写操作和读操作之前执行。</p>
<p>可见变量是另一个确保共享变量被多个线程操作后仍能保持正确结果的机制，CPU为了提高处理速度，通常情况下不会直接与主存打交道，而是先将系统主存中的数据读到缓存中，当从缓存中读取到共享变量，对其进行操作后又不会立即写回主存，所以如果其他CPU也要操作该共享变量，就很有可能读到它的旧值。但是当我们在申明共享变量时加上<code>volatile</code>关键字，将其申明为可见变量时就可以避免这种情况，因为CPU从缓存中读取并修改可见共享变量后会立即写回主存，而且其他CPU在操作之前会先判断缓存中的数据是否已过期，如果过期那么从主存中重新缓存，这样一来可见变量在每个CPU操作时都能保证是最新值。但需要注意的是内存屏障和可见变量都会降低编译器的性能，所以没有必须要使用的情况时不要滥用这两个机制。</p>
<h3 id="u9501_u673A_u5236"><a href="#u9501_u673A_u5236" class="headerlink" title="锁机制"></a>锁机制</h3><p>锁机制在大多数编程语言中都是很常用的线程安全机制，你可以在关键的代码前后，或者只希望同时只能被一个线程执行的任务前后加上线程锁来避免因为多线程给程序造成不可预知的问题。OS X和iOS提供了多种锁的类型，下面让我们来看一看：</p>
<ul>
<li>互斥锁（Mutex）：互斥锁扮演的角色就是代码或者说任务的栅栏，它将你希望保护的代码片段围起来，当其他线程也试图执行这段代码时会被互斥锁阻塞，直到互斥锁被释放，如果多个线程同时竞争一个互斥锁，有且只有一个线程可以获得互斥锁。</li>
<li>递归锁（Recursive lock）：递归锁是互斥锁的变种。它允许一个线程在已经拥有一个锁，并且没有释放的前提下再次获得锁。当该线程释放锁时也需要一个一个释放。</li>
<li>读写锁（Read-write lock）：读写锁一般用在有资源被多个线程频繁的进行读操作，而只偶尔会有专职线程对该资源进行写操作的情况下。读写锁可被多个进行读操作的线程获得，但只能被一个进行写操作的线程获得，当有读操作的线程等待时，写操作的线程就不能获得锁，反之亦然，当写操作的线程在等待时，读操作的线程就不能获得锁。</li>
<li>分配锁（Distributed lock）：这种锁作用在进程级别，将进程保护起来，但是该锁不会阻塞其他进程，而是当其他进程与被保护进程交互时分配锁会告知前来的访问进程被访问进程处于锁状态，让前来访问的进程自行决定下一个操作。</li>
<li>自旋锁（Spin lock）：自旋锁与互斥锁有点类似，但不同的是其他线程不会被自旋锁阻塞，而是而是在进程中空转，就是执行一个空的循环。一般用于自旋锁被持有时间较短的情况。</li>
<li>双检测锁（Double-checked lock）：这种锁的目的是为了最大限度推迟上锁的时间，因为在多线程中线程安全对开销还是挺大的，所以一般能不上锁就不上锁。所以这种锁在上锁之前会先检查一次是否需要上锁，在上锁之后再检查一次，最后才真正执行操作。</li>
</ul>
<h3 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h3><p>Conditions是一种多线程间协调通信的机制，它通常用于标明共享资源是否可被访问或者确保一系列任务能按照指定的执行顺序执行。如果一个线程试图访问一个共享资源，而正在访问该资源的线程将其条件设置为不可访问，那么该线程会被阻塞，直到正在访问该资源的线程将访问条件更改为可访问状态或者说给被阻塞的线程发送信号后，被阻塞的线程才能正常访问这个资源。后面会说明如何使用这种机制。</p>
<h2 id="u8BBE_u8BA1_u7EBF_u7A0B_u5B89_u5168_u9700_u8981_u6CE8_u610F_u7684_u4E8B_u9879"><a href="#u8BBE_u8BA1_u7EBF_u7A0B_u5B89_u5168_u9700_u8981_u6CE8_u610F_u7684_u4E8B_u9879" class="headerlink" title="设计线程安全需要注意的事项"></a>设计线程安全需要注意的事项</h2><p>诚然使用线程安全的各种机制可以是我们的程序更加健壮，不易出错，但是因为这些机制本身也会有较大的性能开销，如果滥用这些机制反而会严重影响到程序的性能。所以我们应该在线程安全和性能之间寻求到一个平衡点，这一节我们就来看看在设计线程安全时应该注意的事项。</p>
<h3 id="u907F_u514D_u6EE5_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236"><a href="#u907F_u514D_u6EE5_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236" class="headerlink" title="避免滥用线程安全机制"></a>避免滥用线程安全机制</h3><p>不论是新的项目还是已经有的项目，在设计逻辑代码或者属性时应该避免产生线程安全与不安全的问题。有效的避免措施就是减少逻辑代码之间的交互，或者说任务与任务之间的交互，线程与线程之间的交互，减少多线程中任务访问同一变量的情况，如果需要那么可以确保每个任务中都有该变量的拷贝，这样就可以有效避免对变量或者任务采取线程安全机制。虽然对变量进行拷贝也会消耗资源，但是我们应该要判断一下这与采用线程安全机制消耗的资源之间谁多谁少，从而做出正确的决定。</p>
<h3 id="u8BA4_u6E05_u4F7F_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236_u65F6_u7684_u9677_u9631"><a href="#u8BA4_u6E05_u4F7F_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236_u65F6_u7684_u9677_u9631" class="headerlink" title="认清使用线程安全机制时的陷阱"></a>认清使用线程安全机制时的陷阱</h3><p>在使用锁机制和内存屏障机制时我们往往需要考虑将它们设置在代码的哪个位置是最正确的，但是有些时候，你认为正确的位置不代表它真的正确，下面是一段伪代码片段，向我们揭示一个使用锁机制时容易发生的陷阱。假设有一个可变类型的数组<code>myArray</code>，但是该数组中的对象是不可变类型的对象<code>anObject</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSLock</span>* arrayLock = <span class="type">GetArrayLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">NSMutableArray</span>* myArray = <span class="type">GetSharedArray</span>(); </span><br><span class="line"></span><br><span class="line">id anObject;</span><br><span class="line"></span><br><span class="line">[arrayLock lock]; </span><br><span class="line"></span><br><span class="line">anObject = [myArray objectAtIndex:<span class="number">0</span>]; </span><br><span class="line"></span><br><span class="line">[arrayLock unlock];</span><br><span class="line"></span><br><span class="line">[anObject doSomething];</span><br></pre></td></tr></table></figure>
<p>上述代码片段中，对从<code>myArray</code>数组中获取第一个元素的操作加了锁，因为该数组是可变类型的，所以加锁防止其他线程同时操作该数组从而导致错误发生，又因为<code>anObject</code>是一个不可变类型对象，所以不需要担心其他线程会对其进行改变，所以调用<code>anObject</code>对象的<code>doSomething</code>方法时并没有加锁。</p>
<p>看起来这段代码的逻辑似乎没什么问题，但是凡事都架不住如果和万一，如果在<code>arrayLock</code>释放锁之后和<code>anObject</code>对象调用<code>doSomething</code>方法之前这区间里，另外一个线程清空了<code>myArray</code>里的元素，这时这段代码的结果会怎样呢？答案显然是因为当前类对<code>anObject</code>对象的引用被释放，<code>anObject</code>对象因为指向了错误的内存地址从而调用方法出错。所以为了避免这种小概率事件的发生，应该将<code>anObject</code>对象调用方法的操作也加上锁：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSLock</span>* arrayLock = <span class="type">GetArrayLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">NSMutableArray</span>* myArray = <span class="type">GetSharedArray</span>();</span><br><span class="line"></span><br><span class="line">id anObject;</span><br><span class="line"></span><br><span class="line">[arrayLock lock]; </span><br><span class="line"></span><br><span class="line">anObject = [myArray objectAtIndex:<span class="number">0</span>]; </span><br><span class="line"></span><br><span class="line">[anObject doSomething]; </span><br><span class="line"></span><br><span class="line">[arrayLock unlock];</span><br></pre></td></tr></table></figure>
<p>那么问题又来了，如果<code>doSomething</code>方法执行的时间很长，线程锁一直无法释放，那么又会对线程的性能产生很大影响。要想彻底解决问题，就要找到产生问题的关键点，在这个示例中产生问题的关键点就是<code>anObject</code>对象有可能被其他线程释放，所以解决问题的关键就是防止<code>anObject</code>对象被释放，我们来看看最终的解决方案：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSLock</span>* arrayLock = <span class="type">GetArrayLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">NSMutableArray</span>* myArray = <span class="type">GetSharedArray</span>(); </span><br><span class="line"></span><br><span class="line">id anObject;</span><br><span class="line"></span><br><span class="line">[arrayLock lock];</span><br><span class="line"></span><br><span class="line">anObject = [myArray objectAtIndex:<span class="number">0</span>]; </span><br><span class="line"></span><br><span class="line">[anObject retain]; </span><br><span class="line"></span><br><span class="line">[arrayLock unlock];</span><br><span class="line"></span><br><span class="line">[anObject doSomething]; </span><br><span class="line"></span><br><span class="line">[anObject release];</span><br></pre></td></tr></table></figure>
<h3 id="u9632_u6B62_u6B7B_u9501_u548C_u6D3B_u9501_u7684_u53D1_u751F"><a href="#u9632_u6B62_u6B7B_u9501_u548C_u6D3B_u9501_u7684_u53D1_u751F" class="headerlink" title="防止死锁和活锁的发生"></a>防止死锁和活锁的发生</h3><p>死锁的意思就是线程A和线程B各持有一把锁，现在线程A在等待线程B释放锁，而线程B又在等待线程A释放锁，所以这两个线程谁也拿不到锁，也不是释放自己持有的锁，就会永远被阻塞在进程中。</p>
<p>活锁的意思是线程A可以使用资源，但它很礼貌，让其他线程先使用资源，线程B也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源，导致活锁，活锁与死锁的区别在于前者的线程并没有被阻塞，而是在不停的做一些与任务无关的事。</p>
<p>产生死锁和活锁的根本原因是线程中持有多把锁，所以避免这两种情况发生的最好办法就是尽量让线程只持有一把锁，如果实在有需求要持有多把锁，那么也应该尽量避免其他线程来请求锁。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u6B63_u786E_u4F7F_u7528volatile_u5173_u952E_u5B57"><a href="#u6B63_u786E_u4F7F_u7528volatile_u5173_u952E_u5B57" class="headerlink" title="正确使用volatile关键字"></a>正确使用volatile关键字</h3><p>如果你已经使用的锁机制来保护一段代码逻辑，那么就不要使用<code>volatile</code>关键字来保护这段代码中使用的变量。上文中说过，可见变量机制会让代码每次从主存中加载读取变量而非缓存，本身就比较影响性能，如果再与锁机制结合，不但没有起到额外的保护作用，反而会严重影响程序的性能。所以如果使用了锁机制，那么可以完全省去使用可见变量机制，因为锁机制就已经可以很好的保护变量的线程安全性了，不需要多此一举。</p>
<h2 id="u4F7F_u7528_u539F_u5B50_u64CD_u4F5C"><a href="#u4F7F_u7528_u539F_u5B50_u64CD_u4F5C" class="headerlink" title="使用原子操作"></a>使用原子操作</h2><p>有些时候我们只希望一些数学运算或者简单的逻辑能够保证线程安全，如果使用锁机制或者条件机制虽然可以实现，但是会耗费较大的资源开销，并且锁机制还会使线程阻塞，造成性能损失，非常不划算，所以当遇到这种情况时，我们可以尝试使用原子操作来达到目的。</p>
<p>我们一般使用原子操作对32位和64位的值执行一些数学运算或简单的逻辑运算，主要依靠底层的硬件指令或者使用内存屏障确保正在执行的操作是线程安全的，下面我们来看看Apple给我们提供了哪些原子操作的方法：</p>
<h3 id="Add_u64CD_u4F5C"><a href="#Add_u64CD_u4F5C" class="headerlink" title="Add操作"></a>Add操作</h3><p>Add操作是将两个整数相加，并将结果存储在其中一个变量中：</p>
<ul>
<li><code>OSAtomicAdd32(__theAmount: Int32, _ __theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicAdd32Barrier(__theAmount: Int32, _ __theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicAdd64(__theAmount: Int64, _ __theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
<li><code>OSAtomicAdd64Barrier(__theAmount: Int64, _ __theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="type">Int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="type">OSAtomicAdd64</span>(<span class="number">20</span>, &amp;num)</span><br><span class="line">        </span><br><span class="line"><span class="type">OSAtomicAdd64Barrier</span>(<span class="number">20</span>, &amp;num)</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(num)</span>"</span>) <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<h3 id="Increment_u64CD_u4F5C"><a href="#Increment_u64CD_u4F5C" class="headerlink" title="Increment操作"></a>Increment操作</h3><p>Increment操作将指定值加1：</p>
<ul>
<li><code>OSAtomicIncrement32(__theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicIncrement32Barrier(__theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicIncrement64(__theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
<li><code>OSAtomicIncrement64Barrier(__theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="type">Int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="type">OSAtomicIncrement64</span>(&amp;num)</span><br><span class="line">        </span><br><span class="line"><span class="type">OSAtomicIncrement64Barrier</span>(&amp;num)</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(num)</span>"</span>) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<h3 id="Decrement_u64CD_u4F5C"><a href="#Decrement_u64CD_u4F5C" class="headerlink" title="Decrement操作"></a>Decrement操作</h3><p>Decrement操作将指定值减1:</p>
<ul>
<li><code>OSAtomicDecrement32(__theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicDecrement32Barrier(__theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicDecrement64(__theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
<li><code>OSAtomicDecrement64Barrier(__theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="type">Int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="type">OSAtomicDecrement64</span>(&amp;num)</span><br><span class="line">        </span><br><span class="line"><span class="type">OSAtomicDecrement64Barrier</span>(&amp;num)</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(num)</span>"</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h3 id="OR_u903B_u8F91_u8FD0_u7B97_u3001AND_u903B_u8F91_u8FD0_u7B97_u3001XOR_u903B_u8F91_u8FD0_u7B97"><a href="#OR_u903B_u8F91_u8FD0_u7B97_u3001AND_u903B_u8F91_u8FD0_u7B97_u3001XOR_u903B_u8F91_u8FD0_u7B97" class="headerlink" title="OR逻辑运算、AND逻辑运算、XOR逻辑运算"></a>OR逻辑运算、AND逻辑运算、XOR逻辑运算</h3><p>对两个32位数值中的位置相同的位执行按位比较：</p>
<ul>
<li><code>OSAtomicOr32(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicOr32Barrier(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicAnd32(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicAnd32Barrier(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicXor32(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicXor32Barrier(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
</ul>
<h3 id="CAS_u64CD_u4F5C"><a href="#CAS_u64CD_u4F5C" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>CAS操作是比较与交换（Compare and Swap）操作，有三个参数分别是旧值、新值、想要比较的值的内存地址，整个过程是先将你期望的旧值与指定的内存地址中的值进行比较，如果相同，那么将该内存地址的值更新为指定的新值，并返回<code>true</code>，如果比较后发现不同，那么不再做任何操作，并返回<code>false</code>，Apple提供了不同类型的CAS原子操作：</p>
<ul>
<li><code>OSAtomicCompareAndSwap32(__oldValue: Int32, _ __newValue: Int32, _ __theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicCompareAndSwap64(__oldValue: Int64, _ __newValue: Int64, _ __theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicCompareAndSwapPtr(__oldValue: UnsafeMutablePointer&lt;Void&gt;, _ __newValue: UnsafeMutablePointer&lt;Void&gt;, _ __theValue: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Void&gt;&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicCompareAndSwapLong(__oldValue: Int, _ __newValue: Int, _ __theValue: UnsafeMutablePointer&lt;Int&gt;) -&gt; Bool</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="type">Int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="type">OSAtomicCompareAndSwap64</span>(<span class="number">10</span>, <span class="number">20</span>, &amp;num)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(num)</span>"</span>) <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num: <span class="type">Int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="type">OSAtomicCompareAndSwap64</span>(<span class="number">11</span>, <span class="number">20</span>, &amp;num)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(num)</span>"</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="u6BD4_u7279_u4F4D_u8BBE_u7F6E_u64CD_u4F5C"><a href="#u6BD4_u7279_u4F4D_u8BBE_u7F6E_u64CD_u4F5C" class="headerlink" title="比特位设置操作"></a>比特位设置操作</h3><p>将给定比特位的值设置位1或者0:</p>
<ul>
<li><code>OSAtomicTestAndSet(__n: UInt32, _ __theAddress: UnsafeMutablePointer&lt;Void&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicTestAndSetBarrier(__n: UInt32, _ __theAddress: UnsafeMutablePointer&lt;Void&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicTestAndClear(__n: UInt32, _ __theAddress: UnsafeMutablePointer&lt;Void&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicTestAndClearBarrier(__n: UInt32, _ __theAddress: UnsafeMutablePointer&lt;Void&gt;) -&gt; Bool</code></li>
</ul>
<h2 id="u4F7F_u7528_u9501_u673A_u5236"><a href="#u4F7F_u7528_u9501_u673A_u5236" class="headerlink" title="使用锁机制"></a>使用锁机制</h2><p>锁机制是多线程编程中最常用的也是最基本的确保线程安全的机制，它能有效的保证多行逻辑代码的线程安全性。OS X和iOS系统为我们提供了基本的互斥锁和基于互斥锁变异的特殊锁以应对不同的情况。这一节我们来看看如何使用锁机制。</p>
<h3 id="POSIX_u4E92_u65A5_u9501"><a href="#POSIX_u4E92_u65A5_u9501" class="headerlink" title="POSIX互斥锁"></a>POSIX互斥锁</h3><p>前文中说过，POSIX是可移植操作系统接口（Portable Operating System Interface of UNIX），它定义了操作系统应该为应用程序提供的接口标准，在类Unix系统中都可以使用。使用POSIX互斥锁很简单，先申明互斥锁指针，类型为<code>UnsafeMutablePointer&lt;pthread_mutex_t&gt;</code>，然后通过<code>pthread_mutex_init</code>函数初始化互斥锁，最后通过<code>pthread_mutex_lock</code>函数和<code>pthread_mutex_unlock</code>函数上锁和释放锁：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> mutex: <span class="type">UnsafeMutablePointer</span>&lt;pthread_mutex_t&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        mutex = <span class="type">UnsafeMutablePointer</span>.alloc(<span class="built_in">sizeof</span>(pthread_mutex_t))</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">posixMutexLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_init(mutex, <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(mutex)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Do work..."</span>)</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_unlock(mutex)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textLock = <span class="type">TestLock</span>()</span><br><span class="line">textLock.posixMutexLock()</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528NSLock"><a href="#u4F7F_u7528NSLock" class="headerlink" title="使用NSLock"></a>使用NSLock</h3><p>在Cocoa框架中，我们可以使用<code>NSLock</code>来实现锁机制，该类遵循了<code>NSLocking</code>协议，并实现了加锁和释放锁的方法。</p>
<p>在<code>NSLock</code>中有两个加锁的方法：</p>
<ul>
<li><code>tryLock</code>：该方法使当前线程试图去获取锁，并返回布尔值表示是否成功，但是当获取锁失败后并不会使当前线程阻塞。</li>
<li><code>lockBeforeDate</code>：该方法与上面的方法类似，但是只有在设置的时间内获取锁失败线程才不会被阻塞，如果获取锁失败时已超出了设置的时间，那么当前线程会被阻塞。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> nslock: <span class="type">NSLock</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        nslock = <span class="type">NSLock</span>()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">acquireLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        nslock.tryLock()</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        nslock.lockBeforeDate(NSDate(timeIntervalSinceNow: 10))</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Do work..."</span>)</span><br><span class="line">        </span><br><span class="line">        nslock.unlock()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textLock = <span class="type">TestLock</span>()</span><br><span class="line">textLock.acquireLock()</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528NSRecursiveLock"><a href="#u4F7F_u7528NSRecursiveLock" class="headerlink" title="使用NSRecursiveLock"></a>使用NSRecursiveLock</h3><p>上文中介绍了几种锁的类型，其中一种叫递归锁，在Cocoa中对应的类是<code>NSRecursiveLock</code>，我们来看看如何使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> nsRecursiveLock: <span class="type">NSRecursiveLock</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        nsRecursiveLock = <span class="type">NSRecursiveLock</span>()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">recursiveFunction</span><span class="params">(<span class="keyword">var</span> value: Int)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        nsRecursiveLock.lock()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> value != <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">            --value</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(value)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            recursiveFunction(value)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        nsRecursiveLock.unlock()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textLock = <span class="type">TestLock</span>()</span><br><span class="line">textLock.recursiveFunction(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528NSConditionLock"><a href="#u4F7F_u7528NSConditionLock" class="headerlink" title="使用NSConditionLock"></a>使用NSConditionLock</h3><p>条件锁也是互斥锁的一种变种，在Cocoa框架中对应的类是<code>NSConditionLock</code>，条件锁顾名思义可以设置加锁和释放锁的条件。假设我们有一个消息队列，并且有消息生产者和消息消费者，那么一般情况是当消息生产者产生消息，放入消息队列，然后消息消费者从消息队列中获取消息，并将其从消息队列移除进行后续操作。那么消费者在获取消息和移除消息时要确保两点先决条件，第一就是获取消息时队列中确实已有消息，第二就是此时生产者不能向队列中添加消息，否则会影响消息队列中消息的顺序或者影响获取到消息的结果，所以在这种情况下我们就可以使用条件锁来保证他们的线程安全：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> nsConditionLock: <span class="type">NSConditionLock</span></span><br><span class="line">    <span class="keyword">var</span> messageQueue = [<span class="type">AnyObject</span>]()</span><br><span class="line">    <span class="keyword">let</span> <span class="type">HAS_MESSAGES</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="type">NO_MESSAGES</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        nsConditionLock = <span class="type">NSConditionLock</span>(condition: <span class="type">NO_MESSAGES</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">produceMessage</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"consumeMessage"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">            </span><br><span class="line">            nsConditionLock.lock()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 生产消息并添加到消息队列中</span></span><br><span class="line">            </span><br><span class="line">            nsConditionLock.unlockWithCondition(<span class="type">HAS_MESSAGES</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">consumeMessage</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">            </span><br><span class="line">            nsConditionLock.lockWhenCondition(<span class="type">HAS_MESSAGES</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从消息队列中获取消息并从队列中移除消息</span></span><br><span class="line">            </span><br><span class="line">            nsConditionLock.unlockWithCondition(messageQueue.isEmpty ? <span class="type">NO_MESSAGES</span> : <span class="type">HAS_MESSAGES</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textLock = <span class="type">TestLock</span>()</span><br><span class="line">textLock.produceMessage()</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528@synchronized_u5173_u952E_u5B57"><a href="#u4F7F_u7528@synchronized_u5173_u952E_u5B57" class="headerlink" title="使用@synchronized关键字"></a>使用@synchronized关键字</h3><p>在Objective-C中，我们会经常使用<code>@synchronized</code>关键字来修饰变量，确保变量的线程安全，它能自动为修饰的变量创建互斥锁或解锁：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">- (void)myMethod:(id)anObj &#123; </span><br><span class="line"></span><br><span class="line">    @synchronized(anObj) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在该作用域中，anObj不会被其他线程改变 </span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码片段中可以看到<code>myMethod:</code>方法的<code>anObj</code>参数在被<code>@synchronized</code>关键字修饰的作用域中是线程安全的。而且使用该关键字还有一个好处，那就是当有多个线程要同时执行一个带参数的方法，但不同线程中传递的参数不同，如果用<code>NSLock</code>将该方法中的逻辑代码上锁，那么就只能有一个线程获得锁，而其他线程就会被阻塞，如果使用<code>@synchronized</code>关键字就可以避免其他线程被阻塞的情况。</p>
<p>但在Swift中，Apple不知出于什么考虑，这个关键字已经不存在了，也就是我们不能在Swift中使用这个关键字对变量加锁了，但关键字都是语法糖，虽然不能使用语法糖，但还是可以使用其背后的机制的，我们来看看objc_sync的源码，看看这个关键字都干了些什么：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Begin synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Allocates recursive mutex associated with 'obj' if needed.</span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line">int objc_sync_enter(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = <span class="type">OBJC_SYNC_SUCCESS</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="type">SyncData</span>* data = id2data(obj, <span class="type">ACQUIRE</span>);</span><br><span class="line">        <span class="built_in">assert</span>(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">DebugNilSync</span>) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// End synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line">int objc_sync_exit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = <span class="type">OBJC_SYNC_SUCCESS</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="type">SyncData</span>* data = id2data(obj, <span class="type">RELEASE</span>); </span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = <span class="type">OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bool okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = <span class="type">OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见<code>@synchronized</code>关键字其实是调用了<code>objc_sync_enter</code>和<code>objc_sync_exit</code>这两个方法，所以在Swift中使用时可以这样给变量加锁：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">(anObj: AnyObject!)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    objc_sync_enter(anObj)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// anObj参数在这两个方法之间具有线程安全特性，不会被其他线程改变</span></span><br><span class="line"></span><br><span class="line">    objc_sync_exit(anObj)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4F7F_u7528Condition_u673A_u5236"><a href="#u4F7F_u7528Condition_u673A_u5236" class="headerlink" title="使用Condition机制"></a>使用Condition机制</h2><p>Condition机制和锁机制很类似，区别也不大，同样都会使线程阻塞，这一节我们来看看如何使用该机制。</p>
<h3 id="u4F7F_u7528NSCondition_u7C7B"><a href="#u4F7F_u7528NSCondition_u7C7B" class="headerlink" title="使用NSCondition类"></a>使用NSCondition类</h3><p>这里举个生产者和消费者的例子，消费者从队列中获取产品进行消费，当队列中没有产品时消费者等待生产者生产，当生产者生产出产品放入队列后再通知消费者继续进行消费：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> products: [<span class="type">AnyObject</span>]</span><br><span class="line">    <span class="keyword">let</span> nscondition: <span class="type">NSCondition</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        products = [<span class="type">AnyObject</span>]()</span><br><span class="line">        </span><br><span class="line">        nscondition = <span class="type">NSCondition</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"consumeProduct"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"generateProduct"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">consumeProduct</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        nscondition.lock()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> products.<span class="built_in">count</span> == <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            nscondition.wait()</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> product = products[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        products.removeAtIndex(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"消费产品"</span>)</span><br><span class="line">        </span><br><span class="line">        nscondition.unlock()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">generateProduct</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        nscondition.lock()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> product = <span class="type">NSObject</span>()</span><br><span class="line">        </span><br><span class="line">        products.append(product)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"生产产品"</span>)</span><br><span class="line">        </span><br><span class="line">        nscondition.signal()</span><br><span class="line">        </span><br><span class="line">        nscondition.unlock()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码中可以看到，<code>NSCondition</code>类同样是用<code>lock</code>和<code>unlock</code>方法进行上锁和释放锁，然后通过<code>wait</code>方法阻塞线程，通过<code>signal</code>方法唤醒阻塞的线程，该方法唤醒的时最近一次使用<code>wait</code>方法等待的线程。如果想一次性唤醒所有在等待的线程，可以使用<code>broadcast</code>方法。<code>NSCondition</code>还有另外一个阻塞线程的方法<code>waitUntilDate(_ limit: NSDate)</code>，该方法设置一个线程阻塞时间并返回一个布尔值，如果在指定的时间内没有信号量的通知，那么就唤醒线程继续进行，此时该方法返回<code>false</code>，如果在指定时间内接收到信号量的通知，此时该方法返回<code>true</code>。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" ]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="Thread" scheme="http://www.devtalking.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Threading Programming Guide 笔记（三）]]></title>
    <link href="http://www.devtalking.com//articles/read-threading-programming-guide-3/"/>
    <id>http://www.devtalking.com//articles/read-threading-programming-guide-3/</id>
    <published>2016-02-17T16:00:00.000Z</published>
    <updated>2016-08-19T01:01:35.000Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/56056" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文章中有对官方文档的翻译，也有自己的理解，官方文档中代码片段的示例在这篇文章中都进行了完整的重写，还有一些文档中没有的代码示例，并且都使用Swift完成，给大家一些Objc与Swift转换的参考。<br>官方文档地址：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></p>
</blockquote>
<h2 id="u4F55_u65F6_u4F7F_u7528Run_Loop"><a href="#u4F55_u65F6_u4F7F_u7528Run_Loop" class="headerlink" title="何时使用Run Loop"></a>何时使用Run Loop</h2><p>前文中多次提到过，在主线程中Run Loop是随着应用程序一起启动的，也就是说当我们打开一个应用时，主线程中的Run Loop就已经启动了，尤其现在我们都使用Xcode中的项目模版创建项目，更是不用考虑主线程中Run Loop的状体。所以只有在二级线程中，也就是我们自己创建的线程中才有机会手动的创建的Run Loop，并对其进行配置的操作。</p>
<p>在前文中还提到过，Run Loop在线程中的主要作用就是帮助线程常驻在进程中，并且不会过多消耗资源。所以说Run Loop在二级线程中也不是必须需要的，要根据该线程执行的任务类型以及在整个应用中担任何作用而决定是否需要使用Run Loop。比如说，如果你创建一个二级线程只是为了执行一个不会频繁执行的一次性任务，或者需要执行很长时间的任务，那么可能就不需要使用Run Loop了。如果你需要一个线程执行周期性的定时任务，或者需要较为频繁的与主线程之间进行交互，那么就需要使用Run Loop。归纳一下需要使用Run Loop的情况大概有以下四点：</p>
<ul>
<li>通过基于端口或自定义的数据源与其他线程进行交互。</li>
<li>在线程中执行定时事件源的任务。</li>
<li>使用Cocoa框架提供的<code>performSelector…</code>系列方法。</li>
<li>在线程中执行较为频繁的，具有周期性的任务。</li>
</ul>
<p>光说不练假把式，下面就让我们来看看如何具体创建、配置、操作Run Loop。</p>
<h2 id="Run_Loop_u5BF9_u8C61"><a href="#Run_Loop_u5BF9_u8C61" class="headerlink" title="Run Loop对象"></a>Run Loop对象</h2><p>要想操作配置Run Loop，那自然需要通过Run Loop对象来完成，它提供了一系列接口，可帮助我们便捷的添加Input sources、timers以及观察者。较高级别的Cocoa框架提供了<code>NSRunLoop</code>类，较底层级别的Core Foundation框架提供了指向<code>CFRunloopRef</code>的指针。</p>
<h3 id="u83B7_u53D6Run_Loop_u5BF9_u8C61"><a href="#u83B7_u53D6Run_Loop_u5BF9_u8C61" class="headerlink" title="获取Run Loop对象"></a>获取Run Loop对象</h3><p>前文中提到过，在Cocoa和Core Foundation框架中都没有提供创建Run Loop的方法，只有从当前线程获取Run Loop的方法：</p>
<ul>
<li>在Cocoa框架中，<code>NSRunLoop</code>类提供了类方法<code>currentRunLoop()</code>获取<code>NSRunLoop</code>对象。<br>> 该方法是获取当前线程中已存在的Run Loop，如果不存在，那其实还是会创建一个Run Loop对象返回，只是Cocoa框架没有向我们暴露该接口。</li>
<li>在Core Foundation框架中提供了<code>CFRunLoopGetCurrent()</code>函数获取<code>CFRunLoop</code>对象。</li>
</ul>
<p>虽然这两个Run Loop对象并不完全等价，它们之间还是可以转换的，我们可以通过<code>NSRunLoop</code>对象提供的<code>getCFRunLoop()</code>方法获取<code>CFRunLoop</code>对象。因为<code>NSRunLoop</code>和<code>CFRunLoop</code>指向的都是当前线程中同一个Run Loop，所以在使用时它们可以混用，比如说要给Run Loop添加观察者时就必须得用<code>CFRunLoop</code>了。</p>
<h3 id="u914D_u7F6ERun_Loop_u89C2_u5BDF_u8005"><a href="#u914D_u7F6ERun_Loop_u89C2_u5BDF_u8005" class="headerlink" title="配置Run Loop观察者"></a>配置Run Loop观察者</h3><p>前文中提到过，可以向Run Loop中添加各种事件源和观察者，这里事件源是必填项，也就是说Run Loop中至少要有一种事件源，不论是Input source还是timer，如果Run Loop中没有事件源的话，那么在启动Run Loop后就会立即退出。而观察者是可选项，如果没有监控Run Loop各运行状态的需求，可以不配置观察者，这一节先看看如何向Run Loop中添加观察者。</p>
<p>在Cocoa框架中，并没有提供创建配置Run Loop观察者的相关接口，所以我们只能通过Core Foundation框架中提供的对象和方法创建并配置Run Loop观察者，下面我们看看示例代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"createAndConfigObserverInSecondaryThread"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="type">NSThread</span>.isMultiThreaded())</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">createAndConfigObserverInSecondaryThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        autoreleasepool&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">let</span> runloop = <span class="type">NSRunLoop</span>.currentRunLoop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">var</span> _self = <span class="keyword">self</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">var</span> observerContext = <span class="type">CFRunLoopObserverContext</span>(version: <span class="number">0</span>, info: &amp;_self, retain: <span class="literal">nil</span>, release: <span class="literal">nil</span>, copyDescription: <span class="literal">nil</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">let</span> observer = <span class="type">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, <span class="type">CFRunLoopActivity</span>.<span class="type">AllActivities</span>.rawValue, <span class="literal">true</span>, <span class="number">0</span>, <span class="keyword">self</span>.observerCallbackFunc(), &amp;observerContext)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(observer != <span class="literal">nil</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 5</span></span><br><span class="line">                <span class="keyword">let</span> cfRunloop = runloop.getCFRunLoop()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 6</span></span><br><span class="line">                <span class="type">CFRunLoopAddObserver</span>(cfRunloop, observer, kCFRunLoopDefaultMode)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 7</span></span><br><span class="line">            <span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(<span class="number">0.5</span>, target: <span class="keyword">self</span>, selector: <span class="string">"fireTimer"</span>, userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> loopCount = <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">repeat</span> &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 8</span></span><br><span class="line">                runloop.runUntilDate(<span class="type">NSDate</span>(timeIntervalSinceNow: <span class="number">1</span>))</span><br><span class="line">                </span><br><span class="line">                loopCount--</span><br><span class="line">            </span><br><span class="line">            &#125; <span class="keyword">while</span>(loopCount &gt; <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">observerCallbackFunc</span><span class="params">()</span></span> -&gt; <span class="type">CFRunLoopObserverCallBack</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;(observer, activity, context) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">switch</span>(activity) &#123;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">Entry</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop已经启动"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">BeforeTimers</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop分配定时任务前"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">BeforeSources</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop分配输入事件源前"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">BeforeWaiting</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop休眠前"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">AfterWaiting</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop休眠后"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">Exit</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop退出后"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">fireTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>下面解读一下上述代码示例，<code>launch()</code>方法在主线程中，通过<code>NSThread</code>类的类方法<code>detachNewThreadSelector:toTarget:withObject:</code>创建并启动一个二级线程，将<code>createAndConfigObserverInSecondaryThread()</code>方法作为事件消息传入该二级线程，这个方法的主要作用就是在二级线程中创建配置Run Loop观察者并启动Run Loop，然后让主线程持续3秒，以便二级线程有足够的时间执行任务。</p>
<p>在<code>createAndConfigObserverInSecondaryThread()</code>中共有8个关键步骤，下面一一进行说明：</p>
<ul>
<li><strong>第一步</strong>：通过<code>NSRunLoop</code>类的类方法<code>currentRunLoop()</code>获取当前线程的Run Loop，这里获取到的Run Loop对象是<code>NSRunLoop</code>对象。</li>
<li><strong>第二步</strong>：申明当前对象的变量，至于为什么要这么做，在下一步中会有说明。</li>
<li><strong>第三步</strong>：通过Core Foundation框架的<code>CFRunLoopObserverContext</code>结构体构造Run Loop观察者上下文，大家需要注意前两个参数，我们先看看这个结构体：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">CFRunLoopObserverContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> version: <span class="type">CFIndex</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> info: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> retain: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;)!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> release: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> copyDescription: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!)!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(version: <span class="type">CFIndex</span>, info: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, retain: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;)!, release: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)!, copyDescription: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!)!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>version</code>：结构体版本号，必须设置为0。</li>
<li><code>info</code>：上下文中<code>retain</code>、<code>release</code>、<code>copyDescription</code>三个回调函数以及Run Loop观察者的回调函数所有者对象的指针。在Swift中，<code>UnsafePointer</code>结构体代表C系语言中申明为常量的指针，<code>UnsafeMutablePoinger</code>结构体代表C系语言中申明为非常量的指针，比如说：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">C</span>:</span><br><span class="line">void functionWithConstArg(const int *constIntPointer);</span><br><span class="line"></span><br><span class="line"><span class="type">Swift</span>:</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">functionWithConstArg</span><span class="params">(constIntPointer: UnsafePointer&lt;Int32&gt;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">C</span>:</span><br><span class="line">void functionWithNotConstArg(unsigned int *unsignedIntPointer);</span><br><span class="line"></span><br><span class="line"><span class="type">Swift</span>:</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">functionWithNotConstArg</span><span class="params">(unsignedIntPointer: UnsafeMutablePointer&lt;UInt32&gt;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">C</span>:</span><br><span class="line">void functionWithNoReturnArg(void *voidPointer);</span><br><span class="line"></span><br><span class="line"><span class="type">Swift</span>:</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">functionWithNoReturnArg</span><span class="params">(voidPointer: UnsafeMutablePointer&lt;Void&gt;)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>第四步</strong>：通过Core Foundation框架的<code>CFRunLoopObserverCreate</code>函数创建<code>CFRunLoopObserver</code>对象：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopObserverCreate</span><span class="params">(allocator: CFAllocator!, <span class="number">_</span> activities: CFOptionFlags, <span class="number">_</span> repeats: Bool, <span class="number">_</span> order: CFIndex, <span class="number">_</span> callout: CFRunLoopObserverCallBack!, <span class="number">_</span> context: UnsafeMutablePointer&lt;CFRunLoopObserverContext&gt;)</span></span> -&gt; <span class="type">CFRunLoopObserver</span>!</span><br></pre></td></tr></table></figure>
<ol>
<li><code>allocator</code>：该参数为对象内存分配器，一般使用默认的分配器<code>kCFAllocatorDefault</code>。</li>
<li><code>activities</code>：该参数配置观察者监听Run Loop的哪种运行状态。在示例中，我们让观察者监听Run Loop的所有运行状态。</li>
<li><code>repeats</code>：该参数标识观察者只监听一次还是每次Run Loop运行时都监听。</li>
<li><code>order</code>：观察者优先级，当Run Loop中有多个观察者监听同一个运行状态时，那么就根据该优先级判断，0为最高优先级别。</li>
<li><code>callout</code>：观察者的回调函数，在Core Foundation框架中用<code>CFRunLoopObserverCallBack</code>重定义了回调函数的闭包。</li>
<li><code>context</code>：观察者的上下文。</li>
</ol>
<ul>
<li><strong>第五步</strong>：因为<code>NSRunLoop</code>没有提供操作观察者的接口，所以我们需要<code>getCFRunLoop()</code>方法获取到<code>CFRunLoop</code>对象。</li>
<li><strong>第六步</strong>：通过<code>CFRunLoopAddObserver</code>函数向当前线程的Run Loop中添加创建好的观察者：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopAddObserver</span><span class="params">(<span class="number">_</span> rl: CFRunLoop!, <span class="number">_</span> observer: CFRunLoopObserver!, <span class="number">_</span> mode: CFString!)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>rl</code>：当前线程的<code>CFRunLoop</code>对象。</li>
<li><code>observer</code>：创建好的观察者。</li>
<li><code>mode</code>：设置将观察者添加到哪个Run Loop模式中。</li>
</ol>
<blockquote>
<p>这里需要注意的是，一个观察者只能被添加到一个Run Loop中，但是可以被添加到Run Loop中的多个模式中。</p>
</blockquote>
<ul>
<li><strong>第七步</strong>：通过Timer事件源向当前线程发送重复执行的定时任务，时间间隔为0.5秒，因为只是为了测试观察者，所以<code>fireTimer()</code>是一个空任务。另外前文中提到过，如果Run Loop中没有任何数据源，那么Run Loop启动后会立即退出，所以大家可以把这行注释了运行看看会有什么效果。</li>
<li><strong>第八步</strong>：通过<code>NSRunLoop</code>对象的<code>runUntilDate(limitDate: NSDate)</code>方法启动Run Loop，设置Run Loop的运行时长为1秒。这里将其放在一个循环里，最大循环次数为10次，也就是说，如果不考虑主线程的运行时间，该二级线程的Run Loop可运行10次。</li>
</ul>
<p>再来看看观察者的回调方法<code>observerCallbackFunc()</code>，上面在介绍<code>CFRunLoopObserverCreate</code>函数时提到观察者的回调函数是<code>CFRunLoopObserverCallBack</code>重定义的一个闭包，我们来看看这个闭包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">CFRunLoopObserverCallBack</span> = (<span class="type">CFRunLoopObserver</span>!, <span class="type">CFRunLoopActivity</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span></span><br></pre></td></tr></table></figure>
<p>这个闭包没有返回值，第一个参数是触发监听的观察者，第二个参数是观察者监听的Run Loop运行状态，第三个参数是观察者的运行上下文环境。所以在回调方法中，我们只需要根据第二个参数的值即可判断观察者监听到的Run Loop状态。大家可以拷贝上面的代码，建一个Command Application运行看看结果。</p>
<h3 id="u542F_u52A8Run_Loop"><a href="#u542F_u52A8Run_Loop" class="headerlink" title="启动Run Loop"></a>启动Run Loop</h3><p>在启动Run Loop前务必要保证已添加一种类型的事件源，原因在前文中已提到多次。在Cocoa框架和Core Foundation框架中启动Run Loop大体有三种形式，分别是无条件启动、设置时间限制启动、指定特定模式启动。</p>
<h4 id="u65E0_u6761_u4EF6_u542F_u52A8"><a href="#u65E0_u6761_u4EF6_u542F_u52A8" class="headerlink" title="无条件启动"></a>无条件启动</h4><p><code>NSRunLoop</code>对象的<code>run()</code>方法和Core Foundation框架中的<code>CFRunLoopRun()</code>函数都是无条件启动Run Loop的方式。这种方式虽然是最简单的启动方式，但也是最不推荐使用的一个方式，因为这种方式将Run Loop置于一个永久运行并且不可控的状态，它使Run Loop只能在默认模式下运行，无法给Run Loop设置特定的或自定义的模式，而且以这种模式启动的Run Loop只能通过<code>CFRunLoopStop(_ rl: CFRunLoop!)</code>函数强制停止。</p>
<h4 id="u8BBE_u7F6E_u65F6_u95F4_u9650_u5236_u542F_u52A8"><a href="#u8BBE_u7F6E_u65F6_u95F4_u9650_u5236_u542F_u52A8" class="headerlink" title="设置时间限制启动"></a>设置时间限制启动</h4><p>该方式对应的方法是<code>NSRunLoop</code>对象的<code>runUntilDate(_ limitDate: NSDate)</code>方法，在启动Run Loop时设置超时时间，一旦超时那么Run Loop则自动退出。该方法的好处是可以在循环中反复启动Run Loop处理相关任务，而且可控制运行时长。</p>
<h4 id="u6307_u5B9A_u7279_u5B9A_u6A21_u5F0F_u542F_u52A8"><a href="#u6307_u5B9A_u7279_u5B9A_u6A21_u5F0F_u542F_u52A8" class="headerlink" title="指定特定模式启动"></a>指定特定模式启动</h4><p>该方式对应的方法是<code>NSRunLoop</code>对象的<code>runMode(_ mode: String, beforeDate limitDate: NSDate)</code>方法和Core Foundation框架的<code>CFRunLoopRunInMode(_ mode: CFString!, _ seconds: CFTimeInterval, _ returnAfterSourceHandled: Bool)</code>函数。前者有两个参数，第一个参数是Run Loop模式，第二个参数仍然是超时时间，该方法使Run Loop只处理指定模式中的事件源事件，当处理完事件或超时Run Loop会退出，该方法的返回值类型是<code>Bool</code>，如果返回<code>true</code>则表示Run Loop启动成功，并分派执行了任务或者达到超时时间，若返回<code>false</code>则表示Run Loop启动失败。后者有三个参数，前两个参数的作用一样，第三个参数的意思是Run Loop是否在执行完任务后就退出，如果设置为<code>false</code>，那么代表Run Loop在执行完任务后不退出，而是一直等到超时后才退出。该方法返回Run Loop的退出状态：</p>
<ul>
<li><code>CFRunLoopRunResult.Finished</code>：表示Run Loop已分派执行完任务，并且再无任务执行的情况下退出。</li>
<li><code>CFRunLoopRunResult.Stopped</code>：表示Run Loop通过<code>CFRunLoopStop(_ rl: CFRunLoop!)</code>函数强制退出。</li>
<li><code>CFRunLoopRunResult.TimedOut</code>：表示Run Loop因为超时时间到而退出。</li>
<li><code>CFRunLoopRunResult.HandledSource</code>：表示Run Loop已执行完任务而退出，改状态只有在<code>returnAfterSourceHandled</code>设置为<code>true</code>时才会出现。</li>
</ul>
<h3 id="u9000_u51FARun_Loop"><a href="#u9000_u51FARun_Loop" class="headerlink" title="退出Run Loop"></a>退出Run Loop</h3><p>退出Run Loop的方式总体来说有三种：</p>
<ul>
<li>启动Run Loop时设置超时时间。</li>
<li>强制退出Run Loop。</li>
<li>移除Run Loop中的事件源，从而使Run Loop退出。</li>
</ul>
<p>第一种方式是推荐使用的方式，因为可以给Run Loop设置可控的运行时间，让它执行完所有的任务以及给观察者发送通知。第二种强制退出Run Loop主要是应对无条件启动Run Loop的情况。第三种方式是最不推荐的方式，虽然在理论上说当Run Loop中没有任何数据源时会立即退出，但是在实际情况中我们创建的二级线程除了执行我们指定的任务外，有可能系统还会让其执行一些系统层面的任务，而且这些任务我们一般无法知晓，所以用这种方式退出Run Loop往往会存在延迟退出。</p>
<h3 id="Run_Loop_u5BF9_u8C61_u7684_u7EBF_u7A0B_u5B89_u5168_u6027"><a href="#Run_Loop_u5BF9_u8C61_u7684_u7EBF_u7A0B_u5B89_u5168_u6027" class="headerlink" title="Run Loop对象的线程安全性"></a>Run Loop对象的线程安全性</h3><p>Run Loop对象的线程安全性取决于我们使用哪种API去操作。Core Foundation框架中的<code>CFRunLoop</code>对象是线程安全的，我们可以在任何线程中使用。Cocoa框架的<code>NSRunLoop</code>对象是线程不安全的，我们必须在拥有Run Loop的当前线程中操作Run Loop，如果操作了不属于当前线程的Run loop，会导致异常和各种潜在的问题发生。</p>
<h2 id="u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90"><a href="#u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90" class="headerlink" title="自定义Run Loop事件源"></a>自定义Run Loop事件源</h2><p>Cocoa框架因为是较为高层的框架，所以没有提供操作较为底层的Run Loop事件源相关的接口和对象，所以我们只能使用Core Foundation框架中的对象和函数创建事件源并给Run Loop设置事件源。</p>
<h3 id="u521B_u5EFARun_Loop_u4E8B_u4EF6_u6E90_u5BF9_u8C61"><a href="#u521B_u5EFARun_Loop_u4E8B_u4EF6_u6E90_u5BF9_u8C61" class="headerlink" title="创建Run Loop事件源对象"></a>创建Run Loop事件源对象</h3><p>我们定义自己的Run Loop事件源首先就是需要创建事件源，我们来看看创建事件源的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopSourceCreate</span><span class="params">(<span class="number">_</span> allocator: CFAllocator!, <span class="number">_</span> order: CFIndex, <span class="number">_</span> context: UnsafeMutablePointer&lt;CFRunLoopSourceContext&gt;)</span></span> -&gt; <span class="type">CFRunLoopSource</span>!</span><br></pre></td></tr></table></figure>
<ol>
<li><code>allocator</code>：该参数为对象内存分配器，一般使用默认的分配器<code>kCFAllocatorDefault</code>。</li>
<li><code>order</code>：事件源优先级，当Run Loop中有多个接收相同事件的事件源被标记为待执行时，那么就根据该优先级判断，0为最高优先级别。</li>
<li><code>context</code>：事件源上下文。</li>
</ol>
<p>Run Loop事件源上下文很重要，我们来看看它的结构：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CFRunLoopSourceContext</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> version: <span class="type">CFIndex</span> </span><br><span class="line">    <span class="keyword">var</span> info: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt; </span><br><span class="line">    <span class="keyword">var</span> retain: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;)! </span><br><span class="line">    <span class="keyword">var</span> release: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)! </span><br><span class="line">    <span class="keyword">var</span> copyDescription: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!)! </span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">equal</span>: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">DarwinBoolean</span>)! </span><br><span class="line">    <span class="keyword">var</span> hash: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">CFHashCode</span>)! </span><br><span class="line">    <span class="keyword">var</span> schedule: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span>)! </span><br><span class="line">    <span class="keyword">var</span> cancel: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span>)! </span><br><span class="line">    <span class="keyword">var</span> perform: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)! </span><br><span class="line">    <span class="keyword">init</span>() </span><br><span class="line">    <span class="keyword">init</span>(version version: <span class="type">CFIndex</span>, info info: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, retain retain: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;)!, release release: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)!, copyDescription copyDescription: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!)!, <span class="built_in">equal</span> <span class="built_in">equal</span>: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">DarwinBoolean</span>)!, hash hash: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">CFHashCode</span>)!, schedule schedule: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span>)!, cancel cancel: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span>)!, perform perform: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)!) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该结构体中我们需要关注的是前两个和后三个属性：</p>
<ol>
<li><code>version</code>：事件源上下文的版本，必须设置为0。</li>
<li><code>info</code>：上下文中<code>retain</code>、<code>release</code>、<code>copyDescription</code>、<code>equal</code>、<code>hash</code>、<code>schedule</code>、<code>cancel</code>、<code>perform</code>这八个回调函数所有者对象的指针。</li>
<li><code>schedule</code>：该回调函数的作用是将该事件源与给它发送事件消息的线程进行关联，也就是说如果主线程想要给该事件源发送事件消息，那么首先主线程得能获取到该事件源。</li>
<li><code>cancel</code>：该回调函数的作用是使该事件源失效。</li>
<li><code>perform</code>：该回调函数的作用是执行其他线程或当前线程给该事件源发来的事件消息。</li>
</ol>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u5C06_u4E8B_u4EF6_u6E90_u6DFB_u52A0_u81F3Run_Loop"><a href="#u5C06_u4E8B_u4EF6_u6E90_u6DFB_u52A0_u81F3Run_Loop" class="headerlink" title="将事件源添加至Run Loop"></a>将事件源添加至Run Loop</h3><p>事件源创建好之后，接下来就是将其添加到指定某个模式的Run Loop中，我们来看看这个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopAddSource</span><span class="params">(<span class="number">_</span> rl: CFRunLoop!, <span class="number">_</span> source: CFRunLoopSource!, <span class="number">_</span> mode: CFString!)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>rl</code>：希望添加事件源的Run Loop对象，类型是<code>CFRunLoop</code>。</li>
<li><code>source</code>：我们创建好的事件源。</li>
<li><code>mode</code>：Run Loop的模式。（可以回顾之前文章）</li>
</ol>
<p>我们再来看看这个方法都干了些什么：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">void <span class="type">CFRunLoopAddSource</span>(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopSourceRef</span> rls, <span class="type">CFStringRef</span> modeName) &#123;</span><br><span class="line">  </span><br><span class="line">    .....</span><br><span class="line">  </span><br><span class="line">    __CFRunLoopSourceSchedule(rls, rl, rlm);</span><br><span class="line">  </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __CFRunLoopSourceSchedule(<span class="type">CFRunLoopSourceRef</span> rls, <span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm) &#123;  </span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="type">NULL</span> != rls-&gt;_context.version0.schedule) &#123;</span><br><span class="line">             rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, rlm-&gt;_name);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述的代码片段可以看出，在<code>CFRunLoopAddSource</code>中调用了<code>__CFRunLoopSourceSchedule</code>内部函数，而该函数中正是执行了Run Loop事件源上下文中的<code>schedule</code>回调函数。也就是说当把事件源添加到Run Loop中后就会将事件源与给它发送事件消息的线程进行关联。</p>
<h3 id="u6807_u8BB0_u4E8B_u4EF6_u6E90_u53CA_u5524_u9192Run_Loop"><a href="#u6807_u8BB0_u4E8B_u4EF6_u6E90_u53CA_u5524_u9192Run_Loop" class="headerlink" title="标记事件源及唤醒Run Loop"></a>标记事件源及唤醒Run Loop</h3><p>前面的文章中说过，srouce0类型，也就是非port类型的事件源都需要进行手动标记，标记完还需要手动唤醒Run Loop，下面我们来看看这两个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopSourceSignal</span><span class="params">(<span class="number">_</span> source: CFRunLoopSource!)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopWakeUp</span><span class="params">(<span class="number">_</span> rl: CFRunLoop!)</span></span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是唤醒Run Loop并不等价与启动Run Loop，因为启动Run Loop时需要对Run Loop进行模式、时限的设置，而唤醒Run Loop只是当已启动的Run Loop休眠时重新让其运行。</p>
<h3 id="u6267_u884CRun_Loop_u4E8B_u4EF6_u6E90_u7684_u4EFB_u52A1"><a href="#u6267_u884CRun_Loop_u4E8B_u4EF6_u6E90_u7684_u4EFB_u52A1" class="headerlink" title="执行Run Loop事件源的任务"></a>执行Run Loop事件源的任务</h3><p>唤醒Run Loop意味着让休眠的Run Loop重新运行，那么我们就从启动Run Loop，让其开始运行的方法看起：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSRunLoop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">runUntilDate</span><span class="params">(limitDate: NSDate)</span></span> &#123;</span><br><span class="line">        <span class="keyword">while</span> runMode(<span class="type">NSDefaultRunLoopMode</span>, beforeDate: limitDate) &amp;&amp; limitDate.timeIntervalSinceReferenceDate &gt; <span class="type">CFAbsoluteTimeGetCurrent</span>() &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">runMode</span><span class="params">(mode: String, beforeDate limitDate: NSDate)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        .....</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> limitTime = limitDate.timeIntervalSinceReferenceDate</span><br><span class="line">        <span class="keyword">let</span> ti = limitTime - <span class="type">CFAbsoluteTimeGetCurrent</span>()</span><br><span class="line">        <span class="type">CFRunLoopRunInMode</span>(modeArg, ti, <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">SInt32</span> <span class="type">CFRunLoopRunInMode</span>(<span class="type">CFStringRef</span> modeName, <span class="type">CFTimeInterval</span> seconds, <span class="type">Boolean</span> returnAfterSourceHandled) &#123;     </span><br><span class="line">    <span class="type">CHECK_FOR_FORK</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="type">CFRunLoopRunSpecific</span>(<span class="type">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">SInt32</span> <span class="type">CFRunLoopRunSpecific</span>(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFStringRef</span> modeName, <span class="type">CFTimeInterval</span> seconds, <span class="type">Boolean</span> returnAfterSourceHandled) &#123;     </span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int32_t __CFRunLoopRun(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm, <span class="type">CFTimeInterval</span> seconds, <span class="type">Boolean</span> stopAfterHandle, <span class="type">Boolean</span> waitIfEmpty) &#123;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">Boolean</span> __CFRunLoopDoSources0(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm, <span class="type">Boolean</span> stopAfterHandle) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">CFTypeRef</span> sources = <span class="type">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopSourceIsSignaled(rls)) &#123;</span><br><span class="line">    </span><br><span class="line">        .....</span><br><span class="line">    </span><br><span class="line">        rls-&gt;_context.version0.perform(rls-&gt;_context.version0.info);</span><br><span class="line">        </span><br><span class="line">        .....</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码片段中可以看出，当Run Loop运行后会调用内部函数<code>__CFRunLoopDoSources0</code>执行自定义事件源的任务，在执行之前会通过内部函数<code>__CFRunLoopSourceIsSignaled(rls)</code>判断事件源是否已被标记为待执行，然后执行Run Loop事件上下文中的<code>perform</code>回调函数。</p>
<h3 id="u79FB_u9664Run_Loop_u4E8B_u4EF6_u6E90"><a href="#u79FB_u9664Run_Loop_u4E8B_u4EF6_u6E90" class="headerlink" title="移除Run Loop事件源"></a>移除Run Loop事件源</h3><p>当我们自定义的事件源完成使命后就可以将其从Run Loop中移除，我们来看看对应的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopRemoveSource</span><span class="params">(<span class="number">_</span> rl: CFRunLoop!, <span class="number">_</span> source: CFRunLoopSource!, <span class="number">_</span> mode: CFString!)</span></span></span><br><span class="line"></span><br><span class="line">void <span class="type">CFRunLoopRemoveSource</span>(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopSourceRef</span> rls, <span class="type">CFStringRef</span> modeName) &#123;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    __CFRunLoopSourceCancel(rls, rl, rlm);</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __CFRunLoopSourceCancel(<span class="type">CFRunLoopSourceRef</span> rls, <span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="type">NULL</span> != rls-&gt;_context.version0.cancel) &#123;</span><br><span class="line">              rls-&gt;_context.version0.cancel(rls-&gt;_context.version0.info, rl, rlm-&gt;_name);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码片段可以看出，当我们调用了<code>CFRunLoopRemoveSource</code>方法后，其实是执行了Run Loop事件源上下文中的<code>cancel</code>回调函数。</p>
<h3 id="u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90_u7684_u5B9E_u9645_u8FD0_u7528"><a href="#u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90_u7684_u5B9E_u9645_u8FD0_u7528" class="headerlink" title="自定义Run Loop事件源的实际运用"></a>自定义Run Loop事件源的实际运用</h3><p>在讲解示例之前，我们先来看看示例Demo的效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-5.gif" alt="LearnThread-5"></p>
<p>在这个示例中，创建了两个自定义事件源，一个添加到主线程中，另一个添加到二级线程中。主线程给二级线程中的自定义事件源发送事件消息，目的是让其改变所有<code>UICollectionViewCell</code>的透明度，当二级线程收到事件消息后执行计算每个<code>UICollectionViewCell</code>透明度的任务，然后再给主线程的自定义事件源发送事件消息，让其更新<code>UICollectionViewCell</code>的透明度并显示。下面来看看类图：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-6-new.png" alt="LearnThread-6"></p>
<p>整个工程一共就这六个类：</p>
<ul>
<li><code>MainCollectionViewController</code>：程序主控制器，启动程序、展示UI及计算<code>UICollectionViewCell</code>透明度的相关方法。</li>
<li><code>MainThreadRunLoopSource</code>：主线程自定义事件源管理对象，负责初始化事件源，将事件源添加至指定线程，标记事件源并唤醒指定Run Loop以及包含上文中说过的事件源最主要的三个回调方法。</li>
<li><code>MainThreadRunLoopSourceContext</code>：主线程自定义事件源上下文，可获取到对应的事件源及添加了该事件源的Run Loop。</li>
<li><code>SecondaryThreadRunLoopSource</code>：二级线程自定义事件源管理对象，负责初始化事件源，将事件源添加至指定线程，标记事件源并唤醒指定Run Loop以及包含上文中说过的事件源最主要的三个回调方法。</li>
<li><code>SecondaryThreadRunLoopSourceContext</code>：二级线程自定义事件源上下文，可获取到对应的事件源及添加了该事件源的Run Loop。</li>
<li><code>AppDelegate</code>：应用程序代理类，这里零时充当为各自定义事件源回调方法执行内容的管理类。</li>
</ul>
<p>下面我按照程序的运行顺序一一对这些类及属性和方法进行简单说明。</p>
<h4 id="u7A0B_u5E8F_u5F00_u59CB_u8FD0_u884C"><a href="#u7A0B_u5E8F_u5F00_u59CB_u8FD0_u884C" class="headerlink" title="程序开始运行"></a>程序开始运行</h4><p><code>MainCollectionViewController</code>类中与UI展示相关的方法在这里就不再累赘了。点击<strong>Start</strong>按钮，调用<code>start()</code>方法，初始化<code>MainThreadRunLoopSource</code>对象，在这个过程中初始化了<code>CFRunLoopSourceContext</code>对象并且创建<code>CFRunLoopSource</code>对象以及初始化该事件源的指令池：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mainThreadRunLoopSource = <span class="type">MainThreadRunLoopSource</span>()</span><br><span class="line">        </span><br><span class="line">mainThreadRunLoopSource.addToCurrentRunLoop()</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> runloopSourceContext = <span class="type">CFRunLoopSourceContext</span>(version: <span class="number">0</span>, info: <span class="built_in">unsafeBitCast</span>(<span class="keyword">self</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>), retain: <span class="literal">nil</span>, release: <span class="literal">nil</span>, copyDescription: <span class="literal">nil</span>, <span class="built_in">equal</span>: <span class="literal">nil</span>, hash: <span class="literal">nil</span>, schedule: runloopSourceScheduleRoutine(), cancel: runloopSourceCancelRoutine(), perform: runloopSourcePerformRoutine())</span><br><span class="line">        </span><br><span class="line">runloopSource = <span class="type">CFRunLoopSourceCreate</span>(kCFAllocatorDefault, <span class="number">0</span>, &amp;runloopSourceContext)</span><br><span class="line">        </span><br><span class="line">commandBuffer = <span class="type">Array</span>&lt;<span class="type">SecondaryThreadRunLoopSourceContext</span>&gt;()</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是<code>CFRunLoopSourceContext</code>的<code>init</code>方法中的第二个参数和<code>CFRunLoopSourceCreate</code>方法的第三个参数都是指针，那么在Swift中，将对象转换为指针的方法有两种：</p>
<ul>
<li>使用<code>unsafeBitCast</code>方法，该方法会将第一个参数的内容按照第二个参数的类型进行转换。一般当需要对象与指针来回转换时使用该方法。</li>
<li>在对象前面加<code>&amp;</code>符号，表示传入指针地址。</li>
</ul>
<p>当主线程的自定义事件源初始化完成之后，调用<code>addToCurrentRunLoop()</code>方法，将事件源添加至当前Run Loop中，即主线程的Run Loop：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cfrunloop = <span class="type">CFRunLoopGetCurrent</span>()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> rls = runloopSource &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="type">CFRunLoopAddSource</span>(cfrunloop, rls, kCFRunLoopDefaultMode)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来创建二级线程，并且让其执行二级线程的配置任务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> secondaryThread = <span class="type">NSThread</span>(target: <span class="keyword">self</span>, selector: <span class="string">"startThreadWithRunloop"</span>, object: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">secondaryThread.start()</span><br></pre></td></tr></table></figure>
<p>在二级线程中同样初始化自定义事件源，并将将其添加至二级线程的Run Loop中，然后启动Run Loop：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">startThreadWithRunloop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    autoreleasepool&#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">var</span> done = <span class="literal">false</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> secondaryThreadRunLoopSource = <span class="type">SecondaryThreadRunLoopSource</span>()</span><br><span class="line">            </span><br><span class="line">        secondaryThreadRunLoopSource.addToCurrentRunLoop()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">let</span> result = <span class="type">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">5</span>, <span class="literal">true</span>)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> ((result == <span class="type">CFRunLoopRunResult</span>.<span class="type">Stopped</span>) || (result == <span class="type">CFRunLoopRunResult</span>.<span class="type">Finished</span>)) &#123;</span><br><span class="line">                    </span><br><span class="line">                done = <span class="literal">true</span>;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125; <span class="keyword">while</span>(!done)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6267_u884C_u4E8B_u4EF6_u6E90_u7684schedule_u56DE_u8C03_u51FD_u6570"><a href="#u6267_u884C_u4E8B_u4EF6_u6E90_u7684schedule_u56DE_u8C03_u51FD_u6570" class="headerlink" title="执行事件源的schedule回调函数"></a>执行事件源的schedule回调函数</h4><p>前文中说过将事件源添加至Run Loop后会触发事件源的<code>schedule</code>回调函数，所以当执行完<code>mainThreadRunLoopSource.addToCurrentRunLoop()</code>这句代码后，便会触发主线程自定义事件源的<code>schedule</code>回调函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">runloopSourceScheduleRoutine</span><span class="params">()</span></span> -&gt; <span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123; (info, runloop, runloopMode) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> mainThreadRunloopSource = <span class="built_in">unsafeBitCast</span>(info, <span class="type">MainThreadRunLoopSource</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> mainThreadRunloopSourceContext = <span class="type">MainThreadRunLoopSourceContext</span>(runloop: runloop, runloopSource: mainThreadRunloopSource)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> appDelegate = <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br><span class="line">            </span><br><span class="line">        appDelegate.performSelector(<span class="string">"registerMainThreadRunLoopSource:"</span>, withObject: mainThreadRunloopSourceContext)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还需注意的是在Swift2.0中，如果一个作为回调函数方法的返回类型是指向函数的指针，这类指针可以转换为闭包，并且要在闭包前面加上<code>@convention(c)</code>标注。在<code>runloopSourceScheduleRoutine()</code>方法中，获取到主线程事件源对象并初始化事件源上下文对象，然后将该事件源上下文对象传给<code>AppDelegate</code>的对应方法注册该事件源上下文对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">registerMainThreadRunLoopSource</span><span class="params">(runloopSourceContext: MainThreadRunLoopSourceContext)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    mainThreadRunloopSourceContext = runloopSourceContext</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自然当在二级线程中执行完<code>secondaryThreadRunLoopSource.addToCurrentRunLoop()</code>这句代码后，也会触发二级线程自定义事件源的<code>schedule</code>回调函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">runloopSourceScheduleRoutine</span><span class="params">()</span></span> -&gt; <span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123; (info, runloop, runloopMode) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> secondaryThreadRunloopSource = <span class="built_in">unsafeBitCast</span>(info, <span class="type">SecondaryThreadRunLoopSource</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> secondaryThreadRunloopSourceContext = <span class="type">SecondaryThreadRunLoopSourceContext</span>(runloop: runloop, runloopSource: secondaryThreadRunloopSource)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> appDelegate = <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br><span class="line">            </span><br><span class="line">        appDelegate.performSelectorOnMainThread(<span class="string">"registerSecondaryThreadRunLoopSource:"</span>, withObject: secondaryThreadRunloopSourceContext, waitUntilDone: <span class="literal">true</span>)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，在该方法中同样是将二级线程事件源上下文对象传给了<code>AppDelegate</code>的对应方法，但是这里用了<code>performSelectorOnMainThread</code>方法，让其在主线程中执行，目的在于注册完上下文对象后就接着从主线程给二级线程发送事件消息了，其实我将这里作为了主线程触发二级线程执行任务的触发点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">registerSecondaryThreadRunLoopSource</span><span class="params">(runloopSourceContext: SecondaryThreadRunLoopSourceContext)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    secondaryThreadRunloopSourceContext = runloopSourceContext</span><br><span class="line">        </span><br><span class="line">    sendCommandToSecondaryThread()</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sendCommandToSecondaryThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    secondaryThreadRunloopSourceContext?.runloopSource?.commandBuffer?.append(mainThreadRunloopSourceContext!)</span><br><span class="line">        </span><br><span class="line">    secondaryThreadRunloopSourceContext?.runloopSource?.signalSourceAndWakeUpRunloop(secondaryThreadRunloopSourceContext!.runloop!)</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看到在<code>sendCommandToSecondaryThread()</code>方法中，将主线程的事件源上下文放入了二级线程事件源的指令池中，这里我设计的是只要指令池中有内容就代表事件源需要执行后续任务了。然后执行了二级线程事件源的<code>signalSourceAndWakeUpRunloop()</code>方法，给其标记为待执行，并唤醒二级线程的Run Loop：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">signalSourceAndWakeUpRunloop</span><span class="params">(runloop: CFRunLoopRef)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">CFRunLoopSourceSignal</span>(runloopSource)</span><br><span class="line">        </span><br><span class="line">    <span class="type">CFRunLoopWakeUp</span>(runloop)</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6267_u884C_u4E8B_u4EF6_u6E90_u7684perform_u56DE_u8C03_u51FD_u6570"><a href="#u6267_u884C_u4E8B_u4EF6_u6E90_u7684perform_u56DE_u8C03_u51FD_u6570" class="headerlink" title="执行事件源的perform回调函数"></a>执行事件源的perform回调函数</h4><p>当二级线程事件源被标记并且二级线程Run Loop被唤醒后，就会触发事件源的<code>perform</code>回调函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">runloopSourcePerformRoutine</span><span class="params">()</span></span> -&gt; <span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123; info -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> appDelegate = <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br><span class="line">            </span><br><span class="line">        appDelegate.performSelector(<span class="string">"performSecondaryThreadRunLoopSourceTask"</span>)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二级线程事件源的<code>perform</code>回调函数会在当前线程，也就是二级线程中执行<code>AppDelegate</code>中的对应方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSecondaryThreadRunLoopSourceTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> secondaryThreadRunloopSourceContext!.runloopSource!.commandBuffer!.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">        mainCollectionViewController!.generateRandomAlpha()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> mainThreadRunloopSourceContext = secondaryThreadRunloopSourceContext!.runloopSource!.commandBuffer![<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">        secondaryThreadRunloopSourceContext!.runloopSource!.commandBuffer!.removeAll()</span><br><span class="line">            </span><br><span class="line">        mainThreadRunloopSourceContext.runloopSource?.commandBuffer?.append(secondaryThreadRunloopSourceContext!)</span><br><span class="line">            </span><br><span class="line">        mainThreadRunloopSourceContext.runloopSource?.signalSourceAndWakeUpRunloop(mainThreadRunloopSourceContext.runloop!)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看到，先会判断二级线程事件源的指令池中有没有内容，如果有的话，那么执行计算<code>UICollectionViewCell</code>透明度的任务，然后从指令池中获取到主线程事件源上下文对象，将二级线程事件源上下文对象放入主线程事件源的指令池中，并将主线程事件源标记为待执行，然后唤醒主线程Run Loop。之后便会触发主线程事件源的<code>perform</code>回调函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">runloopSourcePerformRoutine</span><span class="params">()</span></span> -&gt; <span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123; info -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> appDelegate = <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br><span class="line">            </span><br><span class="line">        appDelegate.performSelector(<span class="string">"performMainThreadRunLoopSourceTask"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performMainThreadRunLoopSourceTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> mainThreadRunloopSourceContext!.runloopSource!.commandBuffer!.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        </span><br><span class="line">        mainThreadRunloopSourceContext!.runloopSource!.commandBuffer!.removeAll()</span><br><span class="line">            </span><br><span class="line">        mainCollectionViewController!.collectionView.reloadData()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> timer = <span class="type">NSTimer</span>(timeInterval: <span class="number">1</span>, target: <span class="keyword">self</span>, selector: <span class="string">"sendCommandToSecondaryThread"</span>, userInfo: <span class="literal">nil</span>, repeats: <span class="literal">false</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="type">NSRunLoop</span>.mainRunLoop().addTimer(timer, forMode: <span class="type">NSDefaultRunLoopMode</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>performMainThreadRunLoopSourceTask()</code>方法中同样会先判断主线程事件源的指令池是否有内容，然后执行<code>MainCollectionViewController</code>中的刷新UI的方法，最后再次给二级线程发送事件消息，以此循环。大家可以去Github下载该示例的<a href="https://github.com/DevTalking/CustomRunloopInputSourceSample.git" target="_blank" rel="external">源码</a>，编译环境是Xcode7.2，然后可以自己试着在界面中添加一个<strong>Stop</strong>按钮，让事件源执行<code>cancel</code>回调函数。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" ]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="Thread" scheme="http://www.devtalking.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Threading Programming Guide 笔记（二）]]></title>
    <link href="http://www.devtalking.com//articles/read-threading-programming-guide-2/"/>
    <id>http://www.devtalking.com//articles/read-threading-programming-guide-2/</id>
    <published>2016-02-09T16:00:00.000Z</published>
    <updated>2016-08-19T01:01:20.000Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/55617" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文章中有对官方文档的翻译，也有自己的理解，官方文档中代码片段的示例在这篇文章中都进行了完整的重写，还有一些文档中没有的代码示例，并且都使用Swift完成，给大家一些Objc与Swift转换的参考。<br>官方文档地址：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></p>
</blockquote>
<h2 id="u7EBF_u7A0B_u5C5E_u6027_u914D_u7F6E"><a href="#u7EBF_u7A0B_u5C5E_u6027_u914D_u7F6E" class="headerlink" title="线程属性配置"></a>线程属性配置</h2><p>线程也是具有若干属性的，自然一些属性也是可配置的，在启动线程之前我们可以对其进行配置，比如线程占用的内存空间大小、线程持久层中的数据、设置线程类型、优先级等。</p>
<h3 id="u914D_u7F6E_u7EBF_u7A0B_u7684_u6808_u7A7A_u95F4_u5927_u5C0F"><a href="#u914D_u7F6E_u7EBF_u7A0B_u7684_u6808_u7A7A_u95F4_u5927_u5C0F" class="headerlink" title="配置线程的栈空间大小"></a>配置线程的栈空间大小</h3><p>在前文中提到过线程对内存空间的消耗，其中一部分就是线程栈，我们可以对线程栈的大小进行配置：</p>
<ul>
<li>Cocoa框架：在OS X v10.5之后的版本和iOS2.0之后的版本中，我们可以通过修改<code>NSThread</code>类的<code>stackSize</code>属性，改变二级线程的线程栈大小，不过这里要注意的是该属性的单位是字节，并且设置的大小必须得是4KB的倍数。</li>
<li>POSIX API：通过<code>pthread_attr_- setstacksize</code>函数给线程属性<code>pthread_attr_t</code>结构体设置线程栈大小，然后在使用<code>pthread_create</code>函数创建线程时将线程属性传入即可。</li>
</ul>
<blockquote>
<p>注意：在使用Cocoa框架的前提下修改线程栈时，不能使用<code>NSThread</code>的<code>detachNewThreadSelector: toTarget:withObject:</code>方法，因为上文中说过，该方法先创建线程，即刻便启动了线程，所以根本没有机会修改线程属性。</p>
</blockquote>
<h3 id="u914D_u7F6E_u7EBF_u7A0B_u5B58_u50A8_u5B57_u5178"><a href="#u914D_u7F6E_u7EBF_u7A0B_u5B58_u50A8_u5B57_u5178" class="headerlink" title="配置线程存储字典"></a>配置线程存储字典</h3><p>每一个线程，在整个生命周期里都会有一个字典，以<code>key-value</code>的形式存储着在线程执行过程中你希望保存下来的各种类型的数据，比如一个常驻线程的运行状态，线程可以在任何时候访问该字典里的数据。</p>
<p>在Cocoa框架中，可以通过<code>NSThread</code>类的<code>threadDictionary</code>属性，获取到<code>NSMutableDictionary</code>类型对象，然后自定义<code>key</code>值，存入任何里先储存的对象或数据。如果使用POSIX线程，可以使用<code>pthread_setspecific</code>和<code>pthread_getspecific</code>函数设置获取线程字典。</p>
<h3 id="u914D_u7F6E_u7EBF_u7A0B_u7C7B_u578B"><a href="#u914D_u7F6E_u7EBF_u7A0B_u7C7B_u578B" class="headerlink" title="配置线程类型"></a>配置线程类型</h3><p>在上文中提到过，线程有Joinable和Detached类型，大多数非底层的线程默认都是Detached类型的，相比Joinable类型的线程来说，Detached类型的线程不用与其他线程结合，并且在执行完任务后可自动被系统回收资源，而且主线程不会因此而阻塞，这着实要方便许多。</p>
<p>使用<code>NSThread</code>创建的线程默认都是Detached类型，而且似乎也不能将其设置为Joinable类型。而使用POSIX API创建的线程则默认为Joinable类型，而且这也是唯一创建Joinable类型线程的方式。通过POSIX API可以在创建线程前通过函数<code>pthread_attr_setdetachstate</code>更新线程属性，将其设置为不同的类型，如果线程已经创建，那么可以使用<code>pthread_detach</code>函数改变其类型。Joinable类型的线程还有一个特性，那就是在终止之前可以将数据传给与之相结合的线程，从而达到线程之间的交互。即将要终止的线程可以通过<code>pthread_exit</code>函数传递指针或者任务执行的结果，然后与之结合的线程可以通过<code>pthread_join</code>函数接受数据。</p>
<p>虽然通过POSIX API创建的线程使用和管理起来较为复杂和麻烦，但这也说明这种方式更为灵活，更能满足不同的使用场景和需求。比如当执行一些关键的任务，不能被打断的任务，像执行I/O操作之类。</p>
<h3 id="u8BBE_u7F6E_u7EBF_u7A0B_u4F18_u5148_u7EA7"><a href="#u8BBE_u7F6E_u7EBF_u7A0B_u4F18_u5148_u7EA7" class="headerlink" title="设置线程优先级"></a>设置线程优先级</h3><p>每一个新创建的二级线程都有它自己的默认优先级，内核会根据线程的各属性通过分配算法计算出线程的优先级。这里需要明确一个概念，高优先级的线程虽然会更早的运行，但这其中并没有执行时间效率的因素，也就是说高优先级的线程会更早的执行它的任务，但在执行任务的时间长短方面并没有特别之处。</p>
<p>不论是通过<code>NSThread</code>创建线程还是通过POSIX API创建线程，他们都提供了设置线程优先级的方法。我们可以通过<code>NSThread</code>的类方法<code>setThreadPriority:</code>设置优先级，因为线程的优先级由0.0～1.0表示，所以设置优先级时也一样。我们也可以通过<code>pthread_setschedparam</code>函数设置线程优先级。</p>
<blockquote>
<p>注意：设置线程的优先级时可以在线程运行时设置。</p>
</blockquote>
<p>虽然我们可以调节线程的优先级，但不到必要时还是不建议调节线程的优先级。因为一旦调高了某个线程的优先级，与低优先级线程的优先等级差距太大，就有可能导致低优先级线程永远得不到运行的机会，从而产生性能瓶颈。比如说有两个线程A和B，起初优先级相差无几，那么在执行任务的时候都会相继无序的运行，如果将线程A的优先级调高，并且当线程A不会因为执行的任务而阻塞时，线程B就可能一直不能运行，此时如果线程A中执行的任务需要与线程B中任务进行数据交互，而迟迟得不到线程B中的结果，此时线程A就会被阻塞，那么程序的性能自然就会产生瓶颈。</p>
<h2 id="u7EBF_u7A0B_u6267_u884C_u7684_u4EFB_u52A1"><a href="#u7EBF_u7A0B_u6267_u884C_u7684_u4EFB_u52A1" class="headerlink" title="线程执行的任务"></a>线程执行的任务</h2><p>在任何平台，线程存在的价值和意义都是一样的，那就是执行任务，不论是方法、函数或一段代码，除了依照语言语法正常编写外，还有一些额外需要大家注意的事项。</p>
<h3 id="Autorelease_Pool"><a href="#Autorelease_Pool" class="headerlink" title="Autorelease Pool"></a>Autorelease Pool</h3><p>在Xcode4.3之前，我们都处在手动管理引用计数的时代，代码里满是<code>retain</code>和<code>release</code>的方法，所以那个时候，被线程执行的任务中，为了能自动处理大量对象的<code>retain</code>和<code>release</code>操作，都会使用<code>NSAutoreleasePool</code>类创建自动释放池，它的作用是将线程中要执行的任务都放在自动释放池中，自动释放池会捕获所有任务中的对象，在任务结束或线程关闭之时自动释放这些对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myThreadMainRoutine</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init]; <span class="comment">// 顶层自动释放池</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程执行任务的逻辑代码</span></span><br><span class="line"></span><br><span class="line">    [pool release];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了自动引用计数（ARC）时代，就不能使用<code>NSAutoreleasePool</code>进行自动释放池管理了，而是新加了<code>@autoreleasepool</code>代码块语法来创建自动释放池：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myThreadMainRoutine</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 线程执行任务的逻辑代码</span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道每个应用程序都是运行在一个主线程里的，而线程都至少得有一个自动释放池，所以说整个应用其实是跑在一个自动释放池中的。大家都知道C系语言中，程序的入口函数都是<code>main</code>函数，当我们创建一个Objective－C的iOS应用后，Xcode会在<strong>Supporting Files</strong>目录下自动为我们创建一个<code>main.m</code>文件：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-2.png" alt="LearnThread-2"></p>
<p>在<code>main.m</code>这个文件中就能证实上面说的那点：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上都是在Objective－C中，但在Swift中，就有点不一样了，<code>NSAutoreleasePool</code>和<code>@autoreleasepool</code>都不能用了，取而代之的是Swift提供的一个方法<code>func autoreleasepool(code: () -&gt; ())</code>，接收的参数为一个闭包，我们可以这样使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performInBackground</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        autoreleasepool(&#123;</span><br><span class="line">        </span><br><span class="line">          <span class="comment">// 线程执行任务的逻辑代码</span></span><br><span class="line">          </span><br><span class="line">          <span class="built_in">print</span>(<span class="string">"I am a event, perform in Background Thread."</span>)  </span><br><span class="line">          </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据尾随闭包的写法，还可以这样使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performInBackground</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        autoreleasepool&#123;</span><br><span class="line">        </span><br><span class="line">          <span class="comment">// 线程执行任务的逻辑代码</span></span><br><span class="line">          </span><br><span class="line">          <span class="built_in">print</span>(<span class="string">"I am a event, perform in Background Thread."</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>有些人可能会问在ARC的时代下为什么还要用自动释放池呢？比如在SDWebImage中就大量使用了<code>@autoreleasepool</code>代码块，其原因就是为了避免内存峰值，大家都知道在MRC时代，除了<code>retain</code>和<code>release</code>方法外，还有一个常用的方法是<code>autorelease</code>，用来延迟释放对象，它释放对象的时机是当前runloop结束时。到了ARC时代，虽然不用我们手动管理内存了，但其自动管理的本质与MRC时是一样的，只不过由编译器帮我们在合适的地方加上了这三个方法，所以说如果在一个线程执行的任务中大量产生需要<code>autorelease</code>的对象时，因为不能及时释放对象，所以就很有可能产生内存峰值。那么在这种任务中在特定的时候使用<code>@autorelease</code>代码块，帮助释放对象，就可以有效的防止内存峰值的发生。</p>
<h3 id="u8BBE_u7F6E_u5F02_u5E38_u5904_u7406"><a href="#u8BBE_u7F6E_u5F02_u5E38_u5904_u7406" class="headerlink" title="设置异常处理"></a>设置异常处理</h3><p>在线程执行任务的时候，难免会出现异常，如果不能及时捕获异常任由其抛出，就会导致整个应用程序退出。在Swift2.0中，Apple提供了新的<a href="http://www.devtalking.com/articles/what-is-new-in-swift/">异常控制处理机制</a>，让我们能像Java中一样形如流水的捕获处理异常。所以在线程执行的任务中，我们尽量使用异常处理机制，提高健壮性。</p>
<h3 id="u521B_u5EFARunloop"><a href="#u521B_u5EFARunloop" class="headerlink" title="创建Runloop"></a>创建Runloop</h3><p>大家知道，一个线程只能执行一个任务，当任务结束后也就意味着这个线程也要结束，频繁的创建线程也是挺消耗资源的一件事，于是就有了常驻线程，前文介绍线程相关概念时也提到过：</p>
<blockquote>
<p>简单的来说，RunLoop用于管理和监听异步添加到线程中的事件，当有事件输入时，系统唤醒线程并将事件分派给RunLoop，当没有需要处理的事件时，RunLoop会让线程进入休眠状态。这样就能让线程常驻在进程中，而不会过多的消耗系统资源，达到有事做事，没事睡觉的效果。</p>
</blockquote>
<p>如果想要线程不结束，那就要被执行的任务不结束，让被执行的任务不结束显然不靠谱，那么就需要一个机制，能占着线程。该机制就是事件循环机制（Eventloop），体现在代码中就是一个<code>do-while</code>循环，不断的接收事件消息、处理事件、等待新事件消息，除非接收到一个让其退出的事件消息，否则它将一直这么循环着，线程自然就不会结束。Runloop就是管理消息和事件，并提供Eventloop函数的对象，线程执行的任务其实就是在Runloop对象的Eventloop函数里运行。关于Runloop更详细的知识及配置<br>操作在后文中会有讲述。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u7EC8_u6B62_u7EBF_u7A0B"><a href="#u7EC8_u6B62_u7EBF_u7A0B" class="headerlink" title="终止线程"></a>终止线程</h3><p>打个不恰当的比方，人终有一死，或正常生老病死，或非正常出事故意外而亡，前者尚合情合理后者悲痛欲绝。线程也一样，有正常终止结束，也有非正常的强制结束，不管是线程本身还是应用程序都希望线程能正常结束，因为正常结束也就意味着被执行的任务正常执行完成，从而让线程处理完后事随即结束，如果在任务执行途中强制终止线程，会导致线程没有机会处理后事，也就是正常释放资源对象等，这样会给应用程序带来例如内存溢出这类潜在的问题，所以强烈不推荐强制终止线程的做法。</p>
<p>如果确实有在任务执行途中终止线程的需求，那么可以使用Runloop，在任务执行过程中定期查看是否有收到终止任务的事件消息，这样一来可以在任务执行途中判断出终止任务的信号，然后进行终止任务的相关处理，比如保存数据等，二来可以让线程有充分的时间释放资源。</p>
<h2 id="Run_Loop"><a href="#Run_Loop" class="headerlink" title="Run Loop"></a>Run Loop</h2><p>Run Loops是线程中的基础结构，在上文中也提到过，Run Loops其实是一个事件循环机制，用来分配、分派线程接受到的事件任务，同时可以让线程成为一个常驻线程，即有任务时处理任务，没任务时休眠，且不消耗资源。在实际应用时，Run Loop的生命周期并不全是自动完成的，还是需要人工进行配置，不论是Cocoa框架还是Core Foundation框架都提供了Run Loop的相关对象对其进行配置和管理。</p>
<blockquote>
<p>注：Core Foundation框架是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能，比如线程和Run Loop、端口、Socket、时间日期等。</p>
</blockquote>
<p>在所有的线程中，不论是主线程还是二级线程，都不需要显示的创建Run Loop对象，这里的显示指的是通过任何<em>create</em>打头的方法创建Run Loop。对于主线程来说，当应用程序通过<code>UIApplicationMain</code>启动时，主线程中的Run Loop就已经创建并启动了，而且也配置好了。那么如果是二级线程，则需要我们手动先获取Run Loop，然后再手动进行配置并启动。下面的章节会向大家详细介绍Run Loop的知识。</p>
<blockquote>
<p>注：在二级线程中获取Run Loop有两种方式，通过<code>NSRunloop</code>的类方法<code>currentRunLoop</code>获取Run Loop对象（<code>NSRunLoop</code>），或者通过Core Foundation框架中的<code>CFRunLoopGetCurrent()</code>函数获取当前线程的Run Loop对象（<code>CFRunLoop</code>）。<code>NSRunLoop</code>是<code>CFRunLoop</code>的上层封装。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nsrunloop = <span class="type">NSRunLoop</span>.currentRunLoop()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> cfrunloop = <span class="type">CFRunLoopGetCurrent</span>()</span><br></pre></td></tr></table></figure>
<h3 id="Run_Loop_u7684_u4E8B_u4EF6_u6765_u6E90"><a href="#Run_Loop_u7684_u4E8B_u4EF6_u6765_u6E90" class="headerlink" title="Run Loop的事件来源"></a>Run Loop的事件来源</h3><p>Run Loop有两个事件来源，一个是<strong>Input source</strong>，接收来自其他线程或应用程序（进程）的异步事件消息，并将消息分派给对应的事件处理方法。另一个是<strong>Timer source</strong>，接收定期循环执行或定时执行的同步事件消息，同样会将消息分派给对应的事件处理方法。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-3.png" alt="LearnThread-3"></p>
<p>上图展示了Run Loop的两类事件来源，以及在Input source中的两种不同的子类型，它们分别对应着Run Loop中不同的处理器。当不同的事件源接收到消息后，通过<code>NSRunLoop</code>的<code>runUntilDate:</code>方法启动运行Run Loop，将事件消息分派给对应的处理器执行，一直到指定的时间时退出Run Loop。</p>
<h3 id="Run_Loop_u7684_u89C2_u5BDF_u8005"><a href="#Run_Loop_u7684_u89C2_u5BDF_u8005" class="headerlink" title="Run Loop的观察者"></a>Run Loop的观察者</h3><p>Run Loop的观察者可以理解为Run Loop自身运行状态的监听器，它可以监听Run Loop的下面这些运行状态：</p>
<ul>
<li>Run Loop准备开始运行时。</li>
<li>当Run Loop准备要执行一个Timer Source事件时。</li>
<li>当Run Loop准备要执行一个Input Source事件时。</li>
<li>当Run Loop准备休眠时。</li>
<li>当Run Loop被进入的事件消息唤醒并且还没有开始让处理器执行事件消息时。</li>
<li>退出Run Loop时。</li>
</ul>
<p>Run Loop的观察者在<code>NSRunloop</code>中没有提供相关接口，所以我们需要通过Core Foundation框架使用它，可以通过<code>CFRunLoopObserverCreate</code>方法创建Run Loop的观察者，类型为<code>CFRunLoopObserverRef</code>，它其实是<code>CFRunLoopObserver</code>的重定义名称。上述的那些可以被监听的运行状态被封装在了<code>CFRunLoopActivity</code>结构体中，对应关系如下：</p>
<ul>
<li><code>CFRunLoopActivity.Entry</code></li>
<li><code>CFRunLoopActivity.BeforeTimers</code></li>
<li><code>CFRunLoopActivity.BeforeSources</code></li>
<li><code>CFRunLoopActivity.BeforeWaiting</code></li>
<li><code>CFRunLoopActivity.AfterWaiting</code></li>
<li><code>CFRunLoopActivity.Exit</code></li>
</ul>
<p>Run Loop的观察者和Timer事件类似，可以只使用一次，也可以重复使用，在创建观察者时可以设置。如果只使用一次，那么当监听到对应的状态后会自行移除，如果是重复使用的，那么会留在Run Loop中多次监听Run Loop相同的运行状态。</p>
<h3 id="Run_Loop_Modes"><a href="#Run_Loop_Modes" class="headerlink" title="Run Loop Modes"></a>Run Loop Modes</h3><p>Run Loop Modes可以称之为Run Loop模式，这个模式可以理解为对Run Loop各种设置项的不同组合，举个例子，iPhone手机运行的iOS有很多系统设置项，假设白天我打开蜂窝数据，晚上我关闭蜂窝数据，而打开无线网络，到睡觉时我关闭蜂窝数据和无线网络，而打开飞行模式。假设在这三个时段中其他的所有设置项都相同，而只有这三个设置项不同，那么就可以说我的手机有三种不同的设置模式，对应着不同的时间段。那么Run Loop的设置项是什么呢？那自然就是前文中提到的不同的事件来源以及观察者了，比如说，Run Loop的模式A（Mode A），只包含接收Timer Source事件源的事件消息以及监听Run Loop运行时的观察者，而模式B（Mode B）只包含接收Input Source事件源的事件消息以及监听Run Loop准备休眠时和退出Run Loop时的观察者，如下图所示：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread%EF%BC%8D7.png" alt="LearnThread-4"></p>
<p>所以说，Run Loop的模式就是不同类型的数据源和不同观察者的集合，当Run Loop运行时要设置它的模式，也就是告知Run Loop只需要关心这个集合中的数据源类型和观察者，其他的一概不予理会。那么通过模式，就可以让Run Loop过滤掉它不关心的一些事件，以及避免被无关的观察者打扰。如果有不在当前模式中的数据源发来事件消息，那只能等Run Loop改为包含有该数据源类型的模式时，才能处理事件消息。</p>
<p>在Cocoa框架和Core Foundation框架中，已经为我们预定义了一些Run Loop模式：</p>
<ul>
<li>默认模式：在<code>NSRunloop</code>中的定义为<code>NSDefaultRunLoopMode</code>，在<code>CFRunloop</code>中的定义为<code>kCFRunLoopDefaultMode</code>。该模式包含的事件源囊括了除网络链接操作的大多数操作以及时间事件，用于当前Run Loop处于空闲状态等待事件时，以及Run Loop开始运行时。</li>
<li>NSConnectionReplyMode：该模式用于监听<code>NSConnection</code>相关对象的返回结果和状态，在系统内部使用，我们一般不会使用该模式。</li>
<li>NSModalPanelRunLoopMode：该模式用于过滤在模态面板中处理的事件（Mac App）。</li>
<li>NSEventTrackingRunLoopMode：该模式用于跟踪用户与界面交互的事件。</li>
<li>模式集合：或者叫模式组，顾名思义就是将多个模式组成一个组，然后将模式组认为是一个模式设置给Run Loop，在<code>NSRunloop</code>中的定义为<code>NSRunLoopCommonModes</code>，在<code>CFRunloop</code>中的定义为<code>kCFRunLoopCommonModes</code>。系统提供的模式组名为Common Modes，它默认包含NSDefaultRunLoopMode、NSModalPanelRunLoopMode、NSEventTrackingRunLoopMode这三个模式。</li>
</ul>
<p>以上五种系统预定的模式中，前四种属于只读模式，也就是我们无法修改它们包含的事件源类型和观察者类型。而模式组我们可以通过Core Foundation框架提供的<code>CFRunLoopAddCommonMode(_ rl: CFRunLoop!, _ mode: CFString!)</code>方法添加新的模式，甚至是我们自定义的模式。这里需要注意的是，既然在使用时，模式组是被当作一个模式使用的，那么自然可以给它设置不同类型的事件源或观察者，当给模式组设置事件源或观察者时，实际是给该模式组包含的所有模式设置。比如说给模式组设置了一个监听Run Loop准备休眠时的观察者，那么该模式组里的所有模式都会被设置该观察者。</p>
<h3 id="Input_Source"><a href="#Input_Source" class="headerlink" title="Input Source"></a>Input Source</h3><p>前文中说过，Input Sources接收到各种操作输入事件消息，然后异步的分派给对应事件处理方法。在Input Sources中又分两大类的事件源，一类是基于端口事件源（Port-based source），在<code>CFRunLoopSourceRef</code>的结构中为source1，主要通过监听应用程序的Mach端口接收事件消息并分派，该类型的事件源可以主动唤醒Run Loop。另一类是自定义事件源（Custom source），在<code>CFRunLoopSourceRef</code>的结构中为source0，一般是接收其他线程的事件消息并分派给当前线程的Run Loop，比如<code>performSwlwctor:onThread:...</code>系列方法，该类型的事件源无法自动唤醒Run Loop，而是需要手动将事件源设置为待执行的标记，然后再手动唤醒Run Loop。虽然这两种类型的事件源接收事件消息的方式不一样，但是当接收到消息后，对消息的分派机制是完全相同的。</p>
<h4 id="Port-Based_Source"><a href="#Port-Based_Source" class="headerlink" title="Port-Based Source"></a>Port-Based Source</h4><p>Cocoa框架和Core Foundation框架都提供了相关的对象和函数用于创建基于端口的事件源。在Cocoa框架中，实现基于端口的事件源主要是通过<code>NSPort</code>类实现的，它代表了交流通道，也就是说在不同的线程的Run Loop中都存在<code>NSPort</code>，那么它们之间就可以通过发送与接收消息（<code>NSPortMessage</code>）互相通信。所以我们只需要通过<code>NSPort</code>类的类方法<code>port</code>创建对象实例，然后通过<code>NSRunloop</code>的方法将其添加到Run Loop中，或者在创建二级线程时将创建好的<code>NSPort</code>对象传入即可，无需我们再做消息、消息上下文、事件源等其他配置，都由Run Loop自行配置好了。而在Core Foundation框架中就比较麻烦一些，大多数配置都需要我们手动配置，在后面会详细举例说明。</p>
<h4 id="Custom_Input_Source"><a href="#Custom_Input_Source" class="headerlink" title="Custom Input Source"></a>Custom Input Source</h4><p>Cocoa框架中没有提供创建自定义事件源的相关接口，我们只能通过Core Foundation框架中提供的对象和函数创建自定义事件源，手动配置事件源各个阶段要处理的逻辑，比如创建<code>CFRunLoopSourceRef</code>事件源对象，通过<code>CFRunLoopScheduleCallBack</code>回调函数配置事件源上下文并注册事件源，通过<code>CFRunLoopPerformCallBack</code>回调函数处理接收到事件消息后的逻辑，通过<code>CFRunLoopCancelCallBack</code>函数销毁事件源等等，在后文中会有详细举例说明。</p>
<p>虽然Cocoa框架没有提供创建自定义事件源的相关对象和接口，但是它为我们预定义好了一些事件源，能让我们在当前线程、其他二级线程、主线程中执行我们希望被执行的方法，让我们看看<code>NSObject</code>中的这些方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelectorOnMainThread</span><span class="params">(<span class="number">_</span> aSelector: Selector, withObject arg: AnyObject?, waitUntilDone wait: Bool)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelectorOnMainThread</span><span class="params">(<span class="number">_</span> aSelector: Selector, withObject arg: AnyObject?, waitUntilDone wait: Bool, modes array: [String]?)</span></span></span><br></pre></td></tr></table></figure>
<p>这两个方法允许我们将当前线程中对象的方法让主线程去执行，可以选择是否阻塞当前线程，以及希望被执行的方法作为事件消息被何种Run Loop模式监听。</p>
<blockquote>
<p>注：如果在主线程中使用该方法，当选择阻塞当前线程，那么发送的方法会立即被主线程执行，若选择不阻塞当前线程，那么被发送的方法将被排进主线程Run Loop的事件队列中，并等待执行。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(<span class="number">_</span> aSelector: Selector, withObject anArgument: AnyObject?, afterDelay delay: NSTimeInterval)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(<span class="number">_</span> aSelector: Selector, withObject anArgument: AnyObject?, afterDelay delay: NSTimeInterval, inModes modes: [String])</span></span></span><br></pre></td></tr></table></figure>
<p>这两个方法允许我们给当前线程发送事件消息，当前线程接收到消息后会依次加入Run Loop的事件消息队列中，等待Run Loop迭代执行。该方法还可以指定消息延迟发送时间及消息希望被何种Run Loop模式监听。</p>
<blockquote>
<p>注：该方法中的延迟时间并不是延迟Run Loop执行事件消息的事件，而是延迟向当前线程发送事件消息的时间。另外，即便不设置延迟时间，那么发送的事件消息也不一定立即被执行，因为在Run Loop的事件消息队列中可以已有若干等待执行的消息。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(<span class="number">_</span> aSelector: Selector, onThread thr: NSThread, withObject arg: AnyObject?, waitUntilDone wait: Bool)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(<span class="number">_</span> aSelector: Selector, onThread thr: NSThread, withObject arg: AnyObject?, waitUntilDone wait: Bool, modes array: [String]?)</span></span></span><br></pre></td></tr></table></figure>
<p>这两个方法允许我们给其他二级线程发送事件消息，前提是要取得目标二级线程的<code>NSThread</code>对象实例，该方法同样提供了是否阻塞当前线程的选项和设置Run Loop模式的选项。</p>
<blockquote>
<p>注：使用该方法给二级线程发送事件消息时要确保目标线程正在运行，换句话说就是目标线程要有启动着的Run Loop。并且保证目标线程执行的任务要在应用程序代理执行<code>applicationDidFinishLaunching:</code>方法前完成，否则主线程就结束了，目标线程自然也就结束了。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelectorInBackground</span><span class="params">(<span class="number">_</span> aSelector: Selector, withObject arg: AnyObject?)</span></span></span><br></pre></td></tr></table></figure>
<p>该方法允许我们在当前应用程序中创建一个二级线程，并将指定的事件消息发送给新创建的二级线程。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">cancelPreviousPerformRequestsWithTarget</span>(<span class="title">_</span> <span class="title">aTarget</span>: <span class="title">AnyObject</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">cancelPreviousPerformRequestsWithTarget</span>(<span class="title">_</span> <span class="title">aTarget</span>: <span class="title">AnyObject</span>, <span class="title">selector</span> <span class="title">aSelector</span>: <span class="title">Selector</span>, <span class="title">object</span> <span class="title">anArgument</span>: <span class="title">AnyObject</span>?)</span></span><br></pre></td></tr></table></figure>
<p>这两个方法是<code>NSObject</code>的类方法，第一个方法作用是在当前线程中取消Run Lop中某对象通过<code>performSelector:withObject:afterDelay:</code>方法发送的所有事件消息执行请求。第二个方法多了两个过滤参数，那就是方法名称和参数，取消指定方法名和参数的事件消息执行请求。</p>
<h3 id="Timer_Source"><a href="#Timer_Source" class="headerlink" title="Timer Source"></a>Timer Source</h3><p>Timer Source顾名思义就是向Run Loop发送在将来某一时间执行或周期性重复执行的同步事件消息。当某线程不需要其他线程通知而需要自己通知自己执行任务时就可以用这种事件源。举个应用场景，在iOS应用中，我们经常会用到搜索功能，而且一些搜索框具有自动搜索的能力，也就是说不用我们点击搜索按钮，只需要输入完我想要搜索的内容就会自动搜索，大家想一想如果每输入一个字就开始立即搜索，不但没有意义，性能开销也大，用户体验自然也很糟糕，我们希望当输入完这句话，或至少输入一部分之后再开始搜索，所以我们就可以在开始输入内容时向执行搜索功能的线程发送定时搜索的事件消息，让其在若干时间后再执行搜索任务，这样就有缓冲时间输入搜索内容了。</p>
<p>这里需要注意的是Timer Source发送给Run Loop的周期性执行任务的重复时间是相对时间。比如说给Run Loop发送了一个每隔5秒执行一次的任务，每次执行任务的正常时间为2秒，执行5次后终止，假设该任务被立即执行，那么当该任务终止时应该历时30秒，但当第一次执行时出现了问题，导致任务执行了20秒，那么该任务只能再执行一次就终止了，执行的这一次其实就是第5次，也就是说不论任务的执行时间延迟与否，Run Loop都会按照初始的时间间隔执行任务，并非按Finish-To-Finish去算的，所以一旦中间任务有延时，那么就会丢失任务执行次数。关于Timer Source的使用，在后文中会有详细举例说明。</p>
<h3 id="Run_Loop_u5185_u90E8_u8FD0_u884C_u903B_u8F91"><a href="#Run_Loop_u5185_u90E8_u8FD0_u884C_u903B_u8F91" class="headerlink" title="Run Loop内部运行逻辑"></a>Run Loop内部运行逻辑</h3><p>在Run Loop的运行生命周期中，无时无刻都伴随着执行等待执行的各种任务以及在不同的运行状态时通知不同的观察者，下面我们看看Run Loop中的运行逻辑到底是怎样的：</p>
<ol>
<li>通知对应观察者Run Loop准备开始运行。</li>
<li>通知对应观察者准备执行定时任务。</li>
<li>通知对应观察者准备执行自定义事件源的任务。</li>
<li>开始执行自定义事件源任务。</li>
<li>如果有基于端口事件源的任务准备待执行，那么立即执行该任务。然后跳到步骤9继续运转。</li>
<li>通知对应观察者线程进入休眠。</li>
<li>如果有下面的事件发生，则唤醒线程：<ol>
<li>接收到基于端口事件源的任务。</li>
<li>定时任务到了该执行的时间点。</li>
<li>Run Loop的超时时间到期。</li>
<li>Run Loop被手动唤醒。</li>
</ol>
</li>
<li>通知对应观察者线程被唤醒。</li>
<li>执行等待执行的任务。<ol>
<li>如果有定时任务已启动，执行定时任务并重启Run Loop。然后跳到步骤2继续运转。</li>
<li>如果有非定时器事件源的任务待执行，那么分派执行该任务。</li>
<li>如果Run Loop被手动唤醒，重启Run Loop。然后跳转到步骤2继续运转。</li>
</ol>
</li>
<li>通知对应观察者已退出Run Loop。</li>
</ol>
<p>以上这些Run Loop中的步骤也不是每一步都会触发，举一个例子：<br>1.对应观察者接收到通知Run Loop准备开始运行 -> 3.对应观察者接收到通知Run Loop准备执行自定义事件源任务 -> 4.开始执行自定义事件源任务 -> 任务执行完毕且没有其他任务待执行 -> 6.线程进入休眠状态，并通知对应观察者 -> 7.接收到定时任务并唤醒线程 -> 8.通知对应观察者线程被唤醒 -> 9.执行定时任务并重启Run Loop -> 2.通知对应观察者准备执行定时任务 －> Run Loop执行定时任务，并在等待下次执行任务的间隔中线程休眠 -> 6.线程进入休眠状态，并通知对应观察者…</p>
<p>这里需要注意的一点是从上面的运行逻辑中可以看出，当观察者接收到执行任务的通知时，Run Loop并没有真正开始执行任务，所以观察者接收到通知的时间与Run Loop真正执行任务的时间有时间差，一般情况下这点时间差影响不大，但如果你需要通过观察者知道Run Loop执行任务的确切时间，并根据这个时间要进行后续操作的话，那么就需要通过结合多个观察者接收到的通知共同确定了。一般通过监听准备执行任务的观察者、监听线程进入休眠的观察者、监听线程被唤醒的观察者共同确定执行任务的确切时间。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" ]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="Thread" scheme="http://www.devtalking.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Threading Programming Guide 笔记（一）]]></title>
    <link href="http://www.devtalking.com//articles/read-threading-programming-guide-1/"/>
    <id>http://www.devtalking.com//articles/read-threading-programming-guide-1/</id>
    <published>2016-01-31T16:00:00.000Z</published>
    <updated>2016-08-19T01:01:01.000Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/54092" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文章中有对官方文档的翻译，也有自己的理解，官方文档中代码片段的示例在这篇文章中都进行了完整的重写，还有一些文档中没有的代码示例，并且都使用Swift完成，给大家一些Objc与Swift转换的参考。<br>官方文档地址：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></p>
</blockquote>
<h2 id="u4EC0_u4E48_u662F_u7EBF_u7A0B"><a href="#u4EC0_u4E48_u662F_u7EBF_u7A0B" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>我们设想在应用程序中，每行代码的执行都有一个执行路径并对应一个执行容器。线程，可以让应用程序中的代码通过多个执行路径执行，从而达到多个代码块同时在不同的执行路径下执行运算，即多任务同时执行。</p>
<p>在系统中，每个程序都是并行状态的，但是并不是一直持续着活跃状态，而是由系统根据程序的需要适时的分配执行时间和内存。在每个程序中，或许存在多个线程，执行着不同的任务，那么系统对程序执行的管理实际上就是对程序中线程的管理，比如适时的将某个线程安排到负载较小的内核中执行，或者阻止正在运行的优先级较低的线程，给优先级较高的线程让路等。所以说线程的运转需要内核级别和应用程序级别相互协调，即内核级别负责将事件分发给不同的线程，并将线程安排在合理的内核上执行以及管理线程的优先级，而应用程序级别是通过代码管理和操控线程的属性及状态。</p>
<h3 id="u4E3A_u4EC0_u4E48_u8981_u4F7F_u7528_u7EBF_u7A0B"><a href="#u4E3A_u4EC0_u4E48_u8981_u4F7F_u7528_u7EBF_u7A0B" class="headerlink" title="为什么要使用线程"></a>为什么要使用线程</h3><p>回到iOS，我们开发的App至少都有一个线程，称之为主线程，线程中执行方法或函数的原则是先进先出原则，一个接一个的执行。假设在我们的App中有从远程下载图片的功能，并且该功能放在主线程中执行，那么当下载一个1080p高清图片时，就会需要耗费较长的时间，如果主线程中下载功能后面还有其他待执行的方法，那么只能等待下载功能完成之后，才能继续执行。所以此时对于用户来说，得不到任何来自App的响应，那么很容易认为是你的App出问题了，如此糟糕的用户体验，足以让用户将你的App打入冷宫甚至删除。</p>
<p>如果我们使用另外一个线程专门处理下载功能，那么该线程和主线程同时执行，对于用户而言，此时可以由主线程对用户做出合适的响应，而下载在另一个线程中同时进行着。所以使用线程对提高程序的用户体验、性能无疑是最好的方法。</p>
<h3 id="u4F7F_u7528_u7EBF_u7A0B_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898"><a href="#u4F7F_u7528_u7EBF_u7A0B_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898" class="headerlink" title="使用线程会导致的问题"></a>使用线程会导致的问题</h3><p>俗话说天下没有免费的午餐，诚然多线程能提高程序的性能、用户体验，但是在光鲜的背后还是要承担一定风险的。使用多线程势必会增加开发人员写代码花费的时间，因为代码的复杂度变高了，开发人员斟酌的频率就会变高，线程与线程之间有交互，容错率就会降低，开发人员调试的时间就会变多。由于多线程依然共享内存，所以会发生两个线程同时对某个数据进行操作，这样很容易使程序的执行结果发生错误。总而言之，多线程好，但使用时要知其根本，做到佩弦自急。</p>
<h2 id="u5B9E_u73B0_u591A_u4EFB_u52A1_u5E76_u53D1_u6267_u884C_u4EFB_u52A1_u7684_u89E3_u51B3_u65B9_u6848"><a href="#u5B9E_u73B0_u591A_u4EFB_u52A1_u5E76_u53D1_u6267_u884C_u4EFB_u52A1_u7684_u89E3_u51B3_u65B9_u6848" class="headerlink" title="实现多任务并发执行任务的解决方案"></a>实现多任务并发执行任务的解决方案</h2><p>因为线程本身相对比较低层，它实现程序中并发执行任务功能的方式也较为复杂，所以我们如果想使用好线程，那么就必须要真正理解线程，要明白在我们的程序中使用线程之后会带来哪些潜在的风险，所谓知己知彼方能百战不殆。同时，我们也不能滥用线程，该用的时候用，不该用的时候就不要画蛇添足。毕竟，使用线程会增加内存的消耗以及CPU得运算时间，要避免物极必反。在真正理解线程之前，我们先看看在OS X和iOS中提供的不那么底层的实现多任务并发执行的解决方案：</p>
<ul>
<li><p>Operation object：该技术出现在OS X 10.5中，通过将要执行的任务封装成操作对象的方式实现任务在多线程中执行。任务可以理解为你要想执行的一段代码。在这个操作对象中不光包含要执行的任务，还包含线程管理的内容，使用时通常与操作队列对象联合使用，操作队列对象会管理操作对象如何使用线程，所以我们只需要关心要执行的任务本身即可。</p>
</li>
<li><p>GCD：该技术出现在OS X 10.6中，它与Operation Object的初衷类似，就是让开发者只关注要执行的任务本身，而不需要去关注线程的管理。你只需要创建好任务，然后将任务添加到一个工作队列里即可，该工作队列会根据当前CPU性能及内核的负载情况，将任务安排到合适的线程中去执行。</p>
</li>
<li><p>Idle-time notification：该技术主要用于处理优先级相对比较低、执行时间比较短的任务，让应用程序在空闲的时候执行这类任务。Cocoa框架提供<code>NSNotificationQueue</code>对象处理空闲时间通知，通过使用<code>NSPostWhenIdle</code>选项，向队列发送空闲时间通知的请求。</p>
</li>
<li><p>Asynchronous functions：系统中有一些支持异步的函数，可以自动让你的代码并行执行。这些异步函数可能通过应用程序的守护进程或者自定义的线程执行你的代码，与主进程或主线程分离，达到并行执行任务的功能。</p>
</li>
<li><p>Timers：我们也可以在应用程序主线程中使用定时器去执行一些比较轻量级的、有一定周期性的任务。</p>
</li>
<li><p>Separate processes：虽然通过另起一个进程比线程更加重量级，但是在某些情况下要比使用线程更好一些，比如你需要的执行的任务和你的应用程序在展现数据和使用方面没有什么关系，但是可以优化你的应用程序的运行环境，或者提高应用程序获取数据的效率等。</p>
</li>
</ul>
<h2 id="u521D_u8BC6_u7EBF_u7A0B_u6982_u5FF5"><a href="#u521D_u8BC6_u7EBF_u7A0B_u6982_u5FF5" class="headerlink" title="初识线程概念"></a>初识线程概念</h2><h3 id="u7EBF_u7A0B_u6280_u672F"><a href="#u7EBF_u7A0B_u6280_u672F" class="headerlink" title="线程技术"></a>线程技术</h3><p>说到OS X和iOS中的线程技术，就不得不说GNU Mach。Apple操作系统中的线程技术是基于Mach线程技术实现的，所以本身就带有线程基本的特性，比如PEM。Mach线程我们几乎不会用到，一般编程中我们可能会使用POSIX API创建线程。</p>
<blockquote>
<p>GNU Mach：GNU是一个类UNIX操作系统，它采用GNU Hurd作为操作系统内核，而GNU Mach是基于GNU Hurd内核技术的微内核。<br>POSIX：可移植操作系统接口（Portable Operating System Interface of UNIX），它定义了操作系统应该为应用程序提供的接口标准， 是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称。<br>PEM：Preemptive Execution Model，以任务的优先级决定立即执行还是延后执行，或者安排至不同的内核执行。</p>
</blockquote>
<p>我们来看看OS X和iOS中主要的两种线程技术：</p>
<ul>
<li>Cocoa Threads：Cocoa框架中提供了<code>NSThread</code>和<code>NSObject</code>类供我们进行线程相关的操作。</li>
<li>POSIX Threads：POSIX的线程API实际是基于C语言的线程接口，这些接口在使用线程和配置线程方面更加容易和灵活。</li>
</ul>
<p>在应用程序层面，不管是什么平台，线程的运行方式都是大体相同的，在线程的运行过程中一般都会经历三种状态，即运行中、准备运行、阻塞。如果某个线程在当前处于不活跃状态，也即是非运行中状态，那么它有可能是处于阻塞状态并在等待执行任务的输入。也有可能已经有任务输入，处于准备运行状态，只是在等待被分派。当我们终止线程后，它会永久性的被系统回收，因为毕竟线程会占用一定的系统内存和CPU运算时间，所以一般情况下，我们放入二级线程（非主线程）中的任务都是比较重要和有意义的任务。</p>
<h3 id="RunLoops"><a href="#RunLoops" class="headerlink" title="RunLoops"></a>RunLoops</h3><p>上一节提到当线程终止后就会永久被系统收回，如果你还有任务需要另起线程执行，就要重新创建线程以及配置，但这也不是必须的，我们可以让线程在空闲的时候休眠，当有任务需要执行时唤醒，就像主线程一样，此时就要用到RunLoop。</p>
<p>简单的来说，RunLoop用于管理和监听异步添加到线程中的事件，当有事件输入时，系统唤醒线程并将事件分派给RunLoop，当没有需要处理的事件时，RunLoop会让线程进入休眠状态。这样就能让线程常驻在进程中，而不会过多的消耗系统资源，达到有事做事，没事睡觉的效果。</p>
<p>主线程中的RunLoop系统已经自动帮我们配置好了，但是我们自己创建的线程，还需要对RunLoop配置一番才可以使用，在后面的章节中都会有详细介绍。</p>
<h3 id="u540C_u6B65_u7B56_u7565"><a href="#u540C_u6B65_u7B56_u7565" class="headerlink" title="同步策略"></a>同步策略</h3><p>诚然，使用线程好处多多，但是之前也提到过，使用线程也是会存在一定问题的，那就是资源竞争，当两个线程在同一时间操作同一个变量时，就会产生问题。一种解决方案是让不同的线程拥有各自独有的变量，虽然可以解决问题，但不是最优方案。较为优雅一些的方案则是使用线程中的同步策略来解决该问题。</p>
<p>常用的同步策略有线程锁、状态位、原子操作。线程锁较为简单粗暴，简单的说当一个线程在操作变量时会挂上一把互斥锁，如果另一个线程先要操作该变量，它就得获得这把锁，但是锁只有一个，必须等第一个线程释放互斥锁后，才可以被其他线程获取，所以这样就解决了资源竞争的问题。状态位策略是通过线程或任务的执行情况生成一个状态，这个状态即像门卫又像协管员，一是阻止线程进行，二是以合适的执行顺序安排协调各个任务。第三个策略则是原子操作，相对前两个策略要更轻量级一些，它能通过硬件指令保证变量在更新完成之后才能被其他线程访问。</p>
<h3 id="u7EBF_u7A0B_u4E4B_u95F4_u7684_u4EA4_u4E92"><a href="#u7EBF_u7A0B_u4E4B_u95F4_u7684_u4EA4_u4E92" class="headerlink" title="线程之间的交互"></a>线程之间的交互</h3><p>虽然我们尽量让每个线程完成独立的任务，但是有些时候我们需要将二级线程中任务的执行结果发送到主线程中进一步进行操作，那么线程之间的交互就不可避免的发生，幸运的是进程中的线程是共享进程空间的，所以实现线程之间的交互也不是那么困难，比如通过发送messages、全局变量、同步策略等都可以实现，在后面的章节中都会有详细介绍。</p>
<h2 id="u4F7F_u7528_u7EBF_u7A0B_u65F6_u9700_u8981_u6CE8_u610F_u7684_u4E8B_u9879"><a href="#u4F7F_u7528_u7EBF_u7A0B_u65F6_u9700_u8981_u6CE8_u610F_u7684_u4E8B_u9879" class="headerlink" title="使用线程时需要注意的事项"></a>使用线程时需要注意的事项</h2><p>无规矩不成方圆，做任何事如果乱来，那必定会出现各种问题。因为线程相对比较底层，所以当我们对线程理解的不是特别透彻时直接创建线程，并手动管理线程，势必会出现正确性和性能上的各种问题，所以就有了这节对使用线程的一些建议。</p>
<h3 id="u907F_u514D_u76F4_u63A5_u521B_u5EFA_u7EBF_u7A0B"><a href="#u907F_u514D_u76F4_u63A5_u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="避免直接创建线程"></a>避免直接创建线程</h3><p>创建并管理线程在代码层面相对比较复杂和繁琐，一个不留神就会产生一些潜在的问题。OS X和iOS都提供了较为上层的创建使用线程的API，就是前面提到一些多任务并发执行的解决方案，比如GCD、Operation objects。使用它们可以帮我们规避在管理线程和处理线程性能方面可能出现的问题，提高多线程操作时的性能和健壮性。</p>
<h3 id="u8BA9_u7EBF_u7A0B_u6267_u884C_u6709_u4EF7_u503C_u7684_u4EFB_u52A1"><a href="#u8BA9_u7EBF_u7A0B_u6267_u884C_u6709_u4EF7_u503C_u7684_u4EFB_u52A1" class="headerlink" title="让线程执行有价值的任务"></a>让线程执行有价值的任务</h3><p>前文中提到过，线程消耗的系统资源不容小视，所以当我们手动创建和管理线程时，尤其要注意这一点。要保证另起线程执行的任务是有意义的、重要的任务，而且该终止的线程要终止，不要让线程有任何空闲时间，以保证系统资源的最优利用。</p>
<h3 id="u907F_u514D_u8D44_u6E90_u7ADE_u4E89"><a href="#u907F_u514D_u8D44_u6E90_u7ADE_u4E89" class="headerlink" title="避免资源竞争"></a>避免资源竞争</h3><p>进程中的线程是共享该进程空间的，所以很容易出现多个线程对同一个变量进行操作从而导致程序执行结果错误的情况。如果为每个线程都提供一份变量的拷贝，的确是可以解决这个问题，但是在开发中这样会造成更大的弊端，所以前文中提到了一些同步策略，能帮助我们达到线程交互及解决资源竞争的目的。但是在理论上还是会有出错的可能，比如让线程在指定的顺序下对某个变量依次进行操作。所以在程序设计阶段应该尽量避免线程之间的资源竞争及减少线程之间的交互。</p>
<h3 id="u7528_u6237_u754C_u9762_u4E0E_u7EBF_u7A0B"><a href="#u7528_u6237_u754C_u9762_u4E0E_u7EBF_u7A0B" class="headerlink" title="用户界面与线程"></a>用户界面与线程</h3><p>用户界面的更新、对用户事件的响应都应该放在主线程中，避免线程不安全的情况，以及能方便的管理UI界面。目前Cocoa框架默认对UI的操作都要在主线程中完成，即使不强制要求，我们也应该这样做。但是有一些情况比较特殊，比如对图片的处理，因为处理图片的过程并不是显性的，所以处理的过程可以放在二级线程中，当处理完成后，再在主线程中显示结果。这样可以有效的提升应用的性能。</p>
<h3 id="u6E05_u695A_u5F53_u7EBF_u7A0B_u7ED3_u675F_u65F6_u5E94_u8BE5_u505A_u4EC0_u4E48"><a href="#u6E05_u695A_u5F53_u7EBF_u7A0B_u7ED3_u675F_u65F6_u5E94_u8BE5_u505A_u4EC0_u4E48" class="headerlink" title="清楚当线程结束时应该做什么"></a>清楚当线程结束时应该做什么</h3><p>当用户退出应用后，理论上该应用进程中的所有线程都会立即被结束。但是如果此时正好有一个二级线程在后台处理其他任务，比如说下载或者正在存储一些数据。那么此时就要判断正在处理的这些任务是否要保留，如果要丢弃，那么直接结束所有线程即可，但是如果要保留，那么就需要主线程等待正在处理任务的二级线程，从而延迟应用退出。</p>
<p>这里处理时有两种情况，如果自行创建的线程并手动管理，那么要使用POSIX API创建具有<strong>joinable</strong>特性的二级线程，使主线程与之相关联。如果是使用Cocoa框架，那么可以使用<code>applicationShouldTerminate:</code>代理方法延迟应用关闭，当二级线程处理完任务后回调<code>replyToApplicationShouldTerminate:</code>通知到主线程，然后关闭应用。</p>
<h3 id="u5F02_u5E38_u5904_u7406"><a href="#u5F02_u5E38_u5904_u7406" class="headerlink" title="异常处理"></a>异常处理</h3><p>每个线程都有捕获当前任务在执行时产生的异常的责任，不论是主线程还是二级线程。如果二级线程产生的异常需要交由主线程处理是也不能任由其抛出，而是先将其捕获，然后向主线程发送消息，告知主线程当前的情况。当消息发出后二级线程可根据需求选择继续处理其他的任务还是终止线程。</p>
<h3 id="u5C3D_u53EF_u80FD_u5C11_u7684_u4F7F_u7528_u5E38_u9A7B_u7EBF_u7A0B"><a href="#u5C3D_u53EF_u80FD_u5C11_u7684_u4F7F_u7528_u5E38_u9A7B_u7EBF_u7A0B" class="headerlink" title="尽可能少的使用常驻线程"></a>尽可能少的使用常驻线程</h3><p>前文中提到过，可以为一些经常需要执行的、具有周期性的、量级较小的任务创建常驻线程，以减少创建关闭线程的资源消耗，但是不能滥用常驻线程。理论上，一个线程执行完任务后就应该关闭，并且关闭线程的最佳时机是执行完任务的后一秒。目的是为了避免空闲线程占用过多的资源从而导致一些潜在的问题。</p>
<h3 id="u786E_u4FDD_u7C7B_u5E93_u7684_u7EBF_u7A0B_u5B89_u5168"><a href="#u786E_u4FDD_u7C7B_u5E93_u7684_u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="确保类库的线程安全"></a>确保类库的线程安全</h3><p>如果我们在开发应用的相关功能，我们完全可以控制这块功能是否需要多线程去完成，但是当我们在开发一个供别人使用的类库时，就没法灵活的控制了。所以只能假设使用我们的类库必定会在多线程的环境中使用，这样我们可以通过锁机制确保线程安全。但是如果我们的类库没有在多线程环境中使用呢？那就会白白浪费掉对锁进行操作的相关资源，只能说使用锁机制可以保证类库线程安全的万无一失，但性能方面会大打折扣。</p>
<p>另一种方式是让使用我们类库的应用要对类库进行明确地初始化，不管是主线程还是二级线程，换句话说也就是让每个线程都有一份我们类库的内容，这样也可以有效的保证类库线程安全。在Cocoa框架中，还有一种可选的方式，就是可以为<code>NSWillBecomeMultiThreadedNotification</code>注册一个观察者，目的是当应用变为多线程环境时可以通知到我们的类库，从而采取相关措施，但这种方式不保险，有可能当类库已经被多线程环境中的代码使用后才收到通知。总而言之，如果开发类库，那么务必要确保其线程安全。</p>
<h2 id="u7EBF_u7A0B_u7684_u8D44_u6E90_u6D88_u8017"><a href="#u7EBF_u7A0B_u7684_u8D44_u6E90_u6D88_u8017" class="headerlink" title="线程的资源消耗"></a>线程的资源消耗</h2><p>在OS X和iOS中，每个应用其实就是一个进程，一个进程中由一个或多个线程组成，每个线程代表了所属应用中代码的执行路径。通常情况下应用始于主线程中的主函数，当需要有其他功能在二级线程中与主线程并行执行时，便可以创建其他二级线程。</p>
<p>一旦二级线程被创建，那么它就是一个独立的实体，线程与线程之间是没有任何关联的，它们有各自的执行堆栈，由内核单独为每个线程分派运行时的执行任务。虽然每个线程是独立实体，但是它们之间是可以相互交互的，在实际的应用中，这类需求是很常见的，因为它们共享所属进程的内存空间，并且拥有相同的读写权，所以也很容易实现线程之间的交互。既然一个应用中可能会有多个线程协作完成功能，所以管理线程就是重中之重了，这一章节会从线程的资源消耗、创建、配置、使用、关闭这几个关键点梳理实际运用中的线程管理。</p>
<p>线程的资源消耗主要分为三类，一类是内存空间的消耗、一类是创建线程消耗的时间、另一类是对开发人员开发成本的消耗。</p>
<p>内存空间的消耗又分为两部分，一部分是内核内存空间，另一部分是应用程序使用的内存空间，每个线程在创建时就会申请这两部分的内存空间。申请内核内存空间是用来存储管理和协调线程的核心数据结构的，而申请应用程序的内存空间是用来存储线程栈和一些初始化数据的。对于用户级别的二级线程来说，对应用程序内存空间的消耗是可以配置的，比如线程栈的空间大小等。下面是两种内存空间通常的消耗情况：</p>
<ul>
<li>内核内存空间：主要存储线程的核心数据结构，每个线程大约会占用1KB的空间。</li>
<li>应用程序内存空间：主要存储线程栈和初始化数据，主线程在OS X中大约占8MB空间，在iOS中大约占1MB。二级线程在两种系统中通常占大约512KB，但是上面提到二级线程在这块是可以配置的，所以可配置的最小空间为16KB，而且配置的空间大小必须是4KB的倍数。</li>
</ul>
<blockquote>
<p>注意：二级线程在创建时只是申请了内存程序空间，但还并没有真正分配给二级线程，只有当二级线程执行代码需要空间时才会真正分配。</p>
</blockquote>
<p>线程的创建时间取决于机器硬件的性能，但通常大约在90毫秒，虽然在我们看来90毫秒很短，但当频繁的创建线程时就会影响到CPU处理其他任务的时间。所以现在往往都会使用线程池，避免频繁的创建全新的线程。</p>
<p>前文中提到过设计和开发多线程的应用较单线程要复杂的多，要注意的事项在上文中就提出了八条，针对每条注意事项，都要花费不少时间去设计代码和测试。所以总体来说如果涉及到多线程，务必会增加开发人员的开发测试时间，但是换来的是应用程序具有更好的健壮性和高性能，所谓慢工出细活。</p>
<h2 id="u521B_u5EFA_u7EBF_u7A0B"><a href="#u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="创建线程"></a>创建线程</h2><p>说到创建线程，就得说说线程的两种类型，<strong>Joinable</strong>和<strong>Detach</strong>。Joinable类型的线程可以被其他线程回收其资源和终止。举个例子，如果一个Joinable的线程与主线程结合，那么当主线程准备结束而该二级线程还没有结束的时候，主线程会被阻塞等待该二级线程，当二级线程结束后由主线程回收其占用资源并将其关闭。如果在主线程还没有结束时，该二级线程结束了，那么它不但不会关闭，而且资源也不会被系统收回，只是等待主线程处理。而Detach的线程则相反，会自行结束关闭线程并且有系统回收其资源。</p>
<p>在OS X和iOS系统中有多种创建线程的方法，不同方法创建出的线程可能会有不同的线程属性，但就线程本身来说并没有什么差异。下面来看看创建线程的不同方法。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u4F7F_u7528NSThread_u521B_u5EFA_u7EBF_u7A0B"><a href="#u4F7F_u7528NSThread_u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="使用NSThread创建线程"></a>使用NSThread创建线程</h3><p>使用<code>NSThread</code>创建线程有两种方式：</p>
<ul>
<li><code>detachNewThreadSelector:toTarget:withObject:</code>：该方法是一个类方法，适用于OS X所有的版本和iOS2.0之后的版本。该方法其实完成了两个动作，先是创建线程，然后启动线程。通过方法名称就可以得知，该方法创建的线程为Detach类型的线程。</li>
<li>创建<code>NSThread</code>对象：这种方法适用于OS X 10.5之后的版本和iOS2.0之后的版本。该方法通过创建<code>NSThread</code>对象，使用它的<code>start()</code>方法启动线程，该方法的好处是可以在启动前通过<code>NSThread</code>对象的各个属性进行配置，待配置妥当后再调用<code>start()</code>方法启动线程。该方法创建的线程也是Detach类型的线程。</li>
</ul>
<h4 id="detachNewThreadSelector_3AtoTarget_3AwithObject_3A"><a href="#detachNewThreadSelector_3AtoTarget_3AwithObject_3A" class="headerlink" title="detachNewThreadSelector:toTarget:withObject:"></a>detachNewThreadSelector:toTarget:withObject:</h4><p>该方法有三个参数：</p>
<ul>
<li>selector：发送给线程的消息，或者说是让线程执行的任务。这里需要注意的是该任务最多只能有一个参数，并且不能有返回值。</li>
<li>target：在新的线程中接收消息的对象。</li>
<li>object：传给target对象的参数，也就是传入selector中的参数。</li>
</ul>
<p>下面来看一个简单示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"methodInSecondaryThread:"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="string">"I am a argument"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">methodInSecondaryThread</span><span class="params">(arg: String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(arg)</span> of event in Secondary Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>上述代码定义了一个类<code>TestThread</code>，包含两个方法<code>launch()</code>和<code>methodInSecondaryThread()</code>，<code>lanch()</code>方法中用<code>print()</code>函数模拟事件，在两个事件中创建一个二级线程，用于执行<code>methodInSecondaryThread()</code>方法，在该方法中执行其他事件。执行看看结果如何：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Terminating</span> app due to uncaught exception '<span class="type">NSInvalidArgumentException'</span>, reason: '*** -[<span class="type">NSThread</span> initWithTarget:selector:object:]: target does not implement selector (*** -[<span class="type">LearnThread</span>.<span class="type">TestThread</span> methodInSecondaryThread])'</span><br></pre></td></tr></table></figure>
<p>结果很不幸，报错了，原因很简单，因为我们的代码是Swift，而<code>NSThread</code>继承了<code>NSObject</code>是Objective-C世界的东西，所以需要对代码进行修改，有两种方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 让NSTread继承NSObject</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在methodInSecondaryThread()方法前添加@objc</span></span><br><span class="line"><span class="preprocessor">@objc</span> <span class="func"><span class="keyword">func</span> <span class="title">methodInSecondaryThread</span><span class="params">(arg: String)</span></span> &#123;</span><br></pre></td></tr></table></figure>
<p>我习惯让类继承<code>NSObject</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"methodInSecondaryThread:"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="string">"I am a argument"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">methodInSecondaryThread</span><span class="params">(arg: String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(arg)</span> of event in Secondary Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>继续运行看看效果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">First</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">Second</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br></pre></td></tr></table></figure>
<p>运行成功了，但似乎少点什么东西，<code>methodInSecondaryThread()</code>方法中的内容并没有打印出来，难道线程没有执行吗？我们通过Instruments可以看到，在运行过程中二级线程是创建过的：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-1.png" alt="LearnThread-1"></p>
<p>导致这个问题的原因和上文介绍的线程类型有关系。因为主线程运行很快，快到当主线程结束时我们创建的二级线程还没来得及执行<code>methodInSecondaryThread()</code>方法，而通过<code>detachNewThreadSelector:toTarget:withObject:</code>创建的二级线程是Detach类型的，没有与主线程结合，所以主线程也不会等待，当主线程结束，进程结束，二级线程自然也结束了。解决这个问题的办法就是让二级线程有执行任务的时间，所以我们可以让主线程停顿几秒，让二级线程完成它的任务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"methodInSecondaryThread:"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="string">"I am a argument"</span>)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">methodInSecondaryThread</span><span class="params">(arg: String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(arg)</span> of event in Secondary Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>再运行就可以看到正确地结果了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">First</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">I</span> am a argument of event <span class="keyword">in</span> <span class="type">Secondary</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">Second</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br></pre></td></tr></table></figure>
<h4 id="u521B_u5EFANSThread_u5BF9_u8C61"><a href="#u521B_u5EFANSThread_u5BF9_u8C61" class="headerlink" title="创建NSThread对象"></a>创建NSThread对象</h4><p>我们可以通过<code>initWithTarget:selector:object:</code>方法实例化一个<code>NSThread</code>对象，该方法的三个参数其实与<code>detachNewThreadSelector:toTarget:withObject:</code>方法的参数一样，只是顺序不一样而已：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> secondaryThread = <span class="type">NSThread</span>(target: <span class="keyword">self</span>, selector: <span class="string">"methodInSecondaryThread:"</span>, object: <span class="string">"I am a argument"</span>)</span><br><span class="line">        </span><br><span class="line">        secondaryThread.start()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">methodInSecondaryThread</span><span class="params">(arg: String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(arg)</span> of event in Secondary Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>上述的代码的运行结果自然也是一样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">First</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">I</span> am a argument of event <span class="keyword">in</span> <span class="type">Secondary</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">Second</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br></pre></td></tr></table></figure>
<p>这种方法依然只能在二级线程中执行最多只有一个参数的函数或方法，如果想要执行多参数的任务，可以将参数放入集合中传递，当然被执行的任务得能正确接收到参数集合。或者可以通过另外一种方法，那就是通过创建继承<code>NSThread</code>的类，然后重写<code>main()</code>方法来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomThread</span>: <span class="title">NSThread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> arg1: <span class="type">String</span>!</span><br><span class="line">    <span class="keyword">var</span> arg2: <span class="type">String</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(arg1: <span class="type">String</span>, arg2: <span class="type">String</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.arg1 = arg1</span><br><span class="line">        <span class="keyword">self</span>.arg2 = arg2</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(<span class="keyword">self</span>.arg1)</span>, <span class="subst">\(<span class="keyword">self</span>.arg2)</span>, we are the arguments in Secondary Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> customThread = <span class="type">CustomThread</span>(arg1: <span class="string">"I am arg1"</span>, arg2: <span class="string">"I am arg2"</span>)</span><br><span class="line">        </span><br><span class="line">        customThread.start()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">methodInSecondaryThread</span><span class="params">(arg: String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(arg)</span> of event in Secondary Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，我们创建了<code>CustomThread</code>类，并继承了<code>NSThread</code>，然后通过初始化方法传参，再重写<code>main()</code>方法处理相关任务。执行结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">First</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">I</span> am arg1, <span class="type">I</span> am arg2, we are the arguments <span class="keyword">in</span> <span class="type">Secondary</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">Second</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528NSObject_u521B_u5EFA_u7EBF_u7A0B"><a href="#u4F7F_u7528NSObject_u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="使用NSObject创建线程"></a>使用NSObject创建线程</h3><p>在OS X和iOS中，<code>NSObject</code>对象本身就具有创建线程的能力，所以只要是继承了<code>NSObject</code>的类自然也具备这个能力：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line"></span><br><span class="line">        performSelectorInBackground(<span class="string">"performInBackground"</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">performInBackground</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I am a event, perform in Background Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>上述代码中的<code>TestThread</code>类继承了<code>NSObject</code>类，那么就可以通过<code>performSelectorInBackground:withObject:</code>方法创建二级线程，该方法只有两个参数：</p>
<ul>
<li>selector：发送给线程的消息，或者说是让线程执行的任务。这里需要注意的是该任务最多只能有一个参数，并且不能有返回值。</li>
<li>object：传给target对象的参数，也就是传入selector中的参数。</li>
</ul>
<p>该方法创建的线程也是Detach类型的。以上这几种方式都是基于Cocoa框架实现的，大家可以使用<code>NSThread</code>的类方法<code>isMultiThreaded</code>去检验，在合适的地方插入这行代码<code>print(NSThread.isMultiThreaded())</code>，看看程序的线程状态。</p>
<h3 id="u4F7F_u7528POSIX_API_u521B_u5EFA_u7EBF_u7A0B"><a href="#u4F7F_u7528POSIX_API_u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="使用POSIX API创建线程"></a>使用POSIX API创建线程</h3><p>在OS X和iOS中，可以通过POSIX API创建线程，上文中提到过，POSIX的线程API实际是基于C语言的线程接口，这些接口在使用线程和配置线程方面更加容易和灵活，移植性也比较强，但由于相对较为底层，如果不熟悉C语言，上手成本会比较高,<code>NSThread</code>就是基于POSIX线程API封装而成的。</p>
<p>POSIX API通过<code>int pthread_create(pthread_t *restrict thread, const pthread_attr_t *restrict attr, void *(*start_routine)(void *), void *restrict arg);</code>函数创建线程：</p>
<ul>
<li>thread：线程标识符。</li>
<li>attr：线程属性设置。</li>
<li>start_routine：线程函数的起始地址。</li>
<li>arg：传递给start_routine的参数。</li>
<li>返回值：成功返回0，出错返回-1。</li>
</ul>
<p>大体的参数其实和使用<code>NSThread</code>创建线程基本一致，不过需要注意的是通过<code>pthread_create()</code>创建的线程是Joinable类型的，如果要将新线程设置为Detach类型，需要在创建前使用<code>pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</code>函数设置其线程属性。</p>
<p>在Cocoa框架中，上文提到的那些同步机制，比如线程锁，当二级线程创建后才就会自动生成。如果在程序中使用POSIX API创建线程，那么Cocoa框架是无法得知当前程序已处于多线程状态的，所以就不会自动开启相关的同步机制，而当我们又没有通过POSIX API手动控制的话，就有可能导致应用程序崩溃的情况。另外要注意的一点是Cocoa框架中的线程锁是不能操作通过POSIX API创建的线程的，反之亦然。所以当Cocoa框架与POSIX API混用的时候，在同步机制方面一定要配套使用。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" ]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="Thread" scheme="http://www.devtalking.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用TVML开发tvOS应用教程]]></title>
    <link href="http://www.devtalking.com//articles/develop-tvos-app-with-tvml/"/>
    <id>http://www.devtalking.com//articles/develop-tvos-app-with-tvml/</id>
    <published>2015-12-30T16:00:00.000Z</published>
    <updated>2016-08-19T00:53:23.000Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>作者：<a href="http://www.raywenderlich.com/u/Kelvin%20Lau" target="_blank" rel="external">Kelvin Lau</a> 原文地址：<a href="http://www.raywenderlich.com/114886/beginning-tvos-development-with-tvml-tutorial" target="_blank" rel="external">Beginning tvOS Development with TVML Tutorial</a></p>
<p>在2015年9月9日的产品发布会中，Apple宣布了新一代的Apple TV以及tvOS，并且在tvOS中集成了App Store。这使得我们多年以来想在Apple TV上开发专属应用的梦想成真了。</p>
<p>我和其他教程团队的成员已经开始深入研究tvOS SDK，并且正在努力为你们准备一些有价值的tvOS教程。在你开这篇文章之前，Chris Wagner已经写了一篇关于tvOS初步印象的<a href="http://www.raywenderlich.com/114313/tvos-initial-impressions" target="_blank" rel="external">文章</a>，我也基于这篇文章，设计了第一个tvOS的教程。</p>
<blockquote>
<p>译者注：可参阅Chris Wagner文章的中译版<a href="http://www.devtalking.com/articles/tvOS-initial-impression/">一个iOS开发者对tvOS SDK的初探</a>。</p>
</blockquote>
<p>在这篇教程中，你将会使用TVML开发你的第一款tvOS应用。信不信由你，你将会使用JavaScript管理你应用的逻辑以及创建TVML模板来展现你应用的UI。</p>
<p>当教程结束后，你应该可以基本理解如果通过TVML和TVJS管理、控制tvOS应用。现在就我们开始吧。</p>
<blockquote>
<p>注意：该教程需要Xcode7.1或更高的版本，你们可以在这里<a href="https://developer.apple.com/xcode/download/" target="_blank" rel="external">下载</a>。虽然你们可以跟着该教程一步一步的进行操作，但我还是建议你们能储备一些基本的JavaScript知识。</p>
</blockquote>
<h2 id="u9009_u62E9_u5F00_u53D1_u65B9_u5F0F"><a href="#u9009_u62E9_u5F00_u53D1_u65B9_u5F0F" class="headerlink" title="选择开发方式"></a>选择开发方式</h2><p>Apple为开发tvOS应用提供了两种方式：</p>
<ol>
<li><strong>TVML Apps</strong>：这类应用是使用完整的新开发技术开发的，比如TVML、TVJS、TVMLKit。在稍后我会解释这些简称的含义以及如何使用它们。</li>
<li><strong>Custom Apps</strong>：这类应用是使用我们已经比较熟悉的开发技术进行开发的，比如大家熟知的一些iOS框架和特性，像Storyboard、UIKit、Auto Layout等。</li>
</ol>
<p>这两种方式没有孰优孰劣之分，都是Apple推荐的方法，只是按需所取，以及你更想尝试哪种方式。</p>
<p>在这篇教程中，你们的目标是开发以个能播放<a href="http://www.rwdevcon.com/" target="_blank" rel="external">RWDevCon</a>讨论视频的tvOS应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-1.gif" alt="tvOS-1"></p>
<p>虽然用上述两种方式都可以开发这个应用，但是使用TVML会更加容易一些。所以这就是你在这篇教程中要学和要做的东西。</p>
<h2 id="u4EC0_u4E48_u662FTVML_uFF1F"><a href="#u4EC0_u4E48_u662FTVML_uFF1F" class="headerlink" title="什么是TVML？"></a>什么是TVML？</h2><p>正如我刚才提到的，第一种开发tvOS应用的方式是通过TVML、TVJS和TVMLKit这些新的技术实现的。如果你们对这些简称比较陌生，不要惊慌，因为他们本就是新鲜玩意。这里我简单解释一下：</p>
<ul>
<li><strong>TVML</strong>是一种XML格式，基于“Television Markup Language”。</li>
<li><strong>TVJS</strong>是基于JavaScript APIs的脚本语言，它可以根据TVML中定义的内容展示应用。</li>
<li><strong>TVMLKit</strong>是连接TVML、TVJS和原生tvOS应用的工具包。</li>
</ul>
<p>如果你是一名经常使用原生API开发原生iOS应用的开发者，那么看到这些类似前端的技术可能会有点退缩。但希望你能保持一颗学习的心，学习了解这些新的强大的特性。</p>
<p>我在这列举一个非常典型的Apple TV的应用场景。大家可以想象一下：你们想把一些内容或信息展现给用户，这些内容和信息储存在你们的服务器上，并且这些内容的格式、查询方式都服务于iPhone或iPad中的应用，那么你肯定会希望你的tvOS中的应用也能方便的使用这些内容，并做到与iOS中应用有相似的展现、查询、导航方式。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-2.jpg" alt="tvOS-2"></p>
<p>上述的这个场景恰恰是我们这片教程中的场景。我们已经有<a href="http://www.rwdevcon.com/" target="_blank" rel="external">RWDevCon</a>网站，上面有许多技术讨论视频，所以运用TVML模板应该很容易实现。并且我们也没有很严格的用户界面的需求，所以我们可以简单方便的使用Apple提供的UI<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">模板</a>。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-3.jpg" alt="tvOS-3"></p>
<p>简而言之：</p>
<ul>
<li><strong>开发TVML App</strong>：如果你主要是通过tvOS应用展现一些内容，不论是音频、视频、文本、图片，并且你已经有服务器存储这些资源。那么使用TVML开发是不错的选择。</li>
<li><strong>开发Custom App</strong>：如果你希望用户不只是被动的通过你的tvOS应用观看或收听内容，而是希望用户与应用有更多的交互，给用户高质量的用户体验。那么你应该选择使用iOS的相关技术开发自定义的应用。</li>
</ul>
<p>现在你们已经大概了解了TVML是如何工作的，以及我们为什么要在这篇教程中使用TVML开发tvOS应用。想要更深入的了解，最好的办法就是由你们在实践中去学习、理解了。让我们开始动手吧！</p>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先你们要确保已经下载并安装了Xcode7.1或更高版本。</p>
<p>然后通过 <strong>File\New\Project</strong> 创建新工程，在侧边栏选择 <strong>tvOS\Application\Single View Application</strong> 模板，然后点击 <strong>Next</strong>：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-4.png" alt="tvOS-4"></p>
<p>项目名称输入 <strong>RWDevCon</strong> ,语言选择 <strong>Swift</strong> ，确保下面的两个复选框为未选中状态，也就是不使用Core Data和单元测试，然后点击 <strong>Next</strong>：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-5.png" alt="tvOS-5"></p>
<p>选择一个目录，点击 <strong>Save</strong> 保存你的项目。Xcode会为你创建一个带有Storyboard的空工程（如果你开发自定义UI的tvOS应用，那么你需要使用Storyboard）。</p>
<p>然而在该教程中你不需要使用Storybard，因为我们会使用TVML来展示应用的UI，而不是用Storybard去设计UI。所以将 <strong>Main.storyboard</strong> 和 <strong>ViewController.swift</strong> 删去，在提示框中选择 <strong>Move To Trash</strong> 彻底删除。</p>
<p>接着打开 <strong>Info.plist</strong> 文件，删掉<code>Main storybaord file base name</code>属性。最后添加新的属性<code>App Transport Security Settings</code>（区分大小写），以及它的子属性<code>Allow Arbitrary Loads</code>，并将其值设为<code>YES</code>。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-6.png" alt="tvOS-6"></p>
<blockquote>
<p>注意：在iOS9中，Apple不允许应用链接非HHTPS协议的服务，所以刚才的操作是很有必要的，因为在该教程中，你们将会以HTTP协议访问本地的服务器，所以你需要在Info.plist中添加上述属性以便允许应用通过HTTP协议访问服务器。</p>
</blockquote>
<h2 id="u52A0_u8F7D_u4F60_u7684TVML"><a href="#u52A0_u8F7D_u4F60_u7684TVML" class="headerlink" title="加载你的TVML"></a>加载你的TVML</h2><p>tvOS应用的生命周期开始于AppDelegate。在这里，你将创建<code>TVApplicationController</code>以及应用上下文，并将它们传给主要的JavaScript文件。</p>
<p>打开<strong>AppDelegate.swift</strong>并做下面这些事：</p>
<ul>
<li>删除所有的方法。</li>
<li>导入<code>TVMLKit</code>。</li>
<li>使AppDelegate遵循<code>TVApplicationControllerDelegate</code>协议。</li>
</ul>
<p>当完成这些事后，你的<strong>AppDelegate.swift</strong>看起来应该像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> TVMLKit</span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span>, <span class="title">TVApplicationControllerDelegate</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> window: <span class="type">UIWindow</span>?</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着添加下面这些属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> appController: <span class="type">TVApplicationController</span>?</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> <span class="type">TVBaseURL</span> = <span class="string">"http://localhost:9001/"</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> <span class="type">TVBootURL</span> = <span class="string">"<span class="subst">\(AppDelegate.TVBaseURL)</span>js/application.js"</span></span><br></pre></td></tr></table></figure>
<p><code>TVApplicationController</code>是<code>TVMLKit</code>中的一个类，它负责与你的服务器的交互。<code>TVBaseURL</code>和<code>TVBootURL</code>包含了你的服务器的地址和JavaScript文件的地址，该JavaScript文件稍后会运行在你的服务器中。</p>
<p>接在在AppDelegate中添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  window = <span class="type">UIWindow</span>(frame: <span class="type">UIScreen</span>.mainScreen().bounds)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> appControllerContext = <span class="type">TVApplicationControllerContext</span>()</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> javaScriptURL = <span class="type">NSURL</span>(string: <span class="type">AppDelegate</span>.<span class="type">TVBootURL</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"unable to create NSURL"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  appControllerContext.javaScriptApplicationURL = javaScriptURL</span><br><span class="line">  appControllerContext.launchOptions[<span class="string">"BASEURL"</span>] = <span class="type">AppDelegate</span>.<span class="type">TVBaseURL</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  appController = <span class="type">TVApplicationController</span>(context: appControllerContext, window: window, delegate: <span class="keyword">self</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码相对还是比较容易理解的：</p>
<ol>
<li>这里你首先创建了一个应用上下文<code>TVApplicationControllerContext</code>的实例，用于稍后初始化你的<code>TVApplicationController</code>。你可以理解为给一个简单的对象设置了一些属性，比如服务器的URL，然后该对象又作为属性设置给了另一个对象。</li>
<li>给应用上下文这个对象实例设置了两个简单的属性：主JavaScript文件的路径和服务器的地址。</li>
<li>通过你刚才设置好的应用上下文初始化<code>TVApplicationController</code>。此时就完全由Apple代码来接管了，他会加载到你的主JavaScript文件，并开始执行其内容。</li>
</ol>
<p>所以到目前为止，是时候让Xcode休息一会了，因为接下来你们将要编写JavaScript了。</p>
<h2 id="The_JavaScript"><a href="#The_JavaScript" class="headerlink" title="The JavaScript"></a>The JavaScript</h2><p>在客户端-服务端这类的tvOS应用中，你的JavaScript文件通常在应用连接的服务器中。在该教程中，你们将会在Mac上搭建一个简单的服务器。</p>
<h3 id="u5BA2_u6237_u7AEF_u4EE3_u7801"><a href="#u5BA2_u6237_u7AEF_u4EE3_u7801" class="headerlink" title="客户端代码"></a>客户端代码</h3><p>为了方便起见，我们把JavaScript文件放在桌面，在你们的 <strong>桌面</strong> 文件夹中新建一个文件夹名为 <strong>client</strong> 。在client文件夹中再新建一个文件夹名为 <strong>js</strong> 。该文件夹将作为你的JavaScript文件的容器。</p>
<p>通过你使用的编辑JavaScript的IDE，新建一个JavaScript文件，名为 <strong>application.js</strong> ，将它保存在你刚才新建的 <strong>js</strong> 文件夹中。然后在 <strong>application.js</strong> 中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">App</span>.onLaunch = function(options) &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> alert = createAlert(<span class="string">"Hello World"</span>, <span class="string">""</span>); <span class="comment">//第二个参数传入空字符串</span></span><br><span class="line">  navigationDocument.presentModal(alert);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> createAlert = function(title, description) &#123;</span><br><span class="line">  <span class="keyword">var</span> alertString = `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">    &lt;document&gt;</span><br><span class="line">      &lt;alertTemplate&gt;</span><br><span class="line">        &lt;title&gt;$&#123;title&#125;&lt;/title&gt;</span><br><span class="line">        &lt;description&gt;$&#123;description&#125;&lt;/description&gt;</span><br><span class="line">      &lt;/alertTemplate&gt;</span><br><span class="line">    &lt;/document&gt;`</span><br><span class="line">    <span class="keyword">var</span> parser = new <span class="type">DOMParser</span>();</span><br><span class="line">    <span class="keyword">var</span> alertDoc = parser.parseFromString(alertString, <span class="string">"application/xml"</span>);</span><br><span class="line">    <span class="keyword">return</span> alertDoc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>App.onLaunch</code>是处理JavaScript文件的入口方法。之前在 <strong>AppDelegate.swift</strong> 中已经初始化好的<code>TVApplicationController</code>会将<code>TVApplicationControllerContext</code>传到这。之后你会使用到上下文中的内容，但是现在，我们只创建一个简单的提示界面并显示在屏幕上。</p>
<ol>
<li>通过下面定义的<code>createAlert</code>函数，我们获得到了为我们展现界面的TVML文件。<code>navigationDocument</code>类似于iOS中的<code>UINavigationController</code>，它提供像栈一样的方式，可以推出或压进展现界面的TVML文件。</li>
<li><code>createAlert</code>是一个返回TVML文件的函数，你可以将它看作类似iOS中的<code>UIAlertController</code>。</li>
</ol>
<p>写到这顺便提一下，Apple已经提供了18种TVML模板供我们使用，你们可以在该<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">Apple TV Markup Language Reference</a>中查阅完成的模板列表。</p>
<p>上述代码中的 <strong>alertTemplate</strong> 就是这18个模板中的其中一个，它的主要用于展示重要信息，比如通过一段消息提示用户在继续操作之前需要执行其他的操作等。此时，距离你们编译运行你们的第一个tvOS应用已为时不远了。</p>
<h3 id="u914D_u7F6E_u670D_u52A1_u5668"><a href="#u914D_u7F6E_u670D_u52A1_u5668" class="headerlink" title="配置服务器"></a>配置服务器</h3><p>打开 <strong>Terminal</strong> 输入如下命令：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd ~/<span class="type">Desktop</span>/client</span><br><span class="line">python -m <span class="type">SimpleHTTPServer</span> <span class="number">9001</span></span><br></pre></td></tr></table></figure>
<p>这两行命令的作用是在先前创建的client目录中开启一个基于Python的web服务器。现在，你们可以准备起飞了！</p>
<p>回到你的Xcode项目中编译运行程序。你应该可以看到你的第一个tvOS TVML应用了！</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-7.png" alt="tvOS-7"></p>
<p>我不知道你们的感觉如何，但是当我第一次运行成功后，我的感受就像下面这个家伙一样：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-8.png" alt="tvOS-8"></p>
<p>在继续进行教程之前，我想花点时间对你们目前已经完成的工作作以总结：</p>
<ol>
<li>你们创建了<code>TVApplicationController</code>实例。它用于管理JavaScript代码。</li>
<li>你们创建了<code>TVApplicationControllerContext</code>实例，并在创建<code>TVApplicationController</code>时将其与之关联。应用上下文有一个<code>launchOption</code>属性，用来构建我们的<code>BASEURL</code>，也就是服务器的地址。该应用上下文也用于配置tvOS应用与哪个服务器连接。</li>
<li>控制器被传到了JavaScript代码中。<code>App.onLaunch</code>作为整个JavaScript文件的入口方法，你们定义了<code>createAlert</code>函数，返回TVML提示信息模板文件，并由<code>navigationDocument</code>管理并展现界面。最后将“Hello World”显示在屏幕上。</li>
</ol>
<p>即使现在你们使用的服务器是运行在本机的，但是你们仍然可以连接一个真实的远程的服务器，可能是一个连着数据库的服务器。你们感受并想象一下应用场景，应该会很酷，对吧？</p>
<h2 id="u5B8C_u5584TVML_u6A21_u677F"><a href="#u5B8C_u5584TVML_u6A21_u677F" class="headerlink" title="完善TVML模板"></a>完善TVML模板</h2><p>我之前提到过，<code>createAlert</code>是一个返回TVML模板文件的函数。有很多属性可由我们在TVML文件中编辑修改，作为一个实验性质的小例子，你们将会在当前的 <strong>alertTemplate</strong> 中添加一个按钮。回到你们的JavaScript代码中，将目光聚焦在<code>createAlert</code>函数上，在模板中添加一个按钮：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> alertString = `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;alertTemplate&gt;</span><br><span class="line">      &lt;title&gt;$&#123;title&#125;&lt;/title&gt;</span><br><span class="line">      &lt;description&gt;$&#123;description&#125;&lt;/description&gt;</span><br><span class="line">      &lt;button&gt;</span><br><span class="line">        &lt;text&gt;<span class="type">OK</span>&lt;/text&gt;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/alertTemplate&gt;</span><br><span class="line">  &lt;/document&gt;`</span><br></pre></td></tr></table></figure>
<p>这里解释一下上述代码：</p>
<ol>
<li>一个TVML文件的第一级标签是<code>&lt;document&gt;</code>，也就是整个模板内容是由<code>&lt;document&gt;</code>和<code>&lt;/document&gt;</code>包起来的。</li>
<li>接着你们开始定义模板。使用Apple提供的 <strong>alertTemplate</strong> 模板，通过<code>createAlert</code>函数将其返回。</li>
<li>在该模板里，根据Apple的<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">Apple TV Markup Language Reference</a>文档规范，添加了按钮、标题、描述三个标签。</li>
</ol>
<p>保存你们刚才编辑的JavaScript文件，再次编译运行。你们看到在提示信息下面出现了一个按钮。瞧，TVML是不是将构建tvOS UI变得很简单！</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-9.png" alt="tvOS-9"></p>
<blockquote>
<p>注意：在一个模板中，你能添加的元素数量和类型基于这个的模板的类型。比如，一个 <strong>loading Template</strong> 就不允许有任何按钮出现。此外，你可以自定义字体、颜色和其他一些属性。但是这些知识已经超越了该教程的范畴。你们可以查阅<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/index.html#//apple_ref/doc/uid/TP40015064-CH41-SW1" target="_blank" rel="external">Apple TV Markup Language Reference</a>文档去了解更多TVML模板的信息。</p>
</blockquote>
<h2 id="u4E30_u5BCCJavaScript_u5BA2_u6237_u7AEF"><a href="#u4E30_u5BCCJavaScript_u5BA2_u6237_u7AEF" class="headerlink" title="丰富JavaScript客户端"></a>丰富JavaScript客户端</h2><p>到目前为止，你们已经完成了一些工作，并且正按照我们的指引一步一步达成目标。在这一节中，你们将要花一点时间在不同的JavaScript文件中将一些逻辑抽象出来，便于能更好的重用。</p>
<p>在 <strong>client/js</strong> 文件夹中新建一个JavaScript文件，名为 <strong>Presenter.js</strong> 。在该文件中，你们将定义<code>Presenter</code>类用于处理导航各个界面，或者说各个TVML模板文件，并且处理事件响应。在 <strong>Presenter.js</strong> 中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Presenter</span> = &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  makeDocument: function(resource) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="type">Presenter</span>.parser) &#123;</span><br><span class="line">      <span class="type">Presenter</span>.parser = new <span class="type">DOMParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> doc = <span class="type">Presenter</span>.parser.parseFromString(resource, <span class="string">"application/xml"</span>);</span><br><span class="line">    <span class="keyword">return</span> doc;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  modalDialogPresenter: function(xml) &#123;</span><br><span class="line">    navigationDocument.presentModal(xml);</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  pushDocument: function(xml) &#123;</span><br><span class="line">    navigationDocument.pushDocument(xml);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们解释一下上述代码：</p>
<ol>
<li>还记得你们在之前<code>createAlert</code>函数中用过的<code>DOMParser</code>类么，它可以将TVML字符串转换为可用于展示的TVML模板对象。因为该类不需要多次创建实例，所以采用单例模式创建它。然后通过<code>DOMParser</code>的<code>parseFormString()</code>方法将TVML字符串转为模板对象。</li>
<li><code>modalDialogPresenter</code>方法通过传入的TVML模板文件，将其模态的展现在屏幕上。</li>
<li><code>pushDocument</code>方法是在导航栈中推送一个TVML模板文件，相当于在iOS中push出一个界面。</li>
</ol>
<p>在之后，你们还会用到<code>Presenter</code>类管理选中处理操作。现在，让我们使用<code>Presenter</code>类对之前的JavaScript代码进行重构。将<code>App.onLaunch</code>中的代码替换为如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">App</span>.onLaunch = function(options) &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> javascriptFiles = [</span><br><span class="line">    `$&#123;options.<span class="type">BASEURL</span>&#125;js/<span class="type">Presenter</span>.js`</span><br><span class="line">  ];</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  evaluateScripts(javascriptFiles, function(success) &#123;</span><br><span class="line">    <span class="keyword">if</span>(success) &#123;</span><br><span class="line">      <span class="keyword">var</span> alert = createAlert(<span class="string">"Hello World!"</span>, <span class="string">""</span>);</span><br><span class="line">      <span class="type">Presenter</span>.modalDialogPresenter(alert);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 3 Handle the error CHALLENGE!//inside else statement of evaluateScripts. </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码相对还是比较容易理解的，我们来看一下：</p>
<ol>
<li>首先创建一个新的JavaScript文件的数组。然后通过<code>options</code>参数获取到<code>BASEURL</code>属性，并组装<code>Presenter.js</code>的路径。这里的<code>options</code>就是之前我们在<code>AppDelegate</code>类中创建的<code>TVApplicationControllerContext</code>，<code>BASEURL</code>自然也是那时我们设置的。</li>
<li><code>evaluateScripts</code>将加载JavaScript文件。</li>
<li>这里，你应该处理异常信息，稍后我们完善这里。</li>
</ol>
<p>在继续进行之前，编译运行程序，确保JavaScript文件修改过之后程序仍能正常运行。此时，我们通过<code>Presenter</code>类对JavaScript代码的重构有了一个良好的开端：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-10.png" alt="tvOS-10"></p>
<p>现在，看看上面代码中被注释的那行，你们能否自行完成对异常处理的挑战呢。如果<code>evaluateScripts</code>处理失败，可能是因为JavaScript文件的路径写错了，那么你可能会希望在此时显示一个提示消息给用户。<strong>提示：</strong> 之所以在这里出现了异常，是因为<code>Presenter</code>类加载失败导致，所以在这里你不能使用<code>Presenter</code>类显示提示信息的界面。</p>
<p>你应该通过之前所学到的知识来解决该问题。如果你们觉得有困难，那么可以参照下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//将这两行代码插入evaluateScripts的else代码块中. </span></span><br><span class="line"><span class="keyword">var</span> errorDoc = createAlert(<span class="string">"Evaluate Scripts Error"</span>, <span class="string">"Error attempting to evaluate external JavaScript files."</span>);</span><br><span class="line">navigationDocument.presentModal(errorDoc);</span><br></pre></td></tr></table></figure>
<p>想要测试错误信息，你们可以修改一下JavaScript文件的路径，比如把<code>Presenter.js</code>改为<code>Presentr.js</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$&#123;options.<span class="type">BASEURL</span>&#125;js/<span class="type">Presentr</span>.js</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u4F7F_u7528CatalogTemplate"><a href="#u4F7F_u7528CatalogTemplate" class="headerlink" title="使用CatalogTemplate"></a>使用CatalogTemplate</h2><p><strong>catalogTemplate</strong>模板同样也是Apple提供的18个模板中的一个。它的作用是以分组的形式展现内容，用它来展示你们最喜欢的RWDevCon视频最好不过了！ <strong>catalogTemplate</strong>有许多有意思的元素：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-11.jpg" alt="tvOS-11"></p>
<h3 id="u590D_u5408_u5143_u7D20_u548C_u7B80_u5355_u5143_u7D20"><a href="#u590D_u5408_u5143_u7D20_u548C_u7B80_u5355_u5143_u7D20" class="headerlink" title="复合元素和简单元素"></a>复合元素和简单元素</h3><p>该模板中的<code>banner</code>元素在应用顶部，用于展示应用基本信息，比如名称、标题等。它本身是一个 <strong>复合元素</strong> ，也就是说它是由多个 <strong>简单元素</strong> 组合而成。比如，在<code>banner</code>中很显然有标题，那么该标题就是一个简单的<code>title</code>元素，并且在<code>title</code>背后还有背景图片，这又是另外一个简单元素<code>background</code>。所以<code>banner</code>是由两个简单元素组合而成。</p>
<p>让我们来试试这个模板吧。打开 <strong>client</strong> 文件夹，在 <strong>js</strong> 文件夹的同级目录新建两个文件夹，分别命名为 <strong>images</strong> 和 <strong>templates</strong> 。此时你的 <strong>client</strong> 文件夹里的内容应该是这样的：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-12.png" alt="tvOS-12"></p>
<p>你们会需要图片构建模板中的Cells，在我们这个场景中就是一个一个的视频，图片自然就是视频的封面了。我已经为你们准备好了封面图片，你们可以从<a href="/cdn3.raywenderlich.com/wp-content/uploads/2015/09/images.zip">这里下载</a>。下载成功后，将他们解压放在刚才你们创建的 <strong>images</strong> 文件夹中。</p>
<p>现在，你们即将要做的工作是在屏幕中显示图片!新建一个JavaScript文件，命名为 <strong>RWDevConTemplate.xml.js</strong> ，将其存在 <strong>templates</strong> 文件夹中。</p>
<p>打开 <strong>RWDevConTemplate.xml.js</strong> ，添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Template</span> = function() &#123; <span class="keyword">return</span> `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;catalogTemplate&gt;</span><br><span class="line">      &lt;banner&gt;</span><br><span class="line">        &lt;title&gt;<span class="type">RWDevConHighlights</span>&lt;/title&gt;</span><br><span class="line">      &lt;/banner&gt;</span><br><span class="line">    &lt;/catalogTemplate&gt;</span><br><span class="line">  &lt;/document&gt;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们试图通过<code>catalogTemplate</code>模板显示一个Banner条。但在使用只包含模板信息的JavaScript文件之前，我们需要通过某种方法让其他的JavaScript文件知道该文件的存在并能加载其模板信息，因为当前它没有通过任何方式向其他JavaScript文件暴露过。所以我们要创建的最后一个JavaScript文件： <strong>ResourceLoader.js</strong> 就是用来解决该问题的！</p>
<h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>新建一个JavaScript文件，命名为 <strong>ResourceLoader.js</strong> ，保存在 <strong>js</strong> 文件夹中，和 <strong>application.js</strong> 、 <strong>Presenter.js</strong> 一起。打开 <strong>ResourceLoader.js</strong> 添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function <span class="type">ResourceLoader</span>(baseurl) &#123;</span><br><span class="line">  this.<span class="type">BASEURL</span> = baseurl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">ResourceLoader</span>.prototype.loadResource = function(resource, callback) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">self</span> = this;</span><br><span class="line">  evaluateScripts([resource], function(success) &#123;</span><br><span class="line">    <span class="keyword">if</span>(success) &#123;</span><br><span class="line">      <span class="keyword">var</span> resource = <span class="type">Template</span>.call(<span class="keyword">self</span>);</span><br><span class="line">      callback.call(<span class="keyword">self</span>, resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> title = <span class="string">"Resource Loader Error"</span>,</span><br><span class="line">          description = `<span class="type">Error</span> loading resource '$&#123;resource&#125;'. \n\n <span class="type">Try</span> again later.`,</span><br><span class="line">          alert = createAlert(title, description);</span><br><span class="line">      navigationDocument.presentModal(alert);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不用过于担心看不懂这些代码逐行的含义，你们只要清楚这些代码的作用是加载其他模板文件就可以了。</p>
<p>之前我们的主屏显示的是“Hello World”的提示信息模板，现在试着将它换成我们创建的<code>RWDevConTemplate</code>。打开 <strong>application.js</strong> 文件，根据如下代码修改之前的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> resourceLoader;</span><br><span class="line"> </span><br><span class="line"><span class="type">App</span>.onLaunch = function(options) &#123;</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">var</span> javascriptFiles = [</span><br><span class="line">    `$&#123;options.<span class="type">BASEURL</span>&#125;js/<span class="type">ResourceLoader</span>.js`, </span><br><span class="line">    `$&#123;options.<span class="type">BASEURL</span>&#125;js/<span class="type">Presenter</span>.js`</span><br><span class="line">  ];</span><br><span class="line"> </span><br><span class="line">  evaluateScripts(javascriptFiles, function(success) &#123;</span><br><span class="line">    <span class="keyword">if</span>(success) &#123;</span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      resourceLoader = new <span class="type">ResourceLoader</span>(options.<span class="type">BASEURL</span>);</span><br><span class="line">      resourceLoader.loadResource(`$&#123;options.<span class="type">BASEURL</span>&#125;templates/<span class="type">RWDevConTemplate</span>.xml.js`, function(resource) &#123;</span><br><span class="line">        <span class="keyword">var</span> doc = <span class="type">Presenter</span>.makeDocument(resource);</span><br><span class="line">        <span class="type">Presenter</span>.pushDocument(doc);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> errorDoc = createAlert(<span class="string">"Evaluate Scripts Error"</span>, <span class="string">"Error attempting to evaluate external JavaScript files."</span>);</span><br><span class="line">      navigationDocument.presentModal(errorDoc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 先不管createAlert函数</span></span><br></pre></td></tr></table></figure>
<p>此时你们已经对之前的代码进行了三处的修改：</p>
<ol>
<li>申明了一个<code>resourceLoader</code>变量。</li>
<li>将 <strong>ResourceLoader.js</strong> 文件添加到JavaScript文件数组中。</li>
<li>使用<code>resourceLoader</code>加载TVML模板，然后使用<code>Presenter</code>展现在屏幕上。</li>
</ol>
<p>编译运行程序，你们应该会看到如下界面：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-13.png" alt="tvOS-13"></p>
<p>恭喜你们，现在你们已经可以通过更好的方式从JavaScript文件中加载TVML模板信息了，而不再使用硬编码写死在代码里！</p>
<h3 id="u5B8C_u5584catalogTemplate"><a href="#u5B8C_u5584catalogTemplate" class="headerlink" title="完善catalogTemplate"></a>完善catalogTemplate</h3><p>你管你们信不信，我们要做的tvOS应用马上要接近尾声了。通过TVML开发tvOS应用最优雅的一件事就是添加界面元素非常之简单。</p>
<p>打开 <strong>RWDevConTemplate.xml.js</strong> 文件，按照如下代码更新之前代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Template</span> = function() &#123; <span class="keyword">return</span> `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;catalogTemplate&gt; </span><br><span class="line">      &lt;banner&gt; </span><br><span class="line">        &lt;title&gt;<span class="type">RWDevConHighlights</span>&lt;/title&gt;</span><br><span class="line">      &lt;/banner&gt;</span><br><span class="line">      <span class="comment">//add stuff here</span></span><br><span class="line">      <span class="comment">//1.</span></span><br><span class="line">      &lt;list&gt; </span><br><span class="line">        &lt;section&gt; </span><br><span class="line">          <span class="comment">//2.</span></span><br><span class="line">      &lt;listItemLockup&gt; </span><br><span class="line">        &lt;title&gt;<span class="type">Inspiration</span> <span class="type">Videos</span>&lt;/title&gt;</span><br><span class="line">        &lt;decorationLabel&gt;<span class="number">13</span>&lt;/decorationLabel&gt;</span><br><span class="line">      &lt;/listItemLockup&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">      &lt;/list&gt;</span><br><span class="line">    &lt;/catalogTemplate&gt;</span><br><span class="line">  &lt;/document&gt;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在上面的代码中，新定义了一个list标签，该标签中的内容就是显示在屏幕上除了Banner以外的全部内容。</li>
<li><code>listItemLockup</code>代表一个组，它以<code>listItemLockup</code>标签开头。在该标签中，通过<code>title</code>标签定义了它的名称“Inspiration Videos”，然后通过<code>decorationLabel</code>标签定义了该组中包含内容的数量。</li>
</ol>
<p>编译运行程序，在模拟器中你们会看到如下界面：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-14.png" alt="tvOS-14"></p>
<p>看着还不赖吧！</p>
<h3 id="u5B8C_u6210catalogTemplate"><a href="#u5B8C_u6210catalogTemplate" class="headerlink" title="完成catalogTemplate"></a>完成catalogTemplate</h3><p>最后，我们准备在模板中添加cell，用于展示每一个视频。打开 <strong>RWDevConTemplate.xml.js</strong> 添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Template</span> = function() &#123; <span class="keyword">return</span> `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;catalogTemplate&gt; </span><br><span class="line">      &lt;banner&gt; </span><br><span class="line">        &lt;title&gt;<span class="type">RWDevConHighlights</span>&lt;/title&gt;</span><br><span class="line">      &lt;/banner&gt;</span><br><span class="line">      &lt;list&gt; </span><br><span class="line">        &lt;section&gt; </span><br><span class="line">      &lt;listItemLockup&gt; </span><br><span class="line">        &lt;title&gt;<span class="type">Inspiration</span> <span class="type">Videos</span>&lt;/title&gt;</span><br><span class="line">        &lt;decorationLabel&gt;<span class="number">13</span>&lt;/decorationLabel&gt;</span><br><span class="line">            <span class="comment">//1. add from here</span></span><br><span class="line">        &lt;relatedContent&gt; </span><br><span class="line">          &lt;grid&gt;</span><br><span class="line">            &lt;section&gt; </span><br><span class="line">                  <span class="comment">//2</span></span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Ray-Wenderlich-Teamwork.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/ray.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;</span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Ryan-Nystrom-Contributing.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/ryan.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">              &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Matthijs-Hollemans-Math-Isnt-Scary.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/matthijs.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Vicki-Wenderlich-Identity.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/vicki.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">              &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Alexis-Gallagher-Identity.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/alexis.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">              &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Marin-Todorov-RW-Folklore.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/marin.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Chris-Wagner-Craftsmanship.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/chris.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">              &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Cesare-Rocchi-Cognition.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/cesare.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Ellen-Shapiro-Starting-Over.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/ellen.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Jake-Gundersen-Opportunity.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/jake.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Kim-Pedersen-Finishing.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/kim.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">              &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Tammy-Coron-Possible.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/tammy.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Saul-Mora-NSBrief.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/saul.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;     </span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">          &lt;/grid&gt;</span><br><span class="line">        &lt;/relatedContent&gt;</span><br><span class="line">      &lt;/listItemLockup&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">      &lt;/list&gt;</span><br><span class="line">    &lt;/catalogTemplate&gt;</span><br><span class="line">  &lt;/document&gt;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>从上述代码中可以看到，在<code>listItemLockup</code>标签中添加了<code>relatedContent</code>，该标签是的作用是显示图中红色圆圈区域的：</li>
</ol>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-15.png" alt="tvOS-15"></p>
<ol>
<li>每个<code>lockup</code>代表一个视频，每个该标签中都有<code>videoURL</code>的属性，它的值就是 <strong>RWDevCon</strong> 网站上视频的地址。对于之后播放视频至关重要。</li>
</ol>
<p>编译运行程序，会看到被你赋予新生命力的应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-16.png" alt="tvOS-16"></p>
<p>现在，我们已经在“Inspiration Videos”这个组里添加了若干视频。让我们打开遥控器的模拟器，选中模拟器，在菜单栏中选择 <strong>Hardware\Show Apple TV Remote</strong> 。你可以通过遥控器中的 <strong>option</strong> 键选择不同的视频。</p>
<h2 id="u64AD_u653E_u89C6_u9891"><a href="#u64AD_u653E_u89C6_u9891" class="headerlink" title="播放视频"></a>播放视频</h2><p>到目前为止，我们已经构建好了应用的页面，看起来还是不错的。此时，你们可以再想想如果用iOS框架完成你们现在已经完成的布局，应该如何做。Apple把一些UI的细节全都抽象了出来，通过一个个模板提供给我们使用，可以让我们简单方便的通过模板创建出完美的界面，不得不说Apple做的太棒了。</p>
<p>接下来让我们完成最后两个遗留的功能：选择视频和播放视频。</p>
<h3 id="u9009_u62E9_u4E8B_u4EF6"><a href="#u9009_u62E9_u4E8B_u4EF6" class="headerlink" title="选择事件"></a>选择事件</h3><p>你们可能已经注意到了，当按下 <strong>enter</strong> 键或者在 <strong>Apple TV Remote</strong> 选择视频时并没有什么反应，所以是时候来实现选择视频的功能了。</p>
<p>打开<code>Presenter</code>，添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">load: function(event) &#123;</span><br><span class="line">  <span class="comment">//1</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">self</span> = this,</span><br><span class="line">  ele = event.target,</span><br><span class="line">  videoURL = ele.getAttribute(<span class="string">"videoURL"</span>)</span><br><span class="line">  <span class="keyword">if</span>(videoURL) &#123;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">var</span> player = new <span class="type">Player</span>();</span><br><span class="line">    <span class="keyword">var</span> playlist = new <span class="type">Playlist</span>();</span><br><span class="line">    <span class="keyword">var</span> mediaItem = new <span class="type">MediaItem</span>(<span class="string">"video"</span>, videoURL);</span><br><span class="line"> </span><br><span class="line">    player.playlist = playlist;</span><br><span class="line">    player.playlist.push(mediaItem);</span><br><span class="line">    player.present();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ol>
<li><code>load</code>函数用来处理视频选择事件。它相当于iOS中的<code>@IBAction</code>，该函数的<code>event</code>参数相当于<code>sender</code>参数。每个<code>event</code>都有一个<code>target</code>，每个<code>target</code>关联着模板中的<code>lockup</code>元素。一个<code>lockup</code>代表应用中的一个视频，它里面有视频封面的属性，以及视频地址<code>videoURL</code>属性。</li>
<li>播放视频非常简单。<code>Player</code>是 <strong>TVJS</strong> 框架提供的一个类，负责所有视频播放的相关功能。你们所要做的只是添加一个播放列表<code>playlist</code>，然后将要播放的项目<code>mediaItem</code>添加到播放列表里。最后通过<code>player.present()</code>方法就可以播放视频了。</li>
</ol>
<p>现在你们已经实现了选择视频后的响应事件。是时候将选择事件与每个视频关联在一起了。打开 <strong>application.js</strong> 文件，在<code>App.onLaunch</code>方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">App</span>.onLaunch = function(options) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//在resourceLoader.loadResource中...</span></span><br><span class="line">  <span class="keyword">var</span> doc = <span class="type">Presenter</span>.makeDocument(resource);</span><br><span class="line">  doc.addEventListener(<span class="string">"select"</span>, <span class="type">Presenter</span>.load.bind(<span class="type">Presenter</span>)); <span class="comment">//add this line</span></span><br><span class="line">  <span class="type">Presenter</span>.pushDocument(doc);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的<code>addEventListener</code>方法相当于iOS中按钮的<code>@IBAction</code>。编译运行程序，选择一个视频播放，你会看到一个完美的视频播放应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-17.gif" alt="tvOS-17"></p>
<p>大家可以在这里下载教程中的完整项目：<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/client.zip" target="_blank" rel="external">client</a>和<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/RWDevCon.zip" target="_blank" rel="external">RWDevCon</a>。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" ]]>
    </summary>
    
      <category term="Apple TV" scheme="http://www.devtalking.com/tags/Apple-TV/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CALayer Animation - Gradient Animation]]></title>
    <link href="http://www.devtalking.com//articles/calayer-animation-gradient-animation/"/>
    <id>http://www.devtalking.com//articles/calayer-animation-gradient-animation/</id>
    <published>2015-09-21T16:00:00.000Z</published>
    <updated>2016-08-19T00:51:36.000Z</updated>
    <content type="html"><![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://www.csdn.net/article/2015-09-22/2825765" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>在很多人的心目中iPhone的经典机型应该是iPhone4，精湛的工艺、完美的屏幕配上暗色的锁屏壁纸，看着屏幕底部闪烁的<strong>slide to unlock</strong>字样，高逼格彰显无遗。时至今日无论iPhone机身样式如何改变，屏幕尺寸如何改变，iOS系统如何改变，唯有锁屏底部闪烁的<strong>滑动来解锁</strong>不变。它的动画效果是如何实现的呢，这篇文章会告诉你们答案。</p>
<h2 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h2><p>新建一个应用名为<strong>GradientAnimation</strong>，打开<code>Main.storyboard</code>，将ViewController的View背景色设置为灰黑色，拖一个UIView到ViewController中，将其颜色设置为无色并设置好布局约束：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-1.png" alt="GradientAnimation - 1"></p>
<p>接着我们拖一个UILabel到刚才拖入的UIView中，设置高宽等同于它的父视图：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-2.png" alt="GradientAnimation - 2"></p>
<p>我对该UILabel的属性设置如下：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-4.png" alt="GradientAnimation - 4"></p>
<p>之后，我们在<code>ViewController</code>中添加UIView和UILabel的Outlet：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-5.png" alt="GradientAnimation - 5"></p>
<p>接下来回到<code>ViewController.swift</code>，我们添加一个常量属性<code>gradientLayer</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> gradientLayer = <span class="type">CAGradientLayer</span>()</span><br></pre></td></tr></table></figure>
<p>这里出现了CALayer的另一个子类CAGradientLayer，这个类的作用就是能在Layer上绘制出渐变颜色的效果，然后在<code>viewDidLoad()</code>中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gradientLayer.bounds = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: backgroundView.frame.size.width, height: backgroundView.frame.size.height)</span><br><span class="line">gradientLayer.position = <span class="type">CGPoint</span>(x: backgroundView.frame.size.width/<span class="number">2</span>, y: backgroundView.frame.size.height/<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>上述两行的代码是设置Layer的大小及位置，这在上两篇文章中已经讲过，这里就不再累赘了。接着我们继续添加两行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gradientLayer.startPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0.5</span>)</span><br><span class="line">gradientLayer.endPoint = <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>既然CAGradientLayer可以绘制出渐变颜色的效果，那自然有颜色渐变的方向，所以这两行代码的作用就是设置颜色渐变的起始点和结束点，这两个属性共同决定了颜色渐变的方向：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-3.png" alt="GradientAnimation - 3"></p>
<p>从上面的示意图中可以看出，CAGradientLayer是通过起始点和结束点的坐标位置来决定颜色渐变的方向的，起始点的默认值是(0.5, 0)，结束点的默认值是(0.5, 1)，也就是说默认的颜色渐变方向是沿垂直中线从上往下渐变的，我们在这里将它改成了沿水平中线从左往右渐变。</p>
<p>接下来我们设置CAGradientLayer的渐变颜色，接着添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gradientLayer.colors = [</span><br><span class="line">    <span class="type">UIColor</span>.blackColor().<span class="type">CGColor</span>,</span><br><span class="line">    <span class="type">UIColor</span>.whiteColor().<span class="type">CGColor</span>,</span><br><span class="line">    <span class="type">UIColor</span>.blackColor().<span class="type">CGColor</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>CAGradientLayer的<code>colors</code>属性类型是一个数组<code>[AnyObject]</code>，这就意味着我们可以实现多个颜色的渐变效果，并且可以规定各个颜色的顺序。不过在我们这个示例中我们只需要两种颜色，不过需要注意的是虽然颜色只有两种，但是整个颜色渐变的过程中有三个原色点，那就是黑、白、黑，所以我们在这个数组中也需要按照原色点的数量和顺序添加相应的颜色，哪怕颜色都是一样的。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>我们既然设置了渐变的三个原色，那么就要对这原色出现的位置进行设置，接着添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gradientLayer.locations = [<span class="number">0.2</span>, <span class="number">0.5</span>, <span class="number">0.8</span>]</span><br></pre></td></tr></table></figure>
<p>从上述代码中不难看出，我们将第一个黑色原色出现的位置设置在了整个Layer长度的十分之二的位置，第二个白色原色在中间，第三个黑色原色在十分之八的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-6.png" alt="GradientAnimation - 6"></p>
<p>设置完CAGradientLayer的相关属性后，我们将<code>gradientLayer</code>添加到<code>backgroundView</code>的Layer中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">backgroundView.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure>
<p>现在我们编译运行一下代码看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-7.png" alt="GradientAnimation - 7"></p>
<p>接下来我们需要让颜色渐变动起来，先创建一个方法<code>gradinetAnimate()</code>，在方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> gradient = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"locations"</span>)</span><br><span class="line">gradient.fromValue = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.25</span>]</span><br><span class="line">gradient.toValue = [<span class="number">0.75</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">gradient.duration = <span class="number">2.5</span></span><br><span class="line">gradient.repeatCount = <span class="type">HUGE</span></span><br><span class="line">gradientLayer.addAnimation(gradient, forKey: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>首先，创建了一个<code>locations</code>类型的动画实例<code>gradient</code>，将<code>fromValue</code>属性，也就是起始位置的属性设置为<code>[0, 0, 0.25]</code>，它的意思是动画开始前，黑色、白色这两个原色的位置在整个Layer的最前端，第二个黑色原色在0.25的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-8.png" alt="GradientAnimation - 8"></p>
<p>而结束位置<code>toValue</code>，将白色和第二个黑色原色位置设置在整个Layer的末端，第一个黑色原色在0.75的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-9.png" alt="GradientAnimation - 9"></p>
<p>从图中可以看出，此时整个Layer都变成了黑色。也就是说，在整个动画中，第一个黑色原色从0移动到0.75的位置，白色原色从0移动到1的位置，第二个黑色原色从0.25移动到1的位置。然后设置动画时间为2.5秒，无线重复次数，最后将<code>gradient</code>动画添加到<code>gradientLayer</code>中。我们在<code>viewDidAppear()</code>方法中调用该动画方法<code>gradientAnimate()</code>，编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-10.gif" alt="GradientAnimation - 10"></p>
<p>动画效果还不赖，但是如何将颜色渐变的动画作用在UILabel的文字上呢？其实非常简单，就是让UILabel上的文字称为CAGradientLayer的遮罩即可，我们先在<code>ViewController</code>中定义一个常量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"DevTalking"</span></span><br></pre></td></tr></table></figure>
<p>然后在<code>viewDidAppear()</code>中的<code>gradientAnimate()</code>方法之前添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">textLabel.text = text</span><br><span class="line">gradientLayer.mask = textLabel.layer</span><br></pre></td></tr></table></figure>
<p>我们再编译运行代码看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-11.gif" alt="GradientAnimation - 11"></p>
<p>到目前为止，锁屏中<strong>滑动来解锁</strong>的动画效果就完成了，这个动画效果在Facebook的Paper应用中也有使用。下一节，我们在该动画的基础上对文字再加点小动画。</p>
<h2 id="Text_Animation"><a href="#Text_Animation" class="headerlink" title="Text Animation"></a>Text Animation</h2><p>首先我们打开<code>AppDelegate.swift</code>，在<code>import UIKit</code>下面添加一个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">delay</span><span class="params">(seconds seconds: Double, completion:<span class="params">()</span></span></span>-&gt;()) &#123;</span><br><span class="line">    <span class="keyword">let</span> intervalTime = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="type">Int64</span>( <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>) * seconds ))</span><br><span class="line">    </span><br><span class="line">    dispatch_after(intervalTime, dispatch_get_main_queue(), &#123;</span><br><span class="line">        completion()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的作用如其名称一样，是一个延迟方法，该方法的第一个参数是想要延迟的时间，第二个参数是一个闭包，也就是延迟的主体。这个方法用到了GCD的知识，<code>dispatch_time</code>主要是用于创建一个类型为<code>dispatch_time_t</code>的相对时间，它的第一个参数指的是起始时间，一般都是用预定义的<code>DISPATCH_TIME_NOW</code>作为第一个参数的值，代表当前的时间。第二个参数代表时间间隔，注意这个参数需要的时间单位是纳秒，所以我们使用预定义的<code>NSEC_PER_SEC</code>纳秒单位乘以希望间隔的秒数。</p>
<p><code>dispatch_after</code>用于在队列中定时执行任务，当你想在一段时间后执行一个任务，那么就可以用这个函数。该函数的第一个参数指定延迟的时间，第二个参数指定一个队列，用于添加任务，第三个参数是一个闭包，也就是要执行的任务。</p>
<p>然后回到<code>ViewController.swift</code>，添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">textAnimate</span><span class="params">(text: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> text.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        textLabel.text = <span class="string">"<span class="subst">\(textLabel.text!)</span><span class="subst">\(text.substringToIndex(text.startIndex.successor()</span>))"</span></span><br><span class="line">        delay(seconds: <span class="number">0.4</span>, completion: &#123;</span><br><span class="line">            <span class="keyword">self</span>.textAnimate(text.substringFromIndex(text.startIndex.successor()))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的参数<code>text</code>就是UILabel中要显示的文字内容。<code>substringToIndex(_ to: Int)</code>方法的作用是从字符串的开头一直截取到指定的位置，但不包括该指定位置的字符。<code>text.startIndex.successor()</code>这句意思是从<code>text</code>的起始位置开始取后面的一个字符。<code>substringFromIndex(_ from: Int)</code>方法的作用是以指定位置并包括指定位置的字符开始，一直截取之后的全部字符。所以整个方法的作用是每隔0.4秒显示一个字符，直到将整个字符串显示完。最后在<code>viewDidAppear()</code>中注释掉<code>textLabel.text = text</code>这行代码，并在方法最后调用<code>textAnimate(text)</code>方法。编译运行代码看看最终效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-12.gif" alt="GradientAnimation - 12"></p>
<p>参考文献来自：<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


]]></content>
    <summary type="html">
    <![CDATA[<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" ]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
</feed>
