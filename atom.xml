<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[程序员说]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.devtalking.com/"/>
  <updated>2016-08-15T05:44:11.000Z</updated>
  <id>http://www.devtalking.com/</id>
  
  <author>
    <name><![CDATA[DevTalking]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Test]]></title>
    <link href="http://www.devtalking.com//articles/thisisatest/"/>
    <id>http://www.devtalking.com//articles/thisisatest/</id>
    <published>2016-08-15T16:00:00.000Z</published>
    <updated>2016-08-15T05:44:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u642D_u5EFAShadowSocks_u670D_u52A1_u5668"><a href="#u642D_u5EFAShadowSocks_u670D_u52A1_u5668" class="headerlink" title="搭建ShadowSocks服务器"></a>搭建ShadowSocks服务器</h1><blockquote>
<p>以下文章内容均在MacOS下实践。</p>
</blockquote>
<h2 id="u8D2D_u4E70VPS"><a href="#u8D2D_u4E70VPS" class="headerlink" title="购买VPS"></a>购买VPS</h2><p>我使用的是<a href="http://www.vultr.com" target="_blank" rel="external">Vultr</a>的VPS，他家的VPS可选的地域较为丰富，而且有日本东京，这对于家里是联通网络的比较亲和，速度较好：<br><img src="/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-13%2020.36.30.png" alt="" title="Server Location"><br>在系统和应用方面Vultr提供的种类也比较丰富：<br><img src="/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-13%2020.39.59.png" alt="" title="Server Type"><br><img src="/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-13%2020.40.07.png" alt="" title="Application"><br>在价格方面，Vultr提供的最低价格为每月5美元，对应的性能足够搭建ShadowSocks：<br><img src="/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-13%2020.42.22.png" alt="" title="Server Price"><br>注册Vultr账号，绑定信用卡，选择自己中意的系统和价格后立即就会为你部署好VPS：<br><img src="/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-13%2020.44.48.png" alt=""><br>当VPS的状态为Running后，就表示VPS已经启动了，然后为该VPS配置我们的SSH公钥：<br> <img src="/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-13%2020.52.56.png" alt=""><br>大家可以看看北京联通ping东京VPS的速度：<br> <img src="/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-14%2014.53.28.png" alt=""></p>
<blockquote>
<p>使用该<a href="http://www.vultr.com/?ref=6955175-3B" target="_blank" rel="external">链接</a>注册可获得20美元的优惠卷。</p>
</blockquote>
<h2 id="u5B89_u88C5ShadowSocks"><a href="#u5B89_u88C5ShadowSocks" class="headerlink" title="安装ShadowSocks"></a>安装ShadowSocks</h2><p>我们使用Python版的ShadowSocks进行安装，首先需要下载<a href="https://pypi.python.org/pypi/pip#downloads" target="_blank" rel="external">pip-8.1.2.tar.gz</a>，然后使用工具将其上传至VPS，我使用的是Commander One，通过SFTP连接VPS：<br><img src="/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-08-13%2021.00.31.png" alt=""><br>使用Terminal连接VPS，一步一步输入以下命令解压安装pip：</p>
<pre><code>tar -xzvf pip-8.1.2.tar.gz
cd pip-8.1.2
python setup.py install
</code></pre><p>然后通过pip安装shadowsocks：</p>
<pre><code>pip install shadowsocks
</code></pre><p>成功后可以看到如下信息：</p>
<pre><code>Collecting shadowsocks
  Downloading shadowsocks-2.8.2.tar.gz
Installing collected packages: shadowsocks
  Running setup.py install for shadowsocks ... done
Successfully installed shadowsocks-2.8.2
</code></pre><h2 id="u914D_u7F6EShadowSocks"><a href="#u914D_u7F6EShadowSocks" class="headerlink" title="配置ShadowSocks"></a>配置ShadowSocks</h2><p>进入到etc目录下，创建shadowsocks.json文件，并添加如下内容：</p>
<pre><code>{
    &quot;server&quot;:&quot;你的VPS的IP&quot;,
    &quot;server_port&quot;:8388,
    &quot;local_port&quot;:1080,
    &quot;password&quot;:&quot;设置一个连接密码&quot;,
    &quot;timeout&quot;:600,
    &quot;method&quot;:&quot;aes-256-cfb&quot;,
    &quot;auth&quot;: true
}
</code></pre><p>该文件就是ShadowSocks的配置文件。</p>
<p>然后输入如下命令启动ShadowSocks服务：</p>
<pre><code>ssserver -c /etc/shadowsocks.json -d start
</code></pre><p>最后清空防火墙规则：</p>
<pre><code>iptables -F
</code></pre><p>至此ShadowSocks服务端就配置完成并可以使用了。</p>
<pre><code>var view = UIView()
view.backgroundColor = UIColor.redColor()

class Test {
    func thisIsATestMethod(method: String) -&gt; Bool {
        let obj = UIView()
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u642D_u5EFAShadowSocks_u670D_u52A1_u5668"><a href="#u642D_u5EFAShadowSocks_u670D_u52A1_u5668" class="headerlink" title="搭建ShadowSock]]>
    </summary>
    
      <category term="Test" scheme="http://www.devtalking.com/tags/Test/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Concurrency Programming Guide 笔记（三）]]></title>
    <link href="http://www.devtalking.com//articles/read-concurrency-programming-guide-3/"/>
    <id>http://www.devtalking.com//articles/read-concurrency-programming-guide-3/</id>
    <published>2016-04-20T16:00:00.000Z</published>
    <updated>2016-04-21T08:32:58.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/69122" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="u901A_u8FC7Dispatch_Queue_u6267_u884C_u4EFB_u52A1"><a href="#u901A_u8FC7Dispatch_Queue_u6267_u884C_u4EFB_u52A1" class="headerlink" title="通过Dispatch Queue执行任务"></a>通过Dispatch Queue执行任务</h2><p>如果想让Dispatch Queue执行任务，首先就是得将任务放入队列中，我们可以异步的将任务加入队列，也可以同步的将任务加入队列，可以一个任务一个任务的加，也可以一组一组的加。这节我们就来看看将任务加入队列的那些事。</p>
<h3 id="u5411_u961F_u5217_u6DFB_u52A0_u4EFB_u52A1"><a href="#u5411_u961F_u5217_u6DFB_u52A0_u4EFB_u52A1" class="headerlink" title="向队列添加任务"></a>向队列添加任务</h3><p>我们可以使用<code>dispatch_async</code>或者<code>dispatch_async_f</code>函数异步的向队列中添加任务，也就是说当我们添加完任务后该函数会立即返回，我们不需要等待任务执行完成，而且我们也不会知道队列到底何时开始执行任务。<code>dispatch_async</code>函数有两个参数，一个是目标队列，类型为<code>dispatch_queue_t</code>，另一个是闭包，类型为<code>dispatch_block_t</code>：</p>
<pre><code class="swift">let serialQueue = dispatch_queue_create(&quot;com.example.MySerialQueue&quot;, nil)

dispatch_async(serialQueue, {

    print(&quot;Task in the queue...&quot;)

})
</code></pre>
<p><code>dispatch_async_f</code>函数有三个参数，第一个是类型为<code>dispatch_queue_t</code>的目标队列，第二个是队列上下文指针，第三个是类型为<code>dispatch_function_t</code>的任务函数，队列上下文指针为该函数的唯一参数：</p>
<pre><code class="swift">class AddTaskToQueue {

    func launch() {

        let serialQueue = dispatch_queue_create(&quot;com.example.MySerialQueue&quot;, nil)

        dispatch_async(serialQueue, {

            print(&quot;Task in the queue...&quot;)

        })

        dispatch_async_f(serialQueue, unsafeBitCast(0, UnsafeMutablePointer&lt;Int&gt;.self), taskFunction())

        sleep(3)

    }

    func taskFunction() -&gt; dispatch_function_t {

        return { context in

            print(&quot;Do some work with context...&quot;)

        }

    }

}

let addTaskToQueue = AddTaskToQueue()
addTaskToQueue.launch()
</code></pre>
<p>除了这两个函数，我们还可以使用<code>dispatch_sync</code>和<code>dispatch_sync_f</code>函数同步的向队列中添加任务，并且我们要等待直到任务执行完成。这两个函数和上面的异步添加任务函数用法完全一致。</p>
<p>那么什么时候用异步什么时候用同步呢，大多数情况下我们都是在主线程中使用GCD分派任务，为了避免阻塞主线程，影响用户体验，所以通常情况下我们都使用异步添加任务的方式。当然为了避免任务与主线程中产生资源竞争的问题，有时候酌情也会使用同步添加任务的方式。</p>
<h3 id="Dispatch_Queue_u7684Completion_Block"><a href="#Dispatch_Queue_u7684Completion_Block" class="headerlink" title="Dispatch Queue的Completion Block"></a>Dispatch Queue的Completion Block</h3><p>还记得<code>NSOperation</code>的<code>completionBlock</code>属性吗，这个回调函数在任务执行完成后调用，用于处理有些后续工作或者消息通知。在Dispatch Queue中并没有类似的属性，但是我们可以通过其他方式来实现。举一个很常见的应用场景，我们在主线程中分派一个下载图片的任务，让其在二级线程中执行，当图片下载完成后通知主线程，并由主线程将图片显示出来，我们看看简单的代码片段：</p>
<pre><code class="swift">class DownloadImage {

    func dispatchTaskInMainThread() {

        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), downloadImage())

    }

    func downloadImage() -&gt; (() -&gt; ()) {

        return {

            print(&quot;Downloading image in \(NSThread.currentThread())&quot;)

            dispatch_async(dispatch_get_main_queue()) {

                print(&quot;Handle image and display in \(NSThread.currentThread())&quot;)

            }

        }

    }

}
</code></pre>
<p>我们来看看上面代码都做了些什么，首先在<code>dispatchTaskInMainThread</code>方法中，我们使用<code>dispatch_get_global_queue</code>函数获取到全局并发队列，然后将<code>downloadImage</code>下载图片的方法作为任务添加到该全局队列中。在<code>downloadImage</code>方法里，当图片下载完成后通过<code>dispatch_get_main_queue</code>函数获取到主队列，也就是在主线程中对图片进行处理，这样我们就达到了Completion Block的效果。</p>
<h3 id="u5728_u961F_u5217_u4E2D_u5FAA_u73AF_u6267_u884C_u4EFB_u52A1"><a href="#u5728_u961F_u5217_u4E2D_u5FAA_u73AF_u6267_u884C_u4EFB_u52A1" class="headerlink" title="在队列中循环执行任务"></a>在队列中循环执行任务</h3><p>在我们的日常开发中，经常会使用到for循环来处理一些任务，而且这些任务之间也并没有先后顺序的关联，每个任务相对比较独立。遇到这种情况，我们可以用<code>dispatch_apply</code>或<code>dispatch_apply_f</code>函数让任务在队列中循环执行，并且可以是并发执行，这样相比for循环的串行执行要更加效率：</p>
<pre><code class="swift">// for循环
let arr = [&quot;Swift&quot;, &quot;Objective-C&quot;, &quot;Java&quot;, &quot;Delphi&quot;, &quot;C++&quot;]

for element in arr {

    print(&quot;Handle element. the element is \(element)&quot;)

}

// dispatch_apply
dispatch_apply(arr.count, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)){ index in

    print(&quot;Handle element. the element is \(arr[index]). Current thread is \(NSThread.currentThread())&quot;)

}
</code></pre>
<p>从上面示例代码片段中可以看到，<code>dispatch_apply</code>函数有三个参数，第一个参数是循环次数，第二个参数是目标队列，第三个则是要执行的闭包任务，循环次数是该闭包的唯一参数。</p>
<h3 id="u6682_u505C_u548C_u91CD_u542F_u961F_u5217"><a href="#u6682_u505C_u548C_u91CD_u542F_u961F_u5217" class="headerlink" title="暂停和重启队列"></a>暂停和重启队列</h3><p>在Dispatch Queue执行任务时，如果我们想暂停队列，可以使用<code>dispatch_suspend</code>函数，重新让队列执行任务可以使用<code>dispatch_resume</code>。这里要注意的是暂停队列只是让队列暂时停止执行下一个任务，而不是中断当前正在执行的任务。</p>
<h3 id="Dispatch_Group_u7684_u4F7F_u7528"><a href="#Dispatch_Group_u7684_u4F7F_u7528" class="headerlink" title="Dispatch Group的使用"></a>Dispatch Group的使用</h3><p>在实际开发中，为了提升性能我们或许会经常使用<code>dispatch_async</code>异步的将任务添加进队列去执行，但有些时候需要之前队列中的多个任务都执行完成之后，才能获取到正确的或者说想要的结果供后续逻辑代码使用，遇到这种情况，就可以使用Dispatch Group，将多个任务在队列中归为一个组，并可以使用<code>dispatch_group_wait</code>函数让之后的逻辑代码等待，直到该组的任务都执行完成后再执行。</p>
<pre><code class="swift">var count = 0

let concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

dispatch_async(concurrentQueue) {

    print(&quot;Task1 in dispatchGroup...&quot;)

    sleep(2)

    count += 1

}

dispatch_async(concurrentQueue) {

    print(&quot;Task2 in dispatchGroup...&quot;)

    sleep(3)

    count += 1

}

dispatch_async(concurrentQueue) {

    print(&quot;Task3 in dispatchGroup...&quot;)

    sleep(1)

    count += 1

}

print(&quot;I expect the count is 3, and the factual count is \(count)&quot;)
</code></pre>
<p>上面的代码片段就是我刚才描述的场景，因为使用的是并发队列，也不好在每个任务里进行回调处理，所以我们永远不会得到正确的<code>count</code>。如果我们使用Dispatch Group事情就简单多了：</p>
<pre><code class="swift">var count = 0

let concurrentQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

let dispatchGroup = dispatch_group_create()

dispatch_group_async(dispatchGroup, concurrentQueue) {

    print(&quot;Task1 in dispatchGroup...&quot;)

    sleep(2)

    count += 1

}

dispatch_group_async(dispatchGroup, concurrentQueue) {

    print(&quot;Task2 in dispatchGroup...&quot;)

    sleep(3)

    count += 1

}

dispatch_group_async(dispatchGroup, concurrentQueue) {

    print(&quot;Task3 in dispatchGroup...&quot;)

    sleep(1)

    count += 1

}

dispatch_group_wait(dispatchGroup, DISPATCH_TIME_FOREVER)

print(&quot;I expect the count is 3, and the factual count is \(count)&quot;)
</code></pre>
<p>上面的代码中，先使用<code>dispatch_group_create</code>函数创建Dispatch Group，然后使用<code>dispatch_group_async</code>函数将任务分进组里，然后再添加进队列中。该函数有三个参数，分别是Dispatch Group、Dispatch Queue和要执行任务的闭包。当添加完任务后使用<code>dispatch_group_wait</code>函数等待，直到指定组的任务全部完成，才会继续执行后面的打印语句，该函数有两个参数，第一个是目标组，第二个是等待时间<code>DISPATCH_TIME_NOW</code>或<code>DISPATCH_TIME_FOREVER</code>。</p>
<h2 id="Dispatch_Source"><a href="#Dispatch_Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h2><p>前面的文章中介绍过Dispatch Source：</p>
<blockquote>
<p>Dispatch Source是GCD中的一个基本类型，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。我们来看看它都有哪些类型：</p>
<ul>
<li>Timer Dispatch Source：定时调度源。</li>
<li>Signal Dispatch Source：监听UNIX信号调度源，比如监听代表挂起指令的SIGSTOP信号。</li>
<li>Descriptor Dispatch Source：监听文件相关操作和Socket相关操作的调度源。</li>
<li>Process Dispatch Source：监听进程相关状态的调度源。</li>
<li>Mach port Dispatch Source：监听Mach相关事件的调度源。</li>
<li>Custom Dispatch Source：监听自定义事件的调度源。</li>
</ul>
</blockquote>
<p>这一节就来看看如何使用Dispatch Source。</p>
<p>用通俗一点的话说就是用GCD的函数指定一个希望监听的系统事件类型，再指定一个捕获到事件后进行逻辑处理的闭包或者函数作为回调函数，然后再指定一个该回调函数执行的Dispatch Queue即可，当监听到指定的系统事件发生时会调用回调函数，将该回调函数作为一个任务放入指定的队列中执行。也就是说当监听到系统事件后就会触发一个任务，并自动将其加入队列执行，这里与之前手动添加任务的模式不同，一旦将Diaptach Source与Dispatch Queue关联后，只要监听到系统事件，Dispatch Source就会自动将任务（回调函数）添加到关联的队列中。</p>
<p>有些时候回调函数执行的时间较长，在这段时间内Dispatch Source又监听到多个系统事件，理论上就会形成事件积压，但好在Dispatch Source有很好的机制解决这个问题，当有多个事件积压时会根据事件类型，将它们进行关联和结合，形成一个新的事件。</p>
<h3 id="u76D1_u542C_u4E8B_u4EF6_u7C7B_u578B"><a href="#u76D1_u542C_u4E8B_u4EF6_u7C7B_u578B" class="headerlink" title="监听事件类型"></a>监听事件类型</h3><p>Dispatch Source一共可以监听六类事件，分为11个类型，我们来看看都是什么：</p>
<ul>
<li><code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>：属于自定义事件，可以通过<code>dispatch_source_get_data</code>函数获取事件变量数据，在我们自定义的方法中可以调用<code>dispatch_source_merge_data</code>函数向Dispatch Source设置数据，下文中会有详细的演示。</li>
<li><code>DISPATCH_SOURCE_TYPE_DATA_OR</code>：属于自定义事件，用法同上面的类型一样。</li>
<li><code>DISPATCH_SOURCE_TYPE_MACH_SEND</code>：Mach端口发送事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_MACH_RECV</code>：Mach端口接收事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_PROC</code>：与进程相关的事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_READ</code>：读文件事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_WRITE</code>：写文件事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_VNODE</code>：文件属性更改事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_SIGNAL</code>：接收信号事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_TIMER</code>：定时器事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_MEMORYPRESSURE</code>：内存压力事件。</li>
</ul>
<h3 id="u521B_u5EFADispatch_Source"><a href="#u521B_u5EFADispatch_Source" class="headerlink" title="创建Dispatch Source"></a>创建Dispatch Source</h3><p>我们可以使用<code>dispatch_source_create</code>函数创建Dispatch Source，该函数有四个参数：</p>
<ul>
<li><code>type</code>：第一个参数用于标识Dispatch Source要监听的事件类型，共有11个类型。</li>
<li><code>handle</code>：第二个参数是取决于要监听的事件类型，比如如果是监听Mach端口相关的事件，那么该参数就是<code>mach_port_t</code>类型的Mach端口号，如果是监听事件变量数据类型的事件那么该参数就不需要，设置为0就可以了。</li>
<li><code>mask</code>：第三个参数同样取决于要监听的事件类型，比如如果是监听文件属性更改的事件，那么该参数就标识文件的哪个属性，比如<code>DISPATCH_VNODE_RENAME</code>。</li>
<li><code>queue</code>：第四个参数设置回调函数所在的队列。</li>
</ul>
<pre><code class="swift">let dispatchQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

let dispatchSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatchQueue)
</code></pre>
<p>上面的代码就是创建Dispatch Source的简单示例。</p>
<h3 id="u8BBE_u7F6E_u4E8B_u4EF6_u5904_u7406_u5668"><a href="#u8BBE_u7F6E_u4E8B_u4EF6_u5904_u7406_u5668" class="headerlink" title="设置事件处理器"></a>设置事件处理器</h3><p>前文中提到过，当Dispatch Source监听到事件时会调用指定的回调函数或闭包，该回调函数或闭包就是Dispatch Source的事件处理器。我们可以使用<code>dispatch_source_set_event_handler</code>或<code>dispatch_source_set_event_handler_f</code>函数给创建好的Dispatch Source设置处理器，前者是设置闭包形式的处理器，后者是设置函数形式的处理器：</p>
<pre><code class="swift">dispatch_source_set_event_handler(dispatchSource, {

    print(&quot;Dispatch Source 事件处理器...&quot;)

})

// 根据闭包尾随的特性，还可以有下面的写法

dispatch_source_set_event_handler(dispatchSource) {

    print(&quot;Dispatch Source 事件处理器...&quot;)

}
</code></pre>
<p>从上面示例代码中可以看到，该函数有两个参数，第一个是设置目标Dispatch Source，第二个参数就是设置处理器了。</p>
<p>既然是事件处理器，那么肯定需要获取一些Dispatch Source的信息，GCD提供了三个在处理器中获取Dispatch Source相关信息的函数，比如<code>handle</code>、<code>mask</code>。而且针对不同类型的Dispatch Source，这三个函数返回数据的值和类型都会不一样，下面来看看这三个函数：</p>
<ul>
<li><code>dispatch_source_get_handle</code>：这个函数用于获取在创建Dispatch Source时设置的第二个参数<code>handle</code>。<ul>
<li>如果是读写文件的Dispatch Source，返回的就是描述符。</li>
<li>如果是信号类型的Dispatch Source，返回的是<code>int</code>类型的信号数。</li>
<li>如果是进程类型的Dispatch Source，返回的是<code>pid_t</code>类型的进程id。</li>
<li>如果是Mach端口类型的Dispatch Source，返回的是<code>mach_port_t</code>类型的Mach端口。</li>
</ul>
</li>
<li><code>dispatch_source_get_data</code>：该函数用于获取Dispatch Source监听到事件的相关数据。<ul>
<li>如果是读文件类型的Dispatch Source，返回的是读到文件内容的字节数。</li>
<li>如果是写文件类型的Dispatch Source，返回的是文件是否可写的标识符，正数表示可写，负数表示不可写。</li>
<li>如果是监听文件属性更改类型的Dispatch Source，返回的是监听到的有更改的文件属性，用常量表示，比如<code>DISPATCH_VNODE_RENAME</code>等。</li>
<li>如果是进程类型的Dispatch Source，返回监听到的进程状态，用常量表示，比如<code>DISPATCH_PROC_EXIT</code>等。</li>
<li>如果是Mach端口类型的Dispatch Source，返回Mach端口的状态，用常量表示，比如<code>DISPATCH_MACH_SEND_DEAD</code>等。</li>
<li>如果是自定义事件类型的Dispatch Source，返回使用<code>dispatch_source_merge_data</code>函数设置的数据。</li>
</ul>
</li>
<li><code>dispatch_source_get_mask</code>：该函数用于获取在创建Dispatch Source时设置的第三个参数<code>mask</code>。在进程类型，文件属性更改类型，Mach端口类型的Dispatch Source下该函数返回的结果与<code>dispatch_source_get_data</code>一样。</li>
</ul>
<h3 id="u6CE8_u518CCancellation_Handler"><a href="#u6CE8_u518CCancellation_Handler" class="headerlink" title="注册Cancellation Handler"></a>注册Cancellation Handler</h3><p>Cancellation Handler就是当Dispatch Source被释放时用来处理一些后续事情，比如关闭文件描述符或者释放Mach端口等。我们可以使用<code>dispatch_source_set_cancel_handler</code>函数或者<code>dispatch_source_set_cancel_handler_f</code>函数给Dispatch Source注册Cancellation Handler：</p>
<pre><code class="swift">dispatch_source_set_cancel_handler(dispatchSource) {

    print(&quot;进行善后处理...&quot;)

}
</code></pre>
<p>该函数有两个参数，第一个参数是目标Dispatch Source，第二个参数就是要进行善后处理的闭包或者函数。</p>
<h3 id="u66F4_u6539Dispatch_Source_u7684_u76EE_u6807_u961F_u5217"><a href="#u66F4_u6539Dispatch_Source_u7684_u76EE_u6807_u961F_u5217" class="headerlink" title="更改Dispatch Source的目标队列"></a>更改Dispatch Source的目标队列</h3><p>在上文中，我们说过可以使用<code>dispatch_source_create</code>函数创建Dispatch Source，并且在创建时会指定回调函数执行的队列，那么如果事后想更改队列，比如说想更改队列的优先级，这时我们可以使用<code>dispatch_set_target_queue</code>函数实现：</p>
<pre><code class="swift">let dispatchQueueDefaultPriority = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

let dispatchSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatchQueueDefaultPriority)

let dispatchQueueLowPriority = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0)

dispatch_set_target_queue(dispatchSource, dispatchQueueLowPriority)
</code></pre>
<p>这里需要注意的是，如果在更改目标队列时，Dispatch Source已经监听到相关事件，并且回调函数已经在之前的队列中执行了，那么会一直在旧的队列中执行完成，不会转移到新的队列中去。</p>
<h3 id="u6682_u505C_u6062_u590DDispatch_Source"><a href="#u6682_u505C_u6062_u590DDispatch_Source" class="headerlink" title="暂停恢复Dispatch Source"></a>暂停恢复Dispatch Source</h3><p>暂停和恢复Dispatch Source与Dispatch Queue一样，都适用<code>dispatch_suspend</code>和<code>dispatch_resume</code>函数。这里需要注意的是刚创建好的Dispatch Source是处于暂停状态的，所以使用时需要用<code>dispatch_resume</code>函数将其启动。</p>
<h3 id="u5E9F_u9664Dispatch_Source"><a href="#u5E9F_u9664Dispatch_Source" class="headerlink" title="废除Dispatch Source"></a>废除Dispatch Source</h3><p>如果我们不再需要使用某个Dispatch Source时，可以使用<code>dispatch_source_cancel</code>函数废除，该函数只有一个参数，那就是目标Dispatch Source。</p>
<h3 id="Dispatch_Source_u5B9E_u8DF5"><a href="#Dispatch_Source_u5B9E_u8DF5" class="headerlink" title="Dispatch Source实践"></a>Dispatch Source实践</h3><p>说了这么多，这一节来看看Dispatch Source到底怎么用。</p>
<h4 id="u7528Dispatch_Source_u76D1_u542C_u5B9A_u65F6_u5668"><a href="#u7528Dispatch_Source_u76D1_u542C_u5B9A_u65F6_u5668" class="headerlink" title="用Dispatch Source监听定时器"></a>用Dispatch Source监听定时器</h4><p>Dispatch Source能监听的事件中有一个类型就是定时器，我们来看看如何实现：</p>
<pre><code class="swift">class TestDispatchSource {

    func launch() {

        let dispatchQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

        let timer = createTimerDispatchSource(dispatch_time(DISPATCH_TIME_NOW, 0), interval: NSEC_PER_SEC * 5, leeway: 0, queue: dispatchQueue) {

            print(&quot;处理定时任务，该任务每5秒执行一次...&quot;)

        }

        dispatch_resume(timer)

        sleep(30)

    }

    func createTimerDispatchSource(startTime: dispatch_time_t, interval: UInt64, leeway: UInt64, queue: dispatch_queue_t, handler: dispatch_block_t) -&gt; dispatch_source_t {

        let timerDispatchSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue)

        dispatch_source_set_timer(timerDispatchSource, startTime, interval, leeway)

        dispatch_source_set_event_handler(timerDispatchSource, handler)

        return timerDispatchSource

    }

}
</code></pre>
<p>上面的代码示例中一个新的函数<code>dispatch_source_set_timer</code>，该函数的作用就是给监听事件类型为<code>DISPATCH_SOURCE_TYPE_TIMER</code>的Dispatch Source设置相关属性，该函数有四个参数：</p>
<ul>
<li><code>source</code>：该参数为目标Dispatch Source，类型为<code>dispatch_source_t</code>.</li>
<li><code>start</code>：该参数为定时器的起始时间，类型为<code>dispatch_time_t</code>。</li>
<li><code>interval</code>：该参数为定时器的间隔时间，类型为<code>UInt64</code>，间隔时间的单位是纳秒。</li>
<li><code>leeway</code>：该参数为间隔时间的精度，类型为<code>UInt64</code>，时间单位也是纳秒。</li>
</ul>
<h4 id="u7528Dispatch_Source_u76D1_u542C_u81EA_u5B9A_u4E49_u4E8B_u4EF6"><a href="#u7528Dispatch_Source_u76D1_u542C_u81EA_u5B9A_u4E49_u4E8B_u4EF6" class="headerlink" title="用Dispatch Source监听自定义事件"></a>用Dispatch Source监听自定义事件</h4><p>Dispatch Source能监听的事件中有一个类型是自定义事件，下面我们来看看如何使用:</p>
<pre><code class="swift">class TestDispatchSource {

    func launch() {

        var totalProcess = 0

        let dispatchSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_DATA_ADD, 0, 0, dispatch_get_main_queue())

        dispatch_source_set_event_handler(dispatchSource) {

            let process = dispatch_source_get_data(dispatchSource)

            totalProcess += Int(process)

            print(&quot;这里可以在主线程更新UI，显示进度条...进度为\(totalProcess)%&quot;)
        }

        dispatch_resume(dispatchSource)

        generateCustomEvent(dispatchSource)

    }

    func generateCustomEvent(dispatchSource: dispatch_source_t) {

        let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)

        for index in 0...100 {

            dispatch_sync(queue) {

                print(&quot;模拟自定义事件...进度为\(index)%&quot;)

                dispatch_source_merge_data(dispatchSource, 1)

                sleep(2)

            }

        }

    }

}
</code></pre>
<p>我们来看看<code>generateCustomEvent(dispatchSource: dispatch_source_t)</code>方法，该方法的作用的是模拟自定义事件，首先创建一个全局并发队列，然后循环让其执行任务，在执行的任务里调用<code>dispatch_source_merge_data</code>函数，就可以触发监听类型为<code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>或者<code>DISPATCH_SOURCE_TYPE_DATA_OR</code>的Dispatch Source。该函数有两个参数，第一个参数是目标Dispatch Source，第二个参数的类型是无符号长整型，用于向目标Dispatch Source中的对应变量追加指定的数。</p>
<p>我们再来看看如何监听自定义时间，首先创建类型为<code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>的Dispatch Source，然后设置回调闭包，在闭包中使用<code>dispatch_source_get_data</code>获取追加的变量值，该函数只有一个参数，就是目标Dispatch Source，这里需要注意的是通过<code>dispatch_source_get_data</code>函数获取的变量值并不是累加值，而是每次调用<code>dispatch_source_merge_data</code>函数时设置的值，所以在上面的示例中用<code>totalProcess</code>变量累加每次获取到的值。</p>
<p>上面的示例可以用来模拟后台进行下载，根据下载的数据量使用<code>dispatch_source_merge_data</code>函数给目标Dispatch Source设置相应的变量值，然后在主线程中监听到Dispatch Source的自定义事件，通过<code>dispatch_source_get_data</code>函数获取到变量，用于更新显示进度条的UI。</p>
<p><a href="http://www.devtalking.com/donate.html"><br>    <img border="0" src="http://www.devtalking.com/donate.png"><br></a><br><a href="http://www.devtalking.com/gongzhonghao.html"><br>    <img border="0" src="http://www.devtalking.com/guanzhugongzhonghao.png"><br></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/69122" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="u901A_u8FC7Dispatc]]>
    </summary>
    
      <category term="Concurrency" scheme="http://www.devtalking.com/tags/Concurrency/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Concurrency Programming Guide 笔记（二）]]></title>
    <link href="http://www.devtalking.com//articles/read-concurrency-programming-guide-2/"/>
    <id>http://www.devtalking.com//articles/read-concurrency-programming-guide-2/</id>
    <published>2016-03-22T16:00:00.000Z</published>
    <updated>2016-03-23T13:31:58.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/63001" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="Operation_u5BF9_u8C61_u7684_u76F8_u5173_u8BBE_u7F6E"><a href="#Operation_u5BF9_u8C61_u7684_u76F8_u5173_u8BBE_u7F6E" class="headerlink" title="Operation对象的相关设置"></a>Operation对象的相关设置</h2><p>Operation对象除了上文中讲到到基本使用方法外还有一些其他的特性，这些特性需要根据我们的应用场景去设置，设置的时机在创建Operation对象之后和运行它或者将其放入操作队列之前，下面让我们来看看Operation对象还有哪些特性。</p>
<h3 id="Operation_u5BF9_u8C61_u4E4B_u95F4_u7684_u4F9D_u8D56"><a href="#Operation_u5BF9_u8C61_u4E4B_u95F4_u7684_u4F9D_u8D56" class="headerlink" title="Operation对象之间的依赖"></a>Operation对象之间的依赖</h3><p>与GCD不同，Operation Queue不遵循先进先出的原则，而且Operation Queue始终是并发执行Operation对象的，所以想让Operation对象串行执行就需要用它的Operation对象依赖特性，该特性可以让Operation对象将自己与另外一个Operation对象进行关联，并且当关联的Operation对象执行完成后才可以执行，这样就达到了串行执行Operation对象的目的。</p>
<p>我们可以用<code>NSOperation</code>的<code>addDependency</code>方法添加依赖的Operation对象，而且产生依赖的这两个Operation对象并不要求必须在相同的操作队列中，但是这种依赖只能是单向的，不能相互依赖。</p>
<pre><code class="swift">import Foundation

class TestOperationDependency {

    func launch() {

        let blockOperationA = NSBlockOperation(block: {

            print(&quot;Task in blockOperationA...&quot;)

            sleep(3)

        })

        let blockOperationB = NSBlockOperation(block: {

            print(&quot;Task in blockOperationB...&quot;)

            sleep(5)

        })

        blockOperationA.addDependency(blockOperationB)

        let operationQueue = NSOperationQueue()

        operationQueue.addOperation(blockOperationA)

        operationQueue.addOperation(blockOperationB)

        sleep(10)

    }

}

let testOperationDependency = TestOperationDependency()

testOperationDependency.launch()
</code></pre>
<p>上面的示例代码展示了如何给Operation对象添加依赖，大家可以注释掉<code>blockOperationA.addDependency(blockOperationB)</code>这一行看看打印结果有什么区别。</p>
<h3 id="Operation_u5BF9_u8C61_u7684_u4F18_u5148_u7EA7"><a href="#Operation_u5BF9_u8C61_u7684_u4F18_u5148_u7EA7" class="headerlink" title="Operation对象的优先级"></a>Operation对象的优先级</h3><p>上文中说了，操作队列里的Operation对象都是并发执行的，如果一个操作队列中有多个Operation对象，那么谁先执行谁后执行取决于Operation对象的依赖Operation对象是否已执行完成，也就是是否处于准备执行的状态。其实Operation对象自身也有优先级的属性，如果有两个都处于准备执行状态的Operation对象，那么优先级高的会先执行，优先级低的后执行。每个Operation对象默认的优先级是<code>NSOperationQueuePriority.Normal</code>级别，我们可以通过设置<code>queuePriority</code>属性更改Operation的在队列中执行的优先级，优先级别有以下五种：</p>
<ul>
<li><code>NSOperationQueuePriority.Normal</code>：正常优先级</li>
<li><code>NSOperationQueuePriority.Low</code>：低优先级</li>
<li><code>NSOperationQueuePriority.VeryLow</code>：非常低优先级</li>
<li><code>NSOperationQueuePriority.High</code>：高优先级</li>
<li><code>NSOperationQueuePriority.VeryHigh</code>：非常高优先级</li>
</ul>
<p>这里我们需要注意一下Operation对象优先级的作用域，它只能作用于相同的操作队列中，不同操作队列中的Operation对象是不受优先级影响的。另外需要注意的是，如果有两个Operation对象，一个处于准备执行状态，但优先级比较低，另一个处于等待状态，但优先级比较高，那么此时仍然是处于准备执行状态的低优先级Operation对象先执行。可见Operation对象的优先级相互影响需要满足两个条件，一是必须处在同一个操作队列中，另一个是Operation对象都处于准备执行状态。</p>
<h3 id="u901A_u8FC7Operation_u5BF9_u8C61_u4FEE_u6539_u7EBF_u7A0B_u4F18_u5148_u7EA7"><a href="#u901A_u8FC7Operation_u5BF9_u8C61_u4FEE_u6539_u7EBF_u7A0B_u4F18_u5148_u7EA7" class="headerlink" title="通过Operation对象修改线程优先级"></a>通过Operation对象修改线程优先级</h3><p>通常情况下，线程的优先级由内核自己管理，不过在OS X v10.6及以后的版本和iOS4到iOS7期间，<code>NSOperation</code>多了一个<code>threadPriority</code>属性，我们可以通过该属性设置Operation对象运行所在线程的优先级，数值范围为0.0到1.0，数字越高优先级越高。不过可能是出于线程安全等方面的考虑，Apple从iOS8开始废除了该属性。</p>
<h3 id="u8BBE_u7F6ECompletion_Block"><a href="#u8BBE_u7F6ECompletion_Block" class="headerlink" title="设置Completion Block"></a>设置Completion Block</h3><p>上篇文章中说过，Operation对象其中的一个特别好的特性就是完成时回调闭包Completion Block。它的作用不言而喻，就是当主要任务执行完成之后做一些收尾的处理工作，我们可以设置<code>completionBlock</code>属性给Operation对象添加完成时回调闭包：</p>
<pre><code class="swift">blockOperationA.completionBlock = {

    print(&quot;blockOperationA has finished...&quot;)

}
</code></pre>
<h2 id="u6267_u884COperation_u5BF9_u8C61"><a href="#u6267_u884COperation_u5BF9_u8C61" class="headerlink" title="执行Operation对象"></a>执行Operation对象</h2><p>虽然前面文章的示例中已经包含了对Operation对象的执行，但是并没详细说明，这节就说说Operation对象的执行。</p>
<h3 id="u4F7F_u7528Operation_Queue"><a href="#u4F7F_u7528Operation_Queue" class="headerlink" title="使用Operation Queue"></a>使用Operation Queue</h3><p>使用Operation Queue操作队列执行Operation对象已然是标配选项了，操作队列在Cocoa框架中对应的类是<code>NSOperationQueue</code>，一个操作队列中可以添加多个Operation对象，但一次到底添加多少Operation对象得根据实际情况而定，比如应用程序对内存的消耗情况、内核的空闲情况等，所以说凡事得有度，不然反而会适得其反。另外需要注意的一点是不论有多少个操作队列，它们都受制于系统的负载、内核空闲等运行情况，所以说并不是说再创建一个操作队列就能执行更多的Operation对象。</p>
<p>在使用操作队列时，我们首先要创建<code>NSOperationQueue</code>的实例：</p>
<pre><code class="swift">let operationQueue = NSOperationQueue()
</code></pre>
<p>然后通过<code>NSOperationQueue</code>的<code>addOperation</code>方法添加Operation对象：</p>
<pre><code class="swift">operationQueue.addOperation(blockOperationA)

operationQueue.addOperation(blockOperationB)
</code></pre>
<p>在OS X v10.6之后和iOS4之后，我们还可以用<code>addOperations:waitUntilFinished:</code>方法添加一组Operation对象：</p>
<pre><code class="swift">operationQueue.addOperations([blockOperationA, blockOperationB], waitUntilFinished: false)
</code></pre>
<p>该方法有两个参数：</p>
<ul>
<li><code>ops: [NSOperation]</code>：Operation对象数组。</li>
<li><code>waitUntilFinished wait: Bool</code>：该参数标示这个操作队列在执行Operation对象时是否会阻塞当前线程。</li>
</ul>
<p>我们还可以通过<code>addOperationWithBlock</code>方法向操作队列中直接添加闭包，而不需要去创建Operation对象：</p>
<pre><code class="swift">operationQueue.addOperationWithBlock({

    print(&quot;The block is running in Operation Queue...&quot;)

})
</code></pre>
<p>除了以上这几种添加Operation对象的方法外，还可以通过<code>NSOperationQueue</code>的<code>maxConcurrentOperationCount</code>属性设置同时执行Operation对象的最大数：</p>
<pre><code class="swift">operationQueue.maxConcurrentOperationCount = 2
</code></pre>
<p>如果设置为1，那么不管该操作队列中添加了多少Operation对象，每次都只运行一个，而且会按照添加Operation对象的顺序去执行。所以如果遇到添加到操作的队列的Operation对象延迟执行了，那么通常会有两个原因：</p>
<ul>
<li>添加的Operation对象数超过了操作队列设置的同时执行Operation对象的最大数。</li>
<li>延迟执行的Operation对象在等待它依赖的Operation对象执行完成。</li>
</ul>
<p>另外需要的注意的是当Operation对象添加到操作队列中后，不要再更改它任务中涉及到的任何属性或者它的依赖，因为到操作队列中的Operation对象随时会被执行，所以如果你自以为它还没有被执行而去修改它，可能并不会达到你想要的结果。</p>
<h3 id="u624B_u52A8_u6267_u884COperation_u5BF9_u8C61"><a href="#u624B_u52A8_u6267_u884COperation_u5BF9_u8C61" class="headerlink" title="手动执行Operation对象"></a>手动执行Operation对象</h3><p>除了用操作队列来执行Operation对象以外，我们还可以手动执行某个Operation对象，但是这需要我们注意更多的细节问题，也要写更多的代码去确保Operation对象能正确执行。在上篇文章中，我们创建过自定义的Operation对象，其中我们知道有几个属性特别需要我们注意，那就是<code>ready</code>、<code>concurrent</code>、<code>executing</code>、<code>finished</code>、<code>cancelled</code>，对应Operation对象是否出于准备执行状态、是否为异步并发执行的、是否正在执行、是否已经执行完成、是否已被终止。这些状态在我们使用操作队列时都不需要理会，都有操作队列帮我们把控判断，确保Operation对象的正确执行，我们只需要在必要的时候获取状态信息查看而已。但是如果手动执行Operation对象，那么这些状态都需要我们来把控，因为你手动执行一个Operation对象时要判断它的依赖对象是否执行完成，是否被终止了等等，所以并不是简单的调用<code>start</code>方法，下面来看看如果正确的手动执行Operation对象：</p>
<pre><code class="swift">func performOperation(operation: NSOperation) -&gt; Bool {

    var result = false

    if operation.ready &amp;&amp; !operation.cancelled {

        if operation.concurrent {

            operation.start()

        } else {

            NSThread.detachNewThreadSelector(&quot;start&quot;, toTarget: operation, withObject: nil)

        }

        result = true

    }

    return result

}
</code></pre>
<h3 id="u7EC8_u6B62Operation_u5BF9_u8C61_u6267_u884C"><a href="#u7EC8_u6B62Operation_u5BF9_u8C61_u6267_u884C" class="headerlink" title="终止Operation对象执行"></a>终止Operation对象执行</h3><p>一旦Operation对象被添加到操作队列中，这个Operation对象就属于这个操作队列了，并且不能被移除，唯一能让Operation对象失效的方法就是通过<code>NSOperation</code>的<code>cancel</code>方法终止它执行，或者也可以通过<code>NSOperationQueue</code>的<code>cancelAllOperations</code>方法终止在队列中的所有Operation对象。</p>
<h3 id="u6682_u505C_u548C_u6062_u590D_u64CD_u4F5C_u961F_u5217"><a href="#u6682_u505C_u548C_u6062_u590D_u64CD_u4F5C_u961F_u5217" class="headerlink" title="暂停和恢复操作队列"></a>暂停和恢复操作队列</h3><p>在实际运用中，如果我们希望暂停操作队列执行Operation对象，可以通过设置<code>NSOperationQueue</code>的<code>suspended</code>属性为<code>false</code>来实现，不过这里要注意的是暂停操作队列只是暂停执行下一个Operation对象，而不是暂停当前正在执行的Operation对象，将<code>suspended</code>属性设置为<code>true</code>后，操作队列则恢复执行。</p>
<h2 id="Dispatch_Queues"><a href="#Dispatch_Queues" class="headerlink" title="Dispatch Queues"></a>Dispatch Queues</h2><p>Dispatch Queue是GCD中的核心功能，它能让我们很方便的异步或同步执行任何被封装为闭包的任务，它的运作模式与Operation Queue很相似，但是有一点不同的是Dispatch Queue是一种先进先出的数据结构，也就是执行任务的顺序永远等同于添加任务时的顺序。GCD中已经为我们提供了几种类型的Dispatch Queue，当然我们也可以根据需求自己创建Dispatch Queue，下面我们先来看看Dispatch Queue的类型：</p>
<ul>
<li>串行Dispatch Queue：该类型的队列一次只能执行一个任务，当前任务完成之后才能执行下一个任务，而且可依任务的不同而在不同的线程中执行，这类队列通常作为私有队列使用。这里需要注意的是虽然该类型的队列一次只能执行一个任务，但是可以让多个串行队列同时开始执行任务，达到并发执行的任务的目的。</li>
<li>并行Dispatch Queue：该类队列可同时执行多个任务，但是执行任务的顺序依然是遵循先进先出的原则，同样可依任务的不同而在不同的线程中执行，这类队列通常作为全局队列使用。</li>
<li>主Dispatch Queue：该类队列实质上也是一个串行队列，但是该队列是一个全局队列，在该队列中执行的任务都是在当前应用的主线程中执行的。通常情况下我们不需要自己创建此类队列。</li>
</ul>
<p>Dispatch Queue与Operation Queue相似，都能让我们更方便的实现并发任务的编程工作，并且能提供更优的性能，因为我们不再需要编写关于线程管理相关的一大堆代码，这些完全都有系统接管，我们只需要将注意力放在要执行的任务即可。举个简单的例子，如果有两个任务需要在不同的线程中执行，但是他们之间存在资源竞争的情况，所以需要保证执行的先后顺序，如果我们自己创建线程实现该场景，那么就务必要用的线程锁机制，确保任务有正确的执行顺序，这势必对系统资源的开销会非常大，如果使用Dispatch Queue，我们只需要将任务安正确的顺序添加到串行队列中即可，省时省力省资源。</p>
<h3 id="u4EFB_u52A1_u7684_u8F7D_u4F53_u662F_u95ED_u5305"><a href="#u4EFB_u52A1_u7684_u8F7D_u4F53_u662F_u95ED_u5305" class="headerlink" title="任务的载体是闭包"></a>任务的载体是闭包</h3><p>在使用Dispatch Queue时，需要将任务封装为闭包。闭包就是一个函数，或者一个指向函数的指针，加上这个函数执行的非局部变量，闭包最大的一个特性就是可以访问父作用域中的局部变量。我们在将任务封装为闭包进行使用时要注意以下这几点：</p>
<ul>
<li>虽然在闭包中可以使用父作用域中的变量，但是尽可能少的使用父作用域中比较大的变量以及不要在闭包中做类似删除清空父作用域中变量的行为。</li>
<li>当将一个封装好任务的闭包添加至Dispatch Qeueu中，Dispatch Queue会自动复制该闭包，并且在执行完成后释放该闭包，所以不同担心闭包中一些值的变化问题，以及资源释放问题。</li>
<li>虽然使用Dispatch Queue执行并发异步任务很方便，但是创建和执行闭包还是有一定资源开销的，所以尽量不要使用Dispatch Queue执行一些很小的任务，要物有所值。如果确实有很小的任务需要并发异步执行，那么使用<code>NSThread</code>的<code>detachNewThreadSelector</code>方法或<code>NSObject</code>的<code>performSelectorInBackground</code>方法去执行也未必不可。</li>
<li>如果同一个队列中的多个任务之间需要共享数据，那么应该使用队列上下文去存储数据，供不同的任务访问。</li>
<li>如果闭包中的任务创建了不少对象，那么应该考虑将整个任务逻辑代码放在<code>autoreleasepool</code>中，虽然Dispatch Queue中也有自动释放池，但是你不能保证它每次释放的时间，所以咱们自己再加一个要来的更保险一些。</li>
</ul>
<h2 id="u521B_u5EFA_u4E0E_u7BA1_u7406Dispatch_Queues"><a href="#u521B_u5EFA_u4E0E_u7BA1_u7406Dispatch_Queues" class="headerlink" title="创建与管理Dispatch Queues"></a>创建与管理Dispatch Queues</h2><p>在使用Dispatch Queue之前，我们首先需要考虑应该创建什么类型的Dispatch Queue，如何进行配置等，这一节就来说一说如何创建和管理Dispatch Queue。</p>
<h3 id="u5168_u5C40_u5E76_u53D1Dispatch_Queue"><a href="#u5168_u5C40_u5E76_u53D1Dispatch_Queue" class="headerlink" title="全局并发Dispatch Queue"></a>全局并发Dispatch Queue</h3><p>并发队列的好处人人皆知，可以方便的同时处理多个任务，在GCD中并发Dispatch Queue同样遵循先进先出的原则，但这只是在运行时适用，如果有个任务在并发队列中还没轮到它执行，那么此时完全可以移除它，而不必等它前面的任务执行完成之后。至于并发队列中没次有多少个任务在执行，这个恐怖在每一秒都在变化，因为影响它的因素有很多，所以之前说过，尽量不要移除移除已经添加进队列的任务。</p>
<p>OS X和iOS系统为我们提供了四种全局并发Dispatch Queue，所谓全局队列，就是我们不需要理会它们的保留和释放问题，而且不需要专门创建它。与其说是四种不如说是一种全局并发队列的四种不同优先级，因为它们之间唯一的不同之处就是队列优先级不同。与Operation Queue不同，在GCD中，Dispatch Queue只有四种优先级：</p>
<ul>
<li><code>DISPATCH_QUEUE_PRIORITY_HIGH</code>：高优先级。</li>
<li><code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>：默认优先级，低于高优先级。</li>
<li><code>DISPATCH_QUEUE_PRIORITY_LOW</code>：低优先级，低于高优先级和默认优先级。</li>
<li><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>：后台优先级，低于高优先级和后台线程执行的任务。</li>
</ul>
<p>我们可以通过<code>dispatch_get_global_queue</code>函数再根据不同的优先级获取不同的全局并发队列，类型为<code>dispatch_queue_t</code>：</p>
<pre><code class="swift">let highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)

let defaultPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)
</code></pre>
<p>我们在使用全局并发队列的时候不需要保留队列的引用，随时要用随时用该函数获取即可。当然我们也可以通过<code>dispatch_queue_create</code>函数自己创建队列：</p>
<pre><code class="swift">let concurrentQueue = dispatch_queue_create(&quot;com.example.MyConcurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT)
</code></pre>
<p>从上面代码可以看到，<code>dispatch_queue_create</code>函数有两个参数，第一个为队列的名称，第二个为队列类型，串行队列为<code>DISPATCH_QUEUE_SERIAL</code>，并发队列为<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>
<h3 id="u4E32_u884CDispatch_Queue"><a href="#u4E32_u884CDispatch_Queue" class="headerlink" title="串行Dispatch Queue"></a>串行Dispatch Queue</h3><p>串行队列可以让我们将任务按照一定顺序执行，能更优的处理多个任务之间的资源竞争问题，比线程锁机制有更小的资源开销和更好的性能，并且不会产生死锁的问题。</p>
<p>系统也为我们提供了一个串行队列，我们可以通过<code>dispatch_get_main_queue</code>函数获取：</p>
<pre><code class="swift">let mainQueue = dispatch_get_main_queue()
</code></pre>
<p>该队列与当前应用的主线程相关联。当然我们也可以自己创建串行队列：</p>
<pre><code class="swift">let serialQueueA = dispatch_queue_create(&quot;com.example.MySerialQueueA&quot;, DISPATCH_QUEUE_SERIAL)

// 或者

let serialQueueB = dispatch_queue_create(&quot;com.example.MySerialQueueB&quot;, nil)
</code></pre>
<p><code>dispatch_queue_create</code>函数的第二个参数如果为<code>nil</code>则默认创建串行队列。当我们创建好串行队列后，系统会自动将创建好的队列与当前应用的主线程进行关联。</p>
<h3 id="u83B7_u53D6_u5F53_u524D_u961F_u5217"><a href="#u83B7_u53D6_u5F53_u524D_u961F_u5217" class="headerlink" title="获取当前队列"></a>获取当前队列</h3><p>如果需要验证或者测试当前队列，我们可以通过<code>dispatch_get_current_queue</code>函数获取当前队列。如果在闭包中调用，返回的是该闭包所在的队列，如果在闭包外调用，返回的则是默认的并发队列。不过该函数在OS X v10.10中和Swift中都不能使用了，取而代之的是通过<code>DISPATCH_CURRENT_QUEUE_LABEL</code>属性的<code>get</code>方法。</p>
<h3 id="u64C5_u7528_u961F_u5217_u4E0A_u4E0B_u6587"><a href="#u64C5_u7528_u961F_u5217_u4E0A_u4E0B_u6587" class="headerlink" title="擅用队列上下文"></a>擅用队列上下文</h3><p>很多情况下，同一个队列中的不同任务之间需要共享数据，尤其像串行队列中的任务，可能由多个任务对某个变量进行处理，或者都需要使用到某个对象，这时就要用到队列上下文:</p>
<pre><code class="swift">import Foundation

class TestDispatchQueue {

    func launch() {

        let serialQueue = dispatch_queue_create(&quot;com.example.MySerialQueue&quot;, DISPATCH_QUEUE_SERIAL)

        dispatch_set_context(serialQueue, unsafeBitCast(0, UnsafeMutablePointer&lt;Int&gt;.self))

        dispatch_async(serialQueue, {

            var taskCount = unsafeBitCast(dispatch_get_context(serialQueue), Int.self)

            taskCount++

            print(&quot;TaskA in the dispatch queue...and The number of task in queue is \(taskCount)&quot;)

            dispatch_set_context(serialQueue, unsafeBitCast(taskCount, UnsafeMutablePointer&lt;Int&gt;.self))

            sleep(1)

        })

        dispatch_async(serialQueue, {

            var taskCount = unsafeBitCast(dispatch_get_context(serialQueue), Int.self)

            taskCount++

            print(&quot;TaskB in the dispatch queue...and The number of task in queue is \(taskCount)&quot;)

            dispatch_set_context(serialQueue, unsafeBitCast(taskCount, UnsafeMutablePointer&lt;Int&gt;.self))

        })

        sleep(3)

    }

}

let testDispatchQueue = TestDispatchQueue()
testDispatchQueue.launch()
</code></pre>
<p>从上面的代码示例中可以看到，在执行代码点，我们用<code>dispatch_set_context</code>函数向<code>serialQueue</code>队列的上下文环境中设置了一个<code>Int</code>类型的变量，初始值为0。该函数有两个参数，第一个是目标队列，第二个参数是上下文数据的指针。然后在闭包中我们使用<code>dispatch_get_context</code>函数获取上下文数据进行进一步的处理。除了基本类型，我们也可以将自定义的类放入队列上下文中：</p>
<pre><code class="swift">import Foundation

class Contact: NSObject {

    let name = &quot;DevTalking&quot;

    let mobile = &quot;10010&quot;

}

class TestDispatchQueue {

    let contact = Contact()

    func launch() {

        let serialQueue = dispatch_queue_create(&quot;com.example.MySerialQueue&quot;, DISPATCH_QUEUE_SERIAL)

        dispatch_set_context(serialQueue, unsafeBitCast(contact, UnsafeMutablePointer&lt;Void&gt;.self))

        dispatch_async(serialQueue, {

            let contact = unsafeBitCast(dispatch_get_context(serialQueue), Contact.self)

            print(&quot;The name is \(contact.name)&quot;)

            sleep(1)

        })

        dispatch_async(serialQueue, {

            let contact = unsafeBitCast(dispatch_get_context(serialQueue), Contact.self)

            print(&quot;The name is \(contact.mobile)&quot;)

        })

        sleep(3)

    }

}

let testDispatchQueue = TestDispatchQueue()
testDispatchQueue.launch()
</code></pre>
<blockquote>
<p>关于<code>unsafeBitCast</code>函数和Swift中指针的用法在<a href="http://www.devtalking.com/articles/read-threading-programming-guide-3/">这里</a>可以有所参考。</p>
</blockquote>
<h3 id="u961F_u5217_u7684_u6536_u5C3E_u5DE5_u4F5C"><a href="#u961F_u5217_u7684_u6536_u5C3E_u5DE5_u4F5C" class="headerlink" title="队列的收尾工作"></a>队列的收尾工作</h3><p>虽然在ARC时代，资源释放的工作已经基本不需要我们手动去做了，但有些时候因为系统释放资源并不是很及时，也会造成内存移除等问题，所以在一些情况下我们还是需要进行手动释放资源的工作，必入添加<code>autoreleasepool</code>保证资源及时释放等。Dispatch Queue也给我们提供了这样的机会（机会针对于ARC时代，在MRC时代是必须要做的），那就是Clean Up  Function清理扫尾函数，当队列被释放时，或者说引用计数为0时会调用该函数，并且将上下文指针也传到了该函数，以便进行清理工作：</p>
<pre><code class="swift">import Foundation

class Contact: NSObject {

    let name = &quot;DevTalking&quot;

    let mobile = &quot;10010&quot;

}

class TestDispatchQueue {

    let contact = Contact()

    func testCleanUpFunction() {

        launch()

        sleep(15)

    }

    func launch() {

        let serialQueue = dispatch_queue_create(&quot;com.example.MySerialQueue&quot;, DISPATCH_QUEUE_SERIAL)

        dispatch_set_context(serialQueue, unsafeBitCast(contact, UnsafeMutablePointer&lt;Void&gt;.self))

        dispatch_set_finalizer_f(serialQueue, myFinalizerFunction())

        dispatch_async(serialQueue, {

            let contact = unsafeBitCast(dispatch_get_context(serialQueue), Contact.self)

            print(&quot;The name is \(contact.name)&quot;)

            sleep(1)

        })

        dispatch_async(serialQueue, {

            let contact = unsafeBitCast(dispatch_get_context(serialQueue), Contact.self)

            print(&quot;The name is \(contact.mobile)&quot;)

        })

        sleep(3)

    }

    func myFinalizerFunction() -&gt; dispatch_function_t {

        return { context in

            let contact = unsafeBitCast(context, Contact.self)

            print(&quot;The name is \(contact.name) and the mobile is \(contact.mobile), The serialQueue has been released and we need clean up context data.&quot;)

            // TODO...

        }

    }

}

let testDispatchQueue = TestDispatchQueue()
testDispatchQueue.testCleanUpFunction()
</code></pre>
<p>从上面的代码示例中可以看到当给队列设置完上下文时，我们使用了<code>dispatch_set_finalizer_f</code>函数给队列设置清理函数，<code>dispatch_set_finalizer_f</code>函数有两个参数，第一个是目标队列，第二个参数是类型为<code>dispatch_function_t</code>的函数指针，也就是清理函数，上下文数据指针是该函数唯一的参数。在上面代码中，我们添加了<code>myFinalizerFunction</code>函数作为清理函数，在该函数中获得上下文数据，然后进行后续的清理工作。</p>
<p><a href="http://www.devtalking.com/donate.html"><br>    <img border="0" src="http://www.devtalking.com/donate.png"><br></a><br><a href="http://www.devtalking.com/gongzhonghao.html"><br>    <img border="0" src="http://www.devtalking.com/guanzhugongzhonghao.png"><br></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/63001" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="Operation_u5BF9_u8]]>
    </summary>
    
      <category term="Concurrency" scheme="http://www.devtalking.com/tags/Concurrency/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Concurrency Programming Guide 笔记（一）]]></title>
    <link href="http://www.devtalking.com//articles/read-concurrency-programming-guide-1/"/>
    <id>http://www.devtalking.com//articles/read-concurrency-programming-guide-1/</id>
    <published>2016-03-10T16:00:00.000Z</published>
    <updated>2016-03-23T13:31:50.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/60236" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>并发任务是指多个任务在某一时刻同时运行。在过去，一提到并发执行任务，首当其冲的解决方案就是在程序中创建多个线程来实现，但是线程本身较为底层，而且管理的难度比较大，如果想做倒最优的线程数量、最恰当的线程创建销毁时机是很难的，以至于虽然达到了并发执行任务的目的，但却以降低程序性能为代价，所以往往得不偿失。</p>
<p>鉴于上述的原因，于是一些实现并发任务的其他方案出现了。在OS X和iOS系统中采用了多种实现并发执行任务的方法，与直接创建线程不同，这些方法让开发者只需要关注要执行的任务，然后让系统执行它们即可，不需要关心线程管理的问题，为开发者提供了一个简单而高效的并发任务编程模式。</p>
<p>其中一种实现任务异步执行的技术就是Grand Central Dispatch（GCD），该技术封提供了系统级别的线程管理功能，我们在使用它时只需要定义我们希望执行的任务，然后将任务添加到对应的分派执行队列中即可。另外一个技术是Operation queues，具体的实现是Objective-C中的<code>NSOperationQueue</code>对象，它的作用和GCD很相似，同样只需要我们定义好任务，然后添加到对应的操作队列中即可，其他与线程管理相关的事都由<code>NSOperationQueue</code>帮我们完成。</p>
<h2 id="Dispatch_Queues_u7B80_u8FF0"><a href="#Dispatch_Queues_u7B80_u8FF0" class="headerlink" title="Dispatch Queues简述"></a>Dispatch Queues简述</h2><p>Dispatch Queues是基于C语言的，执行自定义任务的技术，从字面意思理解其实就是执行任务的队列，使用GCD执行的任务都是放在这个队列中执行的，当然队列的数量可以有多个，类型也不止一种。一个Dispatch queue可以串行的执行任务，也可以并行的执行任务，但不管哪种执行任务的方式，都遵循先进先出的原则。串行队列一次只能执行一个任务，当前任务执行完后才能执行下一个任务，并且执行任务的顺序和添加任务的顺序是一致的。并行队列自然是可同时执行多个任务，不需要等待上个任务完成后才执行下个任务。我们来看看Dispatch queue还有哪些好的特性：</p>
<ul>
<li>有简单宜用，通俗易懂的编程接口。</li>
<li>提供了自动管理的线程池。</li>
<li>可自动调节队列装载任务的速度。</li>
<li>更优的内存使用率。</li>
<li>使用户不用担心死锁的问题。</li>
<li>提供了比线程锁更优的同步机制。</li>
</ul>
<p>使用Dispatch Queue时，需要将任务封装为一个函数或者一个<code>block</code>，<code>block</code>是Objective-C中对闭包的实现，在OS X 10.6和iOS 4.0时引入的，在Swift中直接为闭包。</p>
<h2 id="Dispatch_Sources_u7B80_u8FF0"><a href="#Dispatch_Sources_u7B80_u8FF0" class="headerlink" title="Dispatch Sources简述"></a>Dispatch Sources简述</h2><p>Dispatch Source是GCD中的一个基本类型，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。我们来看看它都有哪些类型：</p>
<ul>
<li>Timer Dispatch Source：定时调度源。</li>
<li>Signal Dispatch Source：监听UNIX信号调度源，比如监听代表挂起指令的SIGSTOP信号。</li>
<li>Descriptor Dispatch Source：监听文件相关操作和Socket相关操作的调度源。</li>
<li>Process Dispatch Source：监听进程相关状态的调度源。</li>
<li>Mach port Dispatch Source：监听Mach相关事件的调度源。</li>
<li>Custom Dispatch Source：监听自定义事件的调度源。</li>
</ul>
<p>Dispatch Source是GCD中很有意思也很有用的一个特性，根据不同类型的调度源，我们可以监听较为底层的系统行为，不论在实现功能方面还是调试功能方面都非常游有用，后文中会再详细讲述。</p>
<h2 id="Operation_Queues_u7B80_u8FF0"><a href="#Operation_Queues_u7B80_u8FF0" class="headerlink" title="Operation Queues简述"></a>Operation Queues简述</h2><p>Operation Queue与Dispatch Queue很类似，都是有任务队列或操作队列的概念，只不过它是由Cocoa框架中的<code>NSOperationQueue</code>类实现的，它俩最主要的区别是任务的执行顺序，在Dispatch Queue中，任务永远都是遵循先进先出的原则，而Operation Queue加入了其他的任务执行顺序特性，使下一个任务的开始不再取决于上个任务是否已完成。</p>
<p>上文说过，使用Dispatch Queue时，需要将任务封装为一个函数或者闭包。而在Operation Queue中，需要将任务封装为一个<code>NSOpertaion</code>对象，然后放入操作队列执行。同时该对象还自带键值观察（KVO）通知特性，可以很方便的监听任务的执行进程。</p>
<h2 id="u8BBE_u8BA1_u5E76_u53D1_u4EFB_u52A1_u65F6_u5E94_u8BE5_u6CE8_u610F_u7684_u4E8B_u9879"><a href="#u8BBE_u8BA1_u5E76_u53D1_u4EFB_u52A1_u65F6_u5E94_u8BE5_u6CE8_u610F_u7684_u4E8B_u9879" class="headerlink" title="设计并发任务时应该注意的事项"></a>设计并发任务时应该注意的事项</h2><p>虽然并发执行任务可以提高程序对用户操作的响应速度，最大化使用内核，提升应用的效率，但是这些都是建立在正确合理使用并发任务技术，以及应用程序确实需要使用这类技术的前提下。如果使用不得当，或者对简单的应用程序画蛇添足，那么反而会因为使用了并发任务技术而导致应用程序性能下降，另一方面开发人员面对的代码复杂度也会增加，维护成本同样会上升。所以在准备使用这类技术前一定要三思而行，从性能、开发成本、维护成本等多个方面去考虑是否需要使用并发任务技术。</p>
<p>考虑是否需要用只是第一步，当确定使用后更不能盲目的就开始开发，因为并发任务技术的使用需要侵入应用程序的整个开发生命周期，所以在应用开发之初，就是考虑如何根据这类技术去设计并发任务，考虑应用中任务的类型、任务中使用的数据结构等等，否则亡羊补牢也为时已晚。这一节主要说说在设计并发任务时应该注意哪些事。</p>
<h3 id="u68B3_u7406_u5E94_u7528_u7A0B_u5E8F_u4E2D_u7684_u4EFB_u52A1"><a href="#u68B3_u7406_u5E94_u7528_u7A0B_u5E8F_u4E2D_u7684_u4EFB_u52A1" class="headerlink" title="梳理应用程序中的任务"></a>梳理应用程序中的任务</h3><p>在动手写代码前，尽量根据需求，穷举应用中的任务以及在任务中涉及到的对象何数据结构，然后分析这些任务的优先级和触发类型，比如罗列出哪些任务是由用户操作触发的，哪些是任务是无需用户参与触发的。</p>
<p>当把任务根据优先级梳理好后，就可以从高优先级的任务开始逐个分析，考虑任务在执行过程中涉及到哪些对象和数据结构，是否会修改变量，被修改的变量是否会对其他变量产生影响，以及任务的执行结果对整个程序产生什么影响等。举个简单的例子，如果一个任务中对某个变量进行了修改，并且这个变量不会对其他变量产生影响，而且任务的执行结果也相对比较独立，那么像这种任务就最合适让它异步去执行。</p>
<h3 id="u8FDB_u4E00_u6B65_u7EC6_u5206_u4EFB_u52A1_u4E2D_u7684_u6267_u884C_u5355_u5143"><a href="#u8FDB_u4E00_u6B65_u7EC6_u5206_u4EFB_u52A1_u4E2D_u7684_u6267_u884C_u5355_u5143" class="headerlink" title="进一步细分任务中的执行单元"></a>进一步细分任务中的执行单元</h3><p>任务可以是一个方法，也可以是一个方法中的一段逻辑，不论是一个方法还是一段逻辑，我们都可以从中拆分出若干个执行单元，然后进一步分析这些执行单元，如果多个执行单元必须得按照特定得顺序执行，而且这一组执行单元的执行结果想对独立，那么可以将这若干执行单元视为执行单元组，可以考虑让该执行单元组异步执行，其他不需要按照特定顺序的执行单元可以分别让它们异步执行。可以使用的技术可以用GCD或者Operation Queue。</p>
<p>在拆分执行单元时，尽量拆的细一点，不要担心执行单元的数量过多，因为GCD和Operation Queue有着高性能的线程管理机制，不需要担心过多的使用任务队列会造成性能损耗。</p>
<h3 id="u786E_u5B9A_u5408_u9002_u7684_u961F_u5217"><a href="#u786E_u5B9A_u5408_u9002_u7684_u961F_u5217" class="headerlink" title="确定合适的队列"></a>确定合适的队列</h3><p>当我们将任务分解为一个个执行单元并分析之后，下一步就是将这些执行单元封装在<code>block</code>中或者封装为<code>NSOperation</code>对象来使用GCD或Operation Queues，但在这之前还需要我们根据执行单元确定好适合的队列，不管是Dispatch queue还是Operation queue，都需要明确是使用串行队列还是并行队列，确定是将多个执行单元放入一个队列中还是分别放入多个队列中，以及使用正确优先级的队列。</p>
<h3 id="u63D0_u9AD8_u6548_u7387_u7684_u5176_u4ED6_u6280_u5DE7"><a href="#u63D0_u9AD8_u6548_u7387_u7684_u5176_u4ED6_u6280_u5DE7" class="headerlink" title="提高效率的其他技巧"></a>提高效率的其他技巧</h3><p>在使用任务队列时注意以下几点，可以有效的提高执行效率：</p>
<ul>
<li>如果应用比较吃内存，那么建议在任务中直接计算一些需要的值，这样比从主存中加载要来的快。</li>
<li>尽早确定顺序执行的任务，尽量将其改为并行任务，比如说有多个任务存在资源竞争问题，那么可以根据情况分别为每个任务拷贝一份该资源，从而避免顺序执行任务，以提高执行效率。</li>
<li>避免使用线程锁机制。在使用GCD或Operation Queues技术时基本不需要使用线程锁，因为有串行队列的存在。</li>
<li>尽量使用系统提供的框架达到并发任务的目的，一些系统提供的框架本身就有一些方法函数可以让任务并发执行，比如<code>UIView</code>提供的一系列动画的方法等。</li>
</ul>
<h2 id="Operation_Queues"><a href="#Operation_Queues" class="headerlink" title="Operation Queues"></a>Operation Queues</h2><p>Operation Queue技术由Cocoa框架提供，用于实现任务并发异步执行的技术，该技术基于面向对象概念。该技术中最主要的两个元素就是Operation对象和Operation队列，我们先来看看Operation对象。</p>
<h3 id="Operation_Objects"><a href="#Operation_Objects" class="headerlink" title="Operation Objects"></a>Operation Objects</h3><p>Operation对象的具体实现是Foundation框架中的<code>NSOperation</code>类，它的主要作用就是将我们希望执行的任务封装起来，然后去执行。<code>NSOperation</code>类本身是一个抽象类，在使用时需要我们创建子类去继承它，实现一些父类的方法，以达到我们使用的需求。同时Foundation框架也提供了两个已经实现好的<code>NSOperation</code>子类，供我们方便的使用：</p>
<ul>
<li><code>NSInvocationOperation</code>：当我们已经有一个方法需要异步去执行，此时显然没有必要为了这一个方法再去创建一个<code>NSOperation</code>的子类，所以我们就可以用<code>NSInvocationOperation</code>类来封装这个方法，然后放入操作队列去执行，以满足我们的需求。</li>
<li><code>NSBlockOperation</code>：该类可以让我们同时执行多个<code>block</code>对象或闭包。</li>
</ul>
<p>同时所有继承<code>NSOperation</code>的子类都会具有如下特性：</p>
<ul>
<li>可自动管理Operation对象之间的依赖关系，举个例子，当一个Operation对象执行之前发现它包含的任务中有依赖其他的Operation对象，并且该Operation对象还没有执行完成，那么当前的Operation对象会等待它的依赖执行完成后才会执行。</li>
<li>支持可选的完成时回调闭包，该闭包可以在Operation对象包含的主要任务执行完之后执行。</li>
<li>自带键值观察（KVO）通知特性，可以监听任务的执行状态。</li>
<li>可在运行时终止任务执行。</li>
</ul>
<p>虽然Operation Queues技术主要是通过将Operation对象放入队列中，实现并发异步的执行任务，但是我们也可以直接通过<code>NSOperation</code>类的<code>start</code>方法让其执行任务，但这样就属于同步执行任务了，我们还可以通过<code>NSOperation</code>类的<code>isConcurrent</code>方法来确定当前任务正在异步执行还是同步执行。</p>
<h3 id="u521B_u5EFANSInvocationOperation_u5BF9_u8C61"><a href="#u521B_u5EFANSInvocationOperation_u5BF9_u8C61" class="headerlink" title="创建NSInvocationOperation对象"></a>创建NSInvocationOperation对象</h3><p>上文中已经提到过，<code>NSInvocationOperation</code>对象是Foundation框架提供的<code>NSOperation</code>抽象类的实现，主要作用是方便我们将已有对象和方法封装为Operation对象，然后放入操作队列执行目标方法，同时该对象的好处是可以避免我们为已有的对象的方法逐个创建Operation对象，避免冗余代码。不过，由于<code>NSInvocationOperation</code>不是类型安全的，所以从Xcode 6.1开始，在Swift中就不能再使用该对象了。我们可以看看在Objective-c中如何创建该对象：</p>
<pre><code class="objc">@implementation MyCustomClass 

- (NSOperation*)taskWithData:(id)data { 

    NSInvocationOperation* theOp = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(myTaskMethod:) object:data];

    return theOp;

｝

- (void)myTaskMethod:(id)data {

    // Perform the task. 

} 

@end
</code></pre>
<p>当<code>NSInvocationOperation</code>对象创建好后，可以调用它父类<code>NSOperation</code>的<code>start</code>方法执行任务，但是这种不放在操作队列中的执行方式都是在当前线程，也就是主线程中同步执行的。</p>
<h3 id="u521B_u5EFANSBlockOperation_u5BF9_u8C61"><a href="#u521B_u5EFANSBlockOperation_u5BF9_u8C61" class="headerlink" title="创建NSBlockOperation对象"></a>创建NSBlockOperation对象</h3><p><code>NSBlockOperation</code>是另外一个由Foundation框架提供的<code>NSOperation</code>抽象类的实现类，该类的作用是将一个或多个block或闭包封装为一个Operation对象。在第一次创建<code>NSBlockOperation</code>时至少要添加一个block：</p>
<pre><code class="swift">import Foundation

class TestBlockOperation {

    func createBlockOperationObject() -&gt; NSOperation {

        print(&quot;The main thread num is \(NSThread.currentThread())&quot;)

        let nsBlockOperation = NSBlockOperation(block: {

            print(&quot;Task in first closure. The thread num is \(NSThread.currentThread())&quot;)

        })

        return nsBlockOperation

    }

}

let testBlockOperation = TestBlockOperation()

let nsBlockOperation = testBlockOperation.createBlockOperationObject()
nsBlockOperation.start()
</code></pre>
<p>上面的代码中我们首先打印了主线程的线程号，然后通过<code>createBlockOperationObject</code>方法创建了一个<code>NSBlockOperation</code>对象，在初始化时的block中同样打印了当前线程的线程号，调用它父类的方法<code>start</code>后，可以看到这个block中的任务是在主线程中执行的：</p>
<pre><code class="swift">The main thread id is &lt;NSThread: 0x101502e40&gt;{number = 1, name = main}
Task in first closure. The thread id is &lt;NSThread: 0x101502e40&gt;{number = 1, name = main}
</code></pre>
<p>然而我们也也可以通过<code>NSBlockOperation</code>对象的方法<code>addExecutionBlock</code>添加其他的block或者说任务：</p>
<pre><code class="swift">import Foundation

class TestBlockOperation {

    func createBlockOperationObject() -&gt; NSOperation {

        print(&quot;The main thread num is \(NSThread.currentThread())&quot;)

        let nsBlockOperation = NSBlockOperation(block: {

            print(&quot;Task in first closure. The thread num is \(NSThread.currentThread())&quot;)

        })

        // 第一种写法
        nsBlockOperation.addExecutionBlock({

            print(&quot;Task in second closure. The thread num is \(NSThread.currentThread())&quot;)

        })

        // 第二种写法
        nsBlockOperation.addExecutionBlock{

            print(&quot;Task in third closure. The thread num is \(NSThread.currentThread())&quot;)

        }

        return nsBlockOperation

    }

}

let testBlockOperation = TestBlockOperation()

let nsBlockOperation = testBlockOperation.createBlockOperationObject()
nsBlockOperation.start()
</code></pre>
<p>当我们再执行<code>NSBlockOperation</code>时，可以看到后面添加的两个任务都在不同的二级线程中执行，此时个任务为并发异步执行：</p>
<pre><code class="swift">The main thread id is &lt;NSThread: 0x101502e40&gt;{number = 1, name = main}
Task in first closure. The thread id is &lt;NSThread: 0x101502e40&gt;{number = 1, name = main}
Task in third closure. The thread id is &lt;NSThread: 0x101009190&gt;{number = 2, name = (null)}
Task in second closure. The thread id is &lt;NSThread: 0x101505110&gt;{number = 3, name = (null)}
</code></pre>
<p>通过上面两段代码可以观察到，当<code>NSBlockOperation</code>中只有一个block时，在调用<code>start</code>方法执行任务时不会为其另开线程，而是在当前线程中同步执行，只有当<code>NSBlockOperation</code>包含多个block时，才会为其另开二级线程，使任务并发异步执行。另外，当<code>NSBlockOperation</code>执行时，它会等待所有的block都执行完成后才会返回执行完成的状态，所以我们可以用<code>NSBloxkOperation</code>跟踪一组block的执行情况。</p>
<h3 id="u81EA_u5B9A_u4E49Operation_u5BF9_u8C61"><a href="#u81EA_u5B9A_u4E49Operation_u5BF9_u8C61" class="headerlink" title="自定义Operation对象"></a>自定义Operation对象</h3><p>如果<code>NSInvocationOperation</code>对象和<code>NSBlockOperation</code>对象都不能满足我们的需求，那么我们可以自己写一个类去继承<code>NSOperation</code>，然后实现我们的需求。在实现自定义Operation对象时，分并发执行任务的Operation对象和非并发执行任务的Operation对象。</p>
<h4 id="u81EA_u5B9A_u4E49_u975E_u5E76_u53D1Operation_u5BF9_u8C61"><a href="#u81EA_u5B9A_u4E49_u975E_u5E76_u53D1Operation_u5BF9_u8C61" class="headerlink" title="自定义非并发Operation对象"></a>自定义非并发Operation对象</h4><p>实现非并发Operation对象相对要简单一些，通常，我们最少要实现两个方法：</p>
<ul>
<li>自定义初始化方法：主要用于在初始化自定义Operation对象时传递必要的参数。</li>
<li><code>main</code>方法：该方法就是处理主要任务的地方，你需要执行的任务都在这个方法里。</li>
</ul>
<p>当然除了上面两个必须的方法外，也可以有被<code>main</code>方法调用的私有方法，或者属性的<code>get</code>、<code>set</code>方法。下面以一个网络请求的例子展示如何创建自定义的Operation对象：</p>
<pre><code class="swift">import Foundation

class MyNonconcurrentOperation: NSOperation {

    var url: String?

    init(withURL url: String) {

        self.url = url

    }

    override func main() {

        // 1.
        guard let strURL = self.url else {

            return

        }

        // 2.
        var nsurl = NSURL(string: strURL)

        // 3.
        var session: NSURLSession? = NSURLSession.sharedSession()

        // 4.
        var dataTask: NSURLSessionDataTask? = session!.dataTaskWithURL(nsurl!, completionHandler: { (nsdata, nsurlrespond, nserror) in

            if let error = nserror {

                print(&quot;出现异常：\(error.localizedDescription)&quot;)

            } else {

                do {

                    let dict = try NSJSONSerialization.JSONObjectWithData(nsdata!, options: NSJSONReadingOptions.MutableContainers)

                    print(dict)

                } catch {

                    print(&quot;出现异常&quot;)

                }

            }

        })

        // 5.
        dataTask!.resume()

        sleep(10)

    }

}

let myNonconcurrentOperation = MyNonconcurrentOperation(withURL: &quot;http://www.baidu.com/s?wd=ios&quot;)
myNonconcurrentOperation.start()
</code></pre>
<p>我们创建了自定义的Operation类<code>MyNonconcurrentOperation</code>，让其继承<code>NSOperation</code>，在<code>MyNonconcurrentOperation</code>中可以看到只有两个方法<code>init</code>和<code>main</code>，前者是该类的初始化方法，主要作用是初始化<code>url</code>这个参数，后者包含了任务的主体逻辑代码，我们来分析一下代码：</p>
<ol>
<li>我们在初始化<code>MyNonconcurrentOperation</code>时，传入了我们希望请求的网络地址，改地址正确与否关系着我们这个任务是否还值得继续往下走，所以在<code>main</code>方法一开始先判断一下<code>url</code>的合法性，示例代码中判断的很简单，实际中应该使用正则表达式去判断一下。</li>
<li>将字符串URL转换为<code>NSURL</code>。</li>
<li>创建<code>NSURLSession</code>实例。</li>
<li>调用<code>NSURLSession</code>实例的<code>dataTaskWithURL</code>方法，创建<code>NSURLSessionDataTask</code>类的实例，用于请求网络。在<code>completionHandler</code>的闭包中去判断请求是否成功，返回数据是否正确以及解析数据等操作。</li>
<li>执行<code>NSURLSessionDataTask</code>请求网络。</li>
</ol>
<p>当我们调用<code>MyNonconcurrentOperation</code>的<code>start</code>方法时，就会执行<code>main</code>方法里的逻辑了，这就是一个简单的非并发自定义Operation对象，之所以说它是非并发，因为它一般都在当前线程中执行任务，既如果你在主线程中初始化它，调用它的<code>start</code>方法，那么它就在主线程中执行，如果在二级线程中进行这些操作，那么就在二级线程中执行。</p>
<blockquote>
<p>注：如果在二级线程中使用非并发自定义Operation对象，那么<code>main</code>方法中的内容应该使用<code>autoreleasepool{}</code>包起来。因为如果在二级线程中，没有主线程的自动释放池，一些资源没法被回收，所以需要加一个自动释放池，如果在主线程中就不需要了。</p>
</blockquote>
<h4 id="u54CD_u5E94_u53D6_u6D88_u4E8B_u4EF6"><a href="#u54CD_u5E94_u53D6_u6D88_u4E8B_u4EF6" class="headerlink" title="响应取消事件"></a>响应取消事件</h4><p>一般情况下，当Operation对象开始执行时，就会一直执行任务，不会中断执行，但是有时需要在任务执行一半时终止任务，这时就需要Operation对象有响应任务终止命令的能力。理论上，在Operation对象执行任务的任何时间点都可以调用<code>NSOperation</code>类的<code>cancel</code>方法终止任务，那么在我们自定义的Operation对象中如何实现响应任务终止呢？我们看看下面的代码：</p>
<pre><code class="swift">import Foundation

class MyNonconcurrentOperation: NSOperation {

    var url: String?

    init(withURL url: String) {

        self.url = url

    }

    override func main() {

        // 1.
        if self.cancelled {

            return

        }

        guard let strURL = self.url else {

            return

        }

        var nsurl = NSURL(string: strURL)

        var session: NSURLSession? = NSURLSession.sharedSession()

        // 2.
        if self.cancelled {

            nsurl = nil

            session = nil

            return

        }

        var dataTask: NSURLSessionDataTask? = session!.dataTaskWithURL(nsurl!, completionHandler: { (nsdata, nsurlrespond, nserror) in

            if let error = nserror {

                print(&quot;出现异常：\(error.localizedDescription)&quot;)

            } else {

                // 4.
                if self.cancelled {

                    nsurl = nil

                    session = nil

                    return

                }

                do {

                    let dict = try NSJSONSerialization.JSONObjectWithData(nsdata!, options: NSJSONReadingOptions.MutableContainers)

                    print(dict)

                } catch {

                    print(&quot;出现异常&quot;)

                }

            }

        })

        // 3.
        if self.cancelled {

            nsurl = nil

            session = nil

            dataTask = nil

            return

        }

        dataTask!.resume()

        sleep(10)

    }

}

let myNonconcurrentOperation = MyNonconcurrentOperation(withURL: &quot;http://www.baidu.com/s?wd=ios&quot;)
myNonconcurrentOperation.start()
myNonconcurrentOperation.cancel()
</code></pre>
<p>从上述代码中可以看到，在<code>main</code>方法里加了很多对<code>self.cancelled</code>值的判断，没错，这就是响应终止执行任务的关键，因为当调用了<code>NSOperation</code>的<code>cancel</code>方法后，<code>cancelled</code>属性就会被置为<code>flase</code>，当判断到该属性的值为<code>false</code>时，代表当前任务已经被取消，我们只需释放资源返回即可。我们只有在整个任务逻辑代码中尽可以细的去判断<code>cancelled</code>属性，才可以达到较为实时的终止效果。上面代码中我分别在四个地方判断了<code>cancelled</code>属性：</p>
<ol>
<li>在任务开始之前。</li>
<li>任务开始不久，这里刚创建了<code>NSURL</code>和<code>NSURLSession</code>，所以如果判断出任务已被取消，则要释放它们的内存地址。</li>
<li>开始请求网络之前，这里同样要释放已经创建的变量内存地址。</li>
<li>网络请求期间。</li>
</ol>
<h4 id="u81EA_u5B9A_u4E49_u5E76_u53D1Operation_u5BF9_u8C61"><a href="#u81EA_u5B9A_u4E49_u5E76_u53D1Operation_u5BF9_u8C61" class="headerlink" title="自定义并发Operation对象"></a>自定义并发Operation对象</h4><p>自定义并发Operation对象其主要实现的就是让任务在当前线程以外的线程执行，相对于非并发Operation对象注意的事项要更多一些，我们先来看要实现的两个方法：</p>
<ul>
<li><code>init</code>：该方法和非并发Operation对象中的作用一样，用于初始化一些属性。</li>
<li><code>start</code>：该方法是自定义并发Operation对象必须要重写父类的一个方法，通常就在这个方法里创建二级线程，让任务运行在当前线程以外的线程中，从而达到并发异步执行任务的目的，所以这个方法中绝对不能调用父类的<code>start</code>方法。</li>
<li><code>main</code>：该方法在非并发Operation对象中就说过，这里的作用的也是一样的，只不过在并发Operation对象中，该方法并不是必须要实现的方法，因为在<code>start</code>方法中就可以完成所有的事情，包括创建线程，配置执行环境以及任务逻辑，但我还是建议将任务相关的逻辑代码都写在该方法中，让<code>start</code>方法只负责执行环境的设置。</li>
</ul>
<p>除了上述这三个方法以外，还有三个属性需要我们重写，就是<code>NSOperation</code>类中的<code>executing</code>、<code>finished</code>、<code>concurrent</code>三个属性，这三个属性分别表示Operation对象是否在执行，是否执行完成以及是否是并发状态。因为并发异步执行的Operation对象并不会阻塞主线程，所以使用它的对象需要知道它的执行情况和状态，所以这三个状态是必须要设置的，下面来看看示例代码：</p>
<pre><code class="swift">import Foundation

class MyConcurrentOperation: NSOperation {

    var url: String?

    private var ifFinished: Bool

    private var ifExecuting: Bool

    override var concurrent: Bool {

        get { return true }

    }

    override var finished: Bool {

        get { return self.ifFinished }

    }

    override var executing: Bool {

        get { return self.ifExecuting }

    }

    init(withURL url: String) {

        self.url = url

        self.ifFinished = false

        self.ifExecuting = false

    }

    override func start() {

        if self.cancelled {

            self.willChangeValueForKey(&quot;finished&quot;)

            self.ifFinished = true

            self.didChangeValueForKey(&quot;finished&quot;)

            return

        } else {

            self.willChangeValueForKey(&quot;executing&quot;)

            NSThread.detachNewThreadSelector(&quot;main&quot;, toTarget: self, withObject: nil)

            self.ifExecuting = true

            self.didChangeValueForKey(&quot;executing&quot;)

        }

    }

    override func main() {

        autoreleasepool{

            guard let strURL = self.url else {

                return

            }

            var nsurl = NSURL(string: strURL)

            var session: NSURLSession? = NSURLSession.sharedSession()

            if self.cancelled {

                nsurl = nil

                session = nil

                self.completeOperation()

                return

            }

            var dataTask: NSURLSessionDataTask? = session!.dataTaskWithURL(nsurl!, completionHandler: { (nsdata, nsurlrespond, nserror) in

                if let error = nserror {

                    print(&quot;出现异常：\(error.localizedDescription)&quot;)

                } else {

                    if self.cancelled {

                        nsurl = nil

                        session = nil

                        self.completeOperation()

                        return

                    }

                    do {

                        let dict = try NSJSONSerialization.JSONObjectWithData(nsdata!, options: NSJSONReadingOptions.MutableContainers)

                        print(dict)

                        self.completeOperation()

                    } catch {

                        print(&quot;出现异常&quot;)

                        self.completeOperation()

                    }

                }

            })

            if self.cancelled {

                nsurl = nil

                session = nil

                dataTask = nil

                self.completeOperation()

                return

            }

            dataTask!.resume()

        }

    }

    func completeOperation() {

        self.willChangeValueForKey(&quot;finished&quot;)

        self.willChangeValueForKey(&quot;executing&quot;)

        self.ifFinished = true

        self.ifExecuting = false

        self.didChangeValueForKey(&quot;finished&quot;)

        self.didChangeValueForKey(&quot;executing&quot;)

    }

}
</code></pre>
<p>由于<code>NSOperation</code>的<code>finished</code>、<code>executing</code>、<code>concurrent</code>这三个属性都是只读的，我们无法重写它们的<code>setter</code>方法，所以我们只能靠新建的私有属性去重写它们的<code>getter</code>方法。为了自定义的Operation对象更像原生的<code>NSOperation</code>子类，我们需要通过<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>方法手动为<code>ifFinished</code>和<code>ifExecuting</code>这两个属性生成KVO通知，将<code>keyPath</code>设置为原生的<code>finished</code>和<code>executing</code>。</p>
<p>上面的代码示例中有几个关键点：</p>
<ul>
<li>在<code>start</code>方法开始之初就要判断一下Operation对象是否被终止任务。</li>
<li><code>main</code>方法中的内容要放在<code>autoreleasepool</code>中，解决在二级线程中的内存释放问题。</li>
<li>如果判断出Operation对象的任务已经被终止，要及时修改<code>ifFinished</code>和<code>ifExecuting</code>属性。</li>
</ul>
<p>我们可以测试一下这个自定义的Operation对象：</p>
<pre><code class="swift">import Foundation

class Test: NSObject {

    private var myContext = 0

    let myConcurrentOperation = MyConcurrentOperation(withURL: &quot;http://www.baidu.com/s?wd=ios&quot;)

    func launch() {

        myConcurrentOperation.addObserver(self, forKeyPath: &quot;finished&quot;, options: .New, context: &amp;myContext)
        myConcurrentOperation.addObserver(self, forKeyPath: &quot;executing&quot;, options: .New, context: &amp;myContext)

        myConcurrentOperation.start()

        sleep(5)

        print(myConcurrentOperation.executing)
        print(myConcurrentOperation.finished)
        print(myConcurrentOperation.concurrent)

        sleep(10)

    }

    override func observeValueForKeyPath(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;) {

        if let change = change where context == &amp;myContext {

            if keyPath == &quot;finished&quot; {

                print(&quot;Finish status has been changed, The new value is \(change[NSKeyValueChangeNewKey]!)&quot;)

            } else if keyPath == &quot;executing&quot; {

                print(&quot;Executing status has been changed, The new value is \(change[NSKeyValueChangeNewKey]!)&quot;)

            }

        }

    }

    deinit {

        myConcurrentOperation.removeObserver(self, forKeyPath: &quot;finished&quot;, context: &amp;myContext)

        myConcurrentOperation.removeObserver(self, forKeyPath: &quot;executing&quot;, context: &amp;myContext)

    }

}

let test = Test()
test.launch()
</code></pre>
<p><a href="http://www.devtalking.com/donate.html"><br>    <img border="0" src="http://www.devtalking.com/donate.png"><br></a><br><a href="http://www.devtalking.com/gongzhonghao.html"><br>    <img border="0" src="http://www.devtalking.com/guanzhugongzhonghao.png"><br></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/60236" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>并发任务是指多个任务在某一时刻同时运行。在过去]]>
    </summary>
    
      <category term="Concurrency" scheme="http://www.devtalking.com/tags/Concurrency/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Threading Programming Guide 笔记（四）]]></title>
    <link href="http://www.devtalking.com//articles/read-threading-programming-guide-4/"/>
    <id>http://www.devtalking.com//articles/read-threading-programming-guide-4/</id>
    <published>2016-02-21T16:00:00.000Z</published>
    <updated>2016-02-21T23:44:33.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/56726" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文章中有对官方文档的翻译，也有自己的理解，官方文档中代码片段的示例在这篇文章中都进行了完整的重写，还有一些文档中没有的代码示例，并且都使用Swift完成，给大家一些Objc与Swift转换的参考。<br>官方文档地址：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></p>
</blockquote>
<h2 id="u914D_u7F6ETimer_u4E8B_u4EF6_u6E90"><a href="#u914D_u7F6ETimer_u4E8B_u4EF6_u6E90" class="headerlink" title="配置Timer事件源"></a>配置Timer事件源</h2><p>配置Timer事件源拢共分几步？很简单，大体只有两步，先创建Timer对象，然后将其添加至Run Loop中。在Cocoa框架和Core Foundation框架中都提供了相关的对象和接口，在Cocoa框架中，它为我们提供了<code>NSTimer</code>类，该类有两个类方法，可以让我们很方便的在当前线程的Run Loop中配置Timer事件源：</p>
<ul>
<li><code>scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</code>：该方法有五个参数分别是执行事件消息时间间隔、接收事件消息的目标对象、事件消息、发送给事件消息的参数、是否重复执行标识。</li>
</ul>
<pre><code class="swift">NSTimer.scheduledTimerWithTimeInterval(0.5, target: self, selector: &quot;fireTimer:&quot;, userInfo: &quot;This is a arg&quot;, repeats: true)

func fireTimer(sender: NSTimer) {

    print(&quot;Fire timer...\(sender.userInfo as! String)&quot;)

}
</code></pre>
<ul>
<li><code>scheduledTimerWithTimeInterval:invocation:repeats:</code>：该方法有三个参数，分别是执行事件消息事件间隔、<code>NSInvocation</code>对象、是否重复执行标识。这里说一下<code>NSInvocation</code>类，该类的作用是静态渲染消息，说的简单粗暴一点，那就是该类表示某个对象中的某个方法，以及该方法的一个或多个参数和返回值,当我们需要发送有多个参数或者有返回值的消息时就可以用这个类。但是在Swift中无法使用这个类，这里就不做过多说明了。</li>
</ul>
<p>以上两个类方法所添加的Timer事件源都只能添加在当前线程的Run Loop中，并且是在默认的Run Loop模式下(<code>NSDefaultRunLoopMode</code>)，如果我们想将Timer事件源添加至其他线程Run Loop的其他模式下，那么就需要创建<code>NSTimer</code>对象，并使用<code>NSRunLoop</code>的<code>addTimer:forMode:</code>方法添加创建好的<code>NSTimer</code>对象：</p>
<pre><code class="swift">import Foundation

class CustomThread: NSThread {

    var myTimer: NSTimer!

    init(myTimer: NSTimer) {

        self.myTimer = myTimer

    }

    override func main() {

        autoreleasepool{

            let runloop = NSRunLoop.currentRunLoop()

            runloop.addTimer(self.myTimer, forMode: NSRunLoopCommonModes)

            print(NSThread.isMultiThreaded())

            runloop.runUntilDate(NSDate(timeIntervalSinceNow: 5))

        }

    }

}

class TestThread: NSObject {

    func testTimerSource() {

        let fireTimer = NSDate(timeIntervalSinceNow: 1)

        let myTimer = NSTimer(fireDate: fireTimer, interval: 0.5, target: self, selector: &quot;timerTask&quot;, userInfo: nil, repeats: true)

        let customThread = CustomThread(myTimer: myTimer)

        customThread.start()

        sleep(5)

    }

    func timerTask() {

        print(&quot;Fire timer...&quot;)

    }

}

let testThread = TestThread()
testThread.testTimerSource()
</code></pre>
<p>在Core Foundation框架中，也为我们提供了一系列相关的类和方法为Run Loop添加Timer事件源，我们一起来看看：</p>
<pre><code class="swift">import Foundation

class TestThread: NSObject {

    func testCFTimerSource() {

        let cfRunloop = CFRunLoopGetCurrent()

        var cfRunloopTimerContext = CFRunLoopTimerContext(version: 0, info: unsafeBitCast(self, UnsafeMutablePointer&lt;Void&gt;.self), retain: nil, release: nil, copyDescription: nil)

        let cfRunloopTimer = CFRunLoopTimerCreate(kCFAllocatorDefault, 1, 0.5, 0, 0, cfRunloopTimerCallback(), &amp;cfRunloopTimerContext)

        CFRunLoopAddTimer(cfRunloop, cfRunloopTimer, kCFRunLoopDefaultMode)

        CFRunLoopRun()
    }

    func cfRunloopTimerCallback() -&gt; CFRunLoopTimerCallBack {

        return { (cfRunloopTimer, info) -&gt; Void in

            print(&quot;Fire timer...&quot;)

        }

    }

}

let testThread = TestThread()
testThread.testCFTimerSource()
</code></pre>
<h2 id="u914D_u7F6E_u57FA_u4E8E_u7AEF_u53E3_u7684_u4E8B_u4EF6_u6E90"><a href="#u914D_u7F6E_u57FA_u4E8E_u7AEF_u53E3_u7684_u4E8B_u4EF6_u6E90" class="headerlink" title="配置基于端口的事件源"></a>配置基于端口的事件源</h2><p>Cocoa框架和Core Foundation框架都提供了创建配置基于端口事件源的类和方法，下面我们来看看如何使用Cocoa框架创建基于端口的事件源以及配置使用该类事件源。</p>
<h3 id="u4F7F_u7528NSMachPort_u5BF9_u8C61"><a href="#u4F7F_u7528NSMachPort_u5BF9_u8C61" class="headerlink" title="使用NSMachPort对象"></a>使用NSMachPort对象</h3><p><code>NSMachPort</code>对象是什么呢？其实就是线程与线程之间通信的桥梁，我们创建一个<code>NSMachPort</code>对象，将其添加至主线程的Run Loop中，然后我们在二级线程执行的任务中就可以获取并使用该对象向主线程发送消息，也就是说这种方式是将<code>NSMachPort</code>对象在不同线程中相互传递从而进行消息传递的。</p>
<h4 id="u5728_u4E3B_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort"><a href="#u5728_u4E3B_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort" class="headerlink" title="在主线程中创建配置NSMachPort"></a>在主线程中创建配置NSMachPort</h4><p>因为<code>NSMachPort</code>只能在OS X系统中使用，所以我们需要创建一个OS X应用的工程我们先来看看代码：</p>
<pre><code class="swift">import Cocoa

class ViewController: NSViewController, NSMachPortDelegate {

    let printMessageId = 1000

    override func viewDidLoad() {

        super.viewDidLoad()

        let mainThreadPort = NSMachPort()

        mainThreadPort.setDelegate(self)

        NSRunLoop.currentRunLoop().addPort(mainThreadPort, forMode: NSDefaultRunLoopMode)

        let workerClass = WorkerClass()

        NSThread.detachNewThreadSelector(&quot;launchThreadWithPort:&quot;, toTarget: workerClass, withObject: mainThreadPort)

    }

    // MARK: NSPortDelegate Method

    func handlePortMessage(message: NSPortMessage) {

    }

}
</code></pre>
<p>首先我们看到<code>ViewController</code>类遵循了<code>NSMachPortDelegate</code>协议，因为它要作为<code>NSMachPort</code>的代理类，通过<code>NSMachPortDelegate</code>的<code>handlePortMessage:</code>方法处理来自二级线程的消息。</p>
<p>在<code>viewDidLoad</code>方法中我们先是创建了<code>NSMachPort</code>对象的实例，接着设置它的代理，然后使用<code>NSRunLoop</code>的<code>addPort:forMode:</code>方法将创建好的端口对象添加至主线程的Run Loop中，最后通过<code>NSThread</code>的<code>detachNewThreadSelector:toTarget:withObject:</code>方法创建二级线程，并让该二级线程执行<code>WorkerClass</code>类中的<code>launchThreadWithPort:</code>方法，同时将刚才创建好的端口对象作为参数传给该方法，也就是将主线程中的端口对象传到了二级线程中。下面来看看<code>handlePortMessage:</code>中应该如何处理接收到的消息：</p>
<pre><code class="swift">func handlePortMessage(message: NSPortMessage) {

    let messageId = message.msgid

    if messageId == UInt32(printMessageId) {

        print(&quot;Receive the message that id is 1000 and this is a print task.&quot;)

    } else {

        // Handle other messages

    }

}
</code></pre>
<p>通过端口传递的消息可以根据消息编号判断该执行什么样的任务，所以该方法中通过<code>NSPortMessage</code>对象获取到消息id然后进行判断并执行相应的任务，消息id在二级线程通过端口向主线程发送消息时可以设置。</p>
<h4 id="u5728_u4E8C_u7EA7_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort"><a href="#u5728_u4E8C_u7EA7_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort" class="headerlink" title="在二级线程中创建配置NSMachPort"></a>在二级线程中创建配置NSMachPort</h4><p>首先二级线程中与主线程中一样，都需要创建端口对象、设置代理、将端口对象添加至当前线程的Run Loop中：</p>
<pre><code class="swift">import Cocoa

class WorkerClass: NSObject, NSMachPortDelegate {

    func launchThreadWithPort(port: NSMachPort) {

        autoreleasepool{

            let secondaryThreadPort = NSMachPort()

            secondaryThreadPort.setDelegate(self)

            let runloop = NSRunLoop.currentRunLoop()

            runloop.addPort(secondaryThreadPort, forMode: NSDefaultRunLoopMode)

            sendPrintMessage(port, receivePort: secondaryThreadPort)

            runloop.runMode(NSDefaultRunLoopMode, beforeDate: NSDate(timeIntervalSinceNow: 500))

        }

    }

    func sendPrintMessage(sendPort: NSMachPort, receivePort: NSMachPort) {


    }

    // MARK: NSPortDelegate Method

    func handlePortMessage(message: NSPortMessage) {

    }

}
</code></pre>
<p>创建并配置好端口后就需要向主线程发送消息了，下面我们来看看<code>sendPrintMessage:receivePort:</code>方法：</p>
<pre><code class="swift">func sendPrintMessage(sendPort: NSMachPort, receivePort: NSMachPort) {

    let portMessage = NSPortMessage(sendPort: sendPort, receivePort: receivePort, components: nil)

    portMessage.msgid = UInt32(1000)

    portMessage.sendBeforeDate(NSDate(timeIntervalSinceNow: 1))

}
</code></pre>
<p>首先需要创建<code>NSPortMessage</code>对象，该对象就是端口之间相互传递的介质，初始化方法的第一个参数为主线程的端口对象，也就是发送消息的目标端口，第二个参数是二级线程的端口对象，第三个参数的作用是向主线程发送需要的数据，该参数的类型是<code>AnyObject</code>的数组。</p>
<p>创建完消息对象后，要给该消息设置消息id，以便主线程接收后进行判断，最后通过<code>sendBeforeDate:</code>方法发送消息。</p>
<h2 id="u7EBF_u7A0B_u5B89_u5168_u673A_u5236"><a href="#u7EBF_u7A0B_u5B89_u5168_u673A_u5236" class="headerlink" title="线程安全机制"></a>线程安全机制</h2><p>在前文中提到过，在应用中使用多线程势必会给增加我们编写代码的工作量，而且会带来一些潜在的问题，最大的问题就是资源竞争的问题，多个线程同时访问资源或者重复更改资源。如果我们足够幸运，这些问题会使应用产生比较明显的异常现象，那我们尚可发现并修复，但是如果这些问题产生的影响不那么明显，或者说只有在应用做一些特定操作才会发生异常，而我们又没测到时就会给我们带来大麻烦。</p>
<p>或许我们可以让每个线程之间都不进行交互，没个线程都有独有资源，从而避免资源竞争问题的发生，但是这并不是长远之计，很多情况下线程之间必须要进行交互，这时我们就需要更好的设计模式或者工具策略来避免这类问题的发生。所幸的是OS X和iOS系统已经提供了多种线程安全的方法，这一节让我们来看看如何使用它们。</p>
<h3 id="u539F_u5B50_u64CD_u4F5C_uFF08Atomic_Operations_uFF09"><a href="#u539F_u5B50_u64CD_u4F5C_uFF08Atomic_Operations_uFF09" class="headerlink" title="原子操作（Atomic Operations）"></a>原子操作（Atomic Operations）</h3><p>原子操作是最简单也是最基本的保证线程安全的方法，原子的本意是<strong>不能被分裂的最小粒子</strong>，故原子操作是<strong>不可被中断的一个或一系列操作</strong>。从处理器角度来说原子操作是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址，从应用层面来说就是当一个线程对共享变量进行操作时，其他线程不能对该变量进行操作，并且其他线程不会被阻塞。</p>
<p>举个简单的例子，有一个共享变量<code>i</code>，初始值是1，现在我们对它进行两次<code>i++</code>的操作，期望值是3，但是在多核CPU的情况下就有可能是CPU1对<code>i</code>进行了一次<code>i++</code>操作，CPU2对<code>i</code>进行了一次<code>i++</code>操作，所以结果就并不是我们期望的值3，而是2，因为CPU1和CPU2同时从各自的缓存中读取变量<code>i</code>，分别进行加一操作，然后分别写入系统内存当中。那么想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。在我们使用原子操作时首先应将变量申明为原子类型（<code>atomic_t</code>），然后根据内核提供的原子操作API对变量进行操作，比如给原子类型的变量<code>v</code>增加值<code>i</code>的函数<code>void atomic_add(int i, atomic_t *v);</code>等。OS X和iOS也提供了一些数学运算和逻辑运算的原子操作供我们使用，这里就不深入说明了，大家如果有兴趣可以去官方文档找找。</p>
<h3 id="u5185_u5B58_u5C4F_u969C_uFF08Memory_Barriers_uFF09_u548C_u53EF_u89C1_u53D8_u91CF_uFF08Volatile_Variables_uFF09"><a href="#u5185_u5B58_u5C4F_u969C_uFF08Memory_Barriers_uFF09_u548C_u53EF_u89C1_u53D8_u91CF_uFF08Volatile_Variables_uFF09" class="headerlink" title="内存屏障（Memory Barriers）和可见变量（Volatile Variables）"></a>内存屏障（Memory Barriers）和可见变量（Volatile Variables）</h3><p>CPU对内存的操作无非就是读和写，我们虽然知道CPU对内存进行了操作，但是我们无法决定在一系列CPU对内存的操作时单个操作指令的顺序，这些顺序完全由CPU随性而来。举个例子，在有两个CPU的情况下，现在有四个指令待操作：</p>
<pre><code class="swift">A = 1; x = A;
B = 2; y = B;
</code></pre>
<p>这四个指令的执行顺序就可能有24种不同的组合。所以内存屏障就是一个帮助CPU规定操作指令顺序的手段，它将内存操作隔开，给屏障两侧的内存操作强加一个顺序关系，比如所有该屏障之前的写操作和读操作必须在该屏障之后的写操作和读操作之前执行。</p>
<p>可见变量是另一个确保共享变量被多个线程操作后仍能保持正确结果的机制，CPU为了提高处理速度，通常情况下不会直接与主存打交道，而是先将系统主存中的数据读到缓存中，当从缓存中读取到共享变量，对其进行操作后又不会立即写回主存，所以如果其他CPU也要操作该共享变量，就很有可能读到它的旧值。但是当我们在申明共享变量时加上<code>volatile</code>关键字，将其申明为可见变量时就可以避免这种情况，因为CPU从缓存中读取并修改可见共享变量后会立即写回主存，而且其他CPU在操作之前会先判断缓存中的数据是否已过期，如果过期那么从主存中重新缓存，这样一来可见变量在每个CPU操作时都能保证是最新值。但需要注意的是内存屏障和可见变量都会降低编译器的性能，所以没有必须要使用的情况时不要滥用这两个机制。</p>
<h3 id="u9501_u673A_u5236"><a href="#u9501_u673A_u5236" class="headerlink" title="锁机制"></a>锁机制</h3><p>锁机制在大多数编程语言中都是很常用的线程安全机制，你可以在关键的代码前后，或者只希望同时只能被一个线程执行的任务前后加上线程锁来避免因为多线程给程序造成不可预知的问题。OS X和iOS提供了多种锁的类型，下面让我们来看一看：</p>
<ul>
<li>互斥锁（Mutex）：互斥锁扮演的角色就是代码或者说任务的栅栏，它将你希望保护的代码片段围起来，当其他线程也试图执行这段代码时会被互斥锁阻塞，直到互斥锁被释放，如果多个线程同时竞争一个互斥锁，有且只有一个线程可以获得互斥锁。</li>
<li>递归锁（Recursive lock）：递归锁是互斥锁的变种。它允许一个线程在已经拥有一个锁，并且没有释放的前提下再次获得锁。当该线程释放锁时也需要一个一个释放。</li>
<li>读写锁（Read-write lock）：读写锁一般用在有资源被多个线程频繁的进行读操作，而只偶尔会有专职线程对该资源进行写操作的情况下。读写锁可被多个进行读操作的线程获得，但只能被一个进行写操作的线程获得，当有读操作的线程等待时，写操作的线程就不能获得锁，反之亦然，当写操作的线程在等待时，读操作的线程就不能获得锁。</li>
<li>分配锁（Distributed lock）：这种锁作用在进程级别，将进程保护起来，但是该锁不会阻塞其他进程，而是当其他进程与被保护进程交互时分配锁会告知前来的访问进程被访问进程处于锁状态，让前来访问的进程自行决定下一个操作。</li>
<li>自旋锁（Spin lock）：自旋锁与互斥锁有点类似，但不同的是其他线程不会被自旋锁阻塞，而是而是在进程中空转，就是执行一个空的循环。一般用于自旋锁被持有时间较短的情况。</li>
<li>双检测锁（Double-checked lock）：这种锁的目的是为了最大限度推迟上锁的时间，因为在多线程中线程安全对开销还是挺大的，所以一般能不上锁就不上锁。所以这种锁在上锁之前会先检查一次是否需要上锁，在上锁之后再检查一次，最后才真正执行操作。</li>
</ul>
<h3 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h3><p>Conditions是一种多线程间协调通信的机制，它通常用于标明共享资源是否可被访问或者确保一系列任务能按照指定的执行顺序执行。如果一个线程试图访问一个共享资源，而正在访问该资源的线程将其条件设置为不可访问，那么该线程会被阻塞，直到正在访问该资源的线程将访问条件更改为可访问状态或者说给被阻塞的线程发送信号后，被阻塞的线程才能正常访问这个资源。后面会说明如何使用这种机制。</p>
<h2 id="u8BBE_u8BA1_u7EBF_u7A0B_u5B89_u5168_u9700_u8981_u6CE8_u610F_u7684_u4E8B_u9879"><a href="#u8BBE_u8BA1_u7EBF_u7A0B_u5B89_u5168_u9700_u8981_u6CE8_u610F_u7684_u4E8B_u9879" class="headerlink" title="设计线程安全需要注意的事项"></a>设计线程安全需要注意的事项</h2><p>诚然使用线程安全的各种机制可以是我们的程序更加健壮，不易出错，但是因为这些机制本身也会有较大的性能开销，如果滥用这些机制反而会严重影响到程序的性能。所以我们应该在线程安全和性能之间寻求到一个平衡点，这一节我们就来看看在设计线程安全时应该注意的事项。</p>
<h3 id="u907F_u514D_u6EE5_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236"><a href="#u907F_u514D_u6EE5_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236" class="headerlink" title="避免滥用线程安全机制"></a>避免滥用线程安全机制</h3><p>不论是新的项目还是已经有的项目，在设计逻辑代码或者属性时应该避免产生线程安全与不安全的问题。有效的避免措施就是减少逻辑代码之间的交互，或者说任务与任务之间的交互，线程与线程之间的交互，减少多线程中任务访问同一变量的情况，如果需要那么可以确保每个任务中都有该变量的拷贝，这样就可以有效避免对变量或者任务采取线程安全机制。虽然对变量进行拷贝也会消耗资源，但是我们应该要判断一下这与采用线程安全机制消耗的资源之间谁多谁少，从而做出正确的决定。</p>
<h3 id="u8BA4_u6E05_u4F7F_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236_u65F6_u7684_u9677_u9631"><a href="#u8BA4_u6E05_u4F7F_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236_u65F6_u7684_u9677_u9631" class="headerlink" title="认清使用线程安全机制时的陷阱"></a>认清使用线程安全机制时的陷阱</h3><p>在使用锁机制和内存屏障机制时我们往往需要考虑将它们设置在代码的哪个位置是最正确的，但是有些时候，你认为正确的位置不代表它真的正确，下面是一段伪代码片段，向我们揭示一个使用锁机制时容易发生的陷阱。假设有一个可变类型的数组<code>myArray</code>，但是该数组中的对象是不可变类型的对象<code>anObject</code>：</p>
<pre><code class="swift">NSLock* arrayLock = GetArrayLock(); 

NSMutableArray* myArray = GetSharedArray(); 

id anObject;

[arrayLock lock]; 

anObject = [myArray objectAtIndex:0]; 

[arrayLock unlock];

[anObject doSomething];
</code></pre>
<p>上述代码片段中，对从<code>myArray</code>数组中获取第一个元素的操作加了锁，因为该数组是可变类型的，所以加锁防止其他线程同时操作该数组从而导致错误发生，又因为<code>anObject</code>是一个不可变类型对象，所以不需要担心其他线程会对其进行改变，所以调用<code>anObject</code>对象的<code>doSomething</code>方法时并没有加锁。</p>
<p>看起来这段代码的逻辑似乎没什么问题，但是凡事都架不住如果和万一，如果在<code>arrayLock</code>释放锁之后和<code>anObject</code>对象调用<code>doSomething</code>方法之前这区间里，另外一个线程清空了<code>myArray</code>里的元素，这时这段代码的结果会怎样呢？答案显然是因为当前类对<code>anObject</code>对象的引用被释放，<code>anObject</code>对象因为指向了错误的内存地址从而调用方法出错。所以为了避免这种小概率事件的发生，应该将<code>anObject</code>对象调用方法的操作也加上锁：</p>
<pre><code class="swift">NSLock* arrayLock = GetArrayLock(); 

NSMutableArray* myArray = GetSharedArray();

id anObject;

[arrayLock lock]; 

anObject = [myArray objectAtIndex:0]; 

[anObject doSomething]; 

[arrayLock unlock];
</code></pre>
<p>那么问题又来了，如果<code>doSomething</code>方法执行的时间很长，线程锁一直无法释放，那么又会对线程的性能产生很大影响。要想彻底解决问题，就要找到产生问题的关键点，在这个示例中产生问题的关键点就是<code>anObject</code>对象有可能被其他线程释放，所以解决问题的关键就是防止<code>anObject</code>对象被释放，我们来看看最终的解决方案：</p>
<pre><code class="swift">NSLock* arrayLock = GetArrayLock(); 

NSMutableArray* myArray = GetSharedArray(); 

id anObject;

[arrayLock lock];

anObject = [myArray objectAtIndex:0]; 

[anObject retain]; 

[arrayLock unlock];

[anObject doSomething]; 

[anObject release];
</code></pre>
<h3 id="u9632_u6B62_u6B7B_u9501_u548C_u6D3B_u9501_u7684_u53D1_u751F"><a href="#u9632_u6B62_u6B7B_u9501_u548C_u6D3B_u9501_u7684_u53D1_u751F" class="headerlink" title="防止死锁和活锁的发生"></a>防止死锁和活锁的发生</h3><p>死锁的意思就是线程A和线程B各持有一把锁，现在线程A在等待线程B释放锁，而线程B又在等待线程A释放锁，所以这两个线程谁也拿不到锁，也不是释放自己持有的锁，就会永远被阻塞在进程中。</p>
<p>活锁的意思是线程A可以使用资源，但它很礼貌，让其他线程先使用资源，线程B也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源，导致活锁，活锁与死锁的区别在于前者的线程并没有被阻塞，而是在不停的做一些与任务无关的事。</p>
<p>产生死锁和活锁的根本原因是线程中持有多把锁，所以避免这两种情况发生的最好办法就是尽量让线程只持有一把锁，如果实在有需求要持有多把锁，那么也应该尽量避免其他线程来请求锁。</p>
<h3 id="u6B63_u786E_u4F7F_u7528volatile_u5173_u952E_u5B57"><a href="#u6B63_u786E_u4F7F_u7528volatile_u5173_u952E_u5B57" class="headerlink" title="正确使用volatile关键字"></a>正确使用volatile关键字</h3><p>如果你已经使用的锁机制来保护一段代码逻辑，那么就不要使用<code>volatile</code>关键字来保护这段代码中使用的变量。上文中说过，可见变量机制会让代码每次从主存中加载读取变量而非缓存，本身就比较影响性能，如果再与锁机制结合，不但没有起到额外的保护作用，反而会严重影响程序的性能。所以如果使用了锁机制，那么可以完全省去使用可见变量机制，因为锁机制就已经可以很好的保护变量的线程安全性了，不需要多此一举。</p>
<h2 id="u4F7F_u7528_u539F_u5B50_u64CD_u4F5C"><a href="#u4F7F_u7528_u539F_u5B50_u64CD_u4F5C" class="headerlink" title="使用原子操作"></a>使用原子操作</h2><p>有些时候我们只希望一些数学运算或者简单的逻辑能够保证线程安全，如果使用锁机制或者条件机制虽然可以实现，但是会耗费较大的资源开销，并且锁机制还会使线程阻塞，造成性能损失，非常不划算，所以当遇到这种情况时，我们可以尝试使用原子操作来达到目的。</p>
<p>我们一般使用原子操作对32位和64位的值执行一些数学运算或简单的逻辑运算，主要依靠底层的硬件指令或者使用内存屏障确保正在执行的操作是线程安全的，下面我们来看看Apple给我们提供了哪些原子操作的方法：</p>
<h3 id="Add_u64CD_u4F5C"><a href="#Add_u64CD_u4F5C" class="headerlink" title="Add操作"></a>Add操作</h3><p>Add操作是将两个整数相加，并将结果存储在其中一个变量中：</p>
<ul>
<li><code>OSAtomicAdd32(__theAmount: Int32, _ __theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicAdd32Barrier(__theAmount: Int32, _ __theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicAdd64(__theAmount: Int64, _ __theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
<li><code>OSAtomicAdd64Barrier(__theAmount: Int64, _ __theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
</ul>
<pre><code class="swift">var num: Int64 = 10

OSAtomicAdd64(20, &amp;num)

OSAtomicAdd64Barrier(20, &amp;num)

print(&quot;\(num)&quot;) // 50
</code></pre>
<h3 id="Increment_u64CD_u4F5C"><a href="#Increment_u64CD_u4F5C" class="headerlink" title="Increment操作"></a>Increment操作</h3><p>Increment操作将指定值加1：</p>
<ul>
<li><code>OSAtomicIncrement32(__theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicIncrement32Barrier(__theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicIncrement64(__theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
<li><code>OSAtomicIncrement64Barrier(__theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
</ul>
<pre><code class="swift">var num: Int64 = 10

OSAtomicIncrement64(&amp;num)

OSAtomicIncrement64Barrier(&amp;num)

print(&quot;\(num)&quot;) // 12
</code></pre>
<h3 id="Decrement_u64CD_u4F5C"><a href="#Decrement_u64CD_u4F5C" class="headerlink" title="Decrement操作"></a>Decrement操作</h3><p>Decrement操作将指定值减1:</p>
<ul>
<li><code>OSAtomicDecrement32(__theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicDecrement32Barrier(__theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicDecrement64(__theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
<li><code>OSAtomicDecrement64Barrier(__theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
</ul>
<pre><code class="swift">var num: Int64 = 10

OSAtomicDecrement64(&amp;num)

OSAtomicDecrement64Barrier(&amp;num)

print(&quot;\(num)&quot;) // 8
</code></pre>
<h3 id="OR_u903B_u8F91_u8FD0_u7B97_u3001AND_u903B_u8F91_u8FD0_u7B97_u3001XOR_u903B_u8F91_u8FD0_u7B97"><a href="#OR_u903B_u8F91_u8FD0_u7B97_u3001AND_u903B_u8F91_u8FD0_u7B97_u3001XOR_u903B_u8F91_u8FD0_u7B97" class="headerlink" title="OR逻辑运算、AND逻辑运算、XOR逻辑运算"></a>OR逻辑运算、AND逻辑运算、XOR逻辑运算</h3><p>对两个32位数值中的位置相同的位执行按位比较：</p>
<ul>
<li><code>OSAtomicOr32(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicOr32Barrier(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicAnd32(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicAnd32Barrier(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicXor32(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicXor32Barrier(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
</ul>
<h3 id="CAS_u64CD_u4F5C"><a href="#CAS_u64CD_u4F5C" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>CAS操作是比较与交换（Compare and Swap）操作，有三个参数分别是旧值、新值、想要比较的值的内存地址，整个过程是先将你期望的旧值与指定的内存地址中的值进行比较，如果相同，那么将该内存地址的值更新为指定的新值，并返回<code>true</code>，如果比较后发现不同，那么不再做任何操作，并返回<code>false</code>，Apple提供了不同类型的CAS原子操作：</p>
<ul>
<li><code>OSAtomicCompareAndSwap32(__oldValue: Int32, _ __newValue: Int32, _ __theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicCompareAndSwap64(__oldValue: Int64, _ __newValue: Int64, _ __theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicCompareAndSwapPtr(__oldValue: UnsafeMutablePointer&lt;Void&gt;, _ __newValue: UnsafeMutablePointer&lt;Void&gt;, _ __theValue: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Void&gt;&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicCompareAndSwapLong(__oldValue: Int, _ __newValue: Int, _ __theValue: UnsafeMutablePointer&lt;Int&gt;) -&gt; Bool</code></li>
</ul>
<pre><code class="swift">var num: Int64 = 10

let result = OSAtomicCompareAndSwap64(10, 20, &amp;num)

print(&quot;\(num)&quot;) // 20

print(result) // true


var num: Int64 = 10

let result = OSAtomicCompareAndSwap64(11, 20, &amp;num)

print(&quot;\(num)&quot;) // 10

print(result) // false
</code></pre>
<h3 id="u6BD4_u7279_u4F4D_u8BBE_u7F6E_u64CD_u4F5C"><a href="#u6BD4_u7279_u4F4D_u8BBE_u7F6E_u64CD_u4F5C" class="headerlink" title="比特位设置操作"></a>比特位设置操作</h3><p>将给定比特位的值设置位1或者0:</p>
<ul>
<li><code>OSAtomicTestAndSet(__n: UInt32, _ __theAddress: UnsafeMutablePointer&lt;Void&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicTestAndSetBarrier(__n: UInt32, _ __theAddress: UnsafeMutablePointer&lt;Void&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicTestAndClear(__n: UInt32, _ __theAddress: UnsafeMutablePointer&lt;Void&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicTestAndClearBarrier(__n: UInt32, _ __theAddress: UnsafeMutablePointer&lt;Void&gt;) -&gt; Bool</code></li>
</ul>
<h2 id="u4F7F_u7528_u9501_u673A_u5236"><a href="#u4F7F_u7528_u9501_u673A_u5236" class="headerlink" title="使用锁机制"></a>使用锁机制</h2><p>锁机制是多线程编程中最常用的也是最基本的确保线程安全的机制，它能有效的保证多行逻辑代码的线程安全性。OS X和iOS系统为我们提供了基本的互斥锁和基于互斥锁变异的特殊锁以应对不同的情况。这一节我们来看看如何使用锁机制。</p>
<h3 id="POSIX_u4E92_u65A5_u9501"><a href="#POSIX_u4E92_u65A5_u9501" class="headerlink" title="POSIX互斥锁"></a>POSIX互斥锁</h3><p>前文中说过，POSIX是可移植操作系统接口（Portable Operating System Interface of UNIX），它定义了操作系统应该为应用程序提供的接口标准，在类Unix系统中都可以使用。使用POSIX互斥锁很简单，先申明互斥锁指针，类型为<code>UnsafeMutablePointer&lt;pthread_mutex_t&gt;</code>，然后通过<code>pthread_mutex_init</code>函数初始化互斥锁，最后通过<code>pthread_mutex_lock</code>函数和<code>pthread_mutex_unlock</code>函数上锁和释放锁：</p>
<pre><code class="swift">class TestLock {

    let mutex: UnsafeMutablePointer&lt;pthread_mutex_t&gt;

    init() {

        mutex = UnsafeMutablePointer.alloc(sizeof(pthread_mutex_t))

    }


    func posixMutexLock() {

        pthread_mutex_init(mutex, nil)

        pthread_mutex_lock(mutex)

        print(&quot;Do work...&quot;)

        pthread_mutex_unlock(mutex)

    }

}

let textLock = TestLock()
textLock.posixMutexLock()
</code></pre>
<h3 id="u4F7F_u7528NSLock"><a href="#u4F7F_u7528NSLock" class="headerlink" title="使用NSLock"></a>使用NSLock</h3><p>在Cocoa框架中，我们可以使用<code>NSLock</code>来实现锁机制，该类遵循了<code>NSLocking</code>协议，并实现了加锁和释放锁的方法。</p>
<p>在<code>NSLock</code>中有两个加锁的方法：</p>
<ul>
<li><code>tryLock</code>：该方法使当前线程试图去获取锁，并返回布尔值表示是否成功，但是当获取锁失败后并不会使当前线程阻塞。</li>
<li><code>lockBeforeDate</code>：该方法与上面的方法类似，但是只有在设置的时间内获取锁失败线程才不会被阻塞，如果获取锁失败时已超出了设置的时间，那么当前线程会被阻塞。</li>
</ul>
<pre><code class="swift">class TestLock {

    let nslock: NSLock

    init() {

        nslock = NSLock()

    }

    func acquireLock() {

        nslock.tryLock()

//        nslock.lockBeforeDate(NSDate(timeIntervalSinceNow: 10))

        print(&quot;Do work...&quot;)

        nslock.unlock()

    }

}

let textLock = TestLock()
textLock.acquireLock()
</code></pre>
<h3 id="u4F7F_u7528NSRecursiveLock"><a href="#u4F7F_u7528NSRecursiveLock" class="headerlink" title="使用NSRecursiveLock"></a>使用NSRecursiveLock</h3><p>上文中介绍了几种锁的类型，其中一种叫递归锁，在Cocoa中对应的类是<code>NSRecursiveLock</code>，我们来看看如何使用：</p>
<pre><code class="swift">class TestLock {

    let nsRecursiveLock: NSRecursiveLock

    init() {

        nsRecursiveLock = NSRecursiveLock()

    }

    func recursiveFunction(var value: Int) {

        nsRecursiveLock.lock()

        if value != 0 {

            --value

            print(&quot;\(value)&quot;)

            recursiveFunction(value)

        }

        nsRecursiveLock.unlock()

    }

}

let textLock = TestLock()
textLock.recursiveFunction(5)
</code></pre>
<h3 id="u4F7F_u7528NSConditionLock"><a href="#u4F7F_u7528NSConditionLock" class="headerlink" title="使用NSConditionLock"></a>使用NSConditionLock</h3><p>条件锁也是互斥锁的一种变种，在Cocoa框架中对应的类是<code>NSConditionLock</code>，条件锁顾名思义可以设置加锁和释放锁的条件。假设我们有一个消息队列，并且有消息生产者和消息消费者，那么一般情况是当消息生产者产生消息，放入消息队列，然后消息消费者从消息队列中获取消息，并将其从消息队列移除进行后续操作。那么消费者在获取消息和移除消息时要确保两点先决条件，第一就是获取消息时队列中确实已有消息，第二就是此时生产者不能向队列中添加消息，否则会影响消息队列中消息的顺序或者影响获取到消息的结果，所以在这种情况下我们就可以使用条件锁来保证他们的线程安全：</p>
<pre><code class="swift">class TestLock {

    let nsConditionLock: NSConditionLock
    var messageQueue = [AnyObject]()
    let HAS_MESSAGES = 1
    let NO_MESSAGES = 0

    init() {

        nsConditionLock = NSConditionLock(condition: NO_MESSAGES)

    }

    func produceMessage() {

        NSThread.detachNewThreadSelector(&quot;consumeMessage&quot;, toTarget: self, withObject: nil)

        while true {

            nsConditionLock.lock()

            // 生产消息并添加到消息队列中

            nsConditionLock.unlockWithCondition(HAS_MESSAGES)

        }

    }

    func consumeMessage() {

        while true {

            nsConditionLock.lockWhenCondition(HAS_MESSAGES)

            // 从消息队列中获取消息并从队列中移除消息

            nsConditionLock.unlockWithCondition(messageQueue.isEmpty ? NO_MESSAGES : HAS_MESSAGES)

        }

    }

}

let textLock = TestLock()
textLock.produceMessage()
</code></pre>
<h3 id="u4F7F_u7528@synchronized_u5173_u952E_u5B57"><a href="#u4F7F_u7528@synchronized_u5173_u952E_u5B57" class="headerlink" title="使用@synchronized关键字"></a>使用@synchronized关键字</h3><p>在Objective-C中，我们会经常使用<code>@synchronized</code>关键字来修饰变量，确保变量的线程安全，它能自动为修饰的变量创建互斥锁或解锁：</p>
<pre><code class="swift">- (void)myMethod:(id)anObj { 

    @synchronized(anObj) {

    // 在该作用域中，anObj不会被其他线程改变 

    }

}
</code></pre>
<p>从上面的代码片段中可以看到<code>myMethod:</code>方法的<code>anObj</code>参数在被<code>@synchronized</code>关键字修饰的作用域中是线程安全的。而且使用该关键字还有一个好处，那就是当有多个线程要同时执行一个带参数的方法，但不同线程中传递的参数不同，如果用<code>NSLock</code>将该方法中的逻辑代码上锁，那么就只能有一个线程获得锁，而其他线程就会被阻塞，如果使用<code>@synchronized</code>关键字就可以避免其他线程被阻塞的情况。</p>
<p>但在Swift中，Apple不知出于什么考虑，这个关键字已经不存在了，也就是我们不能在Swift中使用这个关键字对变量加锁了，但关键字都是语法糖，虽然不能使用语法糖，但还是可以使用其背后的机制的，我们来看看objc_sync的源码，看看这个关键字都干了些什么：</p>
<pre><code class="swift">// Begin synchronizing on &#39;obj&#39;. 
// Allocates recursive mutex associated with &#39;obj&#39; if needed.
// Returns OBJC_SYNC_SUCCESS once lock is acquired.  
int objc_sync_enter(id obj)
{
    int result = OBJC_SYNC_SUCCESS;

    if (obj) {
        SyncData* data = id2data(obj, ACQUIRE);
        assert(data);
        data-&gt;mutex.lock();
    } else {
        // @synchronized(nil) does nothing
        if (DebugNilSync) {
            _objc_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;);
        }
        objc_sync_nil();
    }

    return result;
}


// End synchronizing on &#39;obj&#39;. 
// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR
int objc_sync_exit(id obj)
{
    int result = OBJC_SYNC_SUCCESS;

    if (obj) {
        SyncData* data = id2data(obj, RELEASE); 
        if (!data) {
            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;
        } else {
            bool okay = data-&gt;mutex.tryUnlock();
            if (!okay) {
                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;
            }
        }
    } else {
        // @synchronized(nil) does nothing
    }


    return result;
}
</code></pre>
<p>可见<code>@synchronized</code>关键字其实是调用了<code>objc_sync_enter</code>和<code>objc_sync_exit</code>这两个方法，所以在Swift中使用时可以这样给变量加锁：</p>
<pre><code class="swift">func myMethod(anObj: AnyObject!) {

    objc_sync_enter(anObj)

    // anObj参数在这两个方法之间具有线程安全特性，不会被其他线程改变

    objc_sync_exit(anObj)

}
</code></pre>
<h2 id="u4F7F_u7528Condition_u673A_u5236"><a href="#u4F7F_u7528Condition_u673A_u5236" class="headerlink" title="使用Condition机制"></a>使用Condition机制</h2><p>Condition机制和锁机制很类似，区别也不大，同样都会使线程阻塞，这一节我们来看看如何使用该机制。</p>
<h3 id="u4F7F_u7528NSCondition_u7C7B"><a href="#u4F7F_u7528NSCondition_u7C7B" class="headerlink" title="使用NSCondition类"></a>使用NSCondition类</h3><p>这里举个生产者和消费者的例子，消费者从队列中获取产品进行消费，当队列中没有产品时消费者等待生产者生产，当生产者生产出产品放入队列后再通知消费者继续进行消费：</p>
<pre><code class="swift">class TestLock {

    var products: [AnyObject]
    let nscondition: NSCondition

    init() {

        products = [AnyObject]()

        nscondition = NSCondition()

        NSThread.detachNewThreadSelector(&quot;consumeProduct&quot;, toTarget: self, withObject: nil)

        NSThread.detachNewThreadSelector(&quot;generateProduct&quot;, toTarget: self, withObject: nil)

    }

    func consumeProduct() {

        nscondition.lock()

        guard products.count == 0 else {

            nscondition.wait()

        }

        let product = products[0]

        products.removeAtIndex(0)

        print(&quot;消费产品&quot;)

        nscondition.unlock()

    }

    func generateProduct() {

        nscondition.lock()

        let product = NSObject()

        products.append(product)

        print(&quot;生产产品&quot;)

        nscondition.signal()

        nscondition.unlock()

    }

}
</code></pre>
<p>从上面代码中可以看到，<code>NSCondition</code>类同样是用<code>lock</code>和<code>unlock</code>方法进行上锁和释放锁，然后通过<code>wait</code>方法阻塞线程，通过<code>signal</code>方法唤醒阻塞的线程，该方法唤醒的时最近一次使用<code>wait</code>方法等待的线程。如果想一次性唤醒所有在等待的线程，可以使用<code>broadcast</code>方法。<code>NSCondition</code>还有另外一个阻塞线程的方法<code>waitUntilDate(_ limit: NSDate)</code>，该方法设置一个线程阻塞时间并返回一个布尔值，如果在指定的时间内没有信号量的通知，那么就唤醒线程继续进行，此时该方法返回<code>false</code>，如果在指定时间内接收到信号量的通知，此时该方法返回<code>true</code>。</p>
<p><a href="http://www.devtalking.com/donate.html"><br>    <img border="0" src="http://www.devtalking.com/donate.png"><br></a><br><a href="http://www.devtalking.com/gongzhonghao.html"><br>    <img border="0" src="http://www.devtalking.com/guanzhugongzhonghao.png"><br></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/56726" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="Thread" scheme="http://www.devtalking.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Threading Programming Guide 笔记（三）]]></title>
    <link href="http://www.devtalking.com//articles/read-threading-programming-guide-3/"/>
    <id>http://www.devtalking.com//articles/read-threading-programming-guide-3/</id>
    <published>2016-02-17T16:00:00.000Z</published>
    <updated>2016-02-18T00:01:53.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/56056" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文章中有对官方文档的翻译，也有自己的理解，官方文档中代码片段的示例在这篇文章中都进行了完整的重写，还有一些文档中没有的代码示例，并且都使用Swift完成，给大家一些Objc与Swift转换的参考。<br>官方文档地址：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></p>
</blockquote>
<h2 id="u4F55_u65F6_u4F7F_u7528Run_Loop"><a href="#u4F55_u65F6_u4F7F_u7528Run_Loop" class="headerlink" title="何时使用Run Loop"></a>何时使用Run Loop</h2><p>前文中多次提到过，在主线程中Run Loop是随着应用程序一起启动的，也就是说当我们打开一个应用时，主线程中的Run Loop就已经启动了，尤其现在我们都使用Xcode中的项目模版创建项目，更是不用考虑主线程中Run Loop的状体。所以只有在二级线程中，也就是我们自己创建的线程中才有机会手动的创建的Run Loop，并对其进行配置的操作。</p>
<p>在前文中还提到过，Run Loop在线程中的主要作用就是帮助线程常驻在进程中，并且不会过多消耗资源。所以说Run Loop在二级线程中也不是必须需要的，要根据该线程执行的任务类型以及在整个应用中担任何作用而决定是否需要使用Run Loop。比如说，如果你创建一个二级线程只是为了执行一个不会频繁执行的一次性任务，或者需要执行很长时间的任务，那么可能就不需要使用Run Loop了。如果你需要一个线程执行周期性的定时任务，或者需要较为频繁的与主线程之间进行交互，那么就需要使用Run Loop。归纳一下需要使用Run Loop的情况大概有以下四点：</p>
<ul>
<li>通过基于端口或自定义的数据源与其他线程进行交互。</li>
<li>在线程中执行定时事件源的任务。</li>
<li>使用Cocoa框架提供的<code>performSelector…</code>系列方法。</li>
<li>在线程中执行较为频繁的，具有周期性的任务。</li>
</ul>
<p>光说不练假把式，下面就让我们来看看如何具体创建、配置、操作Run Loop。</p>
<h2 id="Run_Loop_u5BF9_u8C61"><a href="#Run_Loop_u5BF9_u8C61" class="headerlink" title="Run Loop对象"></a>Run Loop对象</h2><p>要想操作配置Run Loop，那自然需要通过Run Loop对象来完成，它提供了一系列接口，可帮助我们便捷的添加Input sources、timers以及观察者。较高级别的Cocoa框架提供了<code>NSRunLoop</code>类，较底层级别的Core Foundation框架提供了指向<code>CFRunloopRef</code>的指针。</p>
<h3 id="u83B7_u53D6Run_Loop_u5BF9_u8C61"><a href="#u83B7_u53D6Run_Loop_u5BF9_u8C61" class="headerlink" title="获取Run Loop对象"></a>获取Run Loop对象</h3><p>前文中提到过，在Cocoa和Core Foundation框架中都没有提供创建Run Loop的方法，只有从当前线程获取Run Loop的方法：</p>
<ul>
<li>在Cocoa框架中，<code>NSRunLoop</code>类提供了类方法<code>currentRunLoop()</code>获取<code>NSRunLoop</code>对象。<blockquote>
<p>该方法是获取当前线程中已存在的Run Loop，如果不存在，那其实还是会创建一个Run Loop对象返回，只是Cocoa框架没有向我们暴露该接口。</p>
</blockquote>
</li>
<li>在Core Foundation框架中提供了<code>CFRunLoopGetCurrent()</code>函数获取<code>CFRunLoop</code>对象。</li>
</ul>
<p>虽然这两个Run Loop对象并不完全等价，它们之间还是可以转换的，我们可以通过<code>NSRunLoop</code>对象提供的<code>getCFRunLoop()</code>方法获取<code>CFRunLoop</code>对象。因为<code>NSRunLoop</code>和<code>CFRunLoop</code>指向的都是当前线程中同一个Run Loop，所以在使用时它们可以混用，比如说要给Run Loop添加观察者时就必须得用<code>CFRunLoop</code>了。</p>
<h3 id="u914D_u7F6ERun_Loop_u89C2_u5BDF_u8005"><a href="#u914D_u7F6ERun_Loop_u89C2_u5BDF_u8005" class="headerlink" title="配置Run Loop观察者"></a>配置Run Loop观察者</h3><p>前文中提到过，可以向Run Loop中添加各种事件源和观察者，这里事件源是必填项，也就是说Run Loop中至少要有一种事件源，不论是Input source还是timer，如果Run Loop中没有事件源的话，那么在启动Run Loop后就会立即退出。而观察者是可选项，如果没有监控Run Loop各运行状态的需求，可以不配置观察者，这一节先看看如何向Run Loop中添加观察者。</p>
<p>在Cocoa框架中，并没有提供创建配置Run Loop观察者的相关接口，所以我们只能通过Core Foundation框架中提供的对象和方法创建并配置Run Loop观察者，下面我们看看示例代码：</p>
<pre><code class="swift">import Foundation

class TestThread: NSObject {

    func launch() {

        print(&quot;First event in Main Thread.&quot;)

        NSThread.detachNewThreadSelector(&quot;createAndConfigObserverInSecondaryThread&quot;, toTarget: self, withObject: nil)

        print(NSThread.isMultiThreaded())

        sleep(3)

        print(&quot;Second event in Main Thread.&quot;)

    }

    func createAndConfigObserverInSecondaryThread() {

        autoreleasepool{

            // 1
            let runloop = NSRunLoop.currentRunLoop()

            // 2
            var _self = self

            // 3
            var observerContext = CFRunLoopObserverContext(version: 0, info: &amp;_self, retain: nil, release: nil, copyDescription: nil)

            // 4
            let observer = CFRunLoopObserverCreate(kCFAllocatorDefault, CFRunLoopActivity.AllActivities.rawValue, true, 0, self.observerCallbackFunc(), &amp;observerContext)

            if(observer != nil) {

                // 5
                let cfRunloop = runloop.getCFRunLoop()

                // 6
                CFRunLoopAddObserver(cfRunloop, observer, kCFRunLoopDefaultMode)

            }

            // 7
            NSTimer.scheduledTimerWithTimeInterval(0.5, target: self, selector: &quot;fireTimer&quot;, userInfo: nil, repeats: true)

            var loopCount = 10

            repeat {

                // 8
                runloop.runUntilDate(NSDate(timeIntervalSinceNow: 1))

                loopCount--

            } while(loopCount &gt; 0)

        }

    }

    func observerCallbackFunc() -&gt; CFRunLoopObserverCallBack {

        return {(observer, activity, context) -&gt; Void in

            switch(activity) {

            case CFRunLoopActivity.Entry:
                print(&quot;Run Loop已经启动&quot;)
                break
            case CFRunLoopActivity.BeforeTimers:
                print(&quot;Run Loop分配定时任务前&quot;)
                break
            case CFRunLoopActivity.BeforeSources:
                print(&quot;Run Loop分配输入事件源前&quot;)
                break
            case CFRunLoopActivity.BeforeWaiting:
                print(&quot;Run Loop休眠前&quot;)
                break
            case CFRunLoopActivity.AfterWaiting:
                print(&quot;Run Loop休眠后&quot;)
                break
            case CFRunLoopActivity.Exit:
                print(&quot;Run Loop退出后&quot;)
                break
            default:
                break

            }

        }

    }

    func fireTimer() {

    }

}

let testThread = TestThread()
testThread.launch()
</code></pre>
<p>下面解读一下上述代码示例，<code>launch()</code>方法在主线程中，通过<code>NSThread</code>类的类方法<code>detachNewThreadSelector:toTarget:withObject:</code>创建并启动一个二级线程，将<code>createAndConfigObserverInSecondaryThread()</code>方法作为事件消息传入该二级线程，这个方法的主要作用就是在二级线程中创建配置Run Loop观察者并启动Run Loop，然后让主线程持续3秒，以便二级线程有足够的时间执行任务。</p>
<p>在<code>createAndConfigObserverInSecondaryThread()</code>中共有8个关键步骤，下面一一进行说明：</p>
<ul>
<li><strong>第一步</strong>：通过<code>NSRunLoop</code>类的类方法<code>currentRunLoop()</code>获取当前线程的Run Loop，这里获取到的Run Loop对象是<code>NSRunLoop</code>对象。</li>
<li><strong>第二步</strong>：申明当前对象的变量，至于为什么要这么做，在下一步中会有说明。</li>
<li><strong>第三步</strong>：通过Core Foundation框架的<code>CFRunLoopObserverContext</code>结构体构造Run Loop观察者上下文，大家需要注意前两个参数，我们先看看这个结构体：</li>
</ul>
<pre><code class="swift">public struct CFRunLoopObserverContext {
    public var version: CFIndex
    public var info: UnsafeMutablePointer&lt;Void&gt;
    public var retain: (@convention(c) (UnsafePointer&lt;Void&gt;) -&gt; UnsafePointer&lt;Void&gt;)!
    public var release: (@convention(c) (UnsafePointer&lt;Void&gt;) -&gt; Void)!
    public var copyDescription: (@convention(c) (UnsafePointer&lt;Void&gt;) -&gt; Unmanaged&lt;CFString&gt;!)!
    public init()
    public init(version: CFIndex, info: UnsafeMutablePointer&lt;Void&gt;, retain: (@convention(c) (UnsafePointer&lt;Void&gt;) -&gt; UnsafePointer&lt;Void&gt;)!, release: (@convention(c) (UnsafePointer&lt;Void&gt;) -&gt; Void)!, copyDescription: (@convention(c) (UnsafePointer&lt;Void&gt;) -&gt; Unmanaged&lt;CFString&gt;!)!)
}
</code></pre>
<ol>
<li><code>version</code>：结构体版本号，必须设置为0。</li>
<li><code>info</code>：上下文中<code>retain</code>、<code>release</code>、<code>copyDescription</code>三个回调函数以及Run Loop观察者的回调函数所有者对象的指针。在Swift中，<code>UnsafePointer</code>结构体代表C系语言中申明为常量的指针，<code>UnsafeMutablePoinger</code>结构体代表C系语言中申明为非常量的指针，比如说：</li>
</ol>
<pre><code class="swift">C:
void functionWithConstArg(const int *constIntPointer);

Swift:
func functionWithConstArg(constIntPointer: UnsafePointer&lt;Int32&gt;)

C:
void functionWithNotConstArg(unsigned int *unsignedIntPointer);

Swift:
func functionWithNotConstArg(unsignedIntPointer: UnsafeMutablePointer&lt;UInt32&gt;)

C:
void functionWithNoReturnArg(void *voidPointer);

Swift:
func functionWithNoReturnArg(voidPointer: UnsafeMutablePointer&lt;Void&gt;)
</code></pre>
<ul>
<li><strong>第四步</strong>：通过Core Foundation框架的<code>CFRunLoopObserverCreate</code>函数创建<code>CFRunLoopObserver</code>对象：</li>
</ul>
<pre><code class="swift">public func CFRunLoopObserverCreate(allocator: CFAllocator!, _ activities: CFOptionFlags, _ repeats: Bool, _ order: CFIndex, _ callout: CFRunLoopObserverCallBack!, _ context: UnsafeMutablePointer&lt;CFRunLoopObserverContext&gt;) -&gt; CFRunLoopObserver!
</code></pre>
<ol>
<li><code>allocator</code>：该参数为对象内存分配器，一般使用默认的分配器<code>kCFAllocatorDefault</code>。</li>
<li><code>activities</code>：该参数配置观察者监听Run Loop的哪种运行状态。在示例中，我们让观察者监听Run Loop的所有运行状态。</li>
<li><code>repeats</code>：该参数标识观察者只监听一次还是每次Run Loop运行时都监听。</li>
<li><code>order</code>：观察者优先级，当Run Loop中有多个观察者监听同一个运行状态时，那么就根据该优先级判断，0为最高优先级别。</li>
<li><code>callout</code>：观察者的回调函数，在Core Foundation框架中用<code>CFRunLoopObserverCallBack</code>重定义了回调函数的闭包。</li>
<li><code>context</code>：观察者的上下文。</li>
</ol>
<ul>
<li><strong>第五步</strong>：因为<code>NSRunLoop</code>没有提供操作观察者的接口，所以我们需要<code>getCFRunLoop()</code>方法获取到<code>CFRunLoop</code>对象。</li>
<li><strong>第六步</strong>：通过<code>CFRunLoopAddObserver</code>函数向当前线程的Run Loop中添加创建好的观察者：</li>
</ul>
<pre><code class="swift">func CFRunLoopAddObserver(_ rl: CFRunLoop!, _ observer: CFRunLoopObserver!, _ mode: CFString!)
</code></pre>
<ol>
<li><code>rl</code>：当前线程的<code>CFRunLoop</code>对象。</li>
<li><code>observer</code>：创建好的观察者。</li>
<li><code>mode</code>：设置将观察者添加到哪个Run Loop模式中。</li>
</ol>
<blockquote>
<p>这里需要注意的是，一个观察者只能被添加到一个Run Loop中，但是可以被添加到Run Loop中的多个模式中。</p>
</blockquote>
<ul>
<li><strong>第七步</strong>：通过Timer事件源向当前线程发送重复执行的定时任务，时间间隔为0.5秒，因为只是为了测试观察者，所以<code>fireTimer()</code>是一个空任务。另外前文中提到过，如果Run Loop中没有任何数据源，那么Run Loop启动后会立即退出，所以大家可以把这行注释了运行看看会有什么效果。</li>
<li><strong>第八步</strong>：通过<code>NSRunLoop</code>对象的<code>runUntilDate(limitDate: NSDate)</code>方法启动Run Loop，设置Run Loop的运行时长为1秒。这里将其放在一个循环里，最大循环次数为10次，也就是说，如果不考虑主线程的运行时间，该二级线程的Run Loop可运行10次。</li>
</ul>
<p>再来看看观察者的回调方法<code>observerCallbackFunc()</code>，上面在介绍<code>CFRunLoopObserverCreate</code>函数时提到观察者的回调函数是<code>CFRunLoopObserverCallBack</code>重定义的一个闭包，我们来看看这个闭包：</p>
<pre><code class="swift">typealias CFRunLoopObserverCallBack = (CFRunLoopObserver!, CFRunLoopActivity, UnsafeMutablePointer&lt;Void&gt;) -&gt; Void
</code></pre>
<p>这个闭包没有返回值，第一个参数是触发监听的观察者，第二个参数是观察者监听的Run Loop运行状态，第三个参数是观察者的运行上下文环境。所以在回调方法中，我们只需要根据第二个参数的值即可判断观察者监听到的Run Loop状态。大家可以拷贝上面的代码，建一个Command Application运行看看结果。</p>
<h3 id="u542F_u52A8Run_Loop"><a href="#u542F_u52A8Run_Loop" class="headerlink" title="启动Run Loop"></a>启动Run Loop</h3><p>在启动Run Loop前务必要保证已添加一种类型的事件源，原因在前文中已提到多次。在Cocoa框架和Core Foundation框架中启动Run Loop大体有三种形式，分别是无条件启动、设置时间限制启动、指定特定模式启动。</p>
<h4 id="u65E0_u6761_u4EF6_u542F_u52A8"><a href="#u65E0_u6761_u4EF6_u542F_u52A8" class="headerlink" title="无条件启动"></a>无条件启动</h4><p><code>NSRunLoop</code>对象的<code>run()</code>方法和Core Foundation框架中的<code>CFRunLoopRun()</code>函数都是无条件启动Run Loop的方式。这种方式虽然是最简单的启动方式，但也是最不推荐使用的一个方式，因为这种方式将Run Loop置于一个永久运行并且不可控的状态，它使Run Loop只能在默认模式下运行，无法给Run Loop设置特定的或自定义的模式，而且以这种模式启动的Run Loop只能通过<code>CFRunLoopStop(_ rl: CFRunLoop!)</code>函数强制停止。</p>
<h4 id="u8BBE_u7F6E_u65F6_u95F4_u9650_u5236_u542F_u52A8"><a href="#u8BBE_u7F6E_u65F6_u95F4_u9650_u5236_u542F_u52A8" class="headerlink" title="设置时间限制启动"></a>设置时间限制启动</h4><p>该方式对应的方法是<code>NSRunLoop</code>对象的<code>runUntilDate(_ limitDate: NSDate)</code>方法，在启动Run Loop时设置超时时间，一旦超时那么Run Loop则自动退出。该方法的好处是可以在循环中反复启动Run Loop处理相关任务，而且可控制运行时长。</p>
<h4 id="u6307_u5B9A_u7279_u5B9A_u6A21_u5F0F_u542F_u52A8"><a href="#u6307_u5B9A_u7279_u5B9A_u6A21_u5F0F_u542F_u52A8" class="headerlink" title="指定特定模式启动"></a>指定特定模式启动</h4><p>该方式对应的方法是<code>NSRunLoop</code>对象的<code>runMode(_ mode: String, beforeDate limitDate: NSDate)</code>方法和Core Foundation框架的<code>CFRunLoopRunInMode(_ mode: CFString!, _ seconds: CFTimeInterval, _ returnAfterSourceHandled: Bool)</code>函数。前者有两个参数，第一个参数是Run Loop模式，第二个参数仍然是超时时间，该方法使Run Loop只处理指定模式中的事件源事件，当处理完事件或超时Run Loop会退出，该方法的返回值类型是<code>Bool</code>，如果返回<code>true</code>则表示Run Loop启动成功，并分派执行了任务或者达到超时时间，若返回<code>false</code>则表示Run Loop启动失败。后者有三个参数，前两个参数的作用一样，第三个参数的意思是Run Loop是否在执行完任务后就退出，如果设置为<code>false</code>，那么代表Run Loop在执行完任务后不退出，而是一直等到超时后才退出。该方法返回Run Loop的退出状态：</p>
<ul>
<li><code>CFRunLoopRunResult.Finished</code>：表示Run Loop已分派执行完任务，并且再无任务执行的情况下退出。</li>
<li><code>CFRunLoopRunResult.Stopped</code>：表示Run Loop通过<code>CFRunLoopStop(_ rl: CFRunLoop!)</code>函数强制退出。</li>
<li><code>CFRunLoopRunResult.TimedOut</code>：表示Run Loop因为超时时间到而退出。</li>
<li><code>CFRunLoopRunResult.HandledSource</code>：表示Run Loop已执行完任务而退出，改状态只有在<code>returnAfterSourceHandled</code>设置为<code>true</code>时才会出现。</li>
</ul>
<h3 id="u9000_u51FARun_Loop"><a href="#u9000_u51FARun_Loop" class="headerlink" title="退出Run Loop"></a>退出Run Loop</h3><p>退出Run Loop的方式总体来说有三种：</p>
<ul>
<li>启动Run Loop时设置超时时间。</li>
<li>强制退出Run Loop。</li>
<li>移除Run Loop中的事件源，从而使Run Loop退出。</li>
</ul>
<p>第一种方式是推荐使用的方式，因为可以给Run Loop设置可控的运行时间，让它执行完所有的任务以及给观察者发送通知。第二种强制退出Run Loop主要是应对无条件启动Run Loop的情况。第三种方式是最不推荐的方式，虽然在理论上说当Run Loop中没有任何数据源时会立即退出，但是在实际情况中我们创建的二级线程除了执行我们指定的任务外，有可能系统还会让其执行一些系统层面的任务，而且这些任务我们一般无法知晓，所以用这种方式退出Run Loop往往会存在延迟退出。</p>
<h3 id="Run_Loop_u5BF9_u8C61_u7684_u7EBF_u7A0B_u5B89_u5168_u6027"><a href="#Run_Loop_u5BF9_u8C61_u7684_u7EBF_u7A0B_u5B89_u5168_u6027" class="headerlink" title="Run Loop对象的线程安全性"></a>Run Loop对象的线程安全性</h3><p>Run Loop对象的线程安全性取决于我们使用哪种API去操作。Core Foundation框架中的<code>CFRunLoop</code>对象是线程安全的，我们可以在任何线程中使用。Cocoa框架的<code>NSRunLoop</code>对象是线程不安全的，我们必须在拥有Run Loop的当前线程中操作Run Loop，如果操作了不属于当前线程的Run loop，会导致异常和各种潜在的问题发生。</p>
<h2 id="u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90"><a href="#u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90" class="headerlink" title="自定义Run Loop事件源"></a>自定义Run Loop事件源</h2><p>Cocoa框架因为是较为高层的框架，所以没有提供操作较为底层的Run Loop事件源相关的接口和对象，所以我们只能使用Core Foundation框架中的对象和函数创建事件源并给Run Loop设置事件源。</p>
<h3 id="u521B_u5EFARun_Loop_u4E8B_u4EF6_u6E90_u5BF9_u8C61"><a href="#u521B_u5EFARun_Loop_u4E8B_u4EF6_u6E90_u5BF9_u8C61" class="headerlink" title="创建Run Loop事件源对象"></a>创建Run Loop事件源对象</h3><p>我们定义自己的Run Loop事件源首先就是需要创建事件源，我们来看看创建事件源的方法：</p>
<pre><code class="swift">func CFRunLoopSourceCreate(_ allocator: CFAllocator!, _ order: CFIndex, _ context: UnsafeMutablePointer&lt;CFRunLoopSourceContext&gt;) -&gt; CFRunLoopSource!
</code></pre>
<ol>
<li><code>allocator</code>：该参数为对象内存分配器，一般使用默认的分配器<code>kCFAllocatorDefault</code>。</li>
<li><code>order</code>：事件源优先级，当Run Loop中有多个接收相同事件的事件源被标记为待执行时，那么就根据该优先级判断，0为最高优先级别。</li>
<li><code>context</code>：事件源上下文。</li>
</ol>
<p>Run Loop事件源上下文很重要，我们来看看它的结构：</p>
<pre><code class="swift">struct CFRunLoopSourceContext { 
    var version: CFIndex 
    var info: UnsafeMutablePointer&lt;Void&gt; 
    var retain: ((UnsafePointer&lt;Void&gt;) -&gt; UnsafePointer&lt;Void&gt;)! 
    var release: ((UnsafePointer&lt;Void&gt;) -&gt; Void)! 
    var copyDescription: ((UnsafePointer&lt;Void&gt;) -&gt; Unmanaged&lt;CFString&gt;!)! 
    var equal: ((UnsafePointer&lt;Void&gt;, UnsafePointer&lt;Void&gt;) -&gt; DarwinBoolean)! 
    var hash: ((UnsafePointer&lt;Void&gt;) -&gt; CFHashCode)! 
    var schedule: ((UnsafeMutablePointer&lt;Void&gt;, CFRunLoop!, CFString!) -&gt; Void)! 
    var cancel: ((UnsafeMutablePointer&lt;Void&gt;, CFRunLoop!, CFString!) -&gt; Void)! 
    var perform: ((UnsafeMutablePointer&lt;Void&gt;) -&gt; Void)! 
    init() 
    init(version version: CFIndex, info info: UnsafeMutablePointer&lt;Void&gt;, retain retain: ((UnsafePointer&lt;Void&gt;) -&gt; UnsafePointer&lt;Void&gt;)!, release release: ((UnsafePointer&lt;Void&gt;) -&gt; Void)!, copyDescription copyDescription: ((UnsafePointer&lt;Void&gt;) -&gt; Unmanaged&lt;CFString&gt;!)!, equal equal: ((UnsafePointer&lt;Void&gt;, UnsafePointer&lt;Void&gt;) -&gt; DarwinBoolean)!, hash hash: ((UnsafePointer&lt;Void&gt;) -&gt; CFHashCode)!, schedule schedule: ((UnsafeMutablePointer&lt;Void&gt;, CFRunLoop!, CFString!) -&gt; Void)!, cancel cancel: ((UnsafeMutablePointer&lt;Void&gt;, CFRunLoop!, CFString!) -&gt; Void)!, perform perform: ((UnsafeMutablePointer&lt;Void&gt;) -&gt; Void)!) 
}
</code></pre>
<p>该结构体中我们需要关注的是前两个和后三个属性：</p>
<ol>
<li><code>version</code>：事件源上下文的版本，必须设置为0。</li>
<li><code>info</code>：上下文中<code>retain</code>、<code>release</code>、<code>copyDescription</code>、<code>equal</code>、<code>hash</code>、<code>schedule</code>、<code>cancel</code>、<code>perform</code>这八个回调函数所有者对象的指针。</li>
<li><code>schedule</code>：该回调函数的作用是将该事件源与给它发送事件消息的线程进行关联，也就是说如果主线程想要给该事件源发送事件消息，那么首先主线程得能获取到该事件源。</li>
<li><code>cancel</code>：该回调函数的作用是使该事件源失效。</li>
<li><code>perform</code>：该回调函数的作用是执行其他线程或当前线程给该事件源发来的事件消息。</li>
</ol>
<h3 id="u5C06_u4E8B_u4EF6_u6E90_u6DFB_u52A0_u81F3Run_Loop"><a href="#u5C06_u4E8B_u4EF6_u6E90_u6DFB_u52A0_u81F3Run_Loop" class="headerlink" title="将事件源添加至Run Loop"></a>将事件源添加至Run Loop</h3><p>事件源创建好之后，接下来就是将其添加到指定某个模式的Run Loop中，我们来看看这个方法：</p>
<pre><code class="swift">func CFRunLoopAddSource(_ rl: CFRunLoop!, _ source: CFRunLoopSource!, _ mode: CFString!)
</code></pre>
<ol>
<li><code>rl</code>：希望添加事件源的Run Loop对象，类型是<code>CFRunLoop</code>。</li>
<li><code>source</code>：我们创建好的事件源。</li>
<li><code>mode</code>：Run Loop的模式。（可以回顾之前文章）</li>
</ol>
<p>我们再来看看这个方法都干了些什么：</p>
<pre><code class="swift">void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) {

    .....

    __CFRunLoopSourceSchedule(rls, rl, rlm);

    .....

}

static void __CFRunLoopSourceSchedule(CFRunLoopSourceRef rls, CFRunLoopRef rl, CFRunLoopModeRef rlm) {    

    .....

    if (0 == rls-&gt;_context.version0.version) {
         if (NULL != rls-&gt;_context.version0.schedule) {
             rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, rlm-&gt;_name);
         }
    } 

    .....

}
</code></pre>
<p>从上述的代码片段可以看出，在<code>CFRunLoopAddSource</code>中调用了<code>__CFRunLoopSourceSchedule</code>内部函数，而该函数中正是执行了Run Loop事件源上下文中的<code>schedule</code>回调函数。也就是说当把事件源添加到Run Loop中后就会将事件源与给它发送事件消息的线程进行关联。</p>
<h3 id="u6807_u8BB0_u4E8B_u4EF6_u6E90_u53CA_u5524_u9192Run_Loop"><a href="#u6807_u8BB0_u4E8B_u4EF6_u6E90_u53CA_u5524_u9192Run_Loop" class="headerlink" title="标记事件源及唤醒Run Loop"></a>标记事件源及唤醒Run Loop</h3><p>前面的文章中说过，srouce0类型，也就是非port类型的事件源都需要进行手动标记，标记完还需要手动唤醒Run Loop，下面我们来看看这两个方法：</p>
<pre><code class="swift">func CFRunLoopSourceSignal(_ source: CFRunLoopSource!)

func CFRunLoopWakeUp(_ rl: CFRunLoop!)
</code></pre>
<p>这里需要注意的是唤醒Run Loop并不等价与启动Run Loop，因为启动Run Loop时需要对Run Loop进行模式、时限的设置，而唤醒Run Loop只是当已启动的Run Loop休眠时重新让其运行。</p>
<h3 id="u6267_u884CRun_Loop_u4E8B_u4EF6_u6E90_u7684_u4EFB_u52A1"><a href="#u6267_u884CRun_Loop_u4E8B_u4EF6_u6E90_u7684_u4EFB_u52A1" class="headerlink" title="执行Run Loop事件源的任务"></a>执行Run Loop事件源的任务</h3><p>唤醒Run Loop意味着让休眠的Run Loop重新运行，那么我们就从启动Run Loop，让其开始运行的方法看起：</p>
<pre><code class="swift">extension NSRunLoop {

    .....

    public func runUntilDate(limitDate: NSDate) {
        while runMode(NSDefaultRunLoopMode, beforeDate: limitDate) &amp;&amp; limitDate.timeIntervalSinceReferenceDate &gt; CFAbsoluteTimeGetCurrent() { }
    }

    public func runMode(mode: String, beforeDate limitDate: NSDate) -&gt; Bool {

        .....

        let limitTime = limitDate.timeIntervalSinceReferenceDate
        let ti = limitTime - CFAbsoluteTimeGetCurrent()
        CFRunLoopRunInMode(modeArg, ti, true)
        return true
    }

}

SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     
    CHECK_FOR_FORK();
    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);
}

SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     

    .....

    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, false);

    .....

    return result;
}

static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, Boolean waitIfEmpty) {

    .....

    __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);

    .....

}

static Boolean __CFRunLoopDoSources0(CFRunLoopRef rl, CFRunLoopModeRef rlm, Boolean stopAfterHandle) {

    CFTypeRef sources = NULL;

    .....

    if (__CFRunLoopSourceIsSignaled(rls)) {

        .....

        rls-&gt;_context.version0.perform(rls-&gt;_context.version0.info);

        .....

    }

    .....

}
</code></pre>
<p>从上述代码片段中可以看出，当Run Loop运行后会调用内部函数<code>__CFRunLoopDoSources0</code>执行自定义事件源的任务，在执行之前会通过内部函数<code>__CFRunLoopSourceIsSignaled(rls)</code>判断事件源是否已被标记为待执行，然后执行Run Loop事件上下文中的<code>perform</code>回调函数。</p>
<h3 id="u79FB_u9664Run_Loop_u4E8B_u4EF6_u6E90"><a href="#u79FB_u9664Run_Loop_u4E8B_u4EF6_u6E90" class="headerlink" title="移除Run Loop事件源"></a>移除Run Loop事件源</h3><p>当我们自定义的事件源完成使命后就可以将其从Run Loop中移除，我们来看看对应的方法：</p>
<pre><code class="swift">func CFRunLoopRemoveSource(_ rl: CFRunLoop!, _ source: CFRunLoopSource!, _ mode: CFString!)

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) {

    .....

    __CFRunLoopSourceCancel(rls, rl, rlm);

    .....

}

static void __CFRunLoopSourceCancel(CFRunLoopSourceRef rls, CFRunLoopRef rl, CFRunLoopModeRef rlm) {
    if (0 == rls-&gt;_context.version0.version) {
          if (NULL != rls-&gt;_context.version0.cancel) {
              rls-&gt;_context.version0.cancel(rls-&gt;_context.version0.info, rl, rlm-&gt;_name);
          }
    }

    .....

}
</code></pre>
<p>从上述代码片段可以看出，当我们调用了<code>CFRunLoopRemoveSource</code>方法后，其实是执行了Run Loop事件源上下文中的<code>cancel</code>回调函数。</p>
<h3 id="u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90_u7684_u5B9E_u9645_u8FD0_u7528"><a href="#u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90_u7684_u5B9E_u9645_u8FD0_u7528" class="headerlink" title="自定义Run Loop事件源的实际运用"></a>自定义Run Loop事件源的实际运用</h3><p>在讲解示例之前，我们先来看看示例Demo的效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-5.gif" alt="LearnThread-5"></p>
<p>在这个示例中，创建了两个自定义事件源，一个添加到主线程中，另一个添加到二级线程中。主线程给二级线程中的自定义事件源发送事件消息，目的是让其改变所有<code>UICollectionViewCell</code>的透明度，当二级线程收到事件消息后执行计算每个<code>UICollectionViewCell</code>透明度的任务，然后再给主线程的自定义事件源发送事件消息，让其更新<code>UICollectionViewCell</code>的透明度并显示。下面来看看类图：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-6-new.png" alt="LearnThread-6"></p>
<p>整个工程一共就这六个类：</p>
<ul>
<li><code>MainCollectionViewController</code>：程序主控制器，启动程序、展示UI及计算<code>UICollectionViewCell</code>透明度的相关方法。</li>
<li><code>MainThreadRunLoopSource</code>：主线程自定义事件源管理对象，负责初始化事件源，将事件源添加至指定线程，标记事件源并唤醒指定Run Loop以及包含上文中说过的事件源最主要的三个回调方法。</li>
<li><code>MainThreadRunLoopSourceContext</code>：主线程自定义事件源上下文，可获取到对应的事件源及添加了该事件源的Run Loop。</li>
<li><code>SecondaryThreadRunLoopSource</code>：二级线程自定义事件源管理对象，负责初始化事件源，将事件源添加至指定线程，标记事件源并唤醒指定Run Loop以及包含上文中说过的事件源最主要的三个回调方法。</li>
<li><code>SecondaryThreadRunLoopSourceContext</code>：二级线程自定义事件源上下文，可获取到对应的事件源及添加了该事件源的Run Loop。</li>
<li><code>AppDelegate</code>：应用程序代理类，这里零时充当为各自定义事件源回调方法执行内容的管理类。</li>
</ul>
<p>下面我按照程序的运行顺序一一对这些类及属性和方法进行简单说明。</p>
<h4 id="u7A0B_u5E8F_u5F00_u59CB_u8FD0_u884C"><a href="#u7A0B_u5E8F_u5F00_u59CB_u8FD0_u884C" class="headerlink" title="程序开始运行"></a>程序开始运行</h4><p><code>MainCollectionViewController</code>类中与UI展示相关的方法在这里就不再累赘了。点击<strong>Start</strong>按钮，调用<code>start()</code>方法，初始化<code>MainThreadRunLoopSource</code>对象，在这个过程中初始化了<code>CFRunLoopSourceContext</code>对象并且创建<code>CFRunLoopSource</code>对象以及初始化该事件源的指令池：</p>
<pre><code class="swift">let mainThreadRunLoopSource = MainThreadRunLoopSource()

mainThreadRunLoopSource.addToCurrentRunLoop()
</code></pre>
<pre><code class="swift">var runloopSourceContext = CFRunLoopSourceContext(version: 0, info: unsafeBitCast(self, UnsafeMutablePointer&lt;Void&gt;.self), retain: nil, release: nil, copyDescription: nil, equal: nil, hash: nil, schedule: runloopSourceScheduleRoutine(), cancel: runloopSourceCancelRoutine(), perform: runloopSourcePerformRoutine())

runloopSource = CFRunLoopSourceCreate(kCFAllocatorDefault, 0, &amp;runloopSourceContext)

commandBuffer = Array&lt;SecondaryThreadRunLoopSourceContext&gt;()
</code></pre>
<p>这里需要注意的是<code>CFRunLoopSourceContext</code>的<code>init</code>方法中的第二个参数和<code>CFRunLoopSourceCreate</code>方法的第三个参数都是指针，那么在Swift中，将对象转换为指针的方法有两种：</p>
<ul>
<li>使用<code>unsafeBitCast</code>方法，该方法会将第一个参数的内容按照第二个参数的类型进行转换。一般当需要对象与指针来回转换时使用该方法。</li>
<li>在对象前面加<code>&amp;</code>符号，表示传入指针地址。</li>
</ul>
<p>当主线程的自定义事件源初始化完成之后，调用<code>addToCurrentRunLoop()</code>方法，将事件源添加至当前Run Loop中，即主线程的Run Loop：</p>
<pre><code class="swift">let cfrunloop = CFRunLoopGetCurrent()

if let rls = runloopSource {

    CFRunLoopAddSource(cfrunloop, rls, kCFRunLoopDefaultMode)

}
</code></pre>
<p>接下来创建二级线程，并且让其执行二级线程的配置任务：</p>
<pre><code class="swift">let secondaryThread = NSThread(target: self, selector: &quot;startThreadWithRunloop&quot;, object: nil)

secondaryThread.start()
</code></pre>
<p>在二级线程中同样初始化自定义事件源，并将将其添加至二级线程的Run Loop中，然后启动Run Loop：</p>
<pre><code class="swift">func startThreadWithRunloop() {

    autoreleasepool{

        var done = false

        let secondaryThreadRunLoopSource = SecondaryThreadRunLoopSource()

        secondaryThreadRunLoopSource.addToCurrentRunLoop()

        repeat {

            let result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 5, true)

            if ((result == CFRunLoopRunResult.Stopped) || (result == CFRunLoopRunResult.Finished)) {

                done = true;

            }

        } while(!done)

    }

}
</code></pre>
<h4 id="u6267_u884C_u4E8B_u4EF6_u6E90_u7684schedule_u56DE_u8C03_u51FD_u6570"><a href="#u6267_u884C_u4E8B_u4EF6_u6E90_u7684schedule_u56DE_u8C03_u51FD_u6570" class="headerlink" title="执行事件源的schedule回调函数"></a>执行事件源的schedule回调函数</h4><p>前文中说过将事件源添加至Run Loop后会触发事件源的<code>schedule</code>回调函数，所以当执行完<code>mainThreadRunLoopSource.addToCurrentRunLoop()</code>这句代码后，便会触发主线程自定义事件源的<code>schedule</code>回调函数：</p>
<pre><code class="swift">func runloopSourceScheduleRoutine() -&gt; @convention(c) (UnsafeMutablePointer&lt;Void&gt;, CFRunLoop!, CFString!) -&gt; Void {

    return { (info, runloop, runloopMode) -&gt; Void in

        let mainThreadRunloopSource = unsafeBitCast(info, MainThreadRunLoopSource.self)

        let mainThreadRunloopSourceContext = MainThreadRunLoopSourceContext(runloop: runloop, runloopSource: mainThreadRunloopSource)

        let appDelegate = UIApplication.sharedApplication().delegate as! AppDelegate

        appDelegate.performSelector(&quot;registerMainThreadRunLoopSource:&quot;, withObject: mainThreadRunloopSourceContext)

    }

}
</code></pre>
<p>这里还需注意的是在Swift2.0中，如果一个作为回调函数方法的返回类型是指向函数的指针，这类指针可以转换为闭包，并且要在闭包前面加上<code>@convention(c)</code>标注。在<code>runloopSourceScheduleRoutine()</code>方法中，获取到主线程事件源对象并初始化事件源上下文对象，然后将该事件源上下文对象传给<code>AppDelegate</code>的对应方法注册该事件源上下文对象：</p>
<pre><code class="swift">func registerMainThreadRunLoopSource(runloopSourceContext: MainThreadRunLoopSourceContext) {

    mainThreadRunloopSourceContext = runloopSourceContext

}
</code></pre>
<p>自然当在二级线程中执行完<code>secondaryThreadRunLoopSource.addToCurrentRunLoop()</code>这句代码后，也会触发二级线程自定义事件源的<code>schedule</code>回调函数：</p>
<pre><code class="swift">func runloopSourceScheduleRoutine() -&gt; @convention(c) (UnsafeMutablePointer&lt;Void&gt;, CFRunLoop!, CFString!) -&gt; Void {

    return { (info, runloop, runloopMode) -&gt; Void in

        let secondaryThreadRunloopSource = unsafeBitCast(info, SecondaryThreadRunLoopSource.self)

        let secondaryThreadRunloopSourceContext = SecondaryThreadRunLoopSourceContext(runloop: runloop, runloopSource: secondaryThreadRunloopSource)

        let appDelegate = UIApplication.sharedApplication().delegate as! AppDelegate

        appDelegate.performSelectorOnMainThread(&quot;registerSecondaryThreadRunLoopSource:&quot;, withObject: secondaryThreadRunloopSourceContext, waitUntilDone: true)

    }

}
</code></pre>
<p>这里要注意的是，在该方法中同样是将二级线程事件源上下文对象传给了<code>AppDelegate</code>的对应方法，但是这里用了<code>performSelectorOnMainThread</code>方法，让其在主线程中执行，目的在于注册完上下文对象后就接着从主线程给二级线程发送事件消息了，其实我将这里作为了主线程触发二级线程执行任务的触发点：</p>
<pre><code class="swift">func registerSecondaryThreadRunLoopSource(runloopSourceContext: SecondaryThreadRunLoopSourceContext) {

    secondaryThreadRunloopSourceContext = runloopSourceContext

    sendCommandToSecondaryThread()

}

func sendCommandToSecondaryThread() {

    secondaryThreadRunloopSourceContext?.runloopSource?.commandBuffer?.append(mainThreadRunloopSourceContext!)

    secondaryThreadRunloopSourceContext?.runloopSource?.signalSourceAndWakeUpRunloop(secondaryThreadRunloopSourceContext!.runloop!)

}
</code></pre>
<p>从上述代码中可以看到在<code>sendCommandToSecondaryThread()</code>方法中，将主线程的事件源上下文放入了二级线程事件源的指令池中，这里我设计的是只要指令池中有内容就代表事件源需要执行后续任务了。然后执行了二级线程事件源的<code>signalSourceAndWakeUpRunloop()</code>方法，给其标记为待执行，并唤醒二级线程的Run Loop：</p>
<pre><code class="swift">func signalSourceAndWakeUpRunloop(runloop: CFRunLoopRef) {

    CFRunLoopSourceSignal(runloopSource)

    CFRunLoopWakeUp(runloop)

}
</code></pre>
<h4 id="u6267_u884C_u4E8B_u4EF6_u6E90_u7684perform_u56DE_u8C03_u51FD_u6570"><a href="#u6267_u884C_u4E8B_u4EF6_u6E90_u7684perform_u56DE_u8C03_u51FD_u6570" class="headerlink" title="执行事件源的perform回调函数"></a>执行事件源的perform回调函数</h4><p>当二级线程事件源被标记并且二级线程Run Loop被唤醒后，就会触发事件源的<code>perform</code>回调函数：</p>
<pre><code class="swift">func runloopSourcePerformRoutine() -&gt; @convention(c) (UnsafeMutablePointer&lt;Void&gt;) -&gt; Void {

    return { info -&gt; Void in

        let appDelegate = UIApplication.sharedApplication().delegate as! AppDelegate

        appDelegate.performSelector(&quot;performSecondaryThreadRunLoopSourceTask&quot;)

    }

}
</code></pre>
<p>二级线程事件源的<code>perform</code>回调函数会在当前线程，也就是二级线程中执行<code>AppDelegate</code>中的对应方法：</p>
<pre><code class="swift">func performSecondaryThreadRunLoopSourceTask() {

    if secondaryThreadRunloopSourceContext!.runloopSource!.commandBuffer!.count &gt; 0 {

        mainCollectionViewController!.generateRandomAlpha()

        let mainThreadRunloopSourceContext = secondaryThreadRunloopSourceContext!.runloopSource!.commandBuffer![0]

        secondaryThreadRunloopSourceContext!.runloopSource!.commandBuffer!.removeAll()

        mainThreadRunloopSourceContext.runloopSource?.commandBuffer?.append(secondaryThreadRunloopSourceContext!)

        mainThreadRunloopSourceContext.runloopSource?.signalSourceAndWakeUpRunloop(mainThreadRunloopSourceContext.runloop!)

    }

}
</code></pre>
<p>从上述代码中可以看到，先会判断二级线程事件源的指令池中有没有内容，如果有的话，那么执行计算<code>UICollectionViewCell</code>透明度的任务，然后从指令池中获取到主线程事件源上下文对象，将二级线程事件源上下文对象放入主线程事件源的指令池中，并将主线程事件源标记为待执行，然后唤醒主线程Run Loop。之后便会触发主线程事件源的<code>perform</code>回调函数：</p>
<pre><code class="swift">func runloopSourcePerformRoutine() -&gt; @convention(c) (UnsafeMutablePointer&lt;Void&gt;) -&gt; Void {

    return { info -&gt; Void in

        let appDelegate = UIApplication.sharedApplication().delegate as! AppDelegate

        appDelegate.performSelector(&quot;performMainThreadRunLoopSourceTask&quot;)

    }

}
</code></pre>
<pre><code class="swift">func performMainThreadRunLoopSourceTask() {

    if mainThreadRunloopSourceContext!.runloopSource!.commandBuffer!.count &gt; 0 {

        mainThreadRunloopSourceContext!.runloopSource!.commandBuffer!.removeAll()

        mainCollectionViewController!.collectionView.reloadData()

        let timer = NSTimer(timeInterval: 1, target: self, selector: &quot;sendCommandToSecondaryThread&quot;, userInfo: nil, repeats: false)

        NSRunLoop.mainRunLoop().addTimer(timer, forMode: NSDefaultRunLoopMode)

    }

}
</code></pre>
<p>在<code>performMainThreadRunLoopSourceTask()</code>方法中同样会先判断主线程事件源的指令池是否有内容，然后执行<code>MainCollectionViewController</code>中的刷新UI的方法，最后再次给二级线程发送事件消息，以此循环。大家可以去Github下载该示例的<a href="https://github.com/DevTalking/CustomRunloopInputSourceSample.git" target="_blank" rel="external">源码</a>，编译环境是Xcode7.2，然后可以自己试着在界面中添加一个<strong>Stop</strong>按钮，让事件源执行<code>cancel</code>回调函数。</p>
<p><a href="http://www.devtalking.com/donate.html"><br>    <img border="0" src="http://www.devtalking.com/donate.png"><br></a><br><a href="http://www.devtalking.com/gongzhonghao.html"><br>    <img border="0" src="http://www.devtalking.com/guanzhugongzhonghao.png"><br></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/56056" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="Thread" scheme="http://www.devtalking.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Threading Programming Guide 笔记（二）]]></title>
    <link href="http://www.devtalking.com//articles/read-threading-programming-guide-2/"/>
    <id>http://www.devtalking.com//articles/read-threading-programming-guide-2/</id>
    <published>2016-02-09T16:00:00.000Z</published>
    <updated>2016-02-15T12:43:58.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/55617" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文章中有对官方文档的翻译，也有自己的理解，官方文档中代码片段的示例在这篇文章中都进行了完整的重写，还有一些文档中没有的代码示例，并且都使用Swift完成，给大家一些Objc与Swift转换的参考。<br>官方文档地址：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></p>
</blockquote>
<h2 id="u7EBF_u7A0B_u5C5E_u6027_u914D_u7F6E"><a href="#u7EBF_u7A0B_u5C5E_u6027_u914D_u7F6E" class="headerlink" title="线程属性配置"></a>线程属性配置</h2><p>线程也是具有若干属性的，自然一些属性也是可配置的，在启动线程之前我们可以对其进行配置，比如线程占用的内存空间大小、线程持久层中的数据、设置线程类型、优先级等。</p>
<h3 id="u914D_u7F6E_u7EBF_u7A0B_u7684_u6808_u7A7A_u95F4_u5927_u5C0F"><a href="#u914D_u7F6E_u7EBF_u7A0B_u7684_u6808_u7A7A_u95F4_u5927_u5C0F" class="headerlink" title="配置线程的栈空间大小"></a>配置线程的栈空间大小</h3><p>在前文中提到过线程对内存空间的消耗，其中一部分就是线程栈，我们可以对线程栈的大小进行配置：</p>
<ul>
<li>Cocoa框架：在OS X v10.5之后的版本和iOS2.0之后的版本中，我们可以通过修改<code>NSThread</code>类的<code>stackSize</code>属性，改变二级线程的线程栈大小，不过这里要注意的是该属性的单位是字节，并且设置的大小必须得是4KB的倍数。</li>
<li>POSIX API：通过<code>pthread_attr_- setstacksize</code>函数给线程属性<code>pthread_attr_t</code>结构体设置线程栈大小，然后在使用<code>pthread_create</code>函数创建线程时将线程属性传入即可。</li>
</ul>
<blockquote>
<p>注意：在使用Cocoa框架的前提下修改线程栈时，不能使用<code>NSThread</code>的<code>detachNewThreadSelector: toTarget:withObject:</code>方法，因为上文中说过，该方法先创建线程，即刻便启动了线程，所以根本没有机会修改线程属性。</p>
</blockquote>
<h3 id="u914D_u7F6E_u7EBF_u7A0B_u5B58_u50A8_u5B57_u5178"><a href="#u914D_u7F6E_u7EBF_u7A0B_u5B58_u50A8_u5B57_u5178" class="headerlink" title="配置线程存储字典"></a>配置线程存储字典</h3><p>每一个线程，在整个生命周期里都会有一个字典，以<code>key-value</code>的形式存储着在线程执行过程中你希望保存下来的各种类型的数据，比如一个常驻线程的运行状态，线程可以在任何时候访问该字典里的数据。</p>
<p>在Cocoa框架中，可以通过<code>NSThread</code>类的<code>threadDictionary</code>属性，获取到<code>NSMutableDictionary</code>类型对象，然后自定义<code>key</code>值，存入任何里先储存的对象或数据。如果使用POSIX线程，可以使用<code>pthread_setspecific</code>和<code>pthread_getspecific</code>函数设置获取线程字典。</p>
<h3 id="u914D_u7F6E_u7EBF_u7A0B_u7C7B_u578B"><a href="#u914D_u7F6E_u7EBF_u7A0B_u7C7B_u578B" class="headerlink" title="配置线程类型"></a>配置线程类型</h3><p>在上文中提到过，线程有Joinable和Detached类型，大多数非底层的线程默认都是Detached类型的，相比Joinable类型的线程来说，Detached类型的线程不用与其他线程结合，并且在执行完任务后可自动被系统回收资源，而且主线程不会因此而阻塞，这着实要方便许多。</p>
<p>使用<code>NSThread</code>创建的线程默认都是Detached类型，而且似乎也不能将其设置为Joinable类型。而使用POSIX API创建的线程则默认为Joinable类型，而且这也是唯一创建Joinable类型线程的方式。通过POSIX API可以在创建线程前通过函数<code>pthread_attr_setdetachstate</code>更新线程属性，将其设置为不同的类型，如果线程已经创建，那么可以使用<code>pthread_detach</code>函数改变其类型。Joinable类型的线程还有一个特性，那就是在终止之前可以将数据传给与之相结合的线程，从而达到线程之间的交互。即将要终止的线程可以通过<code>pthread_exit</code>函数传递指针或者任务执行的结果，然后与之结合的线程可以通过<code>pthread_join</code>函数接受数据。</p>
<p>虽然通过POSIX API创建的线程使用和管理起来较为复杂和麻烦，但这也说明这种方式更为灵活，更能满足不同的使用场景和需求。比如当执行一些关键的任务，不能被打断的任务，像执行I/O操作之类。</p>
<h3 id="u8BBE_u7F6E_u7EBF_u7A0B_u4F18_u5148_u7EA7"><a href="#u8BBE_u7F6E_u7EBF_u7A0B_u4F18_u5148_u7EA7" class="headerlink" title="设置线程优先级"></a>设置线程优先级</h3><p>每一个新创建的二级线程都有它自己的默认优先级，内核会根据线程的各属性通过分配算法计算出线程的优先级。这里需要明确一个概念，高优先级的线程虽然会更早的运行，但这其中并没有执行时间效率的因素，也就是说高优先级的线程会更早的执行它的任务，但在执行任务的时间长短方面并没有特别之处。</p>
<p>不论是通过<code>NSThread</code>创建线程还是通过POSIX API创建线程，他们都提供了设置线程优先级的方法。我们可以通过<code>NSThread</code>的类方法<code>setThreadPriority:</code>设置优先级，因为线程的优先级由0.0～1.0表示，所以设置优先级时也一样。我们也可以通过<code>pthread_setschedparam</code>函数设置线程优先级。</p>
<blockquote>
<p>注意：设置线程的优先级时可以在线程运行时设置。</p>
</blockquote>
<p>虽然我们可以调节线程的优先级，但不到必要时还是不建议调节线程的优先级。因为一旦调高了某个线程的优先级，与低优先级线程的优先等级差距太大，就有可能导致低优先级线程永远得不到运行的机会，从而产生性能瓶颈。比如说有两个线程A和B，起初优先级相差无几，那么在执行任务的时候都会相继无序的运行，如果将线程A的优先级调高，并且当线程A不会因为执行的任务而阻塞时，线程B就可能一直不能运行，此时如果线程A中执行的任务需要与线程B中任务进行数据交互，而迟迟得不到线程B中的结果，此时线程A就会被阻塞，那么程序的性能自然就会产生瓶颈。</p>
<h2 id="u7EBF_u7A0B_u6267_u884C_u7684_u4EFB_u52A1"><a href="#u7EBF_u7A0B_u6267_u884C_u7684_u4EFB_u52A1" class="headerlink" title="线程执行的任务"></a>线程执行的任务</h2><p>在任何平台，线程存在的价值和意义都是一样的，那就是执行任务，不论是方法、函数或一段代码，除了依照语言语法正常编写外，还有一些额外需要大家注意的事项。</p>
<h3 id="Autorelease_Pool"><a href="#Autorelease_Pool" class="headerlink" title="Autorelease Pool"></a>Autorelease Pool</h3><p>在Xcode4.3之前，我们都处在手动管理引用计数的时代，代码里满是<code>retain</code>和<code>release</code>的方法，所以那个时候，被线程执行的任务中，为了能自动处理大量对象的<code>retain</code>和<code>release</code>操作，都会使用<code>NSAutoreleasePool</code>类创建自动释放池，它的作用是将线程中要执行的任务都放在自动释放池中，自动释放池会捕获所有任务中的对象，在任务结束或线程关闭之时自动释放这些对象：</p>
<pre><code class="objc">- (void)myThreadMainRoutine
{

    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; // 顶层自动释放池

    // 线程执行任务的逻辑代码

    [pool release];

}
</code></pre>
<p>到了自动引用计数（ARC）时代，就不能使用<code>NSAutoreleasePool</code>进行自动释放池管理了，而是新加了<code>@autoreleasepool</code>代码块语法来创建自动释放池：</p>
<pre><code class="objc">- (void)myThreadMainRoutine
{

    @autoreleasepool {

     // 线程执行任务的逻辑代码

    }

}
</code></pre>
<p>我们知道每个应用程序都是运行在一个主线程里的，而线程都至少得有一个自动释放池，所以说整个应用其实是跑在一个自动释放池中的。大家都知道C系语言中，程序的入口函数都是<code>main</code>函数，当我们创建一个Objective－C的iOS应用后，Xcode会在<strong>Supporting Files</strong>目录下自动为我们创建一个<code>main.m</code>文件：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-2.png" alt="LearnThread-2"></p>
<p>在<code>main.m</code>这个文件中就能证实上面说的那点：</p>
<pre><code class="objc">int main(int argc, char * argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
</code></pre>
<p>以上都是在Objective－C中，但在Swift中，就有点不一样了，<code>NSAutoreleasePool</code>和<code>@autoreleasepool</code>都不能用了，取而代之的是Swift提供的一个方法<code>func autoreleasepool(code: () -&gt; ())</code>，接收的参数为一个闭包，我们可以这样使用：</p>
<pre><code class="swift">func performInBackground() {

        autoreleasepool({

          // 线程执行任务的逻辑代码

          print(&quot;I am a event, perform in Background Thread.&quot;)  

        })

    }
</code></pre>
<p>根据尾随闭包的写法，还可以这样使用：</p>
<pre><code class="swift">func performInBackground() {

        autoreleasepool{

          // 线程执行任务的逻辑代码

          print(&quot;I am a event, perform in Background Thread.&quot;)

        }

    }
</code></pre>
<p>有些人可能会问在ARC的时代下为什么还要用自动释放池呢？比如在SDWebImage中就大量使用了<code>@autoreleasepool</code>代码块，其原因就是为了避免内存峰值，大家都知道在MRC时代，除了<code>retain</code>和<code>release</code>方法外，还有一个常用的方法是<code>autorelease</code>，用来延迟释放对象，它释放对象的时机是当前runloop结束时。到了ARC时代，虽然不用我们手动管理内存了，但其自动管理的本质与MRC时是一样的，只不过由编译器帮我们在合适的地方加上了这三个方法，所以说如果在一个线程执行的任务中大量产生需要<code>autorelease</code>的对象时，因为不能及时释放对象，所以就很有可能产生内存峰值。那么在这种任务中在特定的时候使用<code>@autorelease</code>代码块，帮助释放对象，就可以有效的防止内存峰值的发生。</p>
<h3 id="u8BBE_u7F6E_u5F02_u5E38_u5904_u7406"><a href="#u8BBE_u7F6E_u5F02_u5E38_u5904_u7406" class="headerlink" title="设置异常处理"></a>设置异常处理</h3><p>在线程执行任务的时候，难免会出现异常，如果不能及时捕获异常任由其抛出，就会导致整个应用程序退出。在Swift2.0中，Apple提供了新的<a href="http://www.devtalking.com/articles/what-is-new-in-swift/">异常控制处理机制</a>，让我们能像Java中一样形如流水的捕获处理异常。所以在线程执行的任务中，我们尽量使用异常处理机制，提高健壮性。</p>
<h3 id="u521B_u5EFARunloop"><a href="#u521B_u5EFARunloop" class="headerlink" title="创建Runloop"></a>创建Runloop</h3><p>大家知道，一个线程只能执行一个任务，当任务结束后也就意味着这个线程也要结束，频繁的创建线程也是挺消耗资源的一件事，于是就有了常驻线程，前文介绍线程相关概念时也提到过：</p>
<blockquote>
<p>简单的来说，RunLoop用于管理和监听异步添加到线程中的事件，当有事件输入时，系统唤醒线程并将事件分派给RunLoop，当没有需要处理的事件时，RunLoop会让线程进入休眠状态。这样就能让线程常驻在进程中，而不会过多的消耗系统资源，达到有事做事，没事睡觉的效果。</p>
</blockquote>
<p>如果想要线程不结束，那就要被执行的任务不结束，让被执行的任务不结束显然不靠谱，那么就需要一个机制，能占着线程。该机制就是事件循环机制（Eventloop），体现在代码中就是一个<code>do-while</code>循环，不断的接收事件消息、处理事件、等待新事件消息，除非接收到一个让其退出的事件消息，否则它将一直这么循环着，线程自然就不会结束。Runloop就是管理消息和事件，并提供Eventloop函数的对象，线程执行的任务其实就是在Runloop对象的Eventloop函数里运行。关于Runloop更详细的知识及配置<br>操作在后文中会有讲述。</p>
<h3 id="u7EC8_u6B62_u7EBF_u7A0B"><a href="#u7EC8_u6B62_u7EBF_u7A0B" class="headerlink" title="终止线程"></a>终止线程</h3><p>打个不恰当的比方，人终有一死，或正常生老病死，或非正常出事故意外而亡，前者尚合情合理后者悲痛欲绝。线程也一样，有正常终止结束，也有非正常的强制结束，不管是线程本身还是应用程序都希望线程能正常结束，因为正常结束也就意味着被执行的任务正常执行完成，从而让线程处理完后事随即结束，如果在任务执行途中强制终止线程，会导致线程没有机会处理后事，也就是正常释放资源对象等，这样会给应用程序带来例如内存溢出这类潜在的问题，所以强烈不推荐强制终止线程的做法。</p>
<p>如果确实有在任务执行途中终止线程的需求，那么可以使用Runloop，在任务执行过程中定期查看是否有收到终止任务的事件消息，这样一来可以在任务执行途中判断出终止任务的信号，然后进行终止任务的相关处理，比如保存数据等，二来可以让线程有充分的时间释放资源。</p>
<h2 id="Run_Loop"><a href="#Run_Loop" class="headerlink" title="Run Loop"></a>Run Loop</h2><p>Run Loops是线程中的基础结构，在上文中也提到过，Run Loops其实是一个事件循环机制，用来分配、分派线程接受到的事件任务，同时可以让线程成为一个常驻线程，即有任务时处理任务，没任务时休眠，且不消耗资源。在实际应用时，Run Loop的生命周期并不全是自动完成的，还是需要人工进行配置，不论是Cocoa框架还是Core Foundation框架都提供了Run Loop的相关对象对其进行配置和管理。</p>
<blockquote>
<p>注：Core Foundation框架是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能，比如线程和Run Loop、端口、Socket、时间日期等。</p>
</blockquote>
<p>在所有的线程中，不论是主线程还是二级线程，都不需要显示的创建Run Loop对象，这里的显示指的是通过任何<em>create</em>打头的方法创建Run Loop。对于主线程来说，当应用程序通过<code>UIApplicationMain</code>启动时，主线程中的Run Loop就已经创建并启动了，而且也配置好了。那么如果是二级线程，则需要我们手动先获取Run Loop，然后再手动进行配置并启动。下面的章节会向大家详细介绍Run Loop的知识。</p>
<blockquote>
<p>注：在二级线程中获取Run Loop有两种方式，通过<code>NSRunloop</code>的类方法<code>currentRunLoop</code>获取Run Loop对象（<code>NSRunLoop</code>），或者通过Core Foundation框架中的<code>CFRunLoopGetCurrent()</code>函数获取当前线程的Run Loop对象（<code>CFRunLoop</code>）。<code>NSRunLoop</code>是<code>CFRunLoop</code>的上层封装。</p>
</blockquote>
<pre><code class="swift">let nsrunloop = NSRunLoop.currentRunLoop()

let cfrunloop = CFRunLoopGetCurrent()
</code></pre>
<h3 id="Run_Loop_u7684_u4E8B_u4EF6_u6765_u6E90"><a href="#Run_Loop_u7684_u4E8B_u4EF6_u6765_u6E90" class="headerlink" title="Run Loop的事件来源"></a>Run Loop的事件来源</h3><p>Run Loop有两个事件来源，一个是<strong>Input source</strong>，接收来自其他线程或应用程序（进程）的异步事件消息，并将消息分派给对应的事件处理方法。另一个是<strong>Timer source</strong>，接收定期循环执行或定时执行的同步事件消息，同样会将消息分派给对应的事件处理方法。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-3.png" alt="LearnThread-3"></p>
<p>上图展示了Run Loop的两类事件来源，以及在Input source中的两种不同的子类型，它们分别对应着Run Loop中不同的处理器。当不同的事件源接收到消息后，通过<code>NSRunLoop</code>的<code>runUntilDate:</code>方法启动运行Run Loop，将事件消息分派给对应的处理器执行，一直到指定的时间时退出Run Loop。</p>
<h3 id="Run_Loop_u7684_u89C2_u5BDF_u8005"><a href="#Run_Loop_u7684_u89C2_u5BDF_u8005" class="headerlink" title="Run Loop的观察者"></a>Run Loop的观察者</h3><p>Run Loop的观察者可以理解为Run Loop自身运行状态的监听器，它可以监听Run Loop的下面这些运行状态：</p>
<ul>
<li>Run Loop准备开始运行时。</li>
<li>当Run Loop准备要执行一个Timer Source事件时。</li>
<li>当Run Loop准备要执行一个Input Source事件时。</li>
<li>当Run Loop准备休眠时。</li>
<li>当Run Loop被进入的事件消息唤醒并且还没有开始让处理器执行事件消息时。</li>
<li>退出Run Loop时。</li>
</ul>
<p>Run Loop的观察者在<code>NSRunloop</code>中没有提供相关接口，所以我们需要通过Core Foundation框架使用它，可以通过<code>CFRunLoopObserverCreate</code>方法创建Run Loop的观察者，类型为<code>CFRunLoopObserverRef</code>，它其实是<code>CFRunLoopObserver</code>的重定义名称。上述的那些可以被监听的运行状态被封装在了<code>CFRunLoopActivity</code>结构体中，对应关系如下：</p>
<ul>
<li><code>CFRunLoopActivity.Entry</code></li>
<li><code>CFRunLoopActivity.BeforeTimers</code></li>
<li><code>CFRunLoopActivity.BeforeSources</code></li>
<li><code>CFRunLoopActivity.BeforeWaiting</code></li>
<li><code>CFRunLoopActivity.AfterWaiting</code></li>
<li><code>CFRunLoopActivity.Exit</code></li>
</ul>
<p>Run Loop的观察者和Timer事件类似，可以只使用一次，也可以重复使用，在创建观察者时可以设置。如果只使用一次，那么当监听到对应的状态后会自行移除，如果是重复使用的，那么会留在Run Loop中多次监听Run Loop相同的运行状态。</p>
<h3 id="Run_Loop_Modes"><a href="#Run_Loop_Modes" class="headerlink" title="Run Loop Modes"></a>Run Loop Modes</h3><p>Run Loop Modes可以称之为Run Loop模式，这个模式可以理解为对Run Loop各种设置项的不同组合，举个例子，iPhone手机运行的iOS有很多系统设置项，假设白天我打开蜂窝数据，晚上我关闭蜂窝数据，而打开无线网络，到睡觉时我关闭蜂窝数据和无线网络，而打开飞行模式。假设在这三个时段中其他的所有设置项都相同，而只有这三个设置项不同，那么就可以说我的手机有三种不同的设置模式，对应着不同的时间段。那么Run Loop的设置项是什么呢？那自然就是前文中提到的不同的事件来源以及观察者了，比如说，Run Loop的模式A（Mode A），只包含接收Timer Source事件源的事件消息以及监听Run Loop运行时的观察者，而模式B（Mode B）只包含接收Input Source事件源的事件消息以及监听Run Loop准备休眠时和退出Run Loop时的观察者，如下图所示：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread%EF%BC%8D7.png" alt="LearnThread-4"></p>
<p>所以说，Run Loop的模式就是不同类型的数据源和不同观察者的集合，当Run Loop运行时要设置它的模式，也就是告知Run Loop只需要关心这个集合中的数据源类型和观察者，其他的一概不予理会。那么通过模式，就可以让Run Loop过滤掉它不关心的一些事件，以及避免被无关的观察者打扰。如果有不在当前模式中的数据源发来事件消息，那只能等Run Loop改为包含有该数据源类型的模式时，才能处理事件消息。</p>
<p>在Cocoa框架和Core Foundation框架中，已经为我们预定义了一些Run Loop模式：</p>
<ul>
<li>默认模式：在<code>NSRunloop</code>中的定义为<code>NSDefaultRunLoopMode</code>，在<code>CFRunloop</code>中的定义为<code>kCFRunLoopDefaultMode</code>。该模式包含的事件源囊括了除网络链接操作的大多数操作以及时间事件，用于当前Run Loop处于空闲状态等待事件时，以及Run Loop开始运行时。</li>
<li>NSConnectionReplyMode：该模式用于监听<code>NSConnection</code>相关对象的返回结果和状态，在系统内部使用，我们一般不会使用该模式。</li>
<li>NSModalPanelRunLoopMode：该模式用于过滤在模态面板中处理的事件（Mac App）。</li>
<li>NSEventTrackingRunLoopMode：该模式用于跟踪用户与界面交互的事件。</li>
<li>模式集合：或者叫模式组，顾名思义就是将多个模式组成一个组，然后将模式组认为是一个模式设置给Run Loop，在<code>NSRunloop</code>中的定义为<code>NSRunLoopCommonModes</code>，在<code>CFRunloop</code>中的定义为<code>kCFRunLoopCommonModes</code>。系统提供的模式组名为Common Modes，它默认包含NSDefaultRunLoopMode、NSModalPanelRunLoopMode、NSEventTrackingRunLoopMode这三个模式。</li>
</ul>
<p>以上五种系统预定的模式中，前四种属于只读模式，也就是我们无法修改它们包含的事件源类型和观察者类型。而模式组我们可以通过Core Foundation框架提供的<code>CFRunLoopAddCommonMode(_ rl: CFRunLoop!, _ mode: CFString!)</code>方法添加新的模式，甚至是我们自定义的模式。这里需要注意的是，既然在使用时，模式组是被当作一个模式使用的，那么自然可以给它设置不同类型的事件源或观察者，当给模式组设置事件源或观察者时，实际是给该模式组包含的所有模式设置。比如说给模式组设置了一个监听Run Loop准备休眠时的观察者，那么该模式组里的所有模式都会被设置该观察者。</p>
<h3 id="Input_Source"><a href="#Input_Source" class="headerlink" title="Input Source"></a>Input Source</h3><p>前文中说过，Input Sources接收到各种操作输入事件消息，然后异步的分派给对应事件处理方法。在Input Sources中又分两大类的事件源，一类是基于端口事件源（Port-based source），在<code>CFRunLoopSourceRef</code>的结构中为source1，主要通过监听应用程序的Mach端口接收事件消息并分派，该类型的事件源可以主动唤醒Run Loop。另一类是自定义事件源（Custom source），在<code>CFRunLoopSourceRef</code>的结构中为source0，一般是接收其他线程的事件消息并分派给当前线程的Run Loop，比如<code>performSwlwctor:onThread:...</code>系列方法，该类型的事件源无法自动唤醒Run Loop，而是需要手动将事件源设置为待执行的标记，然后再手动唤醒Run Loop。虽然这两种类型的事件源接收事件消息的方式不一样，但是当接收到消息后，对消息的分派机制是完全相同的。</p>
<h4 id="Port-Based_Source"><a href="#Port-Based_Source" class="headerlink" title="Port-Based Source"></a>Port-Based Source</h4><p>Cocoa框架和Core Foundation框架都提供了相关的对象和函数用于创建基于端口的事件源。在Cocoa框架中，实现基于端口的事件源主要是通过<code>NSPort</code>类实现的，它代表了交流通道，也就是说在不同的线程的Run Loop中都存在<code>NSPort</code>，那么它们之间就可以通过发送与接收消息（<code>NSPortMessage</code>）互相通信。所以我们只需要通过<code>NSPort</code>类的类方法<code>port</code>创建对象实例，然后通过<code>NSRunloop</code>的方法将其添加到Run Loop中，或者在创建二级线程时将创建好的<code>NSPort</code>对象传入即可，无需我们再做消息、消息上下文、事件源等其他配置，都由Run Loop自行配置好了。而在Core Foundation框架中就比较麻烦一些，大多数配置都需要我们手动配置，在后面会详细举例说明。</p>
<h4 id="Custom_Input_Source"><a href="#Custom_Input_Source" class="headerlink" title="Custom Input Source"></a>Custom Input Source</h4><p>Cocoa框架中没有提供创建自定义事件源的相关接口，我们只能通过Core Foundation框架中提供的对象和函数创建自定义事件源，手动配置事件源各个阶段要处理的逻辑，比如创建<code>CFRunLoopSourceRef</code>事件源对象，通过<code>CFRunLoopScheduleCallBack</code>回调函数配置事件源上下文并注册事件源，通过<code>CFRunLoopPerformCallBack</code>回调函数处理接收到事件消息后的逻辑，通过<code>CFRunLoopCancelCallBack</code>函数销毁事件源等等，在后文中会有详细举例说明。</p>
<p>虽然Cocoa框架没有提供创建自定义事件源的相关对象和接口，但是它为我们预定义好了一些事件源，能让我们在当前线程、其他二级线程、主线程中执行我们希望被执行的方法，让我们看看<code>NSObject</code>中的这些方法：</p>
<pre><code class="swift">func performSelectorOnMainThread(_ aSelector: Selector, withObject arg: AnyObject?, waitUntilDone wait: Bool)

func performSelectorOnMainThread(_ aSelector: Selector, withObject arg: AnyObject?, waitUntilDone wait: Bool, modes array: [String]?)
</code></pre>
<p>这两个方法允许我们将当前线程中对象的方法让主线程去执行，可以选择是否阻塞当前线程，以及希望被执行的方法作为事件消息被何种Run Loop模式监听。</p>
<blockquote>
<p>注：如果在主线程中使用该方法，当选择阻塞当前线程，那么发送的方法会立即被主线程执行，若选择不阻塞当前线程，那么被发送的方法将被排进主线程Run Loop的事件队列中，并等待执行。</p>
</blockquote>
<pre><code class="swift">func performSelector(_ aSelector: Selector, withObject anArgument: AnyObject?, afterDelay delay: NSTimeInterval)

func performSelector(_ aSelector: Selector, withObject anArgument: AnyObject?, afterDelay delay: NSTimeInterval, inModes modes: [String])
</code></pre>
<p>这两个方法允许我们给当前线程发送事件消息，当前线程接收到消息后会依次加入Run Loop的事件消息队列中，等待Run Loop迭代执行。该方法还可以指定消息延迟发送时间及消息希望被何种Run Loop模式监听。</p>
<blockquote>
<p>注：该方法中的延迟时间并不是延迟Run Loop执行事件消息的事件，而是延迟向当前线程发送事件消息的时间。另外，即便不设置延迟时间，那么发送的事件消息也不一定立即被执行，因为在Run Loop的事件消息队列中可以已有若干等待执行的消息。</p>
</blockquote>
<pre><code class="swift">func performSelector(_ aSelector: Selector, onThread thr: NSThread, withObject arg: AnyObject?, waitUntilDone wait: Bool)

func performSelector(_ aSelector: Selector, onThread thr: NSThread, withObject arg: AnyObject?, waitUntilDone wait: Bool, modes array: [String]?)
</code></pre>
<p>这两个方法允许我们给其他二级线程发送事件消息，前提是要取得目标二级线程的<code>NSThread</code>对象实例，该方法同样提供了是否阻塞当前线程的选项和设置Run Loop模式的选项。</p>
<blockquote>
<p>注：使用该方法给二级线程发送事件消息时要确保目标线程正在运行，换句话说就是目标线程要有启动着的Run Loop。并且保证目标线程执行的任务要在应用程序代理执行<code>applicationDidFinishLaunching:</code>方法前完成，否则主线程就结束了，目标线程自然也就结束了。</p>
</blockquote>
<pre><code class="swift">func performSelectorInBackground(_ aSelector: Selector, withObject arg: AnyObject?)
</code></pre>
<p>该方法允许我们在当前应用程序中创建一个二级线程，并将指定的事件消息发送给新创建的二级线程。</p>
<pre><code class="swift">class func cancelPreviousPerformRequestsWithTarget(_ aTarget: AnyObject)

class func cancelPreviousPerformRequestsWithTarget(_ aTarget: AnyObject, selector aSelector: Selector, object anArgument: AnyObject?)
</code></pre>
<p>这两个方法是<code>NSObject</code>的类方法，第一个方法作用是在当前线程中取消Run Lop中某对象通过<code>performSelector:withObject:afterDelay:</code>方法发送的所有事件消息执行请求。第二个方法多了两个过滤参数，那就是方法名称和参数，取消指定方法名和参数的事件消息执行请求。</p>
<h3 id="Timer_Source"><a href="#Timer_Source" class="headerlink" title="Timer Source"></a>Timer Source</h3><p>Timer Source顾名思义就是向Run Loop发送在将来某一时间执行或周期性重复执行的同步事件消息。当某线程不需要其他线程通知而需要自己通知自己执行任务时就可以用这种事件源。举个应用场景，在iOS应用中，我们经常会用到搜索功能，而且一些搜索框具有自动搜索的能力，也就是说不用我们点击搜索按钮，只需要输入完我想要搜索的内容就会自动搜索，大家想一想如果每输入一个字就开始立即搜索，不但没有意义，性能开销也大，用户体验自然也很糟糕，我们希望当输入完这句话，或至少输入一部分之后再开始搜索，所以我们就可以在开始输入内容时向执行搜索功能的线程发送定时搜索的事件消息，让其在若干时间后再执行搜索任务，这样就有缓冲时间输入搜索内容了。</p>
<p>这里需要注意的是Timer Source发送给Run Loop的周期性执行任务的重复时间是相对时间。比如说给Run Loop发送了一个每隔5秒执行一次的任务，每次执行任务的正常时间为2秒，执行5次后终止，假设该任务被立即执行，那么当该任务终止时应该历时30秒，但当第一次执行时出现了问题，导致任务执行了20秒，那么该任务只能再执行一次就终止了，执行的这一次其实就是第5次，也就是说不论任务的执行时间延迟与否，Run Loop都会按照初始的时间间隔执行任务，并非按Finish-To-Finish去算的，所以一旦中间任务有延时，那么就会丢失任务执行次数。关于Timer Source的使用，在后文中会有详细举例说明。</p>
<h3 id="Run_Loop_u5185_u90E8_u8FD0_u884C_u903B_u8F91"><a href="#Run_Loop_u5185_u90E8_u8FD0_u884C_u903B_u8F91" class="headerlink" title="Run Loop内部运行逻辑"></a>Run Loop内部运行逻辑</h3><p>在Run Loop的运行生命周期中，无时无刻都伴随着执行等待执行的各种任务以及在不同的运行状态时通知不同的观察者，下面我们看看Run Loop中的运行逻辑到底是怎样的：</p>
<ol>
<li>通知对应观察者Run Loop准备开始运行。</li>
<li>通知对应观察者准备执行定时任务。</li>
<li>通知对应观察者准备执行自定义事件源的任务。</li>
<li>开始执行自定义事件源任务。</li>
<li>如果有基于端口事件源的任务准备待执行，那么立即执行该任务。然后跳到步骤9继续运转。</li>
<li>通知对应观察者线程进入休眠。</li>
<li>如果有下面的事件发生，则唤醒线程：<ul>
<li>接收到基于端口事件源的任务。</li>
<li>定时任务到了该执行的时间点。</li>
<li>Run Loop的超时时间到期。</li>
<li>Run Loop被手动唤醒。</li>
</ul>
</li>
<li>通知对应观察者线程被唤醒。</li>
<li>执行等待执行的任务。<ul>
<li>如果有定时任务已启动，执行定时任务并重启Run Loop。然后跳到步骤2继续运转。</li>
<li>如果有非定时器事件源的任务待执行，那么分派执行该任务。</li>
<li>如果Run Loop被手动唤醒，重启Run Loop。然后跳转到步骤2继续运转。</li>
</ul>
</li>
<li>通知对应观察者已退出Run Loop。</li>
</ol>
<p>以上这些Run Loop中的步骤也不是每一步都会触发，举一个例子：<br>1.对应观察者接收到通知Run Loop准备开始运行 -&gt; 3.对应观察者接收到通知Run Loop准备执行自定义事件源任务 -&gt; 4.开始执行自定义事件源任务 -&gt; 任务执行完毕且没有其他任务待执行 -&gt; 6.线程进入休眠状态，并通知对应观察者 -&gt; 7.接收到定时任务并唤醒线程 -&gt; 8.通知对应观察者线程被唤醒 -&gt; 9.执行定时任务并重启Run Loop -&gt; 2.通知对应观察者准备执行定时任务 －&gt; Run Loop执行定时任务，并在等待下次执行任务的间隔中线程休眠 -&gt; 6.线程进入休眠状态，并通知对应观察者…</p>
<p>这里需要注意的一点是从上面的运行逻辑中可以看出，当观察者接收到执行任务的通知时，Run Loop并没有真正开始执行任务，所以观察者接收到通知的时间与Run Loop真正执行任务的时间有时间差，一般情况下这点时间差影响不大，但如果你需要通过观察者知道Run Loop执行任务的确切时间，并根据这个时间要进行后续操作的话，那么就需要通过结合多个观察者接收到的通知共同确定了。一般通过监听准备执行任务的观察者、监听线程进入休眠的观察者、监听线程被唤醒的观察者共同确定执行任务的确切时间。</p>
<p><a href="http://www.devtalking.com/donate.html"><br>    <img border="0" src="http://www.devtalking.com/donate.png"><br></a><br><a href="http://www.devtalking.com/gongzhonghao.html"><br>    <img border="0" src="http://www.devtalking.com/guanzhugongzhonghao.png"><br></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/55617" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="Thread" scheme="http://www.devtalking.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读 Threading Programming Guide 笔记（一）]]></title>
    <link href="http://www.devtalking.com//articles/read-threading-programming-guide-1/"/>
    <id>http://www.devtalking.com//articles/read-threading-programming-guide-1/</id>
    <published>2016-01-31T16:00:00.000Z</published>
    <updated>2016-02-03T10:13:13.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/54092" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文章中有对官方文档的翻译，也有自己的理解，官方文档中代码片段的示例在这篇文章中都进行了完整的重写，还有一些文档中没有的代码示例，并且都使用Swift完成，给大家一些Objc与Swift转换的参考。<br>官方文档地址：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></p>
</blockquote>
<h2 id="u4EC0_u4E48_u662F_u7EBF_u7A0B"><a href="#u4EC0_u4E48_u662F_u7EBF_u7A0B" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>我们设想在应用程序中，每行代码的执行都有一个执行路径并对应一个执行容器。线程，可以让应用程序中的代码通过多个执行路径执行，从而达到多个代码块同时在不同的执行路径下执行运算，即多任务同时执行。</p>
<p>在系统中，每个程序都是并行状态的，但是并不是一直持续着活跃状态，而是由系统根据程序的需要适时的分配执行时间和内存。在每个程序中，或许存在多个线程，执行着不同的任务，那么系统对程序执行的管理实际上就是对程序中线程的管理，比如适时的将某个线程安排到负载较小的内核中执行，或者阻止正在运行的优先级较低的线程，给优先级较高的线程让路等。所以说线程的运转需要内核级别和应用程序级别相互协调，即内核级别负责将事件分发给不同的线程，并将线程安排在合理的内核上执行以及管理线程的优先级，而应用程序级别是通过代码管理和操控线程的属性及状态。</p>
<h3 id="u4E3A_u4EC0_u4E48_u8981_u4F7F_u7528_u7EBF_u7A0B"><a href="#u4E3A_u4EC0_u4E48_u8981_u4F7F_u7528_u7EBF_u7A0B" class="headerlink" title="为什么要使用线程"></a>为什么要使用线程</h3><p>回到iOS，我们开发的App至少都有一个线程，称之为主线程，线程中执行方法或函数的原则是先进先出原则，一个接一个的执行。假设在我们的App中有从远程下载图片的功能，并且该功能放在主线程中执行，那么当下载一个1080p高清图片时，就会需要耗费较长的时间，如果主线程中下载功能后面还有其他待执行的方法，那么只能等待下载功能完成之后，才能继续执行。所以此时对于用户来说，得不到任何来自App的响应，那么很容易认为是你的App出问题了，如此糟糕的用户体验，足以让用户将你的App打入冷宫甚至删除。</p>
<p>如果我们使用另外一个线程专门处理下载功能，那么该线程和主线程同时执行，对于用户而言，此时可以由主线程对用户做出合适的响应，而下载在另一个线程中同时进行着。所以使用线程对提高程序的用户体验、性能无疑是最好的方法。</p>
<h3 id="u4F7F_u7528_u7EBF_u7A0B_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898"><a href="#u4F7F_u7528_u7EBF_u7A0B_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898" class="headerlink" title="使用线程会导致的问题"></a>使用线程会导致的问题</h3><p>俗话说天下没有免费的午餐，诚然多线程能提高程序的性能、用户体验，但是在光鲜的背后还是要承担一定风险的。使用多线程势必会增加开发人员写代码花费的时间，因为代码的复杂度变高了，开发人员斟酌的频率就会变高，线程与线程之间有交互，容错率就会降低，开发人员调试的时间就会变多。由于多线程依然共享内存，所以会发生两个线程同时对某个数据进行操作，这样很容易使程序的执行结果发生错误。总而言之，多线程好，但使用时要知其根本，做到佩弦自急。</p>
<h2 id="u5B9E_u73B0_u591A_u4EFB_u52A1_u5E76_u53D1_u6267_u884C_u4EFB_u52A1_u7684_u89E3_u51B3_u65B9_u6848"><a href="#u5B9E_u73B0_u591A_u4EFB_u52A1_u5E76_u53D1_u6267_u884C_u4EFB_u52A1_u7684_u89E3_u51B3_u65B9_u6848" class="headerlink" title="实现多任务并发执行任务的解决方案"></a>实现多任务并发执行任务的解决方案</h2><p>因为线程本身相对比较低层，它实现程序中并发执行任务功能的方式也较为复杂，所以我们如果想使用好线程，那么就必须要真正理解线程，要明白在我们的程序中使用线程之后会带来哪些潜在的风险，所谓知己知彼方能百战不殆。同时，我们也不能滥用线程，该用的时候用，不该用的时候就不要画蛇添足。毕竟，使用线程会增加内存的消耗以及CPU得运算时间，要避免物极必反。在真正理解线程之前，我们先看看在OS X和iOS中提供的不那么底层的实现多任务并发执行的解决方案：</p>
<ul>
<li><p>Operation object：该技术出现在OS X 10.5中，通过将要执行的任务封装成操作对象的方式实现任务在多线程中执行。任务可以理解为你要想执行的一段代码。在这个操作对象中不光包含要执行的任务，还包含线程管理的内容，使用时通常与操作队列对象联合使用，操作队列对象会管理操作对象如何使用线程，所以我们只需要关心要执行的任务本身即可。</p>
</li>
<li><p>GCD：该技术出现在OS X 10.6中，它与Operation Object的初衷类似，就是让开发者只关注要执行的任务本身，而不需要去关注线程的管理。你只需要创建好任务，然后将任务添加到一个工作队列里即可，该工作队列会根据当前CPU性能及内核的负载情况，将任务安排到合适的线程中去执行。</p>
</li>
<li><p>Idle-time notification：该技术主要用于处理优先级相对比较低、执行时间比较短的任务，让应用程序在空闲的时候执行这类任务。Cocoa框架提供<code>NSNotificationQueue</code>对象处理空闲时间通知，通过使用<code>NSPostWhenIdle</code>选项，向队列发送空闲时间通知的请求。</p>
</li>
<li><p>Asynchronous functions：系统中有一些支持异步的函数，可以自动让你的代码并行执行。这些异步函数可能通过应用程序的守护进程或者自定义的线程执行你的代码，与主进程或主线程分离，达到并行执行任务的功能。</p>
</li>
<li><p>Timers：我们也可以在应用程序主线程中使用定时器去执行一些比较轻量级的、有一定周期性的任务。</p>
</li>
<li><p>Separate processes：虽然通过另起一个进程比线程更加重量级，但是在某些情况下要比使用线程更好一些，比如你需要的执行的任务和你的应用程序在展现数据和使用方面没有什么关系，但是可以优化你的应用程序的运行环境，或者提高应用程序获取数据的效率等。</p>
</li>
</ul>
<h2 id="u521D_u8BC6_u7EBF_u7A0B_u6982_u5FF5"><a href="#u521D_u8BC6_u7EBF_u7A0B_u6982_u5FF5" class="headerlink" title="初识线程概念"></a>初识线程概念</h2><h3 id="u7EBF_u7A0B_u6280_u672F"><a href="#u7EBF_u7A0B_u6280_u672F" class="headerlink" title="线程技术"></a>线程技术</h3><p>说到OS X和iOS中的线程技术，就不得不说GNU Mach。Apple操作系统中的线程技术是基于Mach线程技术实现的，所以本身就带有线程基本的特性，比如PEM。Mach线程我们几乎不会用到，一般编程中我们可能会使用POSIX API创建线程。</p>
<blockquote>
<p>GNU Mach：GNU是一个类UNIX操作系统，它采用GNU Hurd作为操作系统内核，而GNU Mach是基于GNU Hurd内核技术的微内核。<br>POSIX：可移植操作系统接口（Portable Operating System Interface of UNIX），它定义了操作系统应该为应用程序提供的接口标准， 是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称。<br>PEM：Preemptive Execution Model，以任务的优先级决定立即执行还是延后执行，或者安排至不同的内核执行。</p>
</blockquote>
<p>我们来看看OS X和iOS中主要的两种线程技术：</p>
<ul>
<li>Cocoa Threads：Cocoa框架中提供了<code>NSThread</code>和<code>NSObject</code>类供我们进行线程相关的操作。</li>
<li>POSIX Threads：POSIX的线程API实际是基于C语言的线程接口，这些接口在使用线程和配置线程方面更加容易和灵活。</li>
</ul>
<p>在应用程序层面，不管是什么平台，线程的运行方式都是大体相同的，在线程的运行过程中一般都会经历三种状态，即运行中、准备运行、阻塞。如果某个线程在当前处于不活跃状态，也即是非运行中状态，那么它有可能是处于阻塞状态并在等待执行任务的输入。也有可能已经有任务输入，处于准备运行状态，只是在等待被分派。当我们终止线程后，它会永久性的被系统回收，因为毕竟线程会占用一定的系统内存和CPU运算时间，所以一般情况下，我们放入二级线程（非主线程）中的任务都是比较重要和有意义的任务。</p>
<h3 id="RunLoops"><a href="#RunLoops" class="headerlink" title="RunLoops"></a>RunLoops</h3><p>上一节提到当线程终止后就会永久被系统收回，如果你还有任务需要另起线程执行，就要重新创建线程以及配置，但这也不是必须的，我们可以让线程在空闲的时候休眠，当有任务需要执行时唤醒，就像主线程一样，此时就要用到RunLoop。</p>
<p>简单的来说，RunLoop用于管理和监听异步添加到线程中的事件，当有事件输入时，系统唤醒线程并将事件分派给RunLoop，当没有需要处理的事件时，RunLoop会让线程进入休眠状态。这样就能让线程常驻在进程中，而不会过多的消耗系统资源，达到有事做事，没事睡觉的效果。</p>
<p>主线程中的RunLoop系统已经自动帮我们配置好了，但是我们自己创建的线程，还需要对RunLoop配置一番才可以使用，在后面的章节中都会有详细介绍。</p>
<h3 id="u540C_u6B65_u7B56_u7565"><a href="#u540C_u6B65_u7B56_u7565" class="headerlink" title="同步策略"></a>同步策略</h3><p>诚然，使用线程好处多多，但是之前也提到过，使用线程也是会存在一定问题的，那就是资源竞争，当两个线程在同一时间操作同一个变量时，就会产生问题。一种解决方案是让不同的线程拥有各自独有的变量，虽然可以解决问题，但不是最优方案。较为优雅一些的方案则是使用线程中的同步策略来解决该问题。</p>
<p>常用的同步策略有线程锁、状态位、原子操作。线程锁较为简单粗暴，简单的说当一个线程在操作变量时会挂上一把互斥锁，如果另一个线程先要操作该变量，它就得获得这把锁，但是锁只有一个，必须等第一个线程释放互斥锁后，才可以被其他线程获取，所以这样就解决了资源竞争的问题。状态位策略是通过线程或任务的执行情况生成一个状态，这个状态即像门卫又像协管员，一是阻止线程进行，二是以合适的执行顺序安排协调各个任务。第三个策略则是原子操作，相对前两个策略要更轻量级一些，它能通过硬件指令保证变量在更新完成之后才能被其他线程访问。</p>
<h3 id="u7EBF_u7A0B_u4E4B_u95F4_u7684_u4EA4_u4E92"><a href="#u7EBF_u7A0B_u4E4B_u95F4_u7684_u4EA4_u4E92" class="headerlink" title="线程之间的交互"></a>线程之间的交互</h3><p>虽然我们尽量让每个线程完成独立的任务，但是有些时候我们需要将二级线程中任务的执行结果发送到主线程中进一步进行操作，那么线程之间的交互就不可避免的发生，幸运的是进程中的线程是共享进程空间的，所以实现线程之间的交互也不是那么困难，比如通过发送messages、全局变量、同步策略等都可以实现，在后面的章节中都会有详细介绍。</p>
<h2 id="u4F7F_u7528_u7EBF_u7A0B_u65F6_u9700_u8981_u6CE8_u610F_u7684_u4E8B_u9879"><a href="#u4F7F_u7528_u7EBF_u7A0B_u65F6_u9700_u8981_u6CE8_u610F_u7684_u4E8B_u9879" class="headerlink" title="使用线程时需要注意的事项"></a>使用线程时需要注意的事项</h2><p>无规矩不成方圆，做任何事如果乱来，那必定会出现各种问题。因为线程相对比较底层，所以当我们对线程理解的不是特别透彻时直接创建线程，并手动管理线程，势必会出现正确性和性能上的各种问题，所以就有了这节对使用线程的一些建议。</p>
<h3 id="u907F_u514D_u76F4_u63A5_u521B_u5EFA_u7EBF_u7A0B"><a href="#u907F_u514D_u76F4_u63A5_u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="避免直接创建线程"></a>避免直接创建线程</h3><p>创建并管理线程在代码层面相对比较复杂和繁琐，一个不留神就会产生一些潜在的问题。OS X和iOS都提供了较为上层的创建使用线程的API，就是前面提到一些多任务并发执行的解决方案，比如GCD、Operation objects。使用它们可以帮我们规避在管理线程和处理线程性能方面可能出现的问题，提高多线程操作时的性能和健壮性。</p>
<h3 id="u8BA9_u7EBF_u7A0B_u6267_u884C_u6709_u4EF7_u503C_u7684_u4EFB_u52A1"><a href="#u8BA9_u7EBF_u7A0B_u6267_u884C_u6709_u4EF7_u503C_u7684_u4EFB_u52A1" class="headerlink" title="让线程执行有价值的任务"></a>让线程执行有价值的任务</h3><p>前文中提到过，线程消耗的系统资源不容小视，所以当我们手动创建和管理线程时，尤其要注意这一点。要保证另起线程执行的任务是有意义的、重要的任务，而且该终止的线程要终止，不要让线程有任何空闲时间，以保证系统资源的最优利用。</p>
<h3 id="u907F_u514D_u8D44_u6E90_u7ADE_u4E89"><a href="#u907F_u514D_u8D44_u6E90_u7ADE_u4E89" class="headerlink" title="避免资源竞争"></a>避免资源竞争</h3><p>进程中的线程是共享该进程空间的，所以很容易出现多个线程对同一个变量进行操作从而导致程序执行结果错误的情况。如果为每个线程都提供一份变量的拷贝，的确是可以解决这个问题，但是在开发中这样会造成更大的弊端，所以前文中提到了一些同步策略，能帮助我们达到线程交互及解决资源竞争的目的。但是在理论上还是会有出错的可能，比如让线程在指定的顺序下对某个变量依次进行操作。所以在程序设计阶段应该尽量避免线程之间的资源竞争及减少线程之间的交互。</p>
<h3 id="u7528_u6237_u754C_u9762_u4E0E_u7EBF_u7A0B"><a href="#u7528_u6237_u754C_u9762_u4E0E_u7EBF_u7A0B" class="headerlink" title="用户界面与线程"></a>用户界面与线程</h3><p>用户界面的更新、对用户事件的响应都应该放在主线程中，避免线程不安全的情况，以及能方便的管理UI界面。目前Cocoa框架默认对UI的操作都要在主线程中完成，即使不强制要求，我们也应该这样做。但是有一些情况比较特殊，比如对图片的处理，因为处理图片的过程并不是显性的，所以处理的过程可以放在二级线程中，当处理完成后，再在主线程中显示结果。这样可以有效的提升应用的性能。</p>
<h3 id="u6E05_u695A_u5F53_u7EBF_u7A0B_u7ED3_u675F_u65F6_u5E94_u8BE5_u505A_u4EC0_u4E48"><a href="#u6E05_u695A_u5F53_u7EBF_u7A0B_u7ED3_u675F_u65F6_u5E94_u8BE5_u505A_u4EC0_u4E48" class="headerlink" title="清楚当线程结束时应该做什么"></a>清楚当线程结束时应该做什么</h3><p>当用户退出应用后，理论上该应用进程中的所有线程都会立即被结束。但是如果此时正好有一个二级线程在后台处理其他任务，比如说下载或者正在存储一些数据。那么此时就要判断正在处理的这些任务是否要保留，如果要丢弃，那么直接结束所有线程即可，但是如果要保留，那么就需要主线程等待正在处理任务的二级线程，从而延迟应用退出。</p>
<p>这里处理时有两种情况，如果自行创建的线程并手动管理，那么要使用POSIX API创建具有<strong>joinable</strong>特性的二级线程，使主线程与之相关联。如果是使用Cocoa框架，那么可以使用<code>applicationShouldTerminate:</code>代理方法延迟应用关闭，当二级线程处理完任务后回调<code>replyToApplicationShouldTerminate:</code>通知到主线程，然后关闭应用。</p>
<h3 id="u5F02_u5E38_u5904_u7406"><a href="#u5F02_u5E38_u5904_u7406" class="headerlink" title="异常处理"></a>异常处理</h3><p>每个线程都有捕获当前任务在执行时产生的异常的责任，不论是主线程还是二级线程。如果二级线程产生的异常需要交由主线程处理是也不能任由其抛出，而是先将其捕获，然后向主线程发送消息，告知主线程当前的情况。当消息发出后二级线程可根据需求选择继续处理其他的任务还是终止线程。</p>
<h3 id="u5C3D_u53EF_u80FD_u5C11_u7684_u4F7F_u7528_u5E38_u9A7B_u7EBF_u7A0B"><a href="#u5C3D_u53EF_u80FD_u5C11_u7684_u4F7F_u7528_u5E38_u9A7B_u7EBF_u7A0B" class="headerlink" title="尽可能少的使用常驻线程"></a>尽可能少的使用常驻线程</h3><p>前文中提到过，可以为一些经常需要执行的、具有周期性的、量级较小的任务创建常驻线程，以减少创建关闭线程的资源消耗，但是不能滥用常驻线程。理论上，一个线程执行完任务后就应该关闭，并且关闭线程的最佳时机是执行完任务的后一秒。目的是为了避免空闲线程占用过多的资源从而导致一些潜在的问题。</p>
<h3 id="u786E_u4FDD_u7C7B_u5E93_u7684_u7EBF_u7A0B_u5B89_u5168"><a href="#u786E_u4FDD_u7C7B_u5E93_u7684_u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="确保类库的线程安全"></a>确保类库的线程安全</h3><p>如果我们在开发应用的相关功能，我们完全可以控制这块功能是否需要多线程去完成，但是当我们在开发一个供别人使用的类库时，就没法灵活的控制了。所以只能假设使用我们的类库必定会在多线程的环境中使用，这样我们可以通过锁机制确保线程安全。但是如果我们的类库没有在多线程环境中使用呢？那就会白白浪费掉对锁进行操作的相关资源，只能说使用锁机制可以保证类库线程安全的万无一失，但性能方面会大打折扣。</p>
<p>另一种方式是让使用我们类库的应用要对类库进行明确地初始化，不管是主线程还是二级线程，换句话说也就是让每个线程都有一份我们类库的内容，这样也可以有效的保证类库线程安全。在Cocoa框架中，还有一种可选的方式，就是可以为<code>NSWillBecomeMultiThreadedNotification</code>注册一个观察者，目的是当应用变为多线程环境时可以通知到我们的类库，从而采取相关措施，但这种方式不保险，有可能当类库已经被多线程环境中的代码使用后才收到通知。总而言之，如果开发类库，那么务必要确保其线程安全。</p>
<h2 id="u7EBF_u7A0B_u7684_u8D44_u6E90_u6D88_u8017"><a href="#u7EBF_u7A0B_u7684_u8D44_u6E90_u6D88_u8017" class="headerlink" title="线程的资源消耗"></a>线程的资源消耗</h2><p>在OS X和iOS中，每个应用其实就是一个进程，一个进程中由一个或多个线程组成，每个线程代表了所属应用中代码的执行路径。通常情况下应用始于主线程中的主函数，当需要有其他功能在二级线程中与主线程并行执行时，便可以创建其他二级线程。</p>
<p>一旦二级线程被创建，那么它就是一个独立的实体，线程与线程之间是没有任何关联的，它们有各自的执行堆栈，由内核单独为每个线程分派运行时的执行任务。虽然每个线程是独立实体，但是它们之间是可以相互交互的，在实际的应用中，这类需求是很常见的，因为它们共享所属进程的内存空间，并且拥有相同的读写权，所以也很容易实现线程之间的交互。既然一个应用中可能会有多个线程协作完成功能，所以管理线程就是重中之重了，这一章节会从线程的资源消耗、创建、配置、使用、关闭这几个关键点梳理实际运用中的线程管理。</p>
<p>线程的资源消耗主要分为三类，一类是内存空间的消耗、一类是创建线程消耗的时间、另一类是对开发人员开发成本的消耗。</p>
<p>内存空间的消耗又分为两部分，一部分是内核内存空间，另一部分是应用程序使用的内存空间，每个线程在创建时就会申请这两部分的内存空间。申请内核内存空间是用来存储管理和协调线程的核心数据结构的，而申请应用程序的内存空间是用来存储线程栈和一些初始化数据的。对于用户级别的二级线程来说，对应用程序内存空间的消耗是可以配置的，比如线程栈的空间大小等。下面是两种内存空间通常的消耗情况：</p>
<ul>
<li>内核内存空间：主要存储线程的核心数据结构，每个线程大约会占用1KB的空间。</li>
<li>应用程序内存空间：主要存储线程栈和初始化数据，主线程在OS X中大约占8MB空间，在iOS中大约占1MB。二级线程在两种系统中通常占大约512KB，但是上面提到二级线程在这块是可以配置的，所以可配置的最小空间为16KB，而且配置的空间大小必须是4KB的倍数。</li>
</ul>
<blockquote>
<p>注意：二级线程在创建时只是申请了内存程序空间，但还并没有真正分配给二级线程，只有当二级线程执行代码需要空间时才会真正分配。</p>
</blockquote>
<p>线程的创建时间取决于机器硬件的性能，但通常大约在90毫秒，虽然在我们看来90毫秒很短，但当频繁的创建线程时就会影响到CPU处理其他任务的时间。所以现在往往都会使用线程池，避免频繁的创建全新的线程。</p>
<p>前文中提到过设计和开发多线程的应用较单线程要复杂的多，要注意的事项在上文中就提出了八条，针对每条注意事项，都要花费不少时间去设计代码和测试。所以总体来说如果涉及到多线程，务必会增加开发人员的开发测试时间，但是换来的是应用程序具有更好的健壮性和高性能，所谓慢工出细活。</p>
<h2 id="u521B_u5EFA_u7EBF_u7A0B"><a href="#u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="创建线程"></a>创建线程</h2><p>说到创建线程，就得说说线程的两种类型，<strong>Joinable</strong>和<strong>Detach</strong>。Joinable类型的线程可以被其他线程回收其资源和终止。举个例子，如果一个Joinable的线程与主线程结合，那么当主线程准备结束而该二级线程还没有结束的时候，主线程会被阻塞等待该二级线程，当二级线程结束后由主线程回收其占用资源并将其关闭。如果在主线程还没有结束时，该二级线程结束了，那么它不但不会关闭，而且资源也不会被系统收回，只是等待主线程处理。而Detach的线程则相反，会自行结束关闭线程并且有系统回收其资源。</p>
<p>在OS X和iOS系统中有多种创建线程的方法，不同方法创建出的线程可能会有不同的线程属性，但就线程本身来说并没有什么差异。下面来看看创建线程的不同方法。</p>
<h3 id="u4F7F_u7528NSThread_u521B_u5EFA_u7EBF_u7A0B"><a href="#u4F7F_u7528NSThread_u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="使用NSThread创建线程"></a>使用NSThread创建线程</h3><p>使用<code>NSThread</code>创建线程有两种方式：</p>
<ul>
<li><code>detachNewThreadSelector:toTarget:withObject:</code>：该方法是一个类方法，适用于OS X所有的版本和iOS2.0之后的版本。该方法其实完成了两个动作，先是创建线程，然后启动线程。通过方法名称就可以得知，该方法创建的线程为Detach类型的线程。</li>
<li>创建<code>NSThread</code>对象：这种方法适用于OS X 10.5之后的版本和iOS2.0之后的版本。该方法通过创建<code>NSThread</code>对象，使用它的<code>start()</code>方法启动线程，该方法的好处是可以在启动前通过<code>NSThread</code>对象的各个属性进行配置，待配置妥当后再调用<code>start()</code>方法启动线程。该方法创建的线程也是Detach类型的线程。</li>
</ul>
<h4 id="detachNewThreadSelector_3AtoTarget_3AwithObject_3A"><a href="#detachNewThreadSelector_3AtoTarget_3AwithObject_3A" class="headerlink" title="detachNewThreadSelector:toTarget:withObject:"></a>detachNewThreadSelector:toTarget:withObject:</h4><p>该方法有三个参数：</p>
<ul>
<li>selector：发送给线程的消息，或者说是让线程执行的任务。这里需要注意的是该任务最多只能有一个参数，并且不能有返回值。</li>
<li>target：在新的线程中接收消息的对象。</li>
<li>object：传给target对象的参数，也就是传入selector中的参数。</li>
</ul>
<p>下面来看一个简单示例：</p>
<pre><code class="swift">import Foundation

class TestThread {

    func launch() {

        print(&quot;First event in Main Thread.&quot;)

        NSThread.detachNewThreadSelector(&quot;methodInSecondaryThread:&quot;, toTarget: self, withObject: &quot;I am a argument&quot;)

        print(&quot;Second event in Main Thread.&quot;)

    }

    func methodInSecondaryThread(arg: String) {

        print(&quot;\(arg) of event in Secondary Thread.&quot;)

    }

}

let testThread = TestThread()
testThread.launch()
</code></pre>
<p>上述代码定义了一个类<code>TestThread</code>，包含两个方法<code>launch()</code>和<code>methodInSecondaryThread()</code>，<code>lanch()</code>方法中用<code>print()</code>函数模拟事件，在两个事件中创建一个二级线程，用于执行<code>methodInSecondaryThread()</code>方法，在该方法中执行其他事件。执行看看结果如何：</p>
<pre><code class="swift">Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;*** -[NSThread initWithTarget:selector:object:]: target does not implement selector (*** -[LearnThread.TestThread methodInSecondaryThread])&#39;
</code></pre>
<p>结果很不幸，报错了，原因很简单，因为我们的代码是Swift，而<code>NSThread</code>继承了<code>NSObject</code>是Objective-C世界的东西，所以需要对代码进行修改，有两种方法：</p>
<pre><code class="swift">// 1. 让NSTread继承NSObject
class TestThread: NSObject {

// 2. 在methodInSecondaryThread()方法前添加@objc
@objc func methodInSecondaryThread(arg: String) {
</code></pre>
<p>我习惯让类继承<code>NSObject</code>：</p>
<pre><code class="swift">import Foundation

class TestThread: NSObject {

    func launch() {

        print(&quot;First event in Main Thread.&quot;)

        NSThread.detachNewThreadSelector(&quot;methodInSecondaryThread:&quot;, toTarget: self, withObject: &quot;I am a argument&quot;)

        print(&quot;Second event in Main Thread.&quot;)

    }

    func methodInSecondaryThread(arg: String) {

        print(&quot;\(arg) of event in Secondary Thread.&quot;)

    }

}

let testThread = TestThread()
testThread.launch()
</code></pre>
<p>继续运行看看效果：</p>
<pre><code class="swift">First event in Main Thread.
Second event in Main Thread.
</code></pre>
<p>运行成功了，但似乎少点什么东西，<code>methodInSecondaryThread()</code>方法中的内容并没有打印出来，难道线程没有执行吗？我们通过Instruments可以看到，在运行过程中二级线程是创建过的：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-1.png" alt="LearnThread-1"></p>
<p>导致这个问题的原因和上文介绍的线程类型有关系。因为主线程运行很快，快到当主线程结束时我们创建的二级线程还没来得及执行<code>methodInSecondaryThread()</code>方法，而通过<code>detachNewThreadSelector:toTarget:withObject:</code>创建的二级线程是Detach类型的，没有与主线程结合，所以主线程也不会等待，当主线程结束，进程结束，二级线程自然也结束了。解决这个问题的办法就是让二级线程有执行任务的时间，所以我们可以让主线程停顿几秒，让二级线程完成它的任务：</p>
<pre><code class="swift">import Foundation

class TestThread: NSObject {

    func launch() {

        print(&quot;First event in Main Thread.&quot;)

        NSThread.detachNewThreadSelector(&quot;methodInSecondaryThread:&quot;, toTarget: self, withObject: &quot;I am a argument&quot;)

        sleep(3)

        print(&quot;Second event in Main Thread.&quot;)

    }

    func methodInSecondaryThread(arg: String) {

        print(&quot;\(arg) of event in Secondary Thread.&quot;)

    }

}

let testThread = TestThread()
testThread.launch()
</code></pre>
<p>再运行就可以看到正确地结果了：</p>
<pre><code class="swift">First event in Main Thread.
I am a argument of event in Secondary Thread.
Second event in Main Thread.
</code></pre>
<h4 id="u521B_u5EFANSThread_u5BF9_u8C61"><a href="#u521B_u5EFANSThread_u5BF9_u8C61" class="headerlink" title="创建NSThread对象"></a>创建NSThread对象</h4><p>我们可以通过<code>initWithTarget:selector:object:</code>方法实例化一个<code>NSThread</code>对象，该方法的三个参数其实与<code>detachNewThreadSelector:toTarget:withObject:</code>方法的参数一样，只是顺序不一样而已：</p>
<pre><code class="swift">import Foundation

class TestThread: NSObject {

    func launch() {

        print(&quot;First event in Main Thread.&quot;)

        let secondaryThread = NSThread(target: self, selector: &quot;methodInSecondaryThread:&quot;, object: &quot;I am a argument&quot;)

        secondaryThread.start()

        sleep(3)

        print(&quot;Second event in Main Thread.&quot;)

    }

    func methodInSecondaryThread(arg: String) {

        print(&quot;\(arg) of event in Secondary Thread.&quot;)

    }

}

let testThread = TestThread()
testThread.launch()
</code></pre>
<p>上述的代码的运行结果自然也是一样的：</p>
<pre><code class="swift">First event in Main Thread.
I am a argument of event in Secondary Thread.
Second event in Main Thread.
</code></pre>
<p>这种方法依然只能在二级线程中执行最多只有一个参数的函数或方法，如果想要执行多参数的任务，可以将参数放入集合中传递，当然被执行的任务得能正确接收到参数集合。或者可以通过另外一种方法，那就是通过创建继承<code>NSThread</code>的类，然后重写<code>main()</code>方法来实现：</p>
<pre><code class="swift">import Foundation

class CustomThread: NSThread {

    var arg1: String!
    var arg2: String!

    init(arg1: String, arg2: String) {

        self.arg1 = arg1
        self.arg2 = arg2

    }

    override func main() {

        print(&quot;\(self.arg1), \(self.arg2), we are the arguments in Secondary Thread.&quot;)

    }

}

class TestThread: NSObject {

    func launch() {

        print(&quot;First event in Main Thread.&quot;)

        let customThread = CustomThread(arg1: &quot;I am arg1&quot;, arg2: &quot;I am arg2&quot;)

        customThread.start()

        sleep(3)

        print(&quot;Second event in Main Thread.&quot;)

    }

    func methodInSecondaryThread(arg: String) {

        print(&quot;\(arg) of event in Secondary Thread.&quot;)

    }

}

let testThread = TestThread()
testThread.launch()
</code></pre>
<p>如上述代码所示，我们创建了<code>CustomThread</code>类，并继承了<code>NSThread</code>，然后通过初始化方法传参，再重写<code>main()</code>方法处理相关任务。执行结果如下：</p>
<pre><code class="swift">First event in Main Thread.
I am arg1, I am arg2, we are the arguments in Secondary Thread.
Second event in Main Thread.
</code></pre>
<h3 id="u4F7F_u7528NSObject_u521B_u5EFA_u7EBF_u7A0B"><a href="#u4F7F_u7528NSObject_u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="使用NSObject创建线程"></a>使用NSObject创建线程</h3><p>在OS X和iOS中，<code>NSObject</code>对象本身就具有创建线程的能力，所以只要是继承了<code>NSObject</code>的类自然也具备这个能力：</p>
<pre><code class="swift">import Foundation

class TestThread: NSObject {

    func launch() {

        print(&quot;First event in Main Thread.&quot;)

        performSelectorInBackground(&quot;performInBackground&quot;, withObject: nil)

        sleep(3)

        print(&quot;Second event in Main Thread.&quot;)

    }

    func performInBackground() {

        print(&quot;I am a event, perform in Background Thread.&quot;)

    }

}

let testThread = TestThread()
testThread.launch()
</code></pre>
<p>上述代码中的<code>TestThread</code>类继承了<code>NSObject</code>类，那么就可以通过<code>performSelectorInBackground:withObject:</code>方法创建二级线程，该方法只有两个参数：</p>
<ul>
<li>selector：发送给线程的消息，或者说是让线程执行的任务。这里需要注意的是该任务最多只能有一个参数，并且不能有返回值。</li>
<li>object：传给target对象的参数，也就是传入selector中的参数。</li>
</ul>
<p>该方法创建的线程也是Detach类型的。以上这几种方式都是基于Cocoa框架实现的，大家可以使用<code>NSThread</code>的类方法<code>isMultiThreaded</code>去检验，在合适的地方插入这行代码<code>print(NSThread.isMultiThreaded())</code>，看看程序的线程状态。</p>
<h3 id="u4F7F_u7528POSIX_API_u521B_u5EFA_u7EBF_u7A0B"><a href="#u4F7F_u7528POSIX_API_u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="使用POSIX API创建线程"></a>使用POSIX API创建线程</h3><p>在OS X和iOS中，可以通过POSIX API创建线程，上文中提到过，POSIX的线程API实际是基于C语言的线程接口，这些接口在使用线程和配置线程方面更加容易和灵活，移植性也比较强，但由于相对较为底层，如果不熟悉C语言，上手成本会比较高,<code>NSThread</code>就是基于POSIX线程API封装而成的。</p>
<p>POSIX API通过<code>int pthread_create(pthread_t *restrict thread, const pthread_attr_t *restrict attr, void *(*start_routine)(void *), void *restrict arg);</code>函数创建线程：</p>
<ul>
<li>thread：线程标识符。</li>
<li>attr：线程属性设置。</li>
<li>start_routine：线程函数的起始地址。</li>
<li>arg：传递给start_routine的参数。</li>
<li>返回值：成功返回0，出错返回-1。</li>
</ul>
<p>大体的参数其实和使用<code>NSThread</code>创建线程基本一致，不过需要注意的是通过<code>pthread_create()</code>创建的线程是Joinable类型的，如果要将新线程设置为Detach类型，需要在创建前使用<code>pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</code>函数设置其线程属性。</p>
<p>在Cocoa框架中，上文提到的那些同步机制，比如线程锁，当二级线程创建后才就会自动生成。如果在程序中使用POSIX API创建线程，那么Cocoa框架是无法得知当前程序已处于多线程状态的，所以就不会自动开启相关的同步机制，而当我们又没有通过POSIX API手动控制的话，就有可能导致应用程序崩溃的情况。另外要注意的一点是Cocoa框架中的线程锁是不能操作通过POSIX API创建的线程的，反之亦然。所以当Cocoa框架与POSIX API混用的时候，在同步机制方面一定要配套使用。</p>
<p><a href="http://www.devtalking.com/donate.html"><br>    <img border="0" src="http://www.devtalking.com/donate.png"><br></a><br><a href="http://www.devtalking.com/gongzhonghao.html"><br>    <img border="0" src="http://www.devtalking.com/guanzhugongzhonghao.png"><br></a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://geek.csdn.net/news/detail/54092" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="Thread" scheme="http://www.devtalking.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用TVML开发tvOS应用教程]]></title>
    <link href="http://www.devtalking.com//articles/develop-tvos-app-with-tvml/"/>
    <id>http://www.devtalking.com//articles/develop-tvos-app-with-tvml/</id>
    <published>2015-12-30T16:00:00.000Z</published>
    <updated>2016-01-02T11:31:51.000Z</updated>
    <content type="html"><![CDATA[<p>作者：<a href="http://www.raywenderlich.com/u/Kelvin%20Lau" target="_blank" rel="external">Kelvin Lau</a> 原文地址：<a href="http://www.raywenderlich.com/114886/beginning-tvos-development-with-tvml-tutorial" target="_blank" rel="external">Beginning tvOS Development with TVML Tutorial</a></p>
<p>在2015年9月9日的产品发布会中，Apple宣布了新一代的Apple TV以及tvOS，并且在tvOS中集成了App Store。这使得我们多年以来想在Apple TV上开发专属应用的梦想成真了。</p>
<p>我和其他教程团队的成员已经开始深入研究tvOS SDK，并且正在努力为你们准备一些有价值的tvOS教程。在你开这篇文章之前，Chris Wagner已经写了一篇关于tvOS初步印象的<a href="http://www.raywenderlich.com/114313/tvos-initial-impressions" target="_blank" rel="external">文章</a>，我也基于这篇文章，设计了第一个tvOS的教程。</p>
<blockquote>
<p>译者注：可参阅Chris Wagner文章的中译版<a href="http://www.devtalking.com/articles/tvOS-initial-impression/">一个iOS开发者对tvOS SDK的初探</a>。</p>
</blockquote>
<p>在这篇教程中，你将会使用TVML开发你的第一款tvOS应用。信不信由你，你将会使用JavaScript管理你应用的逻辑以及创建TVML模板来展现你应用的UI。</p>
<p>当教程结束后，你应该可以基本理解如果通过TVML和TVJS管理、控制tvOS应用。现在就我们开始吧。</p>
<blockquote>
<p>注意：该教程需要Xcode7.1或更高的版本，你们可以在这里<a href="https://developer.apple.com/xcode/download/" target="_blank" rel="external">下载</a>。虽然你们可以跟着该教程一步一步的进行操作，但我还是建议你们能储备一些基本的JavaScript知识。</p>
</blockquote>
<h2 id="u9009_u62E9_u5F00_u53D1_u65B9_u5F0F"><a href="#u9009_u62E9_u5F00_u53D1_u65B9_u5F0F" class="headerlink" title="选择开发方式"></a>选择开发方式</h2><p>Apple为开发tvOS应用提供了两种方式：</p>
<ol>
<li><strong>TVML Apps</strong>：这类应用是使用完整的新开发技术开发的，比如TVML、TVJS、TVMLKit。在稍后我会解释这些简称的含义以及如何使用它们。</li>
<li><strong>Custom Apps</strong>：这类应用是使用我们已经比较熟悉的开发技术进行开发的，比如大家熟知的一些iOS框架和特性，像Storyboard、UIKit、Auto Layout等。</li>
</ol>
<p>这两种方式没有孰优孰劣之分，都是Apple推荐的方法，只是按需所取，以及你更想尝试哪种方式。</p>
<p>在这篇教程中，你们的目标是开发以个能播放<a href="http://www.rwdevcon.com/" target="_blank" rel="external">RWDevCon</a>讨论视频的tvOS应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-1.gif" alt="tvOS-1"></p>
<p>虽然用上述两种方式都可以开发这个应用，但是使用TVML会更加容易一些。所以这就是你在这篇教程中要学和要做的东西。</p>
<h2 id="u4EC0_u4E48_u662FTVML_uFF1F"><a href="#u4EC0_u4E48_u662FTVML_uFF1F" class="headerlink" title="什么是TVML？"></a>什么是TVML？</h2><p>正如我刚才提到的，第一种开发tvOS应用的方式是通过TVML、TVJS和TVMLKit这些新的技术实现的。如果你们对这些简称比较陌生，不要惊慌，因为他们本就是新鲜玩意。这里我简单解释一下：</p>
<ul>
<li><strong>TVML</strong>是一种XML格式，基于“Television Markup Language”。</li>
<li><strong>TVJS</strong>是基于JavaScript APIs的脚本语言，它可以根据TVML中定义的内容展示应用。</li>
<li><strong>TVMLKit</strong>是连接TVML、TVJS和原生tvOS应用的工具包。</li>
</ul>
<p>如果你是一名经常使用原生API开发原生iOS应用的开发者，那么看到这些类似前端的技术可能会有点退缩。但希望你能保持一颗学习的心，学习了解这些新的强大的特性。</p>
<p>我在这列举一个非常典型的Apple TV的应用场景。大家可以想象一下：你们想把一些内容或信息展现给用户，这些内容和信息储存在你们的服务器上，并且这些内容的格式、查询方式都服务于iPhone或iPad中的应用，那么你肯定会希望你的tvOS中的应用也能方便的使用这些内容，并做到与iOS中应用有相似的展现、查询、导航方式。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-2.jpg" alt="tvOS-2"></p>
<p>上述的这个场景恰恰是我们这片教程中的场景。我们已经有<a href="http://www.rwdevcon.com/" target="_blank" rel="external">RWDevCon</a>网站，上面有许多技术讨论视频，所以运用TVML模板应该很容易实现。并且我们也没有很严格的用户界面的需求，所以我们可以简单方便的使用Apple提供的UI<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">模板</a>。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-3.jpg" alt="tvOS-3"></p>
<p>简而言之：</p>
<ul>
<li><strong>开发TVML App</strong>：如果你主要是通过tvOS应用展现一些内容，不论是音频、视频、文本、图片，并且你已经有服务器存储这些资源。那么使用TVML开发是不错的选择。</li>
<li><strong>开发Custom App</strong>：如果你希望用户不只是被动的通过你的tvOS应用观看或收听内容，而是希望用户与应用有更多的交互，给用户高质量的用户体验。那么你应该选择使用iOS的相关技术开发自定义的应用。</li>
</ul>
<p>现在你们已经大概了解了TVML是如何工作的，以及我们为什么要在这篇教程中使用TVML开发tvOS应用。想要更深入的了解，最好的办法就是由你们在实践中去学习、理解了。让我们开始动手吧！</p>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先你们要确保已经下载并安装了Xcode7.1或更高版本。</p>
<p>然后通过 <strong>File\New\Project</strong> 创建新工程，在侧边栏选择 <strong>tvOS\Application\Single View Application</strong> 模板，然后点击 <strong>Next</strong>：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-4.png" alt="tvOS-4"></p>
<p>项目名称输入 <strong>RWDevCon</strong> ,语言选择 <strong>Swift</strong> ，确保下面的两个复选框为未选中状态，也就是不使用Core Data和单元测试，然后点击 <strong>Next</strong>：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-5.png" alt="tvOS-5"></p>
<p>选择一个目录，点击 <strong>Save</strong> 保存你的项目。Xcode会为你创建一个带有Storyboard的空工程（如果你开发自定义UI的tvOS应用，那么你需要使用Storyboard）。</p>
<p>然而在该教程中你不需要使用Storybard，因为我们会使用TVML来展示应用的UI，而不是用Storybard去设计UI。所以将 <strong>Main.storyboard</strong> 和 <strong>ViewController.swift</strong> 删去，在提示框中选择 <strong>Move To Trash</strong> 彻底删除。</p>
<p>接着打开 <strong>Info.plist</strong> 文件，删掉<code>Main storybaord file base name</code>属性。最后添加新的属性<code>App Transport Security Settings</code>（区分大小写），以及它的子属性<code>Allow Arbitrary Loads</code>，并将其值设为<code>YES</code>。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-6.png" alt="tvOS-6"></p>
<blockquote>
<p>注意：在iOS9中，Apple不允许应用链接非HHTPS协议的服务，所以刚才的操作是很有必要的，因为在该教程中，你们将会以HTTP协议访问本地的服务器，所以你需要在Info.plist中添加上述属性以便允许应用通过HTTP协议访问服务器。</p>
</blockquote>
<h2 id="u52A0_u8F7D_u4F60_u7684TVML"><a href="#u52A0_u8F7D_u4F60_u7684TVML" class="headerlink" title="加载你的TVML"></a>加载你的TVML</h2><p>tvOS应用的生命周期开始于AppDelegate。在这里，你将创建<code>TVApplicationController</code>以及应用上下文，并将它们传给主要的JavaScript文件。</p>
<p>打开<strong>AppDelegate.swift</strong>并做下面这些事：</p>
<ul>
<li>删除所有的方法。</li>
<li>导入<code>TVMLKit</code>。</li>
<li>使AppDelegate遵循<code>TVApplicationControllerDelegate</code>协议。</li>
</ul>
<p>当完成这些事后，你的<strong>AppDelegate.swift</strong>看起来应该像这样：</p>
<pre><code class="swift">
import UIKit
import TVMLKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate, TVApplicationControllerDelegate {

  var window: UIWindow?

}
</code></pre>
<p>接着添加下面这些属性：</p>
<pre><code class="swift">
var appController: TVApplicationController?
static let TVBaseURL = &quot;http://localhost:9001/&quot;
static let TVBootURL = &quot;\(AppDelegate.TVBaseURL)js/application.js&quot;
</code></pre>
<p><code>TVApplicationController</code>是<code>TVMLKit</code>中的一个类，它负责与你的服务器的交互。<code>TVBaseURL</code>和<code>TVBootURL</code>包含了你的服务器的地址和JavaScript文件的地址，该JavaScript文件稍后会运行在你的服务器中。</p>
<p>接在在AppDelegate中添加如下方法：</p>
<pre><code class="swift">
func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
  window = UIWindow(frame: UIScreen.mainScreen().bounds)

  // 1
  let appControllerContext = TVApplicationControllerContext()

  // 2
  guard let javaScriptURL = NSURL(string: AppDelegate.TVBootURL) else {
    fatalError(&quot;unable to create NSURL&quot;)
  }
  appControllerContext.javaScriptApplicationURL = javaScriptURL
  appControllerContext.launchOptions[&quot;BASEURL&quot;] = AppDelegate.TVBaseURL

  // 3
  appController = TVApplicationController(context: appControllerContext, window: window, delegate: self)
  return true
}
</code></pre>
<p>这些代码相对还是比较容易理解的：</p>
<ol>
<li>这里你首先创建了一个应用上下文<code>TVApplicationControllerContext</code>的实例，用于稍后初始化你的<code>TVApplicationController</code>。你可以理解为给一个简单的对象设置了一些属性，比如服务器的URL，然后该对象又作为属性设置给了另一个对象。</li>
<li>给应用上下文这个对象实例设置了两个简单的属性：主JavaScript文件的路径和服务器的地址。</li>
<li>通过你刚才设置好的应用上下文初始化<code>TVApplicationController</code>。此时就完全由Apple代码来接管了，他会加载到你的主JavaScript文件，并开始执行其内容。</li>
</ol>
<p>所以到目前为止，是时候让Xcode休息一会了，因为接下来你们将要编写JavaScript了。</p>
<h2 id="The_JavaScript"><a href="#The_JavaScript" class="headerlink" title="The JavaScript"></a>The JavaScript</h2><p>在客户端-服务端这类的tvOS应用中，你的JavaScript文件通常在应用连接的服务器中。在该教程中，你们将会在Mac上搭建一个简单的服务器。</p>
<h3 id="u5BA2_u6237_u7AEF_u4EE3_u7801"><a href="#u5BA2_u6237_u7AEF_u4EE3_u7801" class="headerlink" title="客户端代码"></a>客户端代码</h3><p>为了方便起见，我们把JavaScript文件放在桌面，在你们的 <strong>桌面</strong> 文件夹中新建一个文件夹名为 <strong>client</strong> 。在client文件夹中再新建一个文件夹名为 <strong>js</strong> 。该文件夹将作为你的JavaScript文件的容器。</p>
<p>通过你使用的编辑JavaScript的IDE，新建一个JavaScript文件，名为 <strong>application.js</strong> ，将它保存在你刚才新建的 <strong>js</strong> 文件夹中。然后在 <strong>application.js</strong> 中添加如下代码：</p>
<pre><code class="swift">
App.onLaunch = function(options) {
  // 1
  var alert = createAlert(&quot;Hello World&quot;, &quot;&quot;); //第二个参数传入空字符串
  navigationDocument.presentModal(alert);
}

// 2
var createAlert = function(title, description) {
  var alertString = `&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
    &lt;document&gt;
      &lt;alertTemplate&gt;
        &lt;title&gt;${title}&lt;/title&gt;
        &lt;description&gt;${description}&lt;/description&gt;
      &lt;/alertTemplate&gt;
    &lt;/document&gt;`
    var parser = new DOMParser();
    var alertDoc = parser.parseFromString(alertString, &quot;application/xml&quot;);
    return alertDoc
}
</code></pre>
<p><code>App.onLaunch</code>是处理JavaScript文件的入口方法。之前在 <strong>AppDelegate.swift</strong> 中已经初始化好的<code>TVApplicationController</code>会将<code>TVApplicationControllerContext</code>传到这。之后你会使用到上下文中的内容，但是现在，我们只创建一个简单的提示界面并显示在屏幕上。</p>
<ol>
<li>通过下面定义的<code>createAlert</code>函数，我们获得到了为我们展现界面的TVML文件。<code>navigationDocument</code>类似于iOS中的<code>UINavigationController</code>，它提供像栈一样的方式，可以推出或压进展现界面的TVML文件。</li>
<li><code>createAlert</code>是一个返回TVML文件的函数，你可以将它看作类似iOS中的<code>UIAlertController</code>。</li>
</ol>
<p>写到这顺便提一下，Apple已经提供了18种TVML模板供我们使用，你们可以在该<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">Apple TV Markup Language Reference</a>中查阅完成的模板列表。</p>
<p>上述代码中的 <strong>alertTemplate</strong> 就是这18个模板中的其中一个，它的主要用于展示重要信息，比如通过一段消息提示用户在继续操作之前需要执行其他的操作等。此时，距离你们编译运行你们的第一个tvOS应用已为时不远了。</p>
<h3 id="u914D_u7F6E_u670D_u52A1_u5668"><a href="#u914D_u7F6E_u670D_u52A1_u5668" class="headerlink" title="配置服务器"></a>配置服务器</h3><p>打开 <strong>Terminal</strong> 输入如下命令：</p>
<pre><code class="swift">
cd ~/Desktop/client
python -m SimpleHTTPServer 9001
</code></pre>
<p>这两行命令的作用是在先前创建的client目录中开启一个基于Python的web服务器。现在，你们可以准备起飞了！</p>
<p>回到你的Xcode项目中编译运行程序。你应该可以看到你的第一个tvOS TVML应用了！</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-7.png" alt="tvOS-7"></p>
<p>我不知道你们的感觉如何，但是当我第一次运行成功后，我的感受就像下面这个家伙一样：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-8.png" alt="tvOS-8"></p>
<p>在继续进行教程之前，我想花点时间对你们目前已经完成的工作作以总结：</p>
<ol>
<li>你们创建了<code>TVApplicationController</code>实例。它用于管理JavaScript代码。</li>
<li>你们创建了<code>TVApplicationControllerContext</code>实例，并在创建<code>TVApplicationController</code>时将其与之关联。应用上下文有一个<code>launchOption</code>属性，用来构建我们的<code>BASEURL</code>，也就是服务器的地址。该应用上下文也用于配置tvOS应用与哪个服务器连接。</li>
<li>控制器被传到了JavaScript代码中。<code>App.onLaunch</code>作为整个JavaScript文件的入口方法，你们定义了<code>createAlert</code>函数，返回TVML提示信息模板文件，并由<code>navigationDocument</code>管理并展现界面。最后将“Hello World”显示在屏幕上。</li>
</ol>
<p>即使现在你们使用的服务器是运行在本机的，但是你们仍然可以连接一个真实的远程的服务器，可能是一个连着数据库的服务器。你们感受并想象一下应用场景，应该会很酷，对吧？</p>
<h2 id="u5B8C_u5584TVML_u6A21_u677F"><a href="#u5B8C_u5584TVML_u6A21_u677F" class="headerlink" title="完善TVML模板"></a>完善TVML模板</h2><p>我之前提到过，<code>createAlert</code>是一个返回TVML模板文件的函数。有很多属性可由我们在TVML文件中编辑修改，作为一个实验性质的小例子，你们将会在当前的 <strong>alertTemplate</strong> 中添加一个按钮。回到你们的JavaScript代码中，将目光聚焦在<code>createAlert</code>函数上，在模板中添加一个按钮：</p>
<pre><code class="swift">
var alertString = `&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
  &lt;document&gt;
    &lt;alertTemplate&gt;
      &lt;title&gt;${title}&lt;/title&gt;
      &lt;description&gt;${description}&lt;/description&gt;
      &lt;button&gt;
        &lt;text&gt;OK&lt;/text&gt;
      &lt;/button&gt;
    &lt;/alertTemplate&gt;
  &lt;/document&gt;`
</code></pre>
<p>这里解释一下上述代码：</p>
<ol>
<li>一个TVML文件的第一级标签是<code>&lt;document&gt;</code>，也就是整个模板内容是由<code>&lt;document&gt;</code>和<code>&lt;/document&gt;</code>包起来的。</li>
<li>接着你们开始定义模板。使用Apple提供的 <strong>alertTemplate</strong> 模板，通过<code>createAlert</code>函数将其返回。</li>
<li>在该模板里，根据Apple的<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">Apple TV Markup Language Reference</a>文档规范，添加了按钮、标题、描述三个标签。</li>
</ol>
<p>保存你们刚才编辑的JavaScript文件，再次编译运行。你们看到在提示信息下面出现了一个按钮。瞧，TVML是不是将构建tvOS UI变得很简单！</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-9.png" alt="tvOS-9"></p>
<blockquote>
<p>注意：在一个模板中，你能添加的元素数量和类型基于这个的模板的类型。比如，一个 <strong>loading Template</strong> 就不允许有任何按钮出现。此外，你可以自定义字体、颜色和其他一些属性。但是这些知识已经超越了该教程的范畴。你们可以查阅<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/index.html#//apple_ref/doc/uid/TP40015064-CH41-SW1" target="_blank" rel="external">Apple TV Markup Language Reference</a>文档去了解更多TVML模板的信息。</p>
</blockquote>
<h2 id="u4E30_u5BCCJavaScript_u5BA2_u6237_u7AEF"><a href="#u4E30_u5BCCJavaScript_u5BA2_u6237_u7AEF" class="headerlink" title="丰富JavaScript客户端"></a>丰富JavaScript客户端</h2><p>到目前为止，你们已经完成了一些工作，并且正按照我们的指引一步一步达成目标。在这一节中，你们将要花一点时间在不同的JavaScript文件中将一些逻辑抽象出来，便于能更好的重用。</p>
<p>在 <strong>client/js</strong> 文件夹中新建一个JavaScript文件，名为 <strong>Presenter.js</strong> 。在该文件中，你们将定义<code>Presenter</code>类用于处理导航各个界面，或者说各个TVML模板文件，并且处理事件响应。在 <strong>Presenter.js</strong> 中添加如下代码：</p>
<pre><code class="swift">
var Presenter = {
  // 1
  makeDocument: function(resource) {
    if (!Presenter.parser) {
      Presenter.parser = new DOMParser();
    }
    var doc = Presenter.parser.parseFromString(resource, &quot;application/xml&quot;);
    return doc;
  },
  // 2
  modalDialogPresenter: function(xml) {
    navigationDocument.presentModal(xml);
  },

  // 3
  pushDocument: function(xml) {
    navigationDocument.pushDocument(xml);
  },
}
</code></pre>
<p>让我们解释一下上述代码：</p>
<ol>
<li>还记得你们在之前<code>createAlert</code>函数中用过的<code>DOMParser</code>类么，它可以将TVML字符串转换为可用于展示的TVML模板对象。因为该类不需要多次创建实例，所以采用单例模式创建它。然后通过<code>DOMParser</code>的<code>parseFormString()</code>方法将TVML字符串转为模板对象。</li>
<li><code>modalDialogPresenter</code>方法通过传入的TVML模板文件，将其模态的展现在屏幕上。</li>
<li><code>pushDocument</code>方法是在导航栈中推送一个TVML模板文件，相当于在iOS中push出一个界面。</li>
</ol>
<p>在之后，你们还会用到<code>Presenter</code>类管理选中处理操作。现在，让我们使用<code>Presenter</code>类对之前的JavaScript代码进行重构。将<code>App.onLaunch</code>中的代码替换为如下代码：</p>
<pre><code class="swift">
App.onLaunch = function(options) {
  // 1
  var javascriptFiles = [
    `${options.BASEURL}js/Presenter.js`
  ];
  // 2
  evaluateScripts(javascriptFiles, function(success) {
    if(success) {
      var alert = createAlert(&quot;Hello World!&quot;, &quot;&quot;);
      Presenter.modalDialogPresenter(alert);
    } else {
      // 3 Handle the error CHALLENGE!//inside else statement of evaluateScripts. 
    }
  });
}
</code></pre>
<p>这些代码相对还是比较容易理解的，我们来看一下：</p>
<ol>
<li>首先创建一个新的JavaScript文件的数组。然后通过<code>options</code>参数获取到<code>BASEURL</code>属性，并组装<code>Presenter.js</code>的路径。这里的<code>options</code>就是之前我们在<code>AppDelegate</code>类中创建的<code>TVApplicationControllerContext</code>，<code>BASEURL</code>自然也是那时我们设置的。</li>
<li><code>evaluateScripts</code>将加载JavaScript文件。</li>
<li>这里，你应该处理异常信息，稍后我们完善这里。</li>
</ol>
<p>在继续进行之前，编译运行程序，确保JavaScript文件修改过之后程序仍能正常运行。此时，我们通过<code>Presenter</code>类对JavaScript代码的重构有了一个良好的开端：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-10.png" alt="tvOS-10"></p>
<p>现在，看看上面代码中被注释的那行，你们能否自行完成对异常处理的挑战呢。如果<code>evaluateScripts</code>处理失败，可能是因为JavaScript文件的路径写错了，那么你可能会希望在此时显示一个提示消息给用户。<strong>提示：</strong> 之所以在这里出现了异常，是因为<code>Presenter</code>类加载失败导致，所以在这里你不能使用<code>Presenter</code>类显示提示信息的界面。</p>
<p>你应该通过之前所学到的知识来解决该问题。如果你们觉得有困难，那么可以参照下面的代码：</p>
<pre><code class="swift">
//将这两行代码插入evaluateScripts的else代码块中. 
var errorDoc = createAlert(&quot;Evaluate Scripts Error&quot;, &quot;Error attempting to evaluate external JavaScript files.&quot;);
navigationDocument.presentModal(errorDoc);
</code></pre>
<p>想要测试错误信息，你们可以修改一下JavaScript文件的路径，比如把<code>Presenter.js</code>改为<code>Presentr.js</code>：</p>
<pre><code class="swift">
${options.BASEURL}js/Presentr.js
</code></pre>
<h2 id="u4F7F_u7528CatalogTemplate"><a href="#u4F7F_u7528CatalogTemplate" class="headerlink" title="使用CatalogTemplate"></a>使用CatalogTemplate</h2><p><strong>catalogTemplate</strong>模板同样也是Apple提供的18个模板中的一个。它的作用是以分组的形式展现内容，用它来展示你们最喜欢的RWDevCon视频最好不过了！ <strong>catalogTemplate</strong>有许多有意思的元素：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-11.jpg" alt="tvOS-11"></p>
<h3 id="u590D_u5408_u5143_u7D20_u548C_u7B80_u5355_u5143_u7D20"><a href="#u590D_u5408_u5143_u7D20_u548C_u7B80_u5355_u5143_u7D20" class="headerlink" title="复合元素和简单元素"></a>复合元素和简单元素</h3><p>该模板中的<code>banner</code>元素在应用顶部，用于展示应用基本信息，比如名称、标题等。它本身是一个 <strong>复合元素</strong> ，也就是说它是由多个 <strong>简单元素</strong> 组合而成。比如，在<code>banner</code>中很显然有标题，那么该标题就是一个简单的<code>title</code>元素，并且在<code>title</code>背后还有背景图片，这又是另外一个简单元素<code>background</code>。所以<code>banner</code>是由两个简单元素组合而成。</p>
<p>让我们来试试这个模板吧。打开 <strong>client</strong> 文件夹，在 <strong>js</strong> 文件夹的同级目录新建两个文件夹，分别命名为 <strong>images</strong> 和 <strong>templates</strong> 。此时你的 <strong>client</strong> 文件夹里的内容应该是这样的：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-12.png" alt="tvOS-12"></p>
<p>你们会需要图片构建模板中的Cells，在我们这个场景中就是一个一个的视频，图片自然就是视频的封面了。我已经为你们准备好了封面图片，你们可以从<a href="/cdn3.raywenderlich.com/wp-content/uploads/2015/09/images.zip">这里下载</a>。下载成功后，将他们解压放在刚才你们创建的 <strong>images</strong> 文件夹中。</p>
<p>现在，你们即将要做的工作是在屏幕中显示图片!新建一个JavaScript文件，命名为 <strong>RWDevConTemplate.xml.js</strong> ，将其存在 <strong>templates</strong> 文件夹中。</p>
<p>打开 <strong>RWDevConTemplate.xml.js</strong> ，添加如下代码：</p>
<pre><code class="swift">
var Template = function() { return `&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
  &lt;document&gt;
    &lt;catalogTemplate&gt;
      &lt;banner&gt;
        &lt;title&gt;RWDevConHighlights&lt;/title&gt;
      &lt;/banner&gt;
    &lt;/catalogTemplate&gt;
  &lt;/document&gt;`
}
</code></pre>
<p>现在，我们试图通过<code>catalogTemplate</code>模板显示一个Banner条。但在使用只包含模板信息的JavaScript文件之前，我们需要通过某种方法让其他的JavaScript文件知道该文件的存在并能加载其模板信息，因为当前它没有通过任何方式向其他JavaScript文件暴露过。所以我们要创建的最后一个JavaScript文件： <strong>ResourceLoader.js</strong> 就是用来解决该问题的！</p>
<h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>新建一个JavaScript文件，命名为 <strong>ResourceLoader.js</strong> ，保存在 <strong>js</strong> 文件夹中，和 <strong>application.js</strong> 、 <strong>Presenter.js</strong> 一起。打开 <strong>ResourceLoader.js</strong> 添加如下代码：</p>
<pre><code class="swift">
function ResourceLoader(baseurl) {
  this.BASEURL = baseurl;
}

ResourceLoader.prototype.loadResource = function(resource, callback) {
  var self = this;
  evaluateScripts([resource], function(success) {
    if(success) {
      var resource = Template.call(self);
      callback.call(self, resource);
    } else {
      var title = &quot;Resource Loader Error&quot;,
          description = `Error loading resource &#39;${resource}&#39;. \n\n Try again later.`,
          alert = createAlert(title, description);
      navigationDocument.presentModal(alert);
    }
  }); 
}
</code></pre>
<p>不用过于担心看不懂这些代码逐行的含义，你们只要清楚这些代码的作用是加载其他模板文件就可以了。</p>
<p>之前我们的主屏显示的是“Hello World”的提示信息模板，现在试着将它换成我们创建的<code>RWDevConTemplate</code>。打开 <strong>application.js</strong> 文件，根据如下代码修改之前的代码：</p>
<pre><code class="swift">
// 1
var resourceLoader;

App.onLaunch = function(options) {
  // 2
  var javascriptFiles = [
    `${options.BASEURL}js/ResourceLoader.js`, 
    `${options.BASEURL}js/Presenter.js`
  ];

  evaluateScripts(javascriptFiles, function(success) {
    if(success) {
      // 3
      resourceLoader = new ResourceLoader(options.BASEURL);
      resourceLoader.loadResource(`${options.BASEURL}templates/RWDevConTemplate.xml.js`, function(resource) {
        var doc = Presenter.makeDocument(resource);
        Presenter.pushDocument(doc);
      });
    } else {
      var errorDoc = createAlert(&quot;Evaluate Scripts Error&quot;, &quot;Error attempting to evaluate external JavaScript files.&quot;);
      navigationDocument.presentModal(errorDoc);
    }
  });
}

// 先不管createAlert函数
</code></pre>
<p>此时你们已经对之前的代码进行了三处的修改：</p>
<ol>
<li>申明了一个<code>resourceLoader</code>变量。</li>
<li>将 <strong>ResourceLoader.js</strong> 文件添加到JavaScript文件数组中。</li>
<li>使用<code>resourceLoader</code>加载TVML模板，然后使用<code>Presenter</code>展现在屏幕上。</li>
</ol>
<p>编译运行程序，你们应该会看到如下界面：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-13.png" alt="tvOS-13"></p>
<p>恭喜你们，现在你们已经可以通过更好的方式从JavaScript文件中加载TVML模板信息了，而不再使用硬编码写死在代码里！</p>
<h3 id="u5B8C_u5584catalogTemplate"><a href="#u5B8C_u5584catalogTemplate" class="headerlink" title="完善catalogTemplate"></a>完善catalogTemplate</h3><p>你管你们信不信，我们要做的tvOS应用马上要接近尾声了。通过TVML开发tvOS应用最优雅的一件事就是添加界面元素非常之简单。</p>
<p>打开 <strong>RWDevConTemplate.xml.js</strong> 文件，按照如下代码更新之前代码：</p>
<pre><code class="swift">
var Template = function() { return `&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
  &lt;document&gt;
    &lt;catalogTemplate&gt; 
      &lt;banner&gt; 
        &lt;title&gt;RWDevConHighlights&lt;/title&gt;
      &lt;/banner&gt;
      //add stuff here
      //1.
      &lt;list&gt; 
        &lt;section&gt; 
          //2.
      &lt;listItemLockup&gt; 
        &lt;title&gt;Inspiration Videos&lt;/title&gt;
        &lt;decorationLabel&gt;13&lt;/decorationLabel&gt;
      &lt;/listItemLockup&gt;
        &lt;/section&gt;
      &lt;/list&gt;
    &lt;/catalogTemplate&gt;
  &lt;/document&gt;`
}
</code></pre>
<ol>
<li>在上面的代码中，新定义了一个list标签，该标签中的内容就是显示在屏幕上除了Banner以外的全部内容。</li>
<li><code>listItemLockup</code>代表一个组，它以<code>listItemLockup</code>标签开头。在该标签中，通过<code>title</code>标签定义了它的名称“Inspiration Videos”，然后通过<code>decorationLabel</code>标签定义了该组中包含内容的数量。</li>
</ol>
<p>编译运行程序，在模拟器中你们会看到如下界面：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-14.png" alt="tvOS-14"></p>
<p>看着还不赖吧！</p>
<h3 id="u5B8C_u6210catalogTemplate"><a href="#u5B8C_u6210catalogTemplate" class="headerlink" title="完成catalogTemplate"></a>完成catalogTemplate</h3><p>最后，我们准备在模板中添加cell，用于展示每一个视频。打开 <strong>RWDevConTemplate.xml.js</strong> 添加如下代码：</p>
<pre><code class="swift">
var Template = function() { return `&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
  &lt;document&gt;
    &lt;catalogTemplate&gt; 
      &lt;banner&gt; 
        &lt;title&gt;RWDevConHighlights&lt;/title&gt;
      &lt;/banner&gt;
      &lt;list&gt; 
        &lt;section&gt; 
      &lt;listItemLockup&gt; 
        &lt;title&gt;Inspiration Videos&lt;/title&gt;
        &lt;decorationLabel&gt;13&lt;/decorationLabel&gt;
            //1. add from here
        &lt;relatedContent&gt; 
          &lt;grid&gt;
            &lt;section&gt; 
                  //2
          &lt;lockup videoURL=&quot;http://www.rwdevcon.com/videos/Ray-Wenderlich-Teamwork.mp4&quot;&gt;
            &lt;img src=&quot;${this.BASEURL}images/ray.png&quot; width=&quot;500&quot; height=&quot;308&quot; /&gt;
          &lt;/lockup&gt;
          &lt;lockup videoURL=&quot;http://www.rwdevcon.com/videos/Ryan-Nystrom-Contributing.mp4&quot;&gt;
            &lt;img src=&quot;${this.BASEURL}images/ryan.png&quot; width=&quot;500&quot; height=&quot;308&quot; /&gt;
          &lt;/lockup&gt;                                    
              &lt;lockup videoURL=&quot;http://www.rwdevcon.com/videos/Matthijs-Hollemans-Math-Isnt-Scary.mp4&quot;&gt;
            &lt;img src=&quot;${this.BASEURL}images/matthijs.png&quot; width=&quot;500&quot; height=&quot;308&quot; /&gt;
          &lt;/lockup&gt;                                    
          &lt;lockup videoURL=&quot;http://www.rwdevcon.com/videos/Vicki-Wenderlich-Identity.mp4&quot;&gt;
            &lt;img src=&quot;${this.BASEURL}images/vicki.png&quot; width=&quot;500&quot; height=&quot;308&quot; /&gt;
          &lt;/lockup&gt;                                    
              &lt;lockup videoURL=&quot;http://www.rwdevcon.com/videos/Alexis-Gallagher-Identity.mp4&quot;&gt;
            &lt;img src=&quot;${this.BASEURL}images/alexis.png&quot; width=&quot;500&quot; height=&quot;308&quot; /&gt;
              &lt;/lockup&gt;                                    
          &lt;lockup videoURL=&quot;http://www.rwdevcon.com/videos/Marin-Todorov-RW-Folklore.mp4&quot;&gt;
            &lt;img src=&quot;${this.BASEURL}images/marin.png&quot; width=&quot;500&quot; height=&quot;308&quot; /&gt;
          &lt;/lockup&gt;                                    
          &lt;lockup videoURL=&quot;http://www.rwdevcon.com/videos/Chris-Wagner-Craftsmanship.mp4&quot;&gt;
            &lt;img src=&quot;${this.BASEURL}images/chris.png&quot; width=&quot;500&quot; height=&quot;308&quot; /&gt;
              &lt;/lockup&gt;                                    
          &lt;lockup videoURL=&quot;http://www.rwdevcon.com/videos/Cesare-Rocchi-Cognition.mp4&quot;&gt;
            &lt;img src=&quot;${this.BASEURL}images/cesare.png&quot; width=&quot;500&quot; height=&quot;308&quot; /&gt;
          &lt;/lockup&gt;                                    
          &lt;lockup videoURL=&quot;http://www.rwdevcon.com/videos/Ellen-Shapiro-Starting-Over.mp4&quot;&gt;
            &lt;img src=&quot;${this.BASEURL}images/ellen.png&quot; width=&quot;500&quot; height=&quot;308&quot; /&gt;
          &lt;/lockup&gt;                                    
          &lt;lockup videoURL=&quot;http://www.rwdevcon.com/videos/Jake-Gundersen-Opportunity.mp4&quot;&gt;
            &lt;img src=&quot;${this.BASEURL}images/jake.png&quot; width=&quot;500&quot; height=&quot;308&quot; /&gt;
          &lt;/lockup&gt;                                    
          &lt;lockup videoURL=&quot;http://www.rwdevcon.com/videos/Kim-Pedersen-Finishing.mp4&quot;&gt;
            &lt;img src=&quot;${this.BASEURL}images/kim.png&quot; width=&quot;500&quot; height=&quot;308&quot; /&gt;
          &lt;/lockup&gt;                                    
              &lt;lockup videoURL=&quot;http://www.rwdevcon.com/videos/Tammy-Coron-Possible.mp4&quot;&gt;
            &lt;img src=&quot;${this.BASEURL}images/tammy.png&quot; width=&quot;500&quot; height=&quot;308&quot; /&gt;
          &lt;/lockup&gt;                                    
          &lt;lockup videoURL=&quot;http://www.rwdevcon.com/videos/Saul-Mora-NSBrief.mp4&quot;&gt;
            &lt;img src=&quot;${this.BASEURL}images/saul.png&quot; width=&quot;500&quot; height=&quot;308&quot; /&gt;
          &lt;/lockup&gt;        
        &lt;/section&gt;
          &lt;/grid&gt;
        &lt;/relatedContent&gt;
      &lt;/listItemLockup&gt;
        &lt;/section&gt;
      &lt;/list&gt;
    &lt;/catalogTemplate&gt;
  &lt;/document&gt;`
}
</code></pre>
<ol>
<li>从上述代码中可以看到，在<code>listItemLockup</code>标签中添加了<code>relatedContent</code>，该标签是的作用是显示图中红色圆圈区域的：</li>
</ol>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-15.png" alt="tvOS-15"></p>
<ol>
<li>每个<code>lockup</code>代表一个视频，每个该标签中都有<code>videoURL</code>的属性，它的值就是 <strong>RWDevCon</strong> 网站上视频的地址。对于之后播放视频至关重要。</li>
</ol>
<p>编译运行程序，会看到被你赋予新生命力的应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-16.png" alt="tvOS-16"></p>
<p>现在，我们已经在“Inspiration Videos”这个组里添加了若干视频。让我们打开遥控器的模拟器，选中模拟器，在菜单栏中选择 <strong>Hardware\Show Apple TV Remote</strong> 。你可以通过遥控器中的 <strong>option</strong> 键选择不同的视频。</p>
<h2 id="u64AD_u653E_u89C6_u9891"><a href="#u64AD_u653E_u89C6_u9891" class="headerlink" title="播放视频"></a>播放视频</h2><p>到目前为止，我们已经构建好了应用的页面，看起来还是不错的。此时，你们可以再想想如果用iOS框架完成你们现在已经完成的布局，应该如何做。Apple把一些UI的细节全都抽象了出来，通过一个个模板提供给我们使用，可以让我们简单方便的通过模板创建出完美的界面，不得不说Apple做的太棒了。</p>
<p>接下来让我们完成最后两个遗留的功能：选择视频和播放视频。</p>
<h3 id="u9009_u62E9_u4E8B_u4EF6"><a href="#u9009_u62E9_u4E8B_u4EF6" class="headerlink" title="选择事件"></a>选择事件</h3><p>你们可能已经注意到了，当按下 <strong>enter</strong> 键或者在 <strong>Apple TV Remote</strong> 选择视频时并没有什么反应，所以是时候来实现选择视频的功能了。</p>
<p>打开<code>Presenter</code>，添加如下代码：</p>
<pre><code class="swift">
load: function(event) {
  //1
  var self = this,
  ele = event.target,
  videoURL = ele.getAttribute(&quot;videoURL&quot;)
  if(videoURL) {
    //2
    var player = new Player();
    var playlist = new Playlist();
    var mediaItem = new MediaItem(&quot;video&quot;, videoURL);

    player.playlist = playlist;
    player.playlist.push(mediaItem);
    player.present();
  }
},
</code></pre>
<ol>
<li><code>load</code>函数用来处理视频选择事件。它相当于iOS中的<code>@IBAction</code>，该函数的<code>event</code>参数相当于<code>sender</code>参数。每个<code>event</code>都有一个<code>target</code>，每个<code>target</code>关联着模板中的<code>lockup</code>元素。一个<code>lockup</code>代表应用中的一个视频，它里面有视频封面的属性，以及视频地址<code>videoURL</code>属性。</li>
<li>播放视频非常简单。<code>Player</code>是 <strong>TVJS</strong> 框架提供的一个类，负责所有视频播放的相关功能。你们所要做的只是添加一个播放列表<code>playlist</code>，然后将要播放的项目<code>mediaItem</code>添加到播放列表里。最后通过<code>player.present()</code>方法就可以播放视频了。</li>
</ol>
<p>现在你们已经实现了选择视频后的响应事件。是时候将选择事件与每个视频关联在一起了。打开 <strong>application.js</strong> 文件，在<code>App.onLaunch</code>方法中添加如下代码：</p>
<pre><code class="swift">
App.onLaunch = function(options) {
  //...
  //在resourceLoader.loadResource中...
  var doc = Presenter.makeDocument(resource);
  doc.addEventListener(&quot;select&quot;, Presenter.load.bind(Presenter)); //add this line
  Presenter.pushDocument(doc);
  //...
}
</code></pre>
<p>上述代码中的<code>addEventListener</code>方法相当于iOS中按钮的<code>@IBAction</code>。编译运行程序，选择一个视频播放，你会看到一个完美的视频播放应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-17.gif" alt="tvOS-17"></p>
<p>大家可以在这里下载教程中的完整项目：<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/client.zip" target="_blank" rel="external">client</a>和<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/RWDevCon.zip" target="_blank" rel="external">RWDevCon</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作者：<a href="http://www.raywenderlich.com/u/Kelvin%20Lau" target="_blank" rel="external">Kelvin Lau</a> 原文地址：<a href="http://www.raywender]]>
    </summary>
    
      <category term="Apple TV" scheme="http://www.devtalking.com/tags/Apple-TV/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CALayer Animation - Gradient Animation]]></title>
    <link href="http://www.devtalking.com//articles/calayer-animation-gradient-animation/"/>
    <id>http://www.devtalking.com//articles/calayer-animation-gradient-animation/</id>
    <published>2015-09-21T16:00:00.000Z</published>
    <updated>2016-01-02T15:42:11.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-09-22/2825765" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>在很多人的心目中iPhone的经典机型应该是iPhone4，精湛的工艺、完美的屏幕配上暗色的锁屏壁纸，看着屏幕底部闪烁的<strong>slide to unlock</strong>字样，高逼格彰显无遗。时至今日无论iPhone机身样式如何改变，屏幕尺寸如何改变，iOS系统如何改变，唯有锁屏底部闪烁的<strong>滑动来解锁</strong>不变。它的动画效果是如何实现的呢，这篇文章会告诉你们答案。</p>
<h2 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h2><p>新建一个应用名为<strong>GradientAnimation</strong>，打开<code>Main.storyboard</code>，将ViewController的View背景色设置为灰黑色，拖一个UIView到ViewController中，将其颜色设置为无色并设置好布局约束：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-1.png" alt="GradientAnimation - 1"></p>
<p>接着我们拖一个UILabel到刚才拖入的UIView中，设置高宽等同于它的父视图：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-2.png" alt="GradientAnimation - 2"></p>
<p>我对该UILabel的属性设置如下：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-4.png" alt="GradientAnimation - 4"></p>
<p>之后，我们在<code>ViewController</code>中添加UIView和UILabel的Outlet：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-5.png" alt="GradientAnimation - 5"></p>
<p>接下来回到<code>ViewController.swift</code>，我们添加一个常量属性<code>gradientLayer</code>：</p>
<pre><code class="swift">
let gradientLayer = CAGradientLayer()
</code></pre>
<p>这里出现了CALayer的另一个子类CAGradientLayer，这个类的作用就是能在Layer上绘制出渐变颜色的效果，然后在<code>viewDidLoad()</code>中添加如下代码：</p>
<pre><code class="swift">
gradientLayer.bounds = CGRect(x: 0, y: 0, width: backgroundView.frame.size.width, height: backgroundView.frame.size.height)
gradientLayer.position = CGPoint(x: backgroundView.frame.size.width/2, y: backgroundView.frame.size.height/2)
</code></pre>
<p>上述两行的代码是设置Layer的大小及位置，这在上两篇文章中已经讲过，这里就不再累赘了。接着我们继续添加两行代码：</p>
<pre><code class="swift">
gradientLayer.startPoint = CGPoint(x: 0, y: 0.5)
gradientLayer.endPoint = CGPoint(x: 1, y: 0.5)
</code></pre>
<p>既然CAGradientLayer可以绘制出渐变颜色的效果，那自然有颜色渐变的方向，所以这两行代码的作用就是设置颜色渐变的起始点和结束点，这两个属性共同决定了颜色渐变的方向：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-3.png" alt="GradientAnimation - 3"></p>
<p>从上面的示意图中可以看出，CAGradientLayer是通过起始点和结束点的坐标位置来决定颜色渐变的方向的，起始点的默认值是(0.5, 0)，结束点的默认值是(0.5, 1)，也就是说默认的颜色渐变方向是沿垂直中线从上往下渐变的，我们在这里将它改成了沿水平中线从左往右渐变。</p>
<p>接下来我们设置CAGradientLayer的渐变颜色，接着添加如下代码：</p>
<pre><code class="swift">
gradientLayer.colors = [
    UIColor.blackColor().CGColor,
    UIColor.whiteColor().CGColor,
    UIColor.blackColor().CGColor
]
</code></pre>
<p>CAGradientLayer的<code>colors</code>属性类型是一个数组<code>[AnyObject]</code>，这就意味着我们可以实现多个颜色的渐变效果，并且可以规定各个颜色的顺序。不过在我们这个示例中我们只需要两种颜色，不过需要注意的是虽然颜色只有两种，但是整个颜色渐变的过程中有三个原色点，那就是黑、白、黑，所以我们在这个数组中也需要按照原色点的数量和顺序添加相应的颜色，哪怕颜色都是一样的。</p>
<p>我们既然设置了渐变的三个原色，那么就要对这原色出现的位置进行设置，接着添加如下代码：</p>
<pre><code class="swift">
gradientLayer.locations = [0.2, 0.5, 0.8]
</code></pre>
<p>从上述代码中不难看出，我们将第一个黑色原色出现的位置设置在了整个Layer长度的十分之二的位置，第二个白色原色在中间，第三个黑色原色在十分之八的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-6.png" alt="GradientAnimation - 6"></p>
<p>设置完CAGradientLayer的相关属性后，我们将<code>gradientLayer</code>添加到<code>backgroundView</code>的Layer中：</p>
<pre><code class="swift">
backgroundView.layer.addSublayer(gradientLayer)
</code></pre>
<p>现在我们编译运行一下代码看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-7.png" alt="GradientAnimation - 7"></p>
<p>接下来我们需要让颜色渐变动起来，先创建一个方法<code>gradinetAnimate()</code>，在方法中添加如下代码：</p>
<pre><code class="swift">
let gradient = CABasicAnimation(keyPath: &quot;locations&quot;)
gradient.fromValue = [0, 0, 0.25]
gradient.toValue = [0.75, 1, 1]
gradient.duration = 2.5
gradient.repeatCount = HUGE
gradientLayer.addAnimation(gradient, forKey: nil)
</code></pre>
<p>首先，创建了一个<code>locations</code>类型的动画实例<code>gradient</code>，将<code>fromValue</code>属性，也就是起始位置的属性设置为<code>[0, 0, 0.25]</code>，它的意思是动画开始前，黑色、白色这两个原色的位置在整个Layer的最前端，第二个黑色原色在0.25的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-8.png" alt="GradientAnimation - 8"></p>
<p>而结束位置<code>toValue</code>，将白色和第二个黑色原色位置设置在整个Layer的末端，第一个黑色原色在0.75的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-9.png" alt="GradientAnimation - 9"></p>
<p>从图中可以看出，此时整个Layer都变成了黑色。也就是说，在整个动画中，第一个黑色原色从0移动到0.75的位置，白色原色从0移动到1的位置，第二个黑色原色从0.25移动到1的位置。然后设置动画时间为2.5秒，无线重复次数，最后将<code>gradient</code>动画添加到<code>gradientLayer</code>中。我们在<code>viewDidAppear()</code>方法中调用该动画方法<code>gradientAnimate()</code>，编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-10.gif" alt="GradientAnimation - 10"></p>
<p>动画效果还不赖，但是如何将颜色渐变的动画作用在UILabel的文字上呢？其实非常简单，就是让UILabel上的文字称为CAGradientLayer的遮罩即可，我们先在<code>ViewController</code>中定义一个常量：</p>
<pre><code class="swift">
var text = &quot;DevTalking&quot;
</code></pre>
<p>然后在<code>viewDidAppear()</code>中的<code>gradientAnimate()</code>方法之前添加如下代码：</p>
<pre><code class="swift">
textLabel.text = text
gradientLayer.mask = textLabel.layer
</code></pre>
<p>我们再编译运行代码看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-11.gif" alt="GradientAnimation - 11"></p>
<p>到目前为止，锁屏中<strong>滑动来解锁</strong>的动画效果就完成了，这个动画效果在Facebook的Paper应用中也有使用。下一节，我们在该动画的基础上对文字再加点小动画。</p>
<h2 id="Text_Animation"><a href="#Text_Animation" class="headerlink" title="Text Animation"></a>Text Animation</h2><p>首先我们打开<code>AppDelegate.swift</code>，在<code>import UIKit</code>下面添加一个方法：</p>
<pre><code class="swift">
func delay(seconds seconds: Double, completion:()-&gt;()) {
    let intervalTime = dispatch_time(DISPATCH_TIME_NOW, Int64( Double(NSEC_PER_SEC) * seconds ))

    dispatch_after(intervalTime, dispatch_get_main_queue(), {
        completion()
    })
}
</code></pre>
<p>这个方法的作用如其名称一样，是一个延迟方法，该方法的第一个参数是想要延迟的时间，第二个参数是一个闭包，也就是延迟的主体。这个方法用到了GCD的知识，<code>dispatch_time</code>主要是用于创建一个类型为<code>dispatch_time_t</code>的相对时间，它的第一个参数指的是起始时间，一般都是用预定义的<code>DISPATCH_TIME_NOW</code>作为第一个参数的值，代表当前的时间。第二个参数代表时间间隔，注意这个参数需要的时间单位是纳秒，所以我们使用预定义的<code>NSEC_PER_SEC</code>纳秒单位乘以希望间隔的秒数。</p>
<p><code>dispatch_after</code>用于在队列中定时执行任务，当你想在一段时间后执行一个任务，那么就可以用这个函数。该函数的第一个参数指定延迟的时间，第二个参数指定一个队列，用于添加任务，第三个参数是一个闭包，也就是要执行的任务。</p>
<p>然后回到<code>ViewController.swift</code>，添加如下方法：</p>
<pre><code class="swift">
func textAnimate(text: String) {
    if text.characters.count &gt; 0 {
        textLabel.text = &quot;\(textLabel.text!)\(text.substringToIndex(text.startIndex.successor()))&quot;
        delay(seconds: 0.4, completion: {
            self.textAnimate(text.substringFromIndex(text.startIndex.successor()))
        })
    }
}
</code></pre>
<p>该方法的参数<code>text</code>就是UILabel中要显示的文字内容。<code>substringToIndex(_ to: Int)</code>方法的作用是从字符串的开头一直截取到指定的位置，但不包括该指定位置的字符。<code>text.startIndex.successor()</code>这句意思是从<code>text</code>的起始位置开始取后面的一个字符。<code>substringFromIndex(_ from: Int)</code>方法的作用是以指定位置并包括指定位置的字符开始，一直截取之后的全部字符。所以整个方法的作用是每隔0.4秒显示一个字符，直到将整个字符串显示完。最后在<code>viewDidAppear()</code>中注释掉<code>textLabel.text = text</code>这行代码，并在方法最后调用<code>textAnimate(text)</code>方法。编译运行代码看看最终效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-12.gif" alt="GradientAnimation - 12"></p>
<p>参考文献来自：<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-09-22/2825765" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>在很多人的心目中iPhone的]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ 一个iOS开发者对tvOS SDK的初探]]></title>
    <link href="http://www.devtalking.com//articles/tvOS-initial-impression/"/>
    <id>http://www.devtalking.com//articles/tvOS-initial-impression/</id>
    <published>2015-09-16T16:00:00.000Z</published>
    <updated>2016-01-02T16:09:32.000Z</updated>
    <content type="html"><![CDATA[<p>作者：<a href="http://www.raywenderlich.com/u/cwagdev" target="_blank" rel="external">Chris Wagner</a>  原文地址：<a href="http://www.raywenderlich.com/114313/tvos-initial-impressions" target="_blank" rel="external">tvOS SDK: An iOS Developer’s Initial Impressions</a></p>
<p>在Walter Isaacson编写的《Steve Jobs》的最后一章中，Steve说过“我最终实现并让它拥有了你们能想象到的最简单的用户界面”。当时他指的就是Apple TV。</p>
<p>Steve不幸离世已经过去很久了，但是人们一直翘首以盼着这款产品。就在昨天2015年9月9日，超过四个春秋的期盼，我们终于等来了这个礼物，虽然可能与Steve对这款产品的愿景和理想有所差距，但是革命的步伐已经坚实的迈出了第一步。</p>
<p>作为一名iOS开发者，昨天的产品发布会让我心潮澎湃，因为Apple宣布，新的Apple TV集成了App Store，这就意味着我们可以为它开发专有的应用，并且会让我们重新认知已了解的iOS知识，以及会开启更多新的展现想法、创意的机会。</p>
<p>我和其他教程团队的成员已经开始深入研究tvOS SDK，并且正在努力准备一些有价值的tvOS教程（通宵达旦！），在此同时，我想从一个iOS开发者的视角与大家分享我对tvOS的初步印象。</p>
<p>让我们一探究竟吧！</p>
<h2 id="u57FA_u672C_u6982_u5FF5"><a href="#u57FA_u672C_u6982_u5FF5" class="headerlink" title="基本概念"></a>基本概念</h2><p>老款的Apple TV其实类似一个机顶盒，主要提供的功能是让用户通过及其简单的操作界面导航或浏览视频内容。昨天发布的新Apple TV在此基础上进一步的扩充功能，使一些成熟的应用能在Apple TV中运行，比如购物应用，甚至是游戏。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_02-457x320.jpg" alt="tvOS-1"></p>
<p>让我们来看看以下这些信息：</p>
<ul>
<li><strong>硬件规格：</strong> 值得一说规格是64位 A8处理器，32G或64G的存储空间，2G的内存，1080p的分辨率以及支持HDMI，Siri远程遥控，新的Apple TV遥控器。</li>
<li><strong>价格：</strong> 新Apple TV的定价为32G 149美元，64G 199美元。这样的定价出乎大多人的以外，原以为新Apple TV的价格会更高一些。</li>
<li><strong>发售时间：</strong> Apple在发布会上给出了一个非常模糊和不确定的发售时间“十月下旬”，但是Apple在发布会之后就立即向开发者们提供了tvOS SDK。现在离正式发售已时日不多，如果大家有针对新Apple TV好的想法，我建议你们要抓紧时间了。</li>
<li><strong>开发硬件：</strong> Apple已经宣布了一个开发者计划允许已经注册的开发者们请求<a href="https://developer.apple.com/tvos/developer-kit/" target="_blank" rel="external">Apple TV Developer Kit</a>。该计划可以让开发者们提前对Apple TV进行开发测试。这看起来似乎是一件很美好的事，但是如果你真的要加入该开发者计划，那么仔细看看下面的建议：</li>
</ul>
<p>-&gt; <strong>注意：</strong> 众所周知，iOS、OSX的开发者计划都是收费的，tvOS的开发者计划应该也不例外，不过之前对于该计划的收费信息是非常含糊不清的，但是现在我们通过Apple员工在开发者论坛上发的帖子中<a href="https://forums.developer.apple.com/thread/16984#51332" target="_blank" rel="external">确认</a>了该计划只需要话费1美元即可加入。如果大家有意为tvOS贡献一份力量，或者需要编写教程材料的话，强烈建议你们加入该开发计划。</p>
<h2 id="u5F00_u53D1_tvOS__u5E94_u7528"><a href="#u5F00_u53D1_tvOS__u5E94_u7528" class="headerlink" title="开发 tvOS 应用"></a>开发 tvOS 应用</h2><p>啰嗦完一堆后，显然最重要的事就是怎样为新Apple TV开发应用，这应该也是大家最感兴趣的事！</p>
<p>为新Apple TV开发应用实际就是在为tvOS开发应用，当然tvOS这个名字是由Apple根据不同设备而创造的。tvOS仍然是基于iOS开发的，所以有很多框架大家都应该非常熟悉了。</p>
<p>如果要为tvOS开发应用，大家必须要从开发者中心下载<a href="https://developer.apple.com/xcode/download/" target="_blank" rel="external">Xcode7.1</a>进行开发。该版本是Xcode新的beta版，目前只有该版本支持tvOS以及提供tvOS的模拟器。如果你有需要的话，也可同时下载Xcode7 GM版本，他们可以共存于你们的电脑中。</p>
<p>Apple提供了两种在tvOS上开发应用的方法：</p>
<ol>
<li><strong>TVML Apps：</strong> 这类应用是使用完整的新开发技术开发的，比如TVML、TVJS、TVMLKit。这对我们来说是一个巨大的惊喜，我们会在之后有较详细的介绍。</li>
<li><strong>Custom Apps：</strong> 这类应用是使用我们已经比较熟悉的开发技术进行开发的，比如大家熟知的一些iOS框架，Storyboard、UIKit、Auto Layout等。</li>
</ol>
<p>当你们在为Apple TV开发应用时，你们会发现Xcode中会出现单独的程序目标（这意味着用户将会单独购买的形式购买tvOS应用）。虽然Apple在发布会上说Apple TV中的应用支持通用购买模式，也就是针对iOS和tvOS都支持的应用，用户只需要购买一次即可同时在iPhone和Apple TV上使用。但是从目前的情况来看，我们还不确定Apple是如何实现的，或许在Itunes Connect中支持连接两个程序目标的功能即将来临？</p>
<h3 id="TVML_Apps"><a href="#TVML_Apps" class="headerlink" title="TVML Apps"></a>TVML Apps</h3><p>先前我提过，为tvOS开发应用有两种方式，第一种就是通过TVML、TVJS和TVMLKit技术。如果这些缩写对于你们来说非常陌生，那么不要着急，这就告诉你们他们都是什么：</p>
<ul>
<li><strong>TVML</strong>是一种基于“Television Markup Language”的XML格式。</li>
<li><strong>TVJS</strong>是基于JavaScript APIs的脚本语言，它可以根据TVML中定义的内容展示应用。</li>
<li><strong>TVMLKit</strong>是连接TVML、TVJS和原生tvOS应用的工具包。</li>
</ul>
<p>如果你是一名经常使用原生APIs开发原生iOS应用的开发者，那么看到这些类似前端的技术可能会有点退缩。但希望你能保持一颗学习的心，学习了解这些新的强大的特性。</p>
<p>我在这列举一个非常典型的Apple TV的应用场景。大家可以想象一下：你们想把一些内容或信息展现给用户，这些内容和信息储存在你们的服务器上，并且这些内容的格式、查询方式都服务于iPhone或iPad中的应用，那么你肯定会希望你的tvOS中的应用也能方便的使用这些内容，并做到与iOS中应用有相似的展现、查询、导航方式。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_03-700x296.jpg" alt="tvOS-2"></p>
<p>如果我列举的这个例子正好是你们tvOS应用的需求，那么你可能需要考虑如何使用TVMLKit工具包。Apple已经为我们开发者完成了一些主要的工作，比如提供了许多可重用的tvOS界面展示模板，这些模板大都与iOS应用的界面神似，所以用户们并不会感到陌生，这些模板大概有18种之多。大多数模板都可以让你创建出脱凡的、非常适合家中电视展示的界面。大家可以访问Apple的<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">文档</a>查看这些我们强烈推荐使用的模板。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_04-700x296.jpg" alt="tvOS-3"></p>
<p>我也推荐大家在tvOS模拟器运行<a href="https://developer.apple.com/library/prerelease/tvos/samplecode/TVMLCatalog/Introduction/Intro.html#//apple_ref/doc/uid/TP40016505" target="_blank" rel="external">TVML Catalog sample app</a>去查看每个模板。同时你需要启动一个本地的web服务器，便于tvOS应用通过模板展示内容时访问，所以你需要仔细查阅<strong>README.md</strong>文件去了解相关内容。</p>
<p>诚然TVMLKit还有许多知识点，如果你希望基于它开发一款tvOS应用，那么我提到的一些文档是非常值得你们去查阅参考的。这里我着重推荐大家首先看看如何使用菜单导航类的模板，比如<strong>menuBarTemplate</strong>、<strong>mainTemplate</strong>、<strong>searchTemplate</strong>等。然而，如果你希望用户不只是被动的通过你的tvOS应用观看或收听内容，而是希望用户与应用有更多的交互，给用户高质量的用户体验，那么你们就需要了解如何开发完整的自定义的tvOS应用。</p>
<h3 id="Custom_Apps"><a href="#Custom_Apps" class="headerlink" title="Custom Apps"></a>Custom Apps</h3><p>你所知道的大多数iOS框架，比如UIKit、Core Graphics、CloudKit等等都可以在tvOS中使用。你可以在Apple提供的这个<a href="https://developer.apple.com/library/prerelease/tvos/releasenotes/General/tvOS90APIDiffs/index.html#//apple_ref/doc/uid/TP40016577" target="_blank" rel="external">文档</a>中查看哪些框架可以用，哪些不可以使用。如果你现在正是一名iOS开发者，那么会对这个文档中的列表非常熟悉。而且不管使用Swift还是Objective-C或者C都可以开发tvOS应用。</p>
<p>尽管如此，如果想开发自定义的tvOS应用，还是有许多新的知识需要我们学习，作为一名iOS开发者，也应该掌握甚至精通这些新的知识。</p>
<h2 id="Focus_Engine"><a href="#Focus_Engine" class="headerlink" title="Focus Engine"></a>Focus Engine</h2><p>其中一个对于iOS开发者比较陌生的概念是用户输入/选择方法。在使用Apple TV的过程中，用户不会用手指去按压或滑动屏幕，取而代之的是使用Apple提供的遥控器或者是一些游戏控制器。</p>
<p>tvOS采用了一个被称为<strong>Focus Engine</strong>的引擎系统，它在整个tvOS中有且只有一个。该引擎负责响应当用户使用遥控器上的手势操作或按键操作对菜单或内容进行上下左右的选择。</p>
<p>Focus Engine会自动根据用户的选择决定要聚焦或展示的视图，你不需要在代码中做任何类似选中或导航的处理。比如说，此时展示的界面是你已经在Storyboard中设计好的视图布局，其中有一个视图是当前聚焦状态，那么当用户通过手势往右滑动时，Focus Engine会自动根据当前聚焦的视图找到与之相邻的左边的视图，并将其选中和聚焦。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_05-700x328.jpg" alt="tvOS-4"></p>
<p>作为一个开发者，你必须要学习与Focus Engine相关的API，比如当聚焦的视图发生变化时如何获取通知、如何通过编码触发聚焦视图的改变扥等。更多关于Focus Engine的API可以参阅App Programming Guide for tvOS文档中的<a href="https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/WorkingwiththeAppleTVRemote.html#//apple_ref/doc/uid/TP40015241-CH5-SW14" target="_blank" rel="external"> Supporting Focus Within Your App</a>章节。</p>
<h2 id="TVServices"><a href="#TVServices" class="headerlink" title="TVServices"></a>TVServices</h2><p>虽然iOS开发者在tvOS应用的开发过程中，主要使用的是一些已经比较熟悉的iOS框架，但是也有一些tvOS特有的框架需要开发者们去了解掌握，比如像新加入的<code>TVServices</code>框架。</p>
<p><code>TVServices</code>的主要作用是描述你的应用的内容，以便tvOS在首页的顶部栏位显示。在首页顶部栏位显示的应用都是用户自己设置的，用户可以将他们认为最为常用的或最为重要的应用放在首页顶部栏位，便于快速打开或浏览其中主要信息。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_06-478x320.jpg" alt="tvOS-5"></p>
<p>你们的应用可以在用户不进入应用的情况下，向用户提供简短的、感兴趣的信息，这就会使你的应用有了额外价值，使用<code>TVServices</code>无疑是提高你的应用下载量的绝佳手段。比如一个游戏应用，通过<code>TVServices</code>显示游戏存档，那么用户就可以直接从首页通过游戏存档进入游戏。如果是一个社交应用，那么就可以在首页显示社交动态信息，如果是一个照片分享应用，那么就可以显示近期朋友和家人分享的照片。</p>
<p>更多关于<code>TVServices</code>的信息可以查阅<a href="https://developer.apple.com/library/prerelease/tvos/documentation/TVServices/Reference/TVServices_Ref/index.html#//apple_ref/doc/uid/TP40016412" target="_blank" rel="external">TVServices Framework Reference</a>文档。使用好它对你的应用非常有益。</p>
<h2 id="Parallax_Images"><a href="#Parallax_Images" class="headerlink" title="Parallax Images"></a>Parallax Images</h2><p>还有一件会让你疑惑的可能就是在发布会的Keynote中，Apple着重强调了图片和应用图标的视差效果。这是一个非常棒的视图效果，但是为什么这个特性会被放在Keynote中提及，它为什么这么重要呢？</p>
<p>如果你使用了tvOS模拟器，你就会明白为什么这个特性如此重要。当移动聚焦视图时，你需要向左或向右滑动，但如果你只滑动了一点，Apple会对当前聚焦的视图做一个轻微的旋转处理，目的是让用户知道现在正在作以操作（但是还需要继续滑动来改变聚焦视图）。这是一个着眼于细节但又非常有用的特性。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_07.jpg" alt="tvOS-6"></p>
<p>Apple把视差效果看做tvOS设计中的一个关键组成部分，并强烈建议应用图标和电影海报使用该特性。不过感谢Apple在App Programming Guide for tvOS文档中提供了<a href="https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/CreatingParallaxArtwork.html#//apple_ref/doc/uid/TP40015241-CH19-SW1" target="_blank" rel="external">Creating Parallax Artwork</a>章节，帮助我们创建视差特性的图片资源，以及为我们提供了视察图片资源的预览应用。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_08.jpg" alt="tvOS-7"></p>
<h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><p>每一个购买了新Apple TV的用户，都会收到一个功能强大的新版遥控器。上一代只能上下左右简单选择方位以及只有几个简单导航按键的遥控器，而新一代的Apple TV遥控器增加了更多令人激动的新特性：</p>
<ul>
<li><strong>玻璃触控板：</strong>位于遥控器的顶部，可以让用户在其上面进行一些手势操作，比如滑动、轻拍、点击。</li>
<li><strong>麦克风：</strong>可以让用户通过遥控器访问Siri（Siri有使用国家的限制）以及可以通过语音控制电视的音量。</li>
<li><strong>陀螺仪：</strong>结合动作传感器可以为用户提供非常棒的游戏体验。用户可以通过倾斜遥控器在游戏中控制方向盘开车，或者控制英雄奔跑穿越山洞。</li>
</ul>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_09.jpg" alt="tvOS-8"></p>
<p>你可以使用你知道的处理手势操作的API去监听滑动或轻点，还有一些新的API去监听遥控器上不同的按钮，比如<code>pressesBegan()</code>、<code>pressesEnded()</code>、<code>pressesChanged()</code>和<code>pressesCancelled()</code>。</p>
<p>遥控器通过蓝牙技术与Apple TV主机交互，这意味着为蓝牙游戏控制器敞开的大门（恕我直言，用Apple的遥控器玩游戏并不是很好的选择）。Apple已经宣布<a href="https://steelseries.com/gaming-controllers/nimbus" target="_blank" rel="external">Nimbus Steelseries Controller</a>将会支持新Apple TV。想了解更多关于这方面的信息请查阅<a href="https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/WorkingwithGameControllers.html#//apple_ref/doc/uid/TP40015241-CH18-SW1" target="_blank" rel="external">Working with Game Controllers</a>。</p>
<h2 id="tvOS_and_Games"><a href="#tvOS_and_Games" class="headerlink" title="tvOS and Games"></a>tvOS and Games</h2><p>我们衷心的希望游戏能在tvOS上火起来，Apple似乎是直接瞄准了任天堂漠不关心的一个游戏市场。</p>
<p>tvOS有很健壮的游戏技术作为支撑，SpriteKit和SceneKit都可以在tvOS中正常工作，在Keynote中Crossy Roads开发者展示了他们的tvOS游戏，该游戏使用Unity开发，所以这也暗示着在不久的将来tvOS也会支持Unity开发的游戏。</p>
<p>大多数用SceneKit开发的游戏都可以无缝移植到新Apple TV中。比如Ray就将教程中介绍过的Zombie Conga游戏移植到了新Apple TV中，花费时间还不到10分钟，几乎不需要修改任何代码。</p>
<p>-&gt; 注：游戏视频可前往原文查看，但需要科学上网。</p>
<h2 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h2><p>或许目前关于tvOS比较有疑惑的两点就是本地存储和应用大小的限制。</p>
<h3 id="Limitation_3A_Local_Storage"><a href="#Limitation_3A_Local_Storage" class="headerlink" title="Limitation: Local Storage"></a>Limitation: Local Storage</h3><p>关于本地存储，基本确定是没有！如果你的应用需要持久化用户的数据，那么你需要使用iCloud、CloudKit或者自己的备份服务去实现。任何试图存在Apple TV中的数据都不保证在下次打开应用时还嫩存在。如果你想同步不同设置之间的数据，那么你就需要将数据线存在某个地方，但绝不是Apple TV中。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS_10-480x313.jpg" alt="tvOS-9"></p>
<p>一定要牢记这点，它对于你设计tvOS应用的结构时很关键。这里列出了一些规则：</p>
<ul>
<li><strong>如果你需要存储的数据量小于1MB</strong>，iCloud的key-value存储方式是一个可以选择的方案。但是要切记，iCloud KVS严格限制了只能有所属者才可以访问数据，并且不能共享给其他用户。</li>
<li><strong>如果你需要分享事件或者数据给其他用户</strong>，CloudKit是一个不错的选择方案。</li>
<li><strong>如果你开发的是一个跨平台的应用或者有特殊的需求</strong>，你就得使用你自己的备份服务了。</li>
</ul>
<h3 id="Limitation_3A_App_Size"><a href="#Limitation_3A_App_Size" class="headerlink" title="Limitation: App Size"></a>Limitation: App Size</h3><p>另一个限制是关于应用大小的限制，规定不能超过200MB。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/FlipTable-250x228.png" alt="tvOS-10"></p>
<p>在你们掀桌之前，请回顾一下WWDC2015以及介绍过的“On-Demand Resources”相关API。这几乎像是Apple为tvOS提前铺垫的。</p>
<p>这些API通过按需下载资源文件减小应用初始安装时的大小。开发者可以在Xcode中给多媒体资源文件用标签进行标记，将应用提交后，App Store会自动根据标记将多媒体资源文件拆分为一个一个下载包。当用户在使用应用时如果需要用到某类标记的资源文件，就可以请求下载该标记的资源文件。当然你得有预期的判断，要先于用户使用资源前开始下载他们需要的资源，这样对于用户来说他们根本不会感受到因为下载资源带来的不好的用户体验。</p>
<p>举一个简单的例子，比如你有一款游戏应用有10个关卡。在用户安装该游戏时可以只包含两个关卡的多媒体资源文件。一旦用户完成了第一个关卡，你应该发送一个下载请求，下载第三个关卡的多媒体资源文件。当用户完成了第二个关卡时，第三个关卡需要的资源文件早已下载好准备妥当。在用户的整个游戏过程中，你就可以运用该机制一步一步去下载所需的资源文件。</p>
<p>虽然这种机制对于开发者来说无疑增加了工作量，但是这对用户来说是一件非常愉悦的事情。你试想一下，用户是愿意等待下载一个1GB大小的游戏呢，还是更愿意下载一个100MB大小的游戏并立即开始游戏呢。不过该机制也存在一个隐患，如果用户的网络条件很差，他们一般都更愿意在晚上挂着下载。那么如果用户在白天玩你的游戏，然后同时用龟速的网络下载后面关卡的资源文件，这简直是令人发指的用户体验。不幸的是作为tvOS开发者，在这种情形下目前也无能为力。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>作者：<a href="http://www.raywenderlich.com/u/cwagdev" target="_blank" rel="external">Chris Wagner</a>  原文地址：<a href="http://www.raywenderli]]>
    </summary>
    
      <category term="tvOS" scheme="http://www.devtalking.com/tags/tvOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CALayer Animation - Replicator Animation]]></title>
    <link href="http://www.devtalking.com//articles/calayer-animation-replicator-animation/"/>
    <id>http://www.devtalking.com//articles/calayer-animation-replicator-animation/</id>
    <published>2015-09-08T16:00:00.000Z</published>
    <updated>2016-01-21T09:34:19.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-09-09/2825659" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>上一篇文章通过两个动画示例带大家了解和认识了CALayer动画，包括如何使用CAShapeLayer、CABasicAnimation、CAAnimationGroup等。在这篇文章中，依然会通过两个示例向大家讲解更多CALayer动画的知识。</p>
<p>老规矩，先让我们看看最终要实现的动画效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-17.gif" alt="ReplicatorAnimation-17"></p>
<p>经常听音乐的人对第一个动画效果肯定有会觉得很眼熟，类似播放音乐时音频高低起伏的动画，这种动画在应用中常被用作标识正在播放音乐或广播。第二个动画依然是一个等待加载的动画，在我的印象中肯定是有应用使用过，具体的已经记不清了。下面就让我们来实现这两个动画吧。</p>
<h2 id="Replicator_Animation"><a href="#Replicator_Animation" class="headerlink" title="Replicator Animation"></a>Replicator Animation</h2><p>新建一个项目，名为ReplicatorAnimation，打开<code>Main.storyboard</code>，添加一个UIView，颜色位置按大家喜好设定：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-1.png" alt="ReplicatorAnimation-1"></p>
<p>添加该UIView在<code>ViewController.swift</code>中的Outlet：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-2.png" alt="ReplicatorAnimation-2"></p>
<p>接下来我们在<code>ViewController.swift</code>中添加一个方法<code>firstReplicatorAnimation()</code>，在该方法中编写如下代码：</p>
<pre><code class="swift">
let replicatorLayer = CAReplicatorLayer()
replicatorLayer.bounds = CGRect(x: replicatorAnimationView.frame.origin.x, y: replicatorAnimationView.frame.origin.y, width: replicatorAnimationView.frame.size.width, height: replicatorAnimationView.frame.size.height)
replicatorLayer.anchorPoint = CGPoint(x: 0, y: 0)
replicatorLayer.backgroundColor = UIColor.lightGrayColor().CGColor
replicatorAnimationView.layer.addSublayer(replicatorLayer)
</code></pre>
<p>这里出现的CAReplicatorLayer是一个新面孔，它也是CALayer的子类，正如它的名称一样，CAReplicatorLayer可以对它自己的子Layer进行复制操作。创建了CAReplicatorLayer实例后，设置了它的尺寸大小、位置、锚点位置、背景色，并且将它添加到了<code>replicatorAnimationView</code>的Layer中:</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-4.png" alt="ReplicatorAnimation-4"></p>
<p>这里要啰嗦几句，Layer的默认锚点坐标是(0.5, 0.5)，也就是Layer的中心点位置，而Layer的<code>position</code>又是根据锚点计算的，所以如果你设置Layer的<code>position</code>属性为(10, 10)，就相当于设置了Layer的中心位置为(10, 10)，并不是你期望的左上角位置。所以如果Layer想使用它父视图的坐标位置，就需要将锚点位置设置为(0, 0)，这样一来Layer的<code>position</code>属性标识的就是Layer左上角的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-3.png" alt="ReplicatorAnimation-3"></p>
<p>然后我们继续在<code>firstReplicatorAnimation()</code>方法中添加代码：</p>
<pre><code class="swift">
let rectangle = CALayer()
rectangle.bounds = CGRect(x: 0, y: 0, width: 30, height: 90)
rectangle.anchorPoint = CGPoint(x: 0, y: 0)
rectangle.position = CGPoint(x: replicatorAnimationView.frame.origin.x + 10, y: replicatorAnimationView.frame.origin.y + 110)
rectangle.cornerRadius = 2
rectangle.backgroundColor = UIColor.whiteColor().CGColor
replicatorLayer.addSublayer(rectangle)
</code></pre>
<p>通过上面的代码，再次创建了一个Layer，这次使用的是CALayer，因为我们只需要一个很普通的Layer，为其设置位置、尺寸、背景色、圆角属性，然后添加在<code>replicatorLayer</code>中：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-5.png" alt="ReplicatorAnimation-5"></p>
<p>动画的主体之一已经绘制好了，下面我们让它动起来。在上述代码后面，接着添加如下代码：</p>
<pre><code class="swift">
let moveRectangle = CABasicAnimation(keyPath: &quot;position.y&quot;)
moveRectangle.toValue = rectangle.position.y - 70
moveRectangle.duration = 0.7
moveRectangle.autoreverses = true
moveRectangle.repeatCount = HUGE
rectangle.addAnimation(moveRectangle, forKey: nil)
</code></pre>
<p>首先我们创建了按Y轴移动的动画实例，然后设置了移动的目标位置，动画持续时间，重复次数设置为无限大。这里有一个属性大家可能比较陌生，那就是<code>autoreverses</code>，这个属性为Bool类型，设置为true时，开启自动反向执行动画，比如示例中的白色长方形的移动动画为向上移动50个像素，如过<code>autoreverses</code>设置为false，那么动画结束后，会根据重复次数，白色长方形重新回到初始位置，继续向上移动，如果<code>autoreverses</code>设置为true，则当动画结束后，白色长方形会继续向下移动至初始位置，然后再开始第二次的向上移动动画。</p>
<p>编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-6.gif" alt="ReplicatorAnimation-6"></p>
<p>至此，大家应该也已经看出来了，这个白色的长方形就是动画中第一个上下移动的白色长方形，那么后两个如何创建呢？还需要再写两遍上面的代码吗？请大家在下面的文章中寻找答案。</p>
<p>在上述代码下面再添加一行代码：</p>
<pre><code class="swift">
replicatorLayer.instanceCount = 3
</code></pre>
<p>显而易见，这是CAReplicatorLayer的能力了，这行代码的意思是将<code>replicatorLayer</code>的子Layer复制3份，复制Layer与原Layer的大小、位置、颜色、Layer上的动画等等所有属性都一模一样，所以这时编译运行代码我们看不到任何不同的效果，因为三个白色长方形是重合在一起的，所以我们需要设置每个白色长方形的间隔：</p>
<pre><code class="swift">
replicatorLayer.instanceTransform = CATransform3DMakeTranslation(40, 0, 0)
</code></pre>
<p>这行代码涉及到CAReplicatorLayer的另一个属性<code>instanceTransform</code>，它的作用是设置每个子Layer如何变化。<code>CATransform3DMakeTranslation</code>这个类的含义是使Layer根据X、Y、Z轴进行平移。现在再编译运行看看效果如何：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-7.gif" alt="ReplicatorAnimation-7"></p>
<p>现在三个白色长方形的运动轨迹和时刻都是一直的，这显然不是我们想要的结果，我们需要三个白色长方形有上下起伏的视觉效果，所以我们继续添加一行代码：</p>
<pre><code class="swift">
replicatorLayer.instanceDelay = 0.3
</code></pre>
<p><code>instanceDelay</code>这个属性使CAReplicatorLayer中的每个子Layer的动画起始时间逐个递增。这里我们设置为0.3秒，也就是第一个长方形先执行动画，过0.3秒后第二个开始执行动画，再过0.3秒后第三个开始执行动画。我们编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-8.gif" alt="ReplicatorAnimation-8"></p>
<p>显然我们只想显示<code>replicatorLayer</code>区域里的内容，我们并不想看到超出它边界的内容，所以我们再添加一行代码：</p>
<pre><code class="swift">
replicatorLayer.masksToBounds = true
</code></pre>
<p><code>masksToBounds</code>是CALayer的属性，作用是将Layer视为一个遮罩，只显示遮罩区域内的内容。最后我们回到初始化<code>replicatorLayer</code>的地方，找到这行代码<code>replicatorLayer.backgroundColor = UIColor.lightGrayColor().CGColor</code>，将<code>replicatorLayer</code>的背景色改为无色<code>replicatorLayer.backgroundColor = UIColor.clearColor().CGColor</code>。再次编译运行看看最终效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-9.gif" alt="ReplicatorAnimation-9"></p>
<h2 id="Replicator_Indicator_Animation"><a href="#Replicator_Indicator_Animation" class="headerlink" title="Replicator Indicator Animation"></a>Replicator Indicator Animation</h2><p>CAReplicatorLayer的功能是很强大的，这一节将通过另一个加载动画的实例向大家介绍它的其他特性。</p>
<p>首先打开<code>Main.storyboard</code>，拖进一个新的UIView，位置颜色随大家喜好：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-10.png" alt="ReplicatorAnimation-10"></p>
<p>随后添加该UIView在<code>ViewController.swift</code>中的Outlet <code>activityIndicatorView</code>：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-11.png" alt="ReplicatorAnimation-11"></p>
<p>然后在<code>ViewController.swift</code>中添加一个方法<code>activityIndicatorAnimation</code>，和上一个动画示例一样，我们先创建一个CAReplicatorLayer：</p>
<pre><code class="swift">
let replicatorLayer = CAReplicatorLayer()
replicatorLayer.bounds = CGRect(x: 0, y: 0, width: activityIndicatorView.frame.size.width, height: activityIndicatorView.frame.size.height)
replicatorLayer.position = CGPoint(x: activityIndicatorView.frame.size.width/2, y: activityIndicatorView.frame.size.height/2)
replicatorLayer.backgroundColor = UIColor.lightGrayColor().CGColor
activityIndicatorView.layer.addSublayer(replicatorLayer)
</code></pre>
<p>上述代码和上个示例中的差不多，唯一不同的就是<code>replicatorLayer</code>的锚点使用的是默认值，即锚点就是中点，<code>position</code>属性代表亦是中点，所以将<code>position</code>属性设置为父视图的中点即可。这里意在让大家多多理解CALayer中<code>anchorPoint</code>与<code>position</code>属性。接下来添加如下代码：</p>
<pre><code class="swift">
let circle = CALayer()
circle.bounds = CGRect(x: 0, y: 0, width: 15, height: 15)
circle.position = CGPoint(x: activityIndicatorView.frame.size.width/2, y: activityIndicatorView.frame.size.height/2 - 55)
circle.cornerRadius = 7.5
circle.backgroundColor = UIColor.whiteColor().CGColor
replicatorLayer.addSublayer(circle)
</code></pre>
<p>上述代码的目的是用CALayer创建一个圆形，其实CALayer创建出的形状默认是矩形，但是把四个角的弧度设置为边宽的一半，矩形就变成了圆形。将这个圆形的位置设置在父Layer的中间靠上位置，背景色设置为白色。此时该圆形就是文章开头效果图中第二个动画里的主体了：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-12.png" alt="ReplicatorAnimation-12"></p>
<p>不过在动画中我们看到有许多个小圆形组成一个大圆，如果重复上面的代码，一个一个设置位置，那绝对是令人发指的行为，好在我们有CAReplicatorLayer帮助我们实现，下面就来看看如何使用CAReplicatorLayer复制子Layer，并让子Layer形成一个圆形。让我们接着添加如下代码：</p>
<pre><code class="swift">
replicatorLayer.instanceCount = 15
let angle = CGFloat(2 * M_PI) / CGFloat(15)
replicatorLayer.instanceTransform = CATransform3DMakeRotation(angle, 0, 0, 1)
</code></pre>
<p>上述的代码中，首先对子Layer，也就是白色圆形复制了15份。然后将360°除以15份，算出每一个圆形针对它前一个圆形应该偏移的角度。最后我们用到了<code>CATransform3DMakeRotation</code>，它同样是<code>CATransform3D</code>的一个结构，含义是使Layer在X、Y、Z轴根据给定的角度旋转。这样我们复制的15份圆形就会按照我们计算的角度排列，并形成一个大圆：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-13.png" alt="ReplicatorAnimation-13"></p>
<p>接下来让我们分析一下这个动画，整体看上去感觉像一颗流星拖着尾巴在不停的转圈，但细看每一个小圆点，其实是在不停的进行放大缩小的动画，只不过每个小圆点的动画对于它前一个小圆点的动画有一定的延迟。所以首先我们需要实现小圆点放大缩小的动画，在上述代码后面接着添加如下代码：</p>
<pre><code class="swift">
let scale = CABasicAnimation(keyPath: &quot;transform.scale&quot;)
scale.fromValue = 1
scale.toValue = 0.1
scale.duration = 1
scale.repeatCount = HUGE
circle.addAnimation(scale, forKey: nil)
</code></pre>
<p>首先创建一个按比例缩放类型的动画，设置起始比例为1，也就是当前大小。再设置希望缩放到的比例为0.1。动画持续时间为1秒，重复无限次。最后将该动画添加在小圆点中。编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-14.gif" alt="ReplicatorAnimation-14"></p>
<p>目前每个小圆点是同时执行动画，我们需要设置小圆点的动画延迟时间，接着添加如下代码：</p>
<pre><code class="swift">
replicatorLayer.instanceDelay = 1/15
</code></pre>
<p>这里为什么是1/15呢，因为整个动画的时间是由每个小圆点的动画时间决定的，这里也就是1秒，所有小圆点的延迟时间加起来要等于整个动画的持续时间，所以这里就是用1秒除以小圆点的数量15。编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-15.gif" alt="ReplicatorAnimation-15"></p>
<p>从效果图中可以看到，刚开始的动画不是很自然，那是因为小圆点的初始比例是1，所以一开始会先看到小圆点，然后才会慢慢开始正常的动画。这个问题很好解决，我们让小圆点的初始比例为0.1，也就是刚开始看不到小圆点，这样就可以避免这个情况了，我们接着加一行代码：</p>
<pre><code class="swift">
circle.transform = CATransform3DMakeScale(0.01, 0.01, 0.01)
</code></pre>
<p>同时将<code>replicatorLayer</code>的背景色改为无色，再次编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/ReplicatorAnimation-16.gif" alt="ReplicatorAnimation-16"></p>
<p>展现在我们眼前的是一个完美的加载动画。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>今天主要给大家介绍了CAReplicatorLayer的用法，大家领悟其核心功能复制、延迟后也可以尝试实现其他有趣的动画效果。下篇文章我会向大家介绍CALayer另一个子类的用法，敬请期待吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-09-09/2825659" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>上一篇文章通过两个动画示例带大]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CALayer Animation - Loading Indicator]]></title>
    <link href="http://www.devtalking.com//articles/calayer-animation-loading-lndicator/"/>
    <id>http://www.devtalking.com//articles/calayer-animation-loading-lndicator/</id>
    <published>2015-09-06T16:00:00.000Z</published>
    <updated>2016-06-05T01:25:04.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-09-07/2825633" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="View_vs-_Layer"><a href="#View_vs-_Layer" class="headerlink" title="View vs. Layer"></a>View vs. Layer</h2><p>这篇文章通过两个加载动画向大家介绍CALayer的动画。按照面向对象的思想说，Layer其实就是一个模型类，像Java里的POJO类一样，它包含若干属性，并没有任何处理逻辑的方法，这些属性影响着显示在Layer中的内容。我们先来看看UIView和CALayer之间有什么区别和联系。</p>
<ul>
<li>联系：Layer是View背后的那个女人。每一个UIView后面都有对应的CALayer，大家看到的在UIView中显示的内容其实是在CALayer中。</li>
<li>区别：<ul>
<li>View有复杂的、各种组合的布局机制。Layer只有极简单的布局。</li>
<li>View可以响应用户交互。Layer不能响应用户交互。</li>
<li>View中的绘画逻辑有CPU执行。Layer中的绘画直接有GPU执行。</li>
<li>View有丰富的、功能强大的子类。Layer只有很少的几个子类。</li>
<li>View动画属性较少，局限性较大。Layer由于更底层、动画属性更多，所以可以实现出更灵活、更丰富的动画。</li>
</ul>
</li>
</ul>
<h2 id="u7B2C_u4E00_u4E2ACALayer_u52A8_u753B"><a href="#u7B2C_u4E00_u4E2ACALayer_u52A8_u753B" class="headerlink" title="第一个CALayer动画"></a>第一个CALayer动画</h2><p>Layer动画系列的文章，我不准备系统的从简单到复杂的知识进行讲解，我会通过各种实战示例，示例中用到什么知识点就讲什么知识点。</p>
<p>第一个动画让我们来实现Google Chrome浏览器加载时页签上的等待动画：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GoogleLoadingAnimation-1.gif" alt="GoogleLoadingAnimation-1"></p>
<p>新建项目<strong>GoogleLoading</strong>，打开<code>Main.storyboard</code>，拖拽一个UIView到ViewController中，添加好约束，自行设置ViewController和UIView的背景色，这里UIView的背景色我设置为无色：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GoogleLoadingAnimation-2.png" alt="GoogleLoadingAnimation-2"></p>
<p>然后添加该View的Outlet到<code>ViewController</code>中，这个UIView就是要展示加载动画的View：</p>
<pre><code class="swift">
@IBOutlet weak var loadingView: UIView!
</code></pre>
<p>打开<code>ViewController.swift</code>，申明一个常量属性<code>ovalShapleLayer</code>：</p>
<pre><code class="swift">
let ovalShapeLayer: CAShapeLayer = CAShapeLayer()
</code></pre>
<p><code>ovalShapleLayer</code>的类型是<code>CAShapleLayer</code>，它是<code>CALayer</code>的为数不多的子类之一。它的作用是在屏幕上画出各种形状，不论是简单的圆形、方形还是复杂的五角星或不规则图形都难不住它。<code>CAShapeLayer</code>有如下一些主要属性：</p>
<ul>
<li>strokeColor：笔画颜色。</li>
<li>strokeStart：笔画开始位置。</li>
<li>strokeEnd：笔画结束位置。</li>
<li>fillColor：图形填充颜色。</li>
<li>lineWidth：笔画宽度，即笔画的粗细程度。</li>
<li>lineDashPattern：虚线模式。</li>
<li>path：图形的路径。</li>
<li>lineCap：笔画未闭合位置的形状。</li>
</ul>
<p>我们之所要申明一个<code>CAShapeLayer</code>，是因为要用它在屏幕上画出一个圆形。下面在<code>viewDidLoad()</code>方法中添加如下代码：</p>
<pre><code class="swift">
ovalShapeLayer.strokeColor = UIColor.whiteColor().CGColor
ovalShapeLayer.fillColor = UIColor.clearColor().CGColor
ovalShapeLayer.lineWidth = 7
</code></pre>
<p>这几个属性刚才已经向大家介绍过了，这三行代码的意思是我们画出的圆形笔画颜色是白色，没有填充色，笔画的宽度为7。接着我们申明这个圆形的半径，使这个圆形的大小为容纳它视图大小的80%：</p>
<pre><code class="swift">
let ovalRadius = loadingView.frame.size.height/2 * 0.8
</code></pre>
<p>最后我们设置<code>ovalShapeLayer</code>的路径，这是最关键的一步，因为你要告知<code>CAShapeLayer</code>按照什么路径绘制图形，让我们接着添加如下代码：</p>
<pre><code class="swift">
ovalShapeLayer.path = UIBezierPath(ovalInRect: CGRect(x: loadingView.frame.size.width/2 - ovalRadius, y: loadingView.frame.size.height/2 - ovalRadius, width: ovalRadius * 2, height: ovalRadius * 2)).CGPath
</code></pre>
<p>这里出现了新面孔<code>UIBezierPath</code>，它可以创建基于矢量的路径，是Core Graphics框架关于path的封装。<code>UIBezierPath</code>可以定义简单的形状路径，如椭圆、矩形，或者有多个直线和曲线段组成的形状。在这里我们要使用它的初始化方法<code>init(ovalInRect rect: CGRect)</code>定义一个正圆的路径。设置完路径后，将<code>ovalShapeLayer</code>添加到<code>loadingView</code>视图的Layer中，它就可以按照设定好的路径在<code>loadingView</code>中绘制图形了：</p>
<pre><code class="swift">
loadingView.layer.addSublayer(ovalShapeLayer)
</code></pre>
<p>编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GoogleLoadingAnimation-3.png" alt="GoogleLoadingAnimation-3"></p>
<p>完美的一个圆形。接下来我们要做的是让这个圆只显示一部分，因为Google的加载动画只有大概五分之二的圆形轮廓。让我们继续将目光集中在<code>viewDidLoad()</code>方法中，在<code>loadingView.layer.addSublayer(ovalShapeLayer)</code>这行代码上面添加另一行代码：</p>
<pre><code class="swift">
ovalShapeLayer.strokeEnd = 0.4
</code></pre>
<p>上面的代码将<code>ovalShapeLayer</code>的<code>strokeEnd</code>属性设置为0.4，意思是<code>ovalShapeLayer</code>在绘制圆形时只画整个圆形的五分之二，即笔画结束的位置在整个圆形轮廓的五分之二处。编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GoogleLoadingAnimation-4.png" alt="GoogleLoadingAnimation-4"></p>
<p>看来是我们想要的效果，但是仍有一处细节需要我们完善，看看Google的加载动画，蓝色的部分圆形轮廓两头是圆形的，而我们的圆形轮廓两头是方形的。这个问题很好解决，仍然在<code>loadingView.layer.addSublayer(ovalShapeLayer)</code>这行代码上面添加一行代码：</p>
<pre><code class="swift">
ovalShapeLayer.lineCap = kCALineCapRound
</code></pre>
<p>这行代码的意思是将笔画两头的形状设置为圆形，对应的还有两个常量<code>kCALineCapButt</code>，<code>kCALineCapSquare</code>，大家可以试试。再次编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GoogleLoadingAnimation-5.png" alt="GoogleLoadingAnimation-5"></p>
<p>到目前为止，我们通过CALayer绘制出了动画的主体，接下来要让它动起来。在<code>ViewController.swift</code>中添加<code>beginSimpleAnimate()</code>方法：</p>
<pre><code class="swift">
func beginSimpleAnimation() {
    let rotate = CABasicAnimation(keyPath: &quot;transform.rotation&quot;)
    rotate.duration = 1.5
    rotate.fromValue = 0
    rotate.toValue = 2 * M_PI
    rotate.repeatCount = HUGE
    loadingView.layer.addAnimation(rotate, forKey: nil)
}
</code></pre>
<p>在这个方法中，我们又看到了新面孔<code>CABasicAnimation</code>，该类提供了基本的、单关键帧的Layer属性动画，通过<code>animationWithKeyPath:</code>初始化方法，根据<code>keyPath</code>创建不同的<code>CAPropertyAnimation</code>实例。常用的<code>keyPath</code>有如下一些：</p>
<ul>
<li><code>transform.rotation</code>：旋转动画。</li>
<li><code>transform.ratation.x</code>：按x轴旋转动画。</li>
<li><code>transform.ratation.y</code>：按y轴旋转动画。</li>
<li><code>transform.ratation.z</code>：按z轴旋转动画。</li>
<li><code>transform.scale</code>：按比例放大缩小动画。</li>
<li><code>transform.scale.x</code>：在x轴按比例放大缩小动画。</li>
<li><code>transform.scale.y</code>：在y轴按比例放大缩小动画。</li>
<li><code>transform.scale.z</code>：在z轴按比例放大缩小动画。</li>
<li><code>position</code>：移动位置动画。</li>
<li><code>opacity</code>：透明度动画。</li>
</ul>
<p>以上只是一部分常用的动画<code>keyPath</code>，更多的希望大家在实际运用中去挖掘。在<code>beginSimpleAnimation()</code>方法中，我们使用了<code>transform.rotation</code>，创建了一个旋转动画的实例，然后给该动画设置了四个属性：</p>
<ul>
<li><code>duration</code>：动画持续时间。</li>
<li><code>fromValue</code>：动画起始值。</li>
<li><code>toValue</code>：动画结束值。</li>
<li><code>repeatCount</code>：重复次数。</li>
</ul>
<p>该方法设置这几个属性的含义为使动画主体不停的旋转，旋转一圈的时间为1.5秒。以上这几个概念在UIView的动画中同样存在，大家应该都已经比较熟悉了。然后使用Layer的<code>addAnimation(anim: CAAnimation, forKey key: String?)</code>方法将旋转动画实例添加到目标Layer中，该方法的<code>key</code>是用来标示添加的动画，便于以后重复使用时能方便的检索，如果没有需求可以传值<code>nil</code>。最后<code>viewWillAppear</code>方法中调用<code>beginSimpleAnimation()</code>方法：</p>
<pre><code class="swift">
override func viewWillAppear(animated: Bool) {
    beginSimpleAnimation()
}
</code></pre>
<p>编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GoogleLoadingAnimation-6.gif" alt="GoogleLoadingAnimation-6"></p>
<p>至此我们的第一个简单的CALayer动画就完成了，在下一节我们一起实现一个更加有意思的加载动画，从而向大家介绍新的动画类型及动画组合。</p>
<h2 id="Stroke_Animation_u4E0EAnimation_Group"><a href="#Stroke_Animation_u4E0EAnimation_Group" class="headerlink" title="Stroke Animation与Animation Group"></a>Stroke Animation与Animation Group</h2><p>让我们先看看要实现的效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GoogleLoadingAnimation-7.gif" alt="GoogleLoadingAnimation-7"></p>
<p>这种加载动画在很多应用中都出现过，比如网易新闻、Win版的谷歌浏览器中都有使用。下面就让我们一步一步来实现吧，首先打开<code>Main.storyboard</code>，新添加一个UIView，在<code>ViewController.swift</code>中添加Outlet：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GoogleLoadingAnimation-8.png" alt="GoogleLoadingAnimation-8"></p>
<p>然后定义一个新的CAShapeLayer：</p>
<pre><code class="swift">
let anotherOvalShapeLayer: CAShapeLayer = CAShapeLayer()
</code></pre>
<p>在<code>viewDidLoad()</code>方法中对它进行设置，并将其添加到刚才创建的<code>complexLoadingView</code>中：</p>
<pre><code class="swift">
anotherOvalShapeLayer.strokeColor = UIColor.whiteColor().CGColor
anotherOvalShapeLayer.fillColor = UIColor.clearColor().CGColor
anotherOvalShapeLayer.lineWidth = 7

let anotherOvalRadius = complexLoadingView.frame.size.height/2 * 0.8
anotherOvalShapeLayer.path = UIBezierPath(ovalInRect: CGRect(x: complexLoadingView.frame.size.width/2 - anotherOvalRadius, y: complexLoadingView.frame.size.height/2 - anotherOvalRadius, width: anotherOvalRadius * 2, height: anotherOvalRadius * 2)).CGPath
anotherOvalShapeLayer.lineCap = kCALineCapRound

complexLoadingView.layer.addSublayer(anotherOvalShapeLayer)
</code></pre>
<p>这些操作在上一个动画都已经做过一遍了，这里就不再解释。编译运行看看是否屏幕上又出现了一个圆圈呢：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GoogleLoadingAnimation-9.gif" alt="GoogleLoadingAnimation-9"></p>
<p>接下来在<code>ViewController.swift</code>中添加一个方法<code>beginComplexAnimation()</code>：</p>
<pre><code class="swift">
let strokeStartAnimate = CABasicAnimation(keyPath: &quot;strokeStart&quot;)
strokeStartAnimate.fromValue = -0.5
strokeStartAnimate.toValue = 1

let strokeEndAnimate = CABasicAnimation(keyPath: &quot;strokeEnd&quot;)
strokeEndAnimate.fromValue = 0.0
strokeEndAnimate.toValue = 1

let strokeAnimateGroup = CAAnimationGroup()
strokeAnimateGroup.duration = 1.5
strokeAnimateGroup.repeatCount = HUGE
strokeAnimateGroup.animations = [strokeStartAnimate, strokeEndAnimate]
anotherOvalShapeLayer.addAnimation(strokeAnimateGroup, forKey: nil)
</code></pre>
<p>这里出现了两个新的动画类型，笔画开始动画和笔画结束动画，我们虽然使用CAShapeLayer绘制了一个圆圈，但是它也存在笔画起始位置和笔画终止位置，只不过它俩在同一个位置而已，笔画动画的位置取值在0-1之间，0代表绘制路径的起始位置，1代表绘制路径的终止位置。所以<code>strokeStartAnimate</code>动画让绘制圆圈的笔画起始位置从-0.5开始，目的是让笔画起始绘制时等待一段时间，也就是起始位置延迟绘制。而<code>strokeEndAnimate</code>动画让绘制圆圈的笔画终止位置正常的从0绘制到1。这样一来笔画两头绘制的时间就会不一样，会有一个时间差，这样就有圆圈不断绘制又不断被擦除的效果。</p>
<p><code>strokeStartAnimate</code>和<code>strokeEndAnimate</code>是两个动画，如何作用于一个Layer上呢？这时就要用到<code>CAAnimationGroup</code>，顾名思义它是将多个动画组成一个组，在一个动画组里，子动画会同时进行。动画组可以设置动画持续时间、重复次数以及子动画数组。最后将动画组加在Layer上即可。</p>
<p>最后在<code>viewWillAppear()</code>方法中调用<code>beginComplexAnimation()</code>方法：</p>
<pre><code class="swift">
override func viewWillAppear(animated: Bool) {
    beginSimpleAnimation()
    beginComplexAnimation()
}
</code></pre>
<p>编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GoogleLoadingAnimation-10.gif" alt="GoogleLoadingAnimation-10"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>CALayer动画可以实现比UIView动画更丰富、更底层、效率更高的动画。但是在实际的应用开发中，我们应该按需所用，能用UIView动画实现的我们就可以不用CALayer动画，它俩没有谁优谁劣之分。这篇文章只是CALayer动画的引子，让大家对CALayer动画有初步的了解和认识，之后我在文章中会通过更多的实例帮大家更深入的认识CALayer动画，从而提升自己应用的用户体验。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-09-07/2825633" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="View_vs-_L]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[UIStackView小窥]]></title>
    <link href="http://www.devtalking.com//articles/uistackview/"/>
    <id>http://www.devtalking.com//articles/uistackview/</id>
    <published>2015-08-03T16:00:00.000Z</published>
    <updated>2016-01-31T03:00:45.000Z</updated>
    <content type="html"><![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-08-04/2825372/1" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>自适应、适配、布局这几个关键词一直伴随着iOS开发，从以前的单一尺寸屏幕，到现在的多尺寸屏幕，Apple一直致力于让开发人员尽可能少在这些事上耗费过多的精力，所以Apple在2012年推出了Auto Layout特性，2014年又推出了Adaptive Layout、Size Classes，2015年又推出了Stack View。这些无一不是我们开发者做适配的利器。今天就让我们看看StackView是怎么一回事。</p>
<blockquote>
<p>注：示例开发环境为Xcode7 Beta2</p>
</blockquote>
<p>我们先来看看下面这个常见的布局：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-1.png" alt="StackView-1"></p>
<p>这是一种很常见的汉堡布局，如果我们需要让它自适应不同尺寸的屏幕，我们要添加哪些约束呢？</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-2.png" alt="StackView-2"></p>
<p>看看图中这些约束，你们会不会感到莫名的烦躁呢，至少我是的。更让人抓狂的是，如果需要在中间再添加一个长方形，那么你要修改关联的好几个约束，有没有掀桌的冲动呢？</p>
<p>不过，我们开发人员总是幸运的，Apple在Xcode7中添加了一个新的特性StackView，它能完美的解决这个闹心的问题。</p>
<p>StackView其实一个视图容器，不过它会对它的子视图根据一定规则自动布局，将子视图按栈的排列方式进行布局，并且有几个主要的属性：</p>
<ul>
<li><p>方向<br>StackView有水平和垂直两个方向的布局模式：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-3.png" alt="StackView-3"></p>
</li>
<li><p>间隔<br>StackView可以设置子视图之间的间隔：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-4.png" alt="StackView-4"></p>
</li>
<li><p>对齐方式<br>StackView可以设置子视图的对齐方式（水平方向和垂直方向的该属性值有所区别）：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-5.png" alt="StackView-5"></p>
<ul>
<li>Fill：子视图填充StackView。</li>
<li>Leading：靠左对齐。</li>
<li>Trailing：靠右对齐。</li>
<li>Center：子视图以中线为基准对齐。</li>
<li>Top：靠顶部对齐。</li>
<li>Bottom：靠底部对齐。</li>
<li>First Baseline：按照第一个子视图中文字的第一行对齐。</li>
<li>Last Baseline：按照最后一个子视图中文字的最后一行对齐。</li>
</ul>
</li>
<li><p>分布比例<br>StackView可以设置子视图的分布比例：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-6.png" alt="StackView-6"></p>
<ul>
<li>Fill：默认分布方式。</li>
<li>Fill Equally：子视图的高度或宽度保持一致。</li>
<li>Fill：Proportionally：StackView自己计算出它认为合适的分布方式。</li>
<li>Equal Spacing：子视图保持同等间隔的分布方式。</li>
<li>Equal Centering：每个子视图中心线之间保持一致的分布方式。</li>
</ul>
</li>
</ul>
<p>一切让示例来说话，在这篇文章中我们将逐步开发一个电影影评的应用来详细讲解如何使用StackView。</p>
<h2 id="u7B2C_u4E00_u4E2AStackView"><a href="#u7B2C_u4E00_u4E2AStackView" class="headerlink" title="第一个StackView"></a>第一个StackView</h2><p>打开Xcode，新建一个项目，命名为MovieRate，语言选择Swift。打开Storyboard，删掉当前的ViewController视图，重新拖入TableViewController视图，然后内嵌一个NavigationController，配色大家随意：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-7.png" alt="StackView-7"></p>
<p>然后再删掉初始的<code>ViewController.swfit</code>文件，新建一个UITableViewController名为<code>MovieListTableViewController.swift</code>，以及一个UITableViewCell名为<code>MovieTabelViewCell.swift</code>：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-8.png" alt="StackView-8"></p>
<p>这两个文件的作用不言而喻：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-9.png" alt="StackView-9"></p>
<p>接下来新建一个plist文件<code>Movie.plist</code>，当做TableView的数据源：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-10.png" alt="StackView-10"></p>
<p>然后打开StoryBoard，选择<code>MovieListTableViewController</code>，给<code>MovieTableViewCell</code>设置一个标示符<code>MovieCell</code>，往<code>MovieTableViewCell</code>中拖入两个UIImageView和一个UILabel，不用理会他们的位置和尺寸：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-11.png" alt="StackView-11"></p>
<p>按着command键，同时选中这三个视图，然后点击右下角的Stack按钮：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-12.png" alt="StackView-12"></p>
<p>这时，我们便创建的一个UIStackView，包含刚才选中的那三个视图，或者说我们将选中的那三个视图组合成了一个UIStackView：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-13.png" alt="StackView-13"></p>
<p>选中这个StackView，打开右侧的属性编辑窗口，可以看到在文章前言中讲过的四个主要属性：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-14.png" alt="StackView-14"></p>
<p>虽然被包含的两个的UIImageView和UILabel可以由UIStackView的属性设置布局，但是就UIStackView本身而言，我们还是需要设置它的相关约束：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-15.png" alt="StackView-15"></p>
<p>这两个UIImageView一个展示电影封面图片，一个展示评分，我们在StoryBoard中设置它们的image属性，并将Model设置为Aspect Fit，看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-16.png" alt="StackView-16"></p>
<p>理想总是很丰满，现实总是很骨感，设置了图片后并不是我们想要的结果，图片的大小以及与文字的间隔都有问题。而且还出现了约束错误：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-17.png" alt="StackView-17"></p>
<p>意思是StackView里的这三个内容没有指定x坐标的约束或者宽度的约束。但是作为StackView的子视图，它们的布局情况是由StackView通过各个属性设置的，断然不能在自身上添加约束，那么如何解决这个问题呢？其实很简单，我们选中中间的UILabel，然后打开右侧的尺寸属性面板，找到这两栏：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-18.png" alt="StackView-18"></p>
<p><em>Content Hugging Priority</em>是水平、垂直方向的拉伸优先级，我们将<em>Horizontal</em>设置为250。这样就可以告诉StackView，中间的UILabel水平拉伸的优先级是最高的，当StackView的宽度变大时优先拉伸UILabel的宽度，这样前后两个UIImageView的宽度是保持不变的，否则会默认拉伸StackView中的第一个子视图，所以我们看到第一个UIImageView的宽度被拉伸了。</p>
<p><em>Content Compression Resistance Priority</em>是水平、垂直方向的压缩优先级，道理和上面的拉伸优先级是一样的，我们将UILabel的水平压缩优先级设为749。</p>
<p>现在你们会发现约束错误消失了，第一个UIImageView的宽度也正常了，而中间的UILabel被拉伸了：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-19.png" alt="StackView-19"></p>
<p>接下来在<code>MovieTableViewCell</code>中添加这两个UIImageView和UILabel的<code>IBOutlet</code>：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-20.png" alt="StackView-20"></p>
<p>然后在<code>MovieListTableViewController</code>中实现TableView的数据展示：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-21.png" alt="StackView-21"></p>
<p>然后编译运行程序看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-22.png" alt="StackView-22"></p>
<p>横屏也很完美：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-27.png" alt="StackView-27"></p>
<p>一个完美的Movie List页面已经展现在我们眼前，电影封面、电影名称、电影评分被StackView按合理的布局组织在TableViewCell里，我们只是给StackView设置了简单的四个约束而已。可见StackView在视图布局方面可以给我们带来很大的便利。</p>
<h2 id="StackView_u7684_u5D4C_u5957"><a href="#StackView_u7684_u5D4C_u5957" class="headerlink" title="StackView的嵌套"></a>StackView的嵌套</h2><p>既然UIStackView继承了UIView，那么UIStackView是否可以看做是一个UIView而被包含在UIStackView内呢？答案是肯定的，这一节向大家介绍UIStackView的嵌套。</p>
<p>一些界面发杂的App，只要你仔细分析，总会发现StackView嵌套的布局，或看似相似的布局：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-23.png" alt="StackView-23"></p>
<p>在MovieRate这个示例中，我们将StackView的嵌套运用在电影详情页面里：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-24.png" alt="StackView-24"></p>
<p>上图是电影详情页的布局图，从图中我们可以看到一共有三个StackView，一个嵌套在一个里面。我们在Storyboard中把这个页面创建出来（StackView的创建方法在上一节中已经介绍过了，这里就不再累赘了）：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-25.png" alt="StackView-25"></p>
<p>详情页的数据直接写在Storyboard中了，因为只是说明StackView的嵌套特性，所以界面比较粗糙。点击TableViewCell跳转到详情页的过程不再累赘了，编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIStackView-26.png" alt="StackView-26"></p>
<p>虽然有点丑，但是这个页面展示出了StackView的嵌套特性。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>诚然UIStackView不是万能的，但是无疑它可以在布局和自适应方面给开发者带来便利，在恰当的情形下使用StackView可以事半功倍。而且因为UIStackView是UIView的子类，所以也可以将动画效果作用于UIStackView上，在方便布局之余还能提高用户体验，何乐而不为呢，那么让我们用起来吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文首发<a href="http://www.csdn.net/article/2015-08-04/2825372/1" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="u524D_u8]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
      <category term="UIKit" scheme="http://www.devtalking.com/tags/UIKit/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS UIView Animation - Keyframe]]></title>
    <link href="http://www.devtalking.com//articles/uiview-keyframe-animation/"/>
    <id>http://www.devtalking.com//articles/uiview-keyframe-animation/</id>
    <published>2015-07-27T16:00:00.000Z</published>
    <updated>2016-03-01T08:28:14.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p> 本文首发<a href="http://www.csdn.net/article/2015-07-28/2825314-ios-uiview-animation-5" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
</blockquote>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>有些时候大家可能会遇到制作复杂、具有连贯性UIView动画的需求，这时大家可能会使用在<code>completion</code>闭包中衔接一段一段的动画，使之成为一段连续的动画。</p>
<p>如果我们只是连接2个，或者3个动画，这种方式或许还行得通，但如果有更多的动画片段需要连接的时候，这种方式会带来灾难性的问题，你的代码会非常的冗余，不断的在<code>completion</code>闭包中嵌套代码，使代码维护起来相当的困难。所以今天向大家介绍能更好地实现这个需求的方法，Keyframe动画。</p>
<p>Keyframe动画可以让我们有效的拆分由若干段动画连接而成的复杂动画，可以较为精准的定义每段动画的起始点及持续时间，并且在代码组织方面也非常清晰。先看看今天要带大家实现的动画Demo：</p>
<iframe src="https://player.vimeo.com/video/134543973?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<h2 id="u4F7F_u7528_u573A_u666F"><a href="#u4F7F_u7528_u573A_u666F" class="headerlink" title="使用场景"></a>使用场景</h2><p>我们先来认识一下，在什么样的场景下需要使用Keyframe动画。如图下所示，这是一个由四段动画组成的一个复杂动画，让UIView沿着长方形的轨迹运动：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIViewAnimation-Keyframe-2.png" alt="Keyframe-1"></p>
<p>我们来看看用代码如何实现：</p>
<pre><code class="swift">
UIView.animateWithDuration(1, animations: {
    view.center.x += 200.0
}, completion: { _ in
    UIView.animateWithDuration(1, animations: {
        view.center.y += 100.0
    }, completion: { _ in
        UIView.animateWithDuration(1, animations: {
            view.center.x -= 200.0
        }, completion: { _ in
            UIView.animateWithDuration(1, animations: {
                view.center.y -= 100.0
            }, completion: nil)
        })
    })
})
</code></pre>
<p>通过上面的伪代码可以看到，我们使用了<code>completion</code>闭包的方式连接每一段的动画，代码看起来尚且算清晰，可读性也马马虎虎。但是大家想象一下，如果我们使UIView按照一个复杂的路线运行，这一段动画可能有十几、几十段动画组成的，那么如果再使用<code>completion</code>闭包这种方式连接，那代码是多么的惨不忍睹。幸好我们有Keyframe动画，下面就让我们来看看如何使用Keyframe动画。</p>
<h2 id="Keyframe_u52A8_u753B"><a href="#Keyframe_u52A8_u753B" class="headerlink" title="Keyframe动画"></a>Keyframe动画</h2><p>首先我们会使用到UIView的另一个动画方法<code>animateKeyframesWithDuration(_: delay: options: animations: completion: )</code>：</p>
<pre><code class="swift">
UIView.animateKeyframesWithDuration(2, delay: 0, options: [], animations: {
    // add keyframes
}, completion: nil)
</code></pre>
<p>这个方法的几个参数与前几个使用过的动画方法参数一样。上面代码片段的意思是整个关键帧动画的持续时间为2秒、无延迟、无动画选项、执行完毕后无后续执行的代码。</p>
<blockquote>
<p>注：该方法的动画选项不再是<code>UIViewAnimationOptions</code>，而是<code>UIViewKeyframeAnimationOptions</code>。具体的内容大家可以去查阅Apple的文档。</p>
</blockquote>
<p>接下来我们要在<code>animations</code>闭包中添加关键帧了：</p>
<pre><code class="swift">
UIView.animateKeyframesWithDuration(2, delay: 0, options: [], animations: {
    UIView.addKeyframeWithRelativeStartTime(0, relativeDuration: 0.25, animations: {
        view.center.x += 200.0
    })
}, completion: nil)
</code></pre>
<p><code>addKeyframeWithRelativeStartTime(_: relativeDuration: animations: )</code>是UIView添加关键帧的方法，该方法有三个参数：</p>
<ul>
<li>startTime：关键帧开始时间，该时间是相对整个关键帧动画持续时间的相对时间，一般值在0到1之间。如果为0，则表明这一关键帧从整个动画的第0秒开始执行，如果设为0.5，则表明从整个动画的中间开始执行。</li>
<li>relativeDuration：关键帧持续时间，该时间同样是相对整个关键帧动画持续时间的相对时间，一般值也在0到1之间。如果设为0.25，则表明这一关键帧的持续时间为整个动画持续时间的四分之一。</li>
<li>animations：设置视图动画属性的动画闭包。</li>
</ul>
<p>我们解释一下上面这段代码。整个关键帧动画的持续时间为2秒，第一个关键帧从第0秒开始，运行0.5秒结束。下面我们完成其他三个关键帧：</p>
<pre><code class="swift">
UIView.animateKeyframesWithDuration(2, delay: 0, options: [], animations: {
    UIView.addKeyframeWithRelativeStartTime(0, relativeDuration: 0.25, animations: {
        view.center.x += 200.0
    })
    UIView.addKeyframeWithRelativeStartTime(0.25, relativeDuration: 0.25, animations: {
        view.center.y += 100.0
    })
    UIView.addKeyframeWithRelativeStartTime(0.5, relativeDuration: 0.25, animations: {
        view.center.x -= 200.0
    })
    UIView.addKeyframeWithRelativeStartTime(0.75, relativeDuration: 0.25, animations: {
        view.center.y -= 100.0
    })
}, completion: nil)
</code></pre>
<p>第二个关键帧的开始时间为0.25，也就是从整个动画时间的第0.5时开始执行，同样持续0.5秒。后两个关键帧的参数就不难理解了。</p>
<p>现在整个代码看起来非常整洁，条理清晰，可读性非常好，而且可以有更精确的控制。即使再多几个关键帧也同样可以从容应对。</p>
<p>关键帧动画不仅仅用于同一个视图的分段动画，也可使使用于不同视图的组合动画，由于我们还没讲到图层动画，所以，开篇的示例动画中就使用了关键帧动画实现了多个视图的组合动画。</p>
<h2 id="u793A_u4F8B_u52A8_u753B"><a href="#u793A_u4F8B_u52A8_u753B" class="headerlink" title="示例动画"></a>示例动画</h2><p>在这个示例中虽然看起来是一个纸飞机视图的连续动画，但其实是由三个纸飞机视图组合而成的：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIViewAnimation-Keyframe-3.png" alt="Keyframe-2"></p>
<p>从图中可以看到其实是有三个纸飞机视图，只不过在界面加载之前2号和3号纸飞机视图的透明度都是为零。</p>
<p>整个动画是由这三个纸飞机视图通过关键帧动画组合而成：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIViewAnimation-Keyframe-4.png" alt="Keyframe-3"></p>
<p>图中标示出了三个飞机视图的运行轨迹、视图大小、视图透明度的状态，我们来看看代码如何实现：</p>
<pre><code class="swift">
let zoomInScaleTransform = CGAffineTransformMakeScale(0.2, 0.2)
UIView.animateKeyframesWithDuration(3, delay: 0, options: [], animations: {
    UIView.addKeyframeWithRelativeStartTime(0, relativeDuration: 0.2, animations: {
        self.customHeaderView.paperAirplane.center.x += self.view.frame.width
        self.customHeaderView.paperAirplane.center.y += -180
        self.customHeaderView.paperAirplane.transform = zoomInScaleTransform
    })
    UIView.addKeyframeWithRelativeStartTime(0.3, relativeDuration: 0.01, animations: {
        self.customHeaderView.paperAirplaneOpposite.alpha = 1
        self.customHeaderView.paperAirplaneOpposite.transform = zoomInScaleTransform
    })
    UIView.addKeyframeWithRelativeStartTime(0.3, relativeDuration: 0.5, animations: {
        self.customHeaderView.paperAirplaneOpposite.transform = CGAffineTransformIdentity
        self.customHeaderView.paperAirplaneOpposite.center.x -= self.view.frame.width
        self.customHeaderView.paperAirplaneOpposite.center.y += 90
    })
    UIView.addKeyframeWithRelativeStartTime(0.9, relativeDuration: 0.01, animations: {
        self.customHeaderView.paperAirplaneComeBack.alpha = 1
    })
    UIView.addKeyframeWithRelativeStartTime(0.9, relativeDuration: 0.2, animations: {
        self.customHeaderView.paperAirplaneComeBack.center.x += 33
    })
}, completion: { _ in
    self.restorePaperAirplaneStatus()
})
</code></pre>
<p>大家看到这大家可能会有疑问了，三段动画怎么会有五个关键帧呢，我们来刨析一下：</p>
<ul>
<li>第一个关键帧：完成1号纸飞机视图运动到右上角并移出屏幕，视图逐渐变小的动画。该关键帧从整个动画的第0秒开始执行，持续时间为0.6秒。</li>
<li>第二个关键帧：由于2号纸飞机视图的初始透明度为零，所以在第二个关键帧将透明度设为1，并且缩小视图。注意这两个动作需要在瞬间完成，所以<code>relativeDuration</code>设为0.01，一个极短的时间。开始时间为整个动画的第0.9秒开始，较第一个关键帧延迟0.3秒。</li>
<li>第三个关键帧：与第二个关键帧同时开始执行，完成2号纸飞机视图从小变大、并且往左下角运动，一直移出屏幕。持续时间为1.5秒。</li>
<li>第四个关键帧：与第二个关键帧作用相似，改变3号纸飞机视图的透明度，同样是在瞬间完成。</li>
<li>第五个关键帧：与第四个关键帧同时执行， 完成向右移动的动画，持续0.6秒。</li>
</ul>
<p>关键帧完成之后，在<code>completion</code>闭包中调用<code>restorePaperAirplaneStatus()</code>方法，恢复3个纸飞机视图的状态及位置，以便再次执行动画。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>大家在使用关键帧动画时，对于关键帧的开始时间和持续时间需要仔细设置，保证每个关键帧在合适的时间开始，执行恰当的持续时间。在必要时候也需要在关键帧里修改视图的一些状态，但要设置极短的持续时间，表示瞬间完成。</p>
<p>下一篇会向大家介绍在使用Auto Layout的情况下，如何通过约束实现动画，好了今天就先到这里吧。</p>
<p>参考文献来自：<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p> 本文首发<a href="http://www.csdn.net/article/2015-07-28/2825314-ios-uiview-animation-5" target="_blank" rel="external">CSDN</a>]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS UIView Animation - Practice]]></title>
    <link href="http://www.devtalking.com//articles/uiview-animation-practice/"/>
    <id>http://www.devtalking.com//articles/uiview-animation-practice/</id>
    <published>2015-07-20T16:00:00.000Z</published>
    <updated>2016-03-01T08:32:00.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p> 本文首发<a href="http://www.csdn.net/article/2015-07-20/2825255-ios-uiview-animation-4-practice/1" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
</blockquote>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>上三篇关于UIView Animation的文章向大家介绍了基础的UIView动画，包括移动位置、改变大小、旋转、弹簧动画、过渡动画。这些虽然看起来很简单，但是如果我们仔细分析、分解一个复杂动画时，就会发现这些复杂的动画其实是由若干基础的动画组合而成的。今天这篇文章是实践篇，我选择了Raywenderlich <a href="http://www.raywenderlich.com/73286/top-5-ios-7-animations" target="_blank" rel="external">Top 5 iOS 7 Animations</a>这篇文章中的一个动画效果，带大家一起实现。要实现这个动画效果，除了用到我们上三篇介绍过的知识点以外，还有两个知识点在这篇会介绍给大家，我们先看看实现的效果：</p>
<iframe src="https://player.vimeo.com/video/133654890?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>这个动画示例实现的是一个展示航班信息的应用，左右滑动显示不同的航班信息。我们可以分析一下都用到了哪些动画：</p>
<ul>
<li>淡入淡出：起飞地和目的地、起飞地和目的地下面的横线、底部的航班时间都使用了该动画。</li>
<li>位置移动：起飞地和目的地、小飞机都使用了该动画。</li>
<li>旋转：航站楼登机口前面的小箭头、小飞机都使用了该动画。</li>
<li>过渡动画： 背景图片使用了淡入淡出效果的图片替换过渡动画。</li>
<li>伪3D动画：顶部的时间、航班号、航站楼登机口信息、底部的起飞降落文字都是用了该动画。</li>
</ul>
<p>前三个动画我们之前已经介绍过了，现在我们来介绍后两个动画。</p>
<h2 id="u4F2A3D_u52A8_u753B_u6548_u679C"><a href="#u4F2A3D_u52A8_u753B_u6548_u679C" class="headerlink" title="伪3D动画效果"></a>伪3D动画效果</h2><p>这个伪3D的效果模拟的是一个立体长方形由一面翻转到另一面。因为这不是真正的3D效果，所以我们可以分析一下它是如何模拟的，以上面动画中从下往上翻的效果为例。首先显示的是一个<code>UILabel</code>，当开始进行翻转时，当前显示的<code>UILabel</code>的高度开始慢慢变矮：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIViewAnimation-Practice-1.png" alt="Practice-1"></p>
<p>我们看看用代码怎么实现：</p>
<pre><code class="swift">
UIView.animateWithDuration(1, animations: {
    self.devtalkingLabel.transform = CGAffineTransformMakeScale(1.0, 0.5)
})
</code></pre>
<p>我们可以使用一个转换动画，使用<code>CGAffineTransformMakeScale</code>，它的第一个参数是x坐标的比例，第二个参数是y坐标的比例，这两个值的范围是1.0到0之间。上面的代码用白话文翻译出来就是在1秒内，<code>devtalkingLabel</code>的宽度不变，高度减少一半，减少的过程会自动生成补间动画。</p>
<p>我们接着来分析，在<code>UILabel</code>高度减少的同时，它的位置也会向上移动，我们可以用另外一个转换的动画：</p>
<pre><code class="swift">
UIView.animateWithDuration(1, animations: {
    self.devtalkingLabel.transform = CGAffineTransformMakeScale(1.0, 0.5)
    self.devtalkingLabel.transform = CGAffineTransformMakeTranslation(1.0, -self.devtalkingLabel.frame.height / 2)
})
</code></pre>
<p><code>CGFffineTransformMakeTranslation</code>这个转换动画可以移动UIView的位置，这里需要注意它是以初始位置为基础进行移动的，所以上述代码在字面上的意思是<code>devtalkingLabel</code>在高度变小的同时向上移动它初始宽度一半的距离：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIViewAnimation-Practice-2.png" alt="Practice-2"></p>
<p>但是当我们编译运行后发现事与愿违，转换动画不像动画属性动画那样可以在<code>animations</code>闭包中写多个进行组合，而是由另一个组合转换动画来实现：</p>
<pre><code class="swift">
UIView.animateWithDuration(1, animations: {
    self.devtalkingLabel.transform = CGAffineTransformConcat(CGAffineTransformMakeScale(1.0, 0.5), CGAffineTransformMakeTranslation(1.0, -self.devtalkingLabel.frame.height / 2))
    self.devtalkingLabel.alpha = 0
})
</code></pre>
<p>来看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIViewAnimation-Practice-4.png" alt="Practice-4"></p>
<p>此时，3D翻转效果的一个面已经成型了，也就是当前显示的这一面被向上翻转到顶部去了。接下来我们要实现底部的面翻转到当前显示的这一面。很明显这需要两个面，但我们只有一个<code>UILabel</code>，所以在执行整个翻转效果前需要先复制一个当前<code>UILabel</code>：</p>
<pre><code class="swift">
let devtalkingLabelCopy = UILabel(frame: self.devtalkingLabel.frame)
devtalkingLabelCopy.alpha = 0
devtalkingLabelCopy.text = self.devtalkingLabel.text
devtalkingLabelCopy.font = self.devtalkingLabel.font
devtalkingLabelCopy.textAlignment = self.devtalkingLabel.textAlignment
devtalkingLabelCopy.textColor = self.devtalkingLabel.textColor
devtalkingLabelCopy.backgroundColor = UIColor.clearColor()
</code></pre>
<p>这样我们就复制了一个<code>devtalkingLabel</code>，这个复制品将作为底部的那一面，而且在一开始它的透明度是零，因为底面是看不到的。我们可以想象一下底面向上翻转的效果，其实就是底面的高度从很小慢慢变大，位置从下慢慢向上移动，然后有一个淡入的效果，所以我们在复制出<code>devtalkingLabelCopy</code>后，要调整它的高度和位置，然后添加到父视图中：</p>
<pre><code class="swift">
devtalkingLabelCopy.transform = CGAffineTransformConcat(CGAffineTransformMakeScale(1.0, 0.1), CGAffineTransformMakeTranslation(1.0, self.devtalkingLabel.frame.height / 2))
self.view.addSubview(devtalkingLabelCopy)
</code></pre>
<p>上述代码将<code>devtalkingLabelCopy</code>的高度减小到原本的十分之一，位置向下移动半个高度的位置，然后在之前的<code>animateWithDuration</code>方法的<code>animations</code>闭包中添加如下两行代码：</p>
<pre><code class="swift">
devtalkingLabelCopy.alpha = 1
devtalkingLabelCopy.transform = CGAffineTransformIdentity
</code></pre>
<p><code>CGAffineTransformIdentity</code>的作用是将<code>UIView</code>的<code>transform</code>恢复到初始状态，然后将透明度设为1。编译运行代码我们会看到<code>devtalkingLabel</code>的高度会慢慢变小，位置慢慢上移，最后淡出，<code>devtalkingLabelCopy</code>的高度慢慢变大，位置慢慢上移，最后淡入，整个效果看上去就像一个长方体在向上翻转，达到3D的效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIViewAnimation-Practice-5.png" alt="Practice-5"></p>
<h2 id="u66FF_u6362UIView_u8FC7_u6E21_u52A8_u753B"><a href="#u66FF_u6362UIView_u8FC7_u6E21_u52A8_u753B" class="headerlink" title="替换UIView过渡动画"></a>替换UIView过渡动画</h2><p>在要实现的动画示例中，背景图做了淡入淡出的图片替换过渡动画，这个动画很简单，我们来看看这段伪代码：</p>
<pre><code class="swift">
UIView.transitionWithView(backgroundImageView, duration: 2, options: .TransitionCrossDissolve, animations: {
    backgroundImageView.image = UIImage(named: &quot;imageName&quot;)
}, completion: nil)
</code></pre>
<p>这个方法在上一篇文章中已经介绍过，我们只需要设置动画选项为<code>.TransitionCrossDissolve</code>，在<code>animations</code>闭包中给目标<code>UIImageView</code>设置要过渡的图片即可。</p>
<h2 id="u793A_u4F8B_u52A8_u753B"><a href="#u793A_u4F8B_u52A8_u753B" class="headerlink" title="示例动画"></a>示例动画</h2><p>至此，示例动画中用到的动画知识点都向大家介绍过了，在这一节我会将示例动画中主要的效果的伪代码贴出来给大家说说。关于左右滑动的手势以及<code>PageControl</code>在这里就不在累赘了。</p>
<h3 id="u6570_u636E_u6E90"><a href="#u6570_u636E_u6E90" class="headerlink" title="数据源"></a>数据源</h3><p>为了方便，我们创建一个<code>Flight.plist</code>文件作为数据源：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/UIViewAnimation-Practice-6.png" alt="Practice-6"></p>
<p>我们定义一个延迟加载的属性<code>flight</code>：</p>
<pre><code class="swift">
lazy var flight: NSArray = {
    let path = NSBundle.mainBundle().pathForResource(&quot;Flight&quot;, ofType: &quot;plist&quot;)
    return NSArray(contentsOfFile: path!)!
}()
</code></pre>
<h3 id="u80CC_u666F_u56FE_u7247_u8FC7_u6E21"><a href="#u80CC_u666F_u56FE_u7247_u8FC7_u6E21" class="headerlink" title="背景图片过渡"></a>背景图片过渡</h3><pre><code class="swift">
UIView.transitionWithView(self.backgroundImageView, duration: 2, options: .TransitionCrossDissolve, animations: {
    self.backgroundImageView.image = UIImage(named: flightItem[&quot;bg&quot;] as! String)
}, completion: nil)
</code></pre>
<p>上一节刚介绍过，只是这里图片名称是从数据源中获取的。</p>
<h3 id="3D_u7FFB_u8F6C"><a href="#3D_u7FFB_u8F6C" class="headerlink" title="3D翻转"></a>3D翻转</h3><p>因为有3D翻转动画效果的<code>UIView</code>比较多，而且有<code>UILabel</code>也有<code>UIImageView</code>，所以我们可以提炼成一个方法，将目标<code>UIView</code>和数据源作为参数：</p>
<pre><code class="swift">
func cubeAnimate(targetView: UIView, flightInfo: String) {
    // 判断UIView的具体实现类
    if targetView.isKindOfClass(UILabel) {
        let virtualTargetView = targetView as! UILabel
        // 复制UIView，作为底面
        let viewCopy = UILabel(frame: virtualTargetView.frame)
        viewCopy.alpha = 0
        viewCopy.text = flightInfo
        viewCopy.font = virtualTargetView.font
        viewCopy.textAlignment = virtualTargetView.textAlignment
        viewCopy.textColor = virtualTargetView.textColor
        viewCopy.backgroundColor = UIColor.clearColor()
        // 设置底面UIView的初始位置和高度
        viewCopy.transform = CGAffineTransformConcat(CGAffineTransformMakeScale(1.0, 0.1), CGAffineTransformMakeTranslation(1.0, viewCopy.frame.height / 2))
        self.topView.addSubview(viewCopy)
        UIView.animateWithDuration(2, animations: {
            // 执行UIView和UIViewCopy的动画
            virtualTargetView.transform = CGAffineTransformConcat(CGAffineTransformMakeScale(1.0, 0.1), CGAffineTransformMakeTranslation(1.0, -virtualTargetView.frame.height / 2))
            virtualTargetView.alpha = 0
            viewCopy.alpha = 1
            viewCopy.transform = CGAffineTransformIdentity
        }, completion: { _ in
            // 当动画执行完毕后，将UIViewCopy的信息赋值给UIView，并还原UIView的状态，即与UIViewCopy相同的状态，然后移除UIViewCopy
            virtualTargetView.alpha = 1
            virtualTargetView.text = viewCopy.text
            virtualTargetView.transform = CGAffineTransformIdentity
            viewCopy.removeFromSuperview()
        })
     } else if targetView.isKindOfClass(UIImageView) {
         let virtualTargetView = targetView as! UIImageView
         let viewCopy = UIImageView(frame: virtualTargetView.frame)
         viewCopy.alpha = 0
         viewCopy.image = UIImage(named: flightInfo)
         viewCopy.transform = CGAffineTransformConcat(CGAffineTransformMakeScale(1.0, 0.1), CGAffineTransformMakeTranslation(1.0, viewCopy.frame.height / 2))
         self.topView.addSubview(viewCopy)
         UIView.animateWithDuration(2, animations: {
             virtualTargetView.transform = CGAffineTransformConcat(CGAffineTransformMakeScale(1.0, 0.1), CGAffineTransformMakeTranslation(1.0, -virtualTargetView.frame.height / 2))
             virtualTargetView.alpha = 0
             viewCopy.alpha = 1
             viewCopy.transform = CGAffineTransformIdentity
         }, completion: { _ in
             virtualTargetView.alpha = 1
             virtualTargetView.image = viewCopy.image
             virtualTargetView.transform = CGAffineTransformIdentity
             viewCopy.removeFromSuperview()
         })
     }
}
</code></pre>
<p>具体有这么几个步骤：</p>
<ul>
<li>判断<code>UIView</code>的具体实现类，判断是<code>UILabel</code>还是<code>UIImageView</code>。</li>
<li>复制一份<code>UIView</code>，作为底面。</li>
<li>设置<code>UIViewCopy</code>的初始位置和高度。</li>
<li>执行UIView<code>和</code>UIViewCopy`的动画。</li>
<li>当动画执行完毕后，将<code>UIViewCopy</code>的信息赋值给<code>UIView</code>，并还原<code>UIView</code>的状态，即与<code>UIViewCopy</code>相同的状态，然后移除<code>UIViewCopy</code>。</li>
</ul>
<h3 id="u5C0F_u7BAD_u5934_u65CB_u8F6C_u52A8_u753B"><a href="#u5C0F_u7BAD_u5934_u65CB_u8F6C_u52A8_u753B" class="headerlink" title="小箭头旋转动画"></a>小箭头旋转动画</h3><p>因为航班信息有已降落和即将起飞两种状态，所以小箭头旋转涉及到一个方向问题，我们可以先定义一个枚举类型：</p>
<pre><code class="swift">
enum RotateDirection: Int {
    case Positive = 1
    case Negative = -1
}
</code></pre>
<p>然后写一个箭头旋转的方法：</p>
<pre><code class="swift">
func rotateAnimate(direction: Int) {
   UIView.animateWithDuration(2, animations: {
       // 判断向上还是向下旋转
       if RotateDirection.Positive.rawValue == direction {
           // 在这个示例中小箭头的初始状态是飞机已降落状态，所以想要箭头从起飞状态旋转到降落状态，只要恢复初始状态即可
           self.landedOrDepatureSmallArrowImageView.transform = CGAffineTransformIdentity
       } else {
           // 向上旋转
           let rotation = CGAffineTransformMakeRotation(CGFloat(RotateDirection.Negative.rawValue) * CGFloat(M_PI_2))
           self.landedOrDepatureSmallArrowImageView.transform = rotation
       }
    }, completion: nil)
}
</code></pre>
<p>给大家解释一下上述方法的几个步骤：</p>
<ul>
<li>首先判断旋转的方向，通过传入的<code>direction</code>参数。</li>
<li>如果判断出是降落状态的箭头，也就是向下旋转的箭头，那么我们只需要将<code>landedOrDepatureSmallArrowImageView</code>的<code>transform</code>属性恢复初始值即可，因为在这个示例中小箭头的初始状态就是飞机降落状态。</li>
<li>向上旋转时创建一个<code>CGAffineTransformMakeRotation</code>，然后设置正确地方向和角度即可。</li>
</ul>
<blockquote>
<p> 注：<code>CGAffineTransformMakeRotation</code>转换每次都是以初始位置为准，<code>CGAffineTransformRotation</code>转换是以每次的旋转位置为准。</p>
</blockquote>
<h3 id="u5730_u70B9_u548C_u98DE_u673A_u52A8_u753B"><a href="#u5730_u70B9_u548C_u98DE_u673A_u52A8_u753B" class="headerlink" title="地点和飞机动画"></a>地点和飞机动画</h3><p>起飞地、目的地、飞机的动画是一个组合动画，因为这里面存在飞机出现和消失，以及旋转的时机问题，我们来看看这个方法：</p>
<pre><code class="swift">
func placeAndAirplaneAnimate(flightItem: NSDictionary) {
    UIView.animateWithDuration(1, delay: 0, options: [], animations: {
        // 将起飞地向上移动，同时淡出
        self.targetPlace.center.y += 100
        self.targetPlace.alpha = 0
        // 将目的地向下移动，同时淡出
        self.sourcePlace.center.y -= 100
        self.sourcePlace.alpha = 0
        // 将飞机向右移出屏幕
        self.airplaneImageView.center.x += self.view.bounds.width / 1.5
        }, completion: { _ in
            // 根据传入的数据源更改起飞地和目的地
            self.targetPlace.text = flightItem[&quot;targetPlace&quot;] as? String
            self.sourcePlace.text = flightItem[&quot;sourcePlace&quot;] as? String
            // 将飞机移到屏幕左侧外，这里没有补间动画
            self.airplaneImageView.center.x -= self.view.bounds.width * 1.5
            // 将飞机向上旋转一个角度，这里没有补间动画
            self.airplaneImageView.transform = CGAffineTransformMakeRotation(-3.14/10)
            UIView.animateWithDuration(1.0, animations: {
                // 将起飞地向下移动，也就是恢复到初始位值，同时淡入
                self.targetPlace.center.y -= 100
                self.targetPlace.alpha = 1
                // 将目的地向上移动，也就是恢复到初始位值，同时淡入
                self.sourcePlace.center.y += 100
                self.sourcePlace.alpha = 1
                // 将飞机移动到初始位置
                self.airplaneImageView.center = self.airplaneImageViewOriginalCenter
            })
            UIView.animateWithDuration(0.7, delay: 0.5, options: [], animations: {
                // 将飞机的角度恢复到初始状态
                self.airplaneImageView.transform = CGAffineTransformIdentity
            }, completion: nil)
    })
}
</code></pre>
<p>刨析一下这个方法：</p>
<ul>
<li>首先是起飞地向上移动同时淡出、目的地向下移动同时淡出、将飞机向右移出屏幕，这些动画属性的改变会产生补间动画。</li>
<li>然后当上面这些动画结束后，根据数据源参数更改起飞地和目的地的值，同时将飞机移动屏幕左侧外并向上旋转一个角度，这些属性的改变是不会产生补间动画的，应为它们在<code>completion</code>闭包中。</li>
<li>最后再使用两个动画方法将起飞地向下移动，也就是恢复到初始位值同时淡入，将目的地向上移动，也就是恢复到初始位值同时淡入，将飞机移动到初始位置，将飞机的角度恢复到初始状态。这里为什么不把恢复飞机角度和恢复位置放在一个动画方法里呢？因为恢复飞机角度需要一个延迟时间，也就是当飞机飞入屏幕一会后再恢复角度，表示一个降落的效果，使动画看起来更加逼真。</li>
</ul>
<p>还有底部的时间还有地点下地横线都是淡入淡出的动画比较简单，这里就不在累赘了。</p>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>再简单地动画效果只要组合的恰当，值设置的考究都可以做出出色的动画效果。这些简单地动画效果也是复杂动画效果的基础。上述动画示例的代码可能写的不够精细，还可以提炼的有层次，不过大家了解了知识点后可以自己实现更考究的代码结构，实现更精致的动画。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p> 本文首发<a href="http://www.csdn.net/article/2015-07-20/2825255-ios-uiview-animation-4-practice/1" target="_blank" rel="externa]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS UIView Animation - Transition]]></title>
    <link href="http://www.devtalking.com//articles/uiview-transition-animation/"/>
    <id>http://www.devtalking.com//articles/uiview-transition-animation/</id>
    <published>2015-07-07T16:00:00.000Z</published>
    <updated>2016-03-02T06:16:59.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p> 本文首发<a href="http://www.csdn.net/article/2015-07-06/2825139-ios-uiview-animation-3" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
</blockquote>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>在上两篇文章中向大家介绍了如何创建基于动画属性的视图动画，比如位置、透明度等。但是大家有没有想过添加或删除一个视图时怎样添加相应地动画呢？</p>
<p>当然我们可以用第一篇文章中对用户名、密码输入框的处理办法，但是还有更好的办法处理这种状况。那就是在这篇文章中将向大家介绍的过渡转变（Transition）动画。</p>
<p>过渡转变动画是Apple预定义的动画集，它没有更改视图某属性起始值和终止值的概念，而只需要你设定不同的动画选项即可。</p>
<h2 id="u6DFB_u52A0_u65B0_u89C6_u56FE"><a href="#u6DFB_u52A0_u65B0_u89C6_u56FE" class="headerlink" title="添加新视图"></a>添加新视图</h2><p>在进行示例之前，大家需要注意一点过渡转变动画与动画属性动画的不同之处。我们在创建动画属性动画时只需要在<code>animations</code>闭包中添加对视图动画属性修改的代码即可，它没有作用域或作用视图的概念。而在过渡转变动画中有作用视图的概念，也就是说我们调用过渡转变动画方法时需要指定一个作用视图。</p>
<p>明确这点不同之后，我们对作用视图再作进一步的说明。过渡转变动画中的作用视图并不是我们的目标视图，而是目标视图的容器视图，那么大家不难想象，如果该容器视图中有多个子视图，那么这些子视图都会有过渡转变动画效果。下面用示例像大家说明。</p>
<p>先看看一个简单的视图结构：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/TransitionAnimation-1.png" alt="视图结构"></p>
<p>很明显，我们添加了一个视图作为容器视图，并且尺寸等于屏幕尺寸。在<code>ViewController.swift</code>中有该容器视图的Outlet以及一个图片视图：</p>
<pre><code class="swift">
@IBOutlet weak var containerView: UIView!
let ipadView = UIImageView(frame: CGRectMake(100, 100, 200, 151.5))
</code></pre>
<p>在<code>viewDidLoad()</code>方法中给<code>ipadView</code>指定图片：</p>
<pre><code class="swift">
ipadView.image = UIImage(named: &quot;ipad&quot;)
</code></pre>
<p>然后在<code>viewDidAppear()</code>方法中添加如下代码：</p>
<pre><code class="swift">
UIView.transitionWithView(self.containerView, duration: 1.5, options: .TransitionFlipFromBottom, animations: {
    self.containerView.addSubview(self.ipadView)
}, completion: nil)
</code></pre>
<p>上述代码就是我们今天的主角，过渡转变方法之一，它同样是<code>UIView</code>的类方法，共有五个参数：</p>
<ul>
<li><code>view</code>：第一个参数，也就是作用视图，一般都是容器视图。</li>
<li><code>duration</code>：动画持续时间。</li>
<li><code>options</code>：过渡转变动画选项，由它来确定过渡转变的具体展现形式。</li>
<li><code>animations</code>：动画闭包。</li>
<li><code>completion</code>：动画结束后执行该闭包中的代码。</li>
</ul>
<p>除了第一个参数，其他四个参数大家应该都不会陌生。这段代码用文字解释出来就是将容器视图（<code>containerView</code>）添加子视图（<code>ipadView</code>）的过程使用<code>.TransitionFlipFromBottom</code>类型的过渡转变动画展示出来，持续时间为1.5秒。编译运行看看效果：</p>
<iframe src="https://player.vimeo.com/video/132628194?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>我们再来添加一个子视图（该子视图的初始化代码不再累赘）：</p>
<pre><code class="swift">
UIView.transitionWithView(self.containerView, duration: 1.5, options: .TransitionFlipFromBottom, animations: {
    self.containerView.addSubview(self.ipadView)
    self.containerView.addSubview(self.iphoneView)
}, completion: nil)
</code></pre>
<p>编译运行看看效果：</p>
<iframe src="https://player.vimeo.com/video/132628304?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>大家可以看到这两个子视图都依托与它们的容器视图进行了过渡转变动画。下面的列表是所有过渡转变动画的动画选项，大家可以在你们自己的项目中逐个实验：</p>
<ul>
<li><code>.TransitionFlipFromLeft</code></li>
<li><code>.TransitionFlipFromRight</code></li>
<li><code>.TransitionCurlUp</code></li>
<li><code>.TransitionCurlDown</code></li>
<li><code>.TransitionCrossDissolve</code></li>
<li><code>.TransitionFlipFromTop</code></li>
<li><code>.TransitionFlipFromBottom</code></li>
</ul>
<p>如果我们有多个目标视图，想进行不同的过渡转变动画怎么办？那我们就创建多个目标视图的容器视图，尺寸与目标视图一致，放置在合适的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/TransitionAnimation-2.png" alt="视图结构"></p>
<p>从上图中可以看出，我们在屏幕上放置了四个容器视图，显而易见，我们要分别对这四个容器视图添加过渡转变动画。当然容器视图里要添加什么样的视图随个人喜好。</p>
<p>在<code>viewDidLoad()</code>方法中添加如下代码：</p>
<pre><code class="swift">
UIView.transitionWithView(self.ipadContainerView, duration: 1.5, options: [.CurveEaseOut, .TransitionFlipFromBottom], animations: {
    self.ipadContainerView.addSubview(self.ipadView)
}, completion: nil)

UIView.transitionWithView(self.iphoneContainerView, duration: 1.5, options: [.CurveEaseOut, .TransitionFlipFromLeft], animations: {
    self.iphoneContainerView.addSubview(self.iphoneView)
}, completion: nil)

UIView.transitionWithView(self.webContainerView, duration: 1.5, options: [.CurveEaseOut, .TransitionFlipFromRight], animations: {
    self.webContainerView.addSubview(self.webView)
}, completion: nil)

UIView.transitionWithView(textContainerView, duration: 2, options: [.CurveEaseOut, .TransitionCrossDissolve], animations: {
    self.textContainerView.addSubview(self.textView)
}, completion: nil)
</code></pre>
<p>通过上述代码可以看出，我们对四个容器视图分别添加了过渡转变动画，并且<code>options</code>参数使用了<code>.CurveEaseOut</code>和不同的过渡转变动画选项。编译运行看看效果：</p>
<iframe src="https://player.vimeo.com/video/132628896?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>是不是有点儿意思！不过细心的朋友应该发现了，过渡转变动画的方法没有<code>delay</code>这个很有用的属性，这就导致过渡转变动画都是同时发生，不能设置延迟时间。不过我们可以曲线救国，自己写一个<code>delay</code>方法：</p>
<pre><code class="swift">
func delay(seconds: Double, completion:()-&gt;()) {
    let popTime = dispatch_time(DISPATCH_TIME_NOW, Int64( Double(NSEC_PER_SEC) * seconds ))
    dispatch_after(popTime, dispatch_get_main_queue()) {
        completion()
    }
}
</code></pre>
<p>然后我们修改<code>viewDidLoad()</code>方法中的代码如下：</p>
<pre><code class="swift">
delay(0, completion: {
   UIView.transitionWithView(self.ipadContainerView, duration: 1.5, options: [.CurveEaseOut, .TransitionFlipFromBottom], animations: {
       self.ipadContainerView.addSubview(self.ipadView)
   }, completion: nil)
})

delay(1, completion: {
    UIView.transitionWithView(self.iphoneContainerView, duration: 1.5, options: [.CurveEaseOut, .TransitionFlipFromLeft], animations: {
        self.iphoneContainerView.addSubview(self.iphoneView)
    }, completion: nil)
 })

delay(2, completion: {
    UIView.transitionWithView(self.webContainerView, duration: 1.5, options: [.CurveEaseOut, .TransitionFlipFromRight], animations: {
        self.webContainerView.addSubview(self.webView)
     }, completion: nil)
})

delay(3, completion: {
    UIView.transitionWithView(self.textContainerView, duration: 2, options: [.CurveEaseOut, .TransitionCrossDissolve], animations: {
        self.textContainerView.addSubview(self.textView)
    }, completion: nil)
 })
</code></pre>
<p>我们将每个过渡转变动画延迟1秒进行，编译运行看看效果：</p>
<iframe src="https://player.vimeo.com/video/132629174?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>现在的效果是不是更好了呢！ : ]</p>
<h2 id="u79FB_u9664_u89C6_u56FE"><a href="#u79FB_u9664_u89C6_u56FE" class="headerlink" title="移除视图"></a>移除视图</h2><p>过渡转变动画同样可以用来移除视图。我们在屏幕底部添加一个<code>UIButton</code>，当点击这个按钮的时候，通过过渡转变动画移除按钮上方的那两排字，并且改变屏幕背景色。<code>go()</code>方法是按钮连接在代码中的<strong>Touch Up Inside</strong>方法，在该方法中添加如下代码：</p>
<pre><code class="swift">
UIView.animateWithDuration(0.5, animations: {
    self.view.backgroundColor = UIColor(red: 252.0/255.0, green: 155.0/255.0, blue: 65.0/255.0, alpha: 1)
})
</code></pre>
<p> 编译运行看看效果：</p>
 <iframe src="https://player.vimeo.com/video/132629842?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<h2 id="u66FF_u6362_u89C6_u56FE"><a href="#u66FF_u6362_u89C6_u56FE" class="headerlink" title="替换视图"></a>替换视图</h2><p> 在这一节我们将要学习过渡转变动画的另一个方法，替换视图方法。我设计的场景是当点击<strong>Go</strong>按钮后，除了上一节中的动画效果以外，iPad、iPhone、Web视图也会移位并且替换为别的视图，我们继续在<code>go()</code>方法中的添加如下代码：</p>
<pre><code class="swift">
 UIView.animateWithDuration(1, delay: 0, options: [], animations: {
     self.iphoneView.frame = CGRectMake(0, 0, 334, 72)
     self.iphoneContainerView.frame = CGRectMake(26, 130, 334, 72)
  }, completion: {
          (flag: Bool) in
                if flag {
                        UIView.transitionFromView(self.iphoneContainerView, toView: self.supportIphone, duration: 0.33, options: .TransitionCrossDissolve, completion: nil)
                   }
 })

UIView.animateWithDuration(1, delay: 1, options: [], animations: {
    self.ipadView.frame = CGRectMake(0, 0, 334, 72)
    self.ipadContainerView.frame = CGRectMake(26, 242, 334, 72)
  }, completion: {
          (flag: Bool) in
                if flag {
                        UIView.transitionFromView(self.ipadContainerView, toView: self.supportIpad, duration: 0.33, options: .TransitionCrossDissolve, completion: nil)
                }
})

UIView.animateWithDuration(1, delay: 2, options: [], animations: {
    self.webView.frame = CGRectMake(0, 0, 334, 72)
    self.webContainerView.frame = CGRectMake(26, 354, 334, 72)
}, completion: {
        (flag: Bool) in
                if flag {
                        UIView.transitionFromView(self.webContainerView, toView: self.supportWeb, duration: 0.33, options: .TransitionCrossDissolve, completion: nil)
                }
})
</code></pre>
<p> 我们来解释一下上述的代码，拿iPhone视图为例，首先通过动画属性动画改变它的尺寸大小和位置。然后在<code>completion</code>闭包中添加替换视图方法，该方法有五个参数：</p>
<ul>
<li><code>fromView</code>：被替换的视图。</li>
<li><code>toView</code>：替换之后的视图。</li>
<li><code>duration</code>：动画持续时间。</li>
<li><code>options</code>：动画选项。</li>
<li><code>completion</code>：动画执行结束后执行该闭包中的代码。</li>
</ul>
<p>要注意的是该方法的作用视图可以是容器视图，也可以是目标视图。编译运行看看效果：</p>
<iframe src="https://player.vimeo.com/video/132631364?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<h2 id="u663E_u793A/_u9690_u85CF_u89C6_u56FE"><a href="#u663E_u793A/_u9690_u85CF_u89C6_u56FE" class="headerlink" title="显示/隐藏视图"></a>显示/隐藏视图</h2><p>过渡转变动画也可以用于显示或隐藏视图，这里给出伪代码供参考：</p>
<pre><code class="swift">
UIView.transitionWithView(self.someContainerView, duration: 1.5, options: [.CurveEaseOut, .TransitionFlipFromBottom], animations: {
    self.someView.hidden = true
    // self.someView.hidden = false
}, completion: nil)
</code></pre>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>过渡转变动画有很多动画选项，大家可以自行试试，找出自己喜欢的或最合适的过渡转变动画选项，并且可以尝试过渡转变动画和属性动画的组合，可以使你们的App更加有趣。好了今天就到这里。</p>
<p>参考文献来自：<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p> 本文首发<a href="http://www.csdn.net/article/2015-07-06/2825139-ios-uiview-animation-3" target="_blank" rel="external">CSDN</a>]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS UIView Animation - Spring]]></title>
    <link href="http://www.devtalking.com//articles/uiview-spring-animation/"/>
    <id>http://www.devtalking.com//articles/uiview-spring-animation/</id>
    <published>2015-07-01T16:00:00.000Z</published>
    <updated>2016-03-02T06:20:52.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文首发<a href="http://www.csdn.net/article/2015-07-03/2825122-ios-uiview-animation-2" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
</blockquote>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>通过上一篇文章，大家应该学会了如何使用<code>UIKit</code>创建最基本的视图动画，包括如何指定视图某属性的起始值和结束值，以及动画持续时间、动画延迟时间、动画选项等概念。</p>
<p>但是目前大家实现的动画不论是位置移动还是大小改变都是以一个单一的方向在运动，比如位置从A点到B点，大小半径从1到2:</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/SpringAnimation-1.png" alt="图1"></p>
<p>在这篇文章中，大家会学到更复杂一点的动画，让视图在一次动画中的运动轨迹像弹簧一样，有多次不同方向的运动，最后停止在终点：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/SpringAnimation-2.png" alt="图2"></p>
<p>如果给位置移动的动画添加弹簧效果，那么视图的运动轨迹应该像下图中展现的一样：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/SpringAnimation-3.png" alt="图3"></p>
<p>这会使你的动画看起来更逼真、更真实、更贴近现实。在某些情况下带给用户更好的用户体验。那么让我们开始学习吧。</p>
<h2 id="Spring_u52A8_u753B"><a href="#Spring_u52A8_u753B" class="headerlink" title="Spring动画"></a>Spring动画</h2><p>我们还是以上一篇文章中的登录页面为例，大家应该发现了那个呆板的登录按钮吧，我们今天就让它Q弹起来。</p>
<p>打开<code>ViewController.swift</code>，在<code>viewWillAppear()</code>方法的底部添加如下代码：</p>
<pre><code class="swift">
self.loginButton.center.y += 30
self.loginButton.alpha = 0
</code></pre>
<p>让登录按钮在屏幕呈现之前位置下移30，并且让它透明。然后在<code>viewDidAppear()</code>方法的底部添加如下代码：</p>
<pre><code class="swift">
UIView.animateWithDuration(1, delay: 0.5, usingSpringWithDamping: 0.5, initialSpringVelocity: 0, options: .AllowUserInteraction, animations: {
     self.loginButton.center.y -= 30
     self.loginButton.alpha = 1
}, completion: nil)
</code></pre>
<p>上述的代码大家是不是似曾相识，没错，依然是<code>UIView</code>的类方法，不过又多了两个参数：</p>
<ul>
<li><code>usingSpringWithDamping</code>：弹簧动画的阻尼值，也就是相当于摩擦力的大小，该属性的值从0.0到1.0之间，越靠近0，阻尼越小，弹动的幅度越大，反之阻尼越大，弹动的幅度越小，如果大道一定程度，会出现弹不动的情况。</li>
<li><code>initialSpringVelocity</code>：弹簧动画的速率，或者说是动力。值越小弹簧的动力越小，弹簧拉伸的幅度越小，反之动力越大，弹簧拉伸的幅度越大。这里需要注意的是，如果设置为0，表示忽略该属性，由动画持续时间和阻尼计算动画的效果。</li>
</ul>
<p>下面我们先来看看不同动力的效果：</p>
<ul>
<li>持续时间为3秒，阻尼为0.5，动力为1：</li>
</ul>
<iframe src="https://player.vimeo.com/video/132389962?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<ul>
<li>持续时间为3秒，阻尼为0.5，动力为20：</li>
</ul>
<iframe src="https://player.vimeo.com/video/132389963?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>当<code>initialSpringVelocity</code>的值为1时，登录按钮上下弹力并不是很强劲，当设置为20时，登录按钮直接冲过了密码输入框，这就是动力的效果。</p>
<p>然后我们再看看不同阻尼的效果：</p>
<ul>
<li>持续时间为3秒，阻尼为0.1，动力为0：</li>
</ul>
<iframe src="https://player.vimeo.com/video/132389964?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<ul>
<li>持续时间为3秒，阻尼为1，动力为0：</li>
</ul>
<iframe src="https://player.vimeo.com/video/132389966?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>当<code>usingSpringWithDamping</code>属性值为0.1时，表示阻尼很小，虽然没有动力因素的影响，但登录按钮弹动的幅度依然比较大，相当于在冰面滑行一样。当该属性为1时，表示阻尼非常大，可以看到登录按钮几乎是没有什么弹动的幅度。这就是阻尼的效果。</p>
<p>大家需要注意的一点是，弹簧动画并不只作用于位置的变化，它可以作用于所有动画属性的变化，比如我们在<code>animations</code>的闭包中除了位置的变化外，还有透明度的变化，它也同样有弹簧动画的效果，只不过它没有位置变化那么明显和贴近真实，它会表现出一闪一闪的效果：</p>
<iframe src="https://player.vimeo.com/video/132389969?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>大家可以尝试这几个属性不同值的组合，选出一个自己觉得满意的弹簧效果即可。</p>
<h2 id="u5C06_u52A8_u753B_u8FD0_u7528_u5230_u4EBA_u673A_u4EA4_u4E92"><a href="#u5C06_u52A8_u753B_u8FD0_u7528_u5230_u4EBA_u673A_u4EA4_u4E92" class="headerlink" title="将动画运用到人机交互"></a>将动画运用到人机交互</h2><p>上一节讲的弹簧动画的确可以让我们的UI变得鲜活起来，但这仅仅是看在眼里的，对于用户的操作却并没有什么响应和反馈。在这节会教大家如何让视图在用户进行点击操作时以动画的形式给予响应和反馈。</p>
<p>在<code>ViewController.swift</code>中有一个名为<code>login()</code>的方法，关联了登录按钮的<strong>Touch Up Inside</strong>事件，在该方法中添加如下代码：</p>
<pre><code class="swift">
UIView.animateWithDuration(0.5, delay: 0.0, usingSpringWithDamping: 0.2, initialSpringVelocity: 0.0, options: .AllowUserInteraction, animations: {
    self.loginButton.bounds.size.width += 25
}, completion: nil)
</code></pre>
<p>此时每当我们点击登录按钮一次，它就会变胖一些。编译运行看一下效果：</p>
<iframe src="https://player.vimeo.com/video/132390547?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>我们可以再组合一个效果，使点击登录按钮时不仅让它变胖，还有轻微的向下弹跳效果。在<code>login()</code>方法底部添加如下代码：</p>
<pre><code class="swift">
UIView.animateWithDuration(0.3, delay: 0.0, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.0, options: .AllowUserInteraction, animations: {
    self.loginButton.center.y += 10
}, completion: nil)
</code></pre>
<p>编译运行看一下效果：</p>
<iframe src="https://player.vimeo.com/video/132390546?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>以上只是两个简单的将动画运用到人机交互的例子，大家可以在自己的项目中将一些用户的操作加上视图的动画反馈，让你的应用鲜活起来。</p>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>这一篇文章向大家讲解了<code>UIView</code>的Spring动画，以及将动画运用到人机交互中，使提升应用的用户体验，大家可以多多尝试Spring动画的各个属性，以及结合<a href="http://www.devtalking.com/articles/uiview-first-animation/">上一篇文章</a>的知识，组合出更美妙的动画效果。下一篇文章会给大家介绍<code>UIView</code>的Transition动画，敬请期待。</p>
<p>参考文献来自：<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文首发<a href="http://www.csdn.net/article/2015-07-03/2825122-ios-uiview-animation-2" target="_blank" rel="external">CSDN</a>，]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS UIView Animation - First Animation]]></title>
    <link href="http://www.devtalking.com//articles/uiview-first-animation/"/>
    <id>http://www.devtalking.com//articles/uiview-first-animation/</id>
    <published>2015-06-27T16:00:00.000Z</published>
    <updated>2016-03-02T06:49:39.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文首发<a href="http://www.csdn.net/article/2015-07-02/2825115-ios-uiview-animation-1" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
</blockquote>
<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>在一个看脸的社会中，不论什么事物，长的好看总是能多吸引一些目光。App同样不例外，一款面相不错的App就算功能已经被轮子千百遍，依然会有人买账，理由就是看的顺眼，于是平面设计人员越来越被重视。白驹过隙，斗转星移，人们已然不满足于静态的美感，于是动态的用户体验应运而生，平面设计人员捉襟见肘，是我们程序员出马的时候了。</p>
<p>这篇文章是UIView Animation的第一篇，从极简的概念开始，为大家揭开Animation的神秘面纱。我们以一个登录界面为例。美丽的太阳，婀娜的云，还有几个小山包，中间静躺着用户名、密码输入框和登录按钮。搁以前，这个界面许是会亮瞎眼现如今尼玛狗都嫌。所以我们的目标是赋予这个界面生命力。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/FirstAnimation-LoginScreen.png" alt="登录页"></p>
<blockquote>
<p>注意：本文章基于Swift 2.0和Xcode 7 Beta2编写。登录界面中的所有元素都已经连接到了代码中（outlet），在这个示例中我们先不使用Auto Layout和SizeClasses。</p>
</blockquote>
<h2 id="u4F1A_u52A8_u7684_u8F93_u5165_u6846"><a href="#u4F1A_u52A8_u7684_u8F93_u5165_u6846" class="headerlink" title="会动的输入框"></a>会动的输入框</h2><p>我们的第一个场景应该是这样。用户打开App，启动画面过后显示登录界面，此时屏幕上还没有用户名和密码的输入框，下一秒他们从屏幕左侧飘然而至。</p>
<h3 id="u9996_u5148"><a href="#u9996_u5148" class="headerlink" title="首先"></a>首先</h3><p>我们需要在登录界面还没有展现给用户的时候把用户名和密码的输入框移至屏幕外面。打开<code>ViewController.swift</code>，在<code>viewWillAppear()</code>方法中添加以下代码：</p>
<pre><code class="swift">
self.username.center.x -= self.view.bounds.width
self.password.center.x -= self.view.bounds.width
</code></pre>
<p>这两行代码使用户名、密码输入框移出屏幕外，这里可以使用简单暴力的方式，直接让<code>center</code>的<code>x</code>减去屏幕宽度。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/FirstAnimation-LoginScreen-1.png" alt="输入框移出屏幕"></p>
<h3 id="u7136_u540E"><a href="#u7136_u540E" class="headerlink" title="然后"></a>然后</h3><p>我们在<code>viewDidAppear()</code>方法中添加以下代码：</p>
<pre><code class="swift">
UIView.animateWithDuration(0.5, animations: {
    self.username.center.x += self.view.bounds.width
    self.password.center.x += self.view.bounds.width
})
</code></pre>
<p><code>animationWithDuration(_:animations:)</code>是<code>UIView</code>的类方法，从方法名就可以看出，该方法可使<code>UIView</code>动起来。它有两个参数：</p>
<ul>
<li><code>duration</code>：动画的持续时间。</li>
<li><code>animation</code>：动画闭包，在这个闭包中你可以改变<code>UIView</code>的各种动画属性。</li>
</ul>
<p>因为该方法是一个类方法，所以在闭包中你可以同时改变多个<code>views</code>的动画属性。所以在上述代码中，同时改变了用户名和密码输入框的位置。编译运行，我们可以看到如下效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/FirstAnimation-1.gif" alt="FirstAnimation-1"></p>
<p>但是由于两个输入框是同时从屏幕外滑入，略显呆板，所以我们用另一个方法再来润色一下。</p>
<h3 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h3><p>我们更新<code>viewDidAppear()</code>中的代码：</p>
<pre><code class="swift">
UIView.animateWithDuration(0.5, animations: {
    self.username.center.x += self.view.bounds.width
//  self.password.center.x += self.view.bounds.width
})

UIView.animateWithDuration(0.5, delay: 0.3, options: .AllowUserInteraction, animations: {
    self.password.center.x += self.view.bounds.width
}, completion: nil)
</code></pre>
<p><code>animationWithDuration(_:delay:options:animations:completion:)</code>方法同样是<code>UIView</code>的类方法，但是多了3个参数：</p>
<ul>
<li><code>delay</code>：顾名思义，动画迟延执行的时间。</li>
<li><code>options</code>：自定义动画的一些效果，比如重复动画、前后运动等。这个参数在后面的文章中会说明。</li>
<li><code>completion</code>：也是一个闭包，当动画执行完之后会执行该闭包中的逻辑，可以用来连接动画，或者是在动画结束后你需要做一些清理工作等。</li>
</ul>
<p>现在编译运行，可以看到如下效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/FirstAnimation-2.gif" alt="FirstAnimation-2"></p>
<p>用户名输入框先滑入屏幕，在0.3秒的延迟后，密码输入框紧随其后。</p>
<h2 id="u52A8_u753B_u5C5E_u6027"><a href="#u52A8_u753B_u5C5E_u6027" class="headerlink" title="动画属性"></a>动画属性</h2><p>在上一节，我们体验了视图的简单动画效果，不难发现，其实真正导致视图动起来的是<code>animations</code>闭包中的代码，也就是对视图属性的改变，然后<code>UIView</code>的类方法生成了视图某属性的起始值和终止值之间的补间动画。这引出了另一个概念，那就是视图的动画属性，诚然不是所有的视图属性都是动画属性，下面给大家介绍一下视图的动画属性。</p>
<h3 id="u4F4D_u7F6E_u548C_u5927_u5C0F"><a href="#u4F4D_u7F6E_u548C_u5927_u5C0F" class="headerlink" title="位置和大小"></a>位置和大小</h3><ul>
<li><code>bounds</code>：改变视图内容的位置和尺寸大小的属性。</li>
<li><code>frame</code>：改变视图的位置和尺寸大小的属性。</li>
<li><code>center</code>：改变视图位置的属性。</li>
</ul>
<h3 id="u5916_u89C2"><a href="#u5916_u89C2" class="headerlink" title="外观"></a>外观</h3><ul>
<li><code>backgroundColor</code>：改变背景色时，<code>UIKit</code>会线性的从原始颜色转变为目标颜色。</li>
<li><code>alpha</code>：改变透明度，<code>UIKit</code>会创建淡入淡出的效果。</li>
</ul>
<h3 id="u8F6C_u6362"><a href="#u8F6C_u6362" class="headerlink" title="转换"></a>转换</h3><p><code>transform</code>属性的类型为<code>CGAffineTransform</code>，它是一个结构体，<code>CoreGraphics</code>中有若干方法可生成不同的<code>CGAffineTransform</code>结构，使视图旋转、按比例缩放、翻转等，我们来看看它如何使用。在<code>viewDidAppear()</code>方法中添加如下代码：</p>
<pre><code class="swift">
let rotation = CGAffineTransformMakeRotation(CGFloat(M_PI))
UIView.animateWithDuration(1, animations: {
    self.sun.transform = rotation
})
</code></pre>
<p>首先创建了一个旋转的结构，参数是一个<code>CGFloat</code>类型的角度，这里我们使用预定义好的常量比如<code>M_PI</code>代表3.14…，也就是旋转一周、<code>M_PI_2</code>代表1.57…，也就是旋转半周等。</p>
<p>然后在<code>animations</code>闭包中将创建的旋转结构赋值给屏幕上太阳视图的<code>transform</code>属性。编译运行可以看到如下效果：</p>
<iframe src="https://player.vimeo.com/video/132005476?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>我们再来看看缩放，在<code>viewDidAppear()</code>方法中添加如下代码：</p>
<pre><code class="swift">
let scale = CGAffineTransformMakeScale(0.5, 0.5)       
UIView.animateWithDuration(1, animations: {
    self.cloudBig.transform = scale
})
</code></pre>
<p>首先创建了一个缩放的结构，第一个参数是x轴的缩放比例，第二个参数是y轴的缩放比例。同样在<code>animations</code>闭包中将创建的缩放结构赋值给屏幕上云朵视图的<code>transform</code>属性。编译运行可以看到如下效果：</p>
<iframe src="https://player.vimeo.com/video/132005775?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<h2 id="u52A8_u753B_u9009_u9879"><a href="#u52A8_u753B_u9009_u9879" class="headerlink" title="动画选项"></a>动画选项</h2><p>大家应该还记得我们之前使用过<code>animationWithDuration(_:delay:options:animations:completion:)</code>方法，其中的<code>options</code>当时没有详细的讲述，这节会向大家说明该属性。<code>options</code>选项可以使你自定义让<code>UIKit</code>如何创建你的动画。该属性需要一个或多个<code>UIAnimationOptions</code>枚举类型，让我们来看看都有哪些动画选项吧。</p>
<h3 id="u91CD_u590D_u7C7B"><a href="#u91CD_u590D_u7C7B" class="headerlink" title="重复类"></a>重复类</h3><ul>
<li><code>.Repeat</code>：该属性可以使你的动画永远重复的运行。</li>
<li><code>.Autoreverse</code>：该属性可以使你的动画当运行结束后按照相反的行为继续运行回去。该属性只能和<code>.Repeat</code>属性组合使用。</li>
</ul>
<p>我们来看看怎么使用这两个属性，我们修改一个密码输入框的动画：</p>
<pre><code class="swift">
UIView.animateWithDuration(0.5, delay: 0.3, options: .Repeat, animations: {
    self.password.center.x += self.view.bounds.width
}, completion: nil)
</code></pre>
<p>编译运行看看效果：</p>
<iframe src="https://player.vimeo.com/video/132008765?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>可以看到密码输入框不停的从左向右滑入。大家可以自己试试<code>.Autoreverse</code>的效果或者<code>[.Repeat, .Autoreverse]</code>组合效果。</p>
<h3 id="u52A8_u753B_u7F13_u51B2"><a href="#u52A8_u753B_u7F13_u51B2" class="headerlink" title="动画缓冲"></a>动画缓冲</h3><p>在现实生活中，几乎没有什么东西可以突然开始运动，然后突然停止一动不动。可以运动的物体基本都是以较慢的速度启动，逐渐加速，达到一个稳定的速度，然后当要停止时，会逐渐减速，最后停止。所以要使动画更加逼真，也可以采用这种方式，那就是<strong>ease-in</strong>和<strong>ease-out</strong>。</p>
<ul>
<li><code>.CurveLinear</code> ：该属性既不会使动画加速也不会使动画减速，只是做以线性运动。</li>
<li><code>.CurveEaseIn</code>：该属性使动画在开始时加速运行。</li>
<li><code>.CurveEaseOut</code>：该属性使动画在结束时减速运行。</li>
<li><code>.CurveEaseInOut</code>：该属性结合了上述两种情况，使动画在开始时加速，在结束时减速。</li>
</ul>
<p>下面依然以密码输入框作为示例，修改密码输入框的动画代码：</p>
<pre><code class="swift">
UIView.animateWithDuration(0.5, delay: 0.3, options: [.Repeat, .Autoreverse, .CurveEaseOut], animations: {
    self.password.center.x += self.view.bounds.width
}, completion: nil)
</code></pre>
<p>上面的代码中组合了三种动画选项，首先让动画重复执行，然后让动画在一次执行完毕后接着反方向再次执行，最后让动画在结束时减速。编译运行，这次我们减慢动画的运行速度来看看：</p>
<iframe src="https://player.vimeo.com/video/132012000?title=0&byline=0&portrait=0" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

<p>从上面的效果中可以看到当密码输入框滑入屏幕的后半段时速度有明显的减慢。大家也可以在自己的项目中试试其他动画选项的组合。</p>
<h2 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h2><p>看完这篇文章后，相信大家对iOS的动画有了大致的了解，也学会了如何实现简单的视图动画，当然这些只是iOS Animation的冰山一角，我会陆续向大家介绍iOS Animation的其他知识，今天就先到这吧。</p>
<p>参考文献来自：<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文首发<a href="http://www.csdn.net/article/2015-07-02/2825115-ios-uiview-animation-1" target="_blank" rel="external">CSDN</a>，]]>
    </summary>
    
      <category term="Animation" scheme="http://www.devtalking.com/tags/Animation/"/>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Swift 2.0初探]]></title>
    <link href="http://www.devtalking.com//articles/what-is-new-in-swift/"/>
    <id>http://www.devtalking.com//articles/what-is-new-in-swift/</id>
    <published>2015-06-19T16:00:00.000Z</published>
    <updated>2016-01-01T14:07:00.000Z</updated>
    <content type="html"><![CDATA[<p>转眼间，Swift已经一岁多了，这门新鲜、语法时尚、类型安全、执行速度更快的语言已经渐渐的深入广大开发者的心。我同样也是非常喜爱这门新的编程语言。</p>
<p>今年6月，一年一度的WWDC大会如期而至，在大会上Apple发布了Swift 2.0，引入了很多新的特性，以帮助开发者能更快，更简单的构建应用。我在这里也说道说道Swift 2.0中值得大家注意的新特性。</p>
<h2 id="guard_u8BED_u53E5"><a href="#guard_u8BED_u53E5" class="headerlink" title="guard语句"></a><code>guard</code>语句</h2><p><code>guard</code>语句和<code>if</code>语句有点类似，都是根据其关键字之后的表达式的布尔值决定下一步执行什么。但与<code>if</code>语句不同的是，<code>guard</code>语句只会有一个代码块，不像<code>if</code>语句可以<code>if else</code>多个代码块。</p>
<p>那么<code>guard</code>语句的作用到底是什么呢？顾名思义，就是守护。<code>guard</code>语句判断其后的表达式布尔值为<code>false</code>时，才会执行之后代码块里的代码，如果为<code>true</code>，则跳过整个<code>guard</code>语句，我们举例来看看。</p>
<p>我们以今年高考为例，在进入考场时一般都会检查身份证和准考证，我们写这样一个方法：</p>
<pre><code class="swift">
func checkup(person: [String: String!]) {

    // 检查身份证，如果身份证没带，则不能进入考场
    guard let id = person[&quot;id&quot;] else {
        print(&quot;没有身份证，不能进入考场!&quot;)
        return
    }

    // 检查准考证，如果准考证没带，则不能进入考场
    guard let examNumber = person[&quot;examNumber&quot;] else {
        print(&quot;没有准考证，不能进入考场!&quot;)
        return
    }

    // 身份证和准考证齐全，方可进入考场
    print(&quot;您的身份证号为:\(id)，准考证号为:\(examNumber)。请进入考场!&quot;)

}

checkup([&quot;id&quot;: &quot;123456&quot;]) // 没有准考证，不能进入考场!
checkup([&quot;examNumber&quot;: &quot;654321&quot;]) // 没有身份证，不能进入考场!
checkup([&quot;id&quot;: &quot;123456&quot;, &quot;examNumber&quot;: &quot;654321&quot;]) // 您的身份证号为:123456，准考证号为:654321。请进入考场!
</code></pre>
<p>上述代码中的第一个<code>guard</code>语句用于检查身份证，如果检查到身份证没带，也就是表达式为<code>false</code>时，执行大括号里的代码，并返回。第二个<code>guard</code>语句则检查准考证。</p>
<p>如果两证齐全，则执行最后一个打印语句，上面的两个<code>guard</code>语句大括号内的代码都不会执行，因为他们表达式的布尔值都是<code>true</code>。</p>
<p>这里值得注意的是，<code>id</code>和<code>examNumber</code>可以在<code>guard</code>语句之外使用，也就是说当<code>guard</code>对其表达式进行验证后，<code>id</code>和<code>examNumber</code>可在整个方法的作用域中使用，并且是解包后的。</p>
<p>我们再用<code>if else</code>语句写一个类似的方法：</p>
<pre><code class="swift">
func checkupUseIf(person: [String: String!]) {

    if let id = person[&quot;id&quot;], let examNumber = person[&quot;examNumber&quot;] {
        print(&quot;您的身份证号为:\(id)，准考证号为:\(examNumber)。请进入考场！&quot;)
    } else {
        print(&quot;证件不齐全，不能进入考场!&quot;)
    }

    print(&quot;您的身份证号为:\(id)，准考证号为:\(examNumber)&quot;)  // 报异常

}

checkupUseIf([&quot;id&quot;: &quot;123456&quot;]) // 证件不齐全，不能进入考场!
checkupUseIf([&quot;examNumber&quot;: &quot;654321&quot;]) // 证件不齐全，不能进入考场!
checkupUseIf([&quot;id&quot;: &quot;123456&quot;, &quot;examNumber&quot;: &quot;654321&quot;]) // 您的身份证号为:123456，准考证号为:654321。请进入考场!
</code></pre>
<p>我们可以看到用<code>if else</code>实现的方法显然不如<code>guard</code>实现的那么精准。而且<code>id</code>和<code>examNumber</code>的作用域只限在<code>if</code>的第一个大括号内，超出这个作用域编译就会报错。</p>
<p>通过上述两个小例子不难看出，<code>guard</code>语句正如一个称职的守卫，层层把关，严防一切不允许发生的事，并且让代码具有更高的可读性，非常棒。</p>
<h2 id="u5F02_u5E38_u5904_u7406"><a href="#u5F02_u5E38_u5904_u7406" class="headerlink" title="异常处理"></a>异常处理</h2><p>在Swift 1.0时代是没有异常处理和抛出机制的，如果要处理异常，要么使用<code>if else</code>语句或<code>switch</code>语句判断处理，要么使用闭包形式的回调函数处理，再要么就使用<code>NSError</code>处理。以上这些方法都不能像Java中的<code>try catch</code>异常控制语句那样行如流水、从容不迫的处理异常，而且也会降低代码的可读性。当Swift 2.0到来后，一切都不一样了。</p>
<p>在Swift 2.0中Apple提供了使用<code>throws</code>、<code>throw</code>、<code>try</code>、<code>do</code>、<code>catch</code>这五个关键字组成的异常控制处理机制。下面我们来举例看看如何使用，我用使用手机刷朋友圈为例。</p>
<p>首先我们需要定义异常枚举，在Swift 2.0中Apple提供了<code>ErrorType</code>协议需要我们自定义的异常枚举遵循：</p>
<pre><code class="swift">
enum WechatError: ErrorType {
    case NoBattery // 手机没电
    case NoNetwork // 手机没网
    case NoDataStream // 手机没有流量
}
</code></pre>
<p>我们定义了导致不能刷微信的错误枚举<code>’wechatError</code>。然后定义一个检查是否可以刷微信的方法<code>checkIsWechatOk()</code>：</p>
<pre><code class="swift">
func checkIsWechatOk(isPhoneHasBattery: Bool, isPhoneHasNetwork: Bool, dataStream: Int) throws {

    guard isPhoneHasBattery else {
        throw WechatError.NoBattery
    }

    guard isPhoneHasNetwork else {
        throw WechatError.NoNetwork
    }

    guard dataStream &gt; 50 else {
        throw WechatError.NoDataStream
    }

}
</code></pre>
<p>这里注意，在方法名后有<code>throws</code>关键字，意思为该方法产生的异常向上层抛出。在方法体内使用<code>guard</code>语句对各种状态进行判断，然后使用<code>throw</code>关键字抛出对应的异常。然后我们定义刷微信的方法：</p>
<pre><code class="swift">
func playWechat(isPhoneHasBattery: Bool, isPhoneHasNetwork: Bool, dataStream: Int) {

    do {
        try checkIsWechatOk(isPhoneHasBattery, isPhoneHasNetwork: isPhoneHasNetwork, dataStream: dataStream)
        print(&quot;放心刷，刷到天昏地暗！&quot;)
    } catch WechatError.NoBattery {
        print(&quot;手机都没电，刷个鬼啊！&quot;)
    } catch WechatError.NoNetwork {
        print(&quot;没有网络哎，洗洗玩单机吧！&quot;)
    } catch WechatError.NoDataStream {
        print(&quot;没有流量了，去蹭Wifi吧！&quot;)
    } catch {
        print(&quot;见鬼了！&quot;)
    }

}

playWechat(true, isPhoneHasNetwork: true, dataStream: 60) // 放心刷，刷到天昏地暗！
playWechat(true, isPhoneHasNetwork: false, dataStream: 60) // 没有网络哎，洗洗玩单机吧！
playWechat(false, isPhoneHasNetwork: true, dataStream: 60) // 手机都没电，刷个鬼啊！
playWechat(true, isPhoneHasNetwork: true, dataStream: 30) // 没有流量了，去蹭Wifi吧！
</code></pre>
<p>上述的代码示例中，首先检查是否可以刷微信的方法前使用<code>try</code>关键字，表示允许该方法抛出异常，然后使用了<code>do catch</code>控制语句捕获抛出的异常，进而做相关的逻辑处理。</p>
<p>这套异常处理机制使Swift更加的全面和安全，并且提高了代码的可读性，非常棒。</p>
<h2 id="u534F_u8BAE_u6269_u5C55"><a href="#u534F_u8BAE_u6269_u5C55" class="headerlink" title="协议扩展"></a>协议扩展</h2><p>在Swift 1.0 时代，协议（<code>Protocol</code>）基本上类似一个接口，定义若干属性和方法，供类、结构体、枚举遵循和实现。在Swift 2.0中，可以对协议进行属性或者方法的扩展，和扩展类与结构体类似。这让我们开启了面向协议编程的篇章。</p>
<p>Swift中，大多数基础对象都遵循了<code>CustomStringConvertible</code>协议，比如<code>Array</code>、<code>Dictionary</code>（Swift 1.0中的<code>Printable</code>协议），该协议定义了<code>description</code>方法，用于<code>print</code>方法打印对象。现在我们对该协议扩展一个方法，让其打印出大写的内容:</p>
<pre><code class="swift">
var arr = [&quot;hello&quot;, &quot;world&quot;]
print(arr.description) // &quot;[hello, world]&quot;

extension CustomStringConvertible {
    var upperDescription: String {
        return &quot;\(self.description.uppercaseString)&quot;
    }
}

print(arr.upperDescription) // &quot;[HELLO, WORLD]&quot;
</code></pre>
<p>如果在Swfit 1.0时代，要想达到上述示例的效果，那么我们需要分别对<code>Array</code>、<code>Dictionary</code>进行扩展，所以协议的扩展极大的提高了我们的编程效率，也同样使代码更简洁和易读。</p>
<h2 id="u6253_u5370_u8BED_u53E5_u7684_u6539_u53D8"><a href="#u6253_u5370_u8BED_u53E5_u7684_u6539_u53D8" class="headerlink" title="打印语句的改变"></a>打印语句的改变</h2><p>在Swift1中，有’println()’和’print()’两个在控制台打印语句的方法，前者是换行打印，后者是连行打印。在Swift2中，’println()’已成为过去，取而代之的是他俩的结合体。如果你想做换行打印，现在需要这样写：</p>
<pre><code class="swift">
print(&quot;我要换行！&quot;, appendNewline: true)
</code></pre>
<h2 id="available_u68C0_u67E5"><a href="#available_u68C0_u67E5" class="headerlink" title="available检查"></a><code>available</code>检查</h2><p>作为iOS开发者，谁都希望使用最新版本iOS的Api进行开发，省事省力。但常常事与愿违，因为我们经常需要适配老版本的iOS，这就会面临一个问题，一些新特性特性或一些类无法在老版本的iOS中使用，所以在编码过程中经常会对iOS的版本做以判断，就像这样：</p>
<pre><code class="swift">
if NSClassFromString(&quot;NSURLQueryItem&quot;) != nil {
    // iOS 8或更高版本
} else{
    // iOS8之前的版本
}
</code></pre>
<p>以上这只是一种方式，在Swift 2.0之前也没有一个标准的模式或机制帮助开发者判断iOS版本，而且容易出现疏漏。在Swift 2.0到来后，我们有了标准的方式来做这个工作：</p>
<pre><code class="swift">
if #available(iOS 8, *) {
    // iOS 8或更高版本
    let queryItem = NSURLQueryItem()

} else {
    // iOS8之前的版本

}
</code></pre>
<p>这个特性让我们太幸福。</p>
<h2 id="do-while_u8BED_u53E5_u91CD_u547D_u540D"><a href="#do-while_u8BED_u53E5_u91CD_u547D_u540D" class="headerlink" title="do-while语句重命名"></a><code>do-while</code>语句重命名</h2><p>经典的<code>do-while</code>语句改名了，改为了<code>repeat-while</code>：</p>
<pre><code class="swift">
var i = 0
repeat {
    i++
    print(i)
} while i &lt; 10
</code></pre>
<p>个人感觉更加直观了。</p>
<h2 id="defer_u5173_u952E_u5B57"><a href="#defer_u5173_u952E_u5B57" class="headerlink" title="defer关键字"></a><code>defer</code>关键字</h2><p>在一些语言中，有<code>try/finally</code>这样的控制语句，比如Java。这种语句可以让我们在<code>finally</code>代码块中执行必须要执行的代码，不管之前怎样的兴风作浪。在Swift 2.0中，Apple提供了<code>defer</code>关键字，让我们可以实现同样的效果。</p>
<pre><code class="swift">
func checkSomething() {

    print(&quot;CheckPoint 1&quot;)
    doSomething()
    print(&quot;CheckPoint 4&quot;)

}

func doSomething() {

    print(&quot;CheckPoint 2&quot;)
    defer {
        print(&quot;Clean up here&quot;)
    }
    print(&quot;CheckPoint 3&quot;)

}

checkSomething() // CheckPoint 1, CheckPoint 2, CheckPoint 3, Clean up here, CheckPoint 4
</code></pre>
<p>上述示例可以看到，在打印出“CheckPoint 2”之后并没有打印出“Clean up here”，而是“CheckPoint 3”，这就是<code>defer</code>的作用，它对进行了<code>print(&quot;Clean up here&quot;)</code>延迟。我们再来看一个I/O的示例：</p>
<pre><code class="swift">
// 伪代码
func writeSomething() {

    let file = OpenFile()

    let ioStatus = fetchIOStatus()
    guard ioStatus != &quot;error&quot; else {
        return
    }
    file.write()

    closeFile(file)

}
</code></pre>
<p>上述示例是一个I/O操作的伪代码，如果获取到的<code>ioStatus</code>正常，那么该方法没有问题，如果<code>ioStatus</code>取到的是<code>error</code>，那么会被<code>guard</code>语句抓到执行<code>return</code>操作，这样的话<code>closeFile(file)</code>就永远都不会执行了，一个严重的Bug就这样产生了。下面我们看看如何用<code>defer</code>来解决这个问题：</p>
<pre><code class="swift">
// 伪代码
func writeSomething() {

    let file = OpenFile()
    defer {
        closeFile(file)
    }

    let ioStatus = fetchIOStatus()
    guard ioStatus != &quot;error&quot; else {
        return
    }
    file.write()

}
</code></pre>
<p>我们将<code>closeFile(file)</code>放在<code>defer</code>代码块里，这样即使<code>ioStatus</code>为<code>error</code>，在执行<code>return</code>前会先执行<code>defer</code>里的代码，这样就保证了不管发生什么，最后都会将文件关闭。</p>
<p><code>defer</code>又一个保证我们代码健壮性的特性，我非常喜欢。</p>
<p>Swift 2.0中的新特性当然不止以上这些，但窥一斑可见全豹，Swift 2.0努力将更快、更安全做到极致，这是开发人员的福音，让我们尽情享受这门美妙的语言吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>转眼间，Swift已经一岁多了，这门新鲜、语法时尚、类型安全、执行速度更快的语言已经渐渐的深入广大开发者的心。我同样也是非常喜爱这门新的编程语言。</p>
<p>今年6月，一年一度的WWDC大会如期而至，在大会上Apple发布了Swift 2.0，引入了很多新的特性，以帮助]]>
    </summary>
    
      <category term="Swift" scheme="http://www.devtalking.com/tags/Swift/"/>
    
  </entry>
  
</feed>
