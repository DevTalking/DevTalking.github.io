<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>




  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="程序员说" type="application/atom+xml" />



  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="程序员说">
<meta property="og:url" content="http://www.devtalking.com/index.html">
<meta property="og:site_name" content="程序员说">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员说">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> 程序员说 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?980738dc41a50d91861a17ad4b768a1f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">程序员说</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/angularjs1x-guide/" itemprop="url">
                  温故而知新-AngularJS 1.x 小记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-09-19T00:00:00+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/angularjs1x-guide/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/angularjs1x-guide/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>本文首发<a href="http://geek.csdn.net/news/detail/102405" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h1 id="AngularJS_u662F_u4EC0_u4E48"><a href="#AngularJS_u662F_u4EC0_u4E48" class="headerlink" title="AngularJS是什么"></a>AngularJS是什么</h1><p>我们知道HTML是一种创建网页的静态标记语言，它很基础，但不失灵活，然而它自身并不提供对灵活性的具体实现，所以我们要创建具有可用性及赏心悦目的Web应用就需要使用其他语言与之结合去操控它的DOM、标签、标签属性、标签层级结构实现样式变换、动态数据变换、动态元素变换等，比如结合CSS和JavaScript语言。</p>
<p>但是越多的结合就意味着功能实现越复杂，我们需要写大量的代码去实现类似数据绑定、动态展现、远程服务请求等功能，所以jQuery这类的JS库、ember这类的框架应用而生。前者让我们在完成某些单一功能时调用它封装好的方法，从而减少代码量。后者让我们可以遵循它的规范去填充它设计好的代码结构，从而逐步完成完整的应用功能。</p>
<p>而AngularJS是JS库和框架的结合，它诞生于2009年，由Misko Hevery 等人创建，后为Google所收购并发扬光大。AngularJS通过为开发者呈现一个更高层次的抽象来简化应用的开发，提供了构建一个CRUD应用可能用到的全部内容包括：自定义HTML标签、事件绑定、数据绑定、基本模板标识符、表单验证、路由、深度链接、组件重用、依赖注入等。</p>
<blockquote>
<p>文章中的所有示例均可在<a href="https://github.com/DevTalking/AngularJS1.x-guide.git" target="_blank" rel="external">这里</a>下载。</p>
</blockquote>
<h1 id="AngularJS_u7684_u7279_u6027"><a href="#AngularJS_u7684_u7279_u6027" class="headerlink" title="AngularJS的特性"></a>AngularJS的特性</h1><p>AngularJS有着诸多的特性，但最为核心的是其Scope概念、MVC模式、路由、模块化、依赖注入、指令系统、双向数据绑定、Service、Provider等。</p>
<h2 id="u6A21_u5757_u5316"><a href="#u6A21_u5757_u5316" class="headerlink" title="模块化"></a>模块化</h2><p>我们先从AngularJS的模块化特性说起。什么是模块？既应用程序中不同功能的容器。在AngularJS中，我们可以按业务功能的不同将实现划分为不同的模块，这些模块可以在一个JS文件中，也可以将它们放在不同的JS文件中，既一个JS文件为一个模块。</p>
<h3 id="u6A21_u5757_u5316_u7684_u4F18_u52BF"><a href="#u6A21_u5757_u5316_u7684_u4F18_u52BF" class="headerlink" title="模块化的优势"></a>模块化的优势</h3><p>使用模块化在我们的编程阶段有着诸多的好处：</p>
<ul>
<li>可以使我们的代码结构非常清晰，有较好的可读性。</li>
<li>可以使我们复用代码。</li>
<li>在前端编程中，我们都知道JS的引用顺序是很重要的，但使用AngularJS的模块时我们不需要关系每个模块之间的顺序。</li>
<li>可以很好的实现单元测试。</li>
</ul>
<h3 id="u5B9A_u4E49_u6A21_u5757"><a href="#u5B9A_u4E49_u6A21_u5757" class="headerlink" title="定义模块"></a>定义模块</h3><p>定义一个模块很简单，在JS文件中申明一个模块：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mianModule = angular.module(<span class="string">"mianModule"</span>, []);</span><br></pre></td></tr></table></figure>
<p>使用AngularJS的<code>module</code>方法申明一个模块，该方法有两个参数：</p>
<ul>
<li>第一个参数为模块名称。</li>
<li>第二个参数为一个数组，该参数的含义为当前定义的模块所依赖的模块，如果有依赖模块则传入包含模块名称的数组，若无依赖则传入空数组。</li>
</ul>
<h3 id="u4F7F_u7528_u6A21_u5757"><a href="#u4F7F_u7528_u6A21_u5757" class="headerlink" title="使用模块"></a>使用模块</h3><p>在了解如何使用定义好的模块之前，需要先清楚在AngularJS中，模块与模块之间可以是相互独立，老死不相往来的关系，也可以是依赖关系，并且可以是嵌套依赖关系：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="comment">// 互相独立的模块</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"><span class="keyword">var</span> anotherModule = angular.module(<span class="string">"anotherModule"</span>, []);</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="comment">// 有依赖关系的模块</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, [<span class="string">"secondModule"</span>]);</span><br><span class="line"><span class="keyword">var</span> secondModule = angular.module(<span class="string">"secondModule"</span>, [<span class="string">"thirdModule"</span>]);</span><br><span class="line"><span class="keyword">var</span> thirdModule = angular.module(<span class="string">"thirdModule"</span>, []);</span><br></pre></td></tr></table></figure>
<p>在AngularJS中使用定义好的模块也有两种方式，对应两种不同的应用场景。</p>
<h4 id="ngApp_u65B9_u5F0F"><a href="#ngApp_u65B9_u5F0F" class="headerlink" title="ngApp方式"></a>ngApp方式</h4><p>这种方式是AngularJS团队比较推荐的使用方法，只需要在HTML标签中使用AngularJS的<code>ng-app</code>指令指定要使用的模块既可，一般指定的是应用的主模块，或者说是应用入口模块：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Module<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>ng-app</code>指令的含义类似Java中的<code>main</code>方法，是当前页面中应用的唯一主入口，所以<strong>一个页面中只能使用一次<code>np-app</code>指令</strong>。将<code>ng-app</code>指令定义在哪个HTML的标签中就表示该标签及它的所有子标签就会被AngularJS接管，这一部分HTML代码将可以使用AngularJS所有的功能和特性，也就是使用AngularJS开发的Web应用的主入口。通常情况下都会在<code>body</code>标签中使用<code>ng-app</code>指令。</p>
<p>因为使用这种方式只能指定一个应用入口模块，所以为了能使用多模块的特性，就需要抽象出一个主模块，然后将其他所有模块加入主模块的依赖关系中，这里要注意的是因为AngularJS中的模块依赖可以向下穿透，类似类的继承，所以加入主模块依赖关系中的模块并不是所有的模块，而只是处于依赖层级顶层的模块。<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-1.png" alt="主模块依赖关系"><br>如上图所示，在主模块中只需要添加<code>DataHandleModule</code>和<code>NetworkModule</code>两个模块既可。但是这种方式的弊端是在HTML页面中并不能直观的表现出页面的哪些部分使用了何种模块，而且本身提供了模块化的特性，但最终又要抽象到一个模块中去使用，始终有点不是很舒服。</p>
<h4 id="u624B_u52A8_u52A0_u8F7D_u65B9_u5F0F"><a href="#u624B_u52A8_u52A0_u8F7D_u65B9_u5F0F" class="headerlink" title="手动加载方式"></a>手动加载方式</h4><p>虽然使用<code>ng-app</code>的形式可以满足需求，但是还要考虑想抽象出主模块，然后依赖一大堆模块，如果更希望可以在HTML标签中指定使用的模块，此时就需要手动的加载模块了:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="comment">// 互相独立的模块</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"><span class="keyword">var</span> anotherModule = angular.module(<span class="string">"anotherModule"</span>, []);</span><br><span class="line"></span><br><span class="line">angular.element(document).ready(function() &#123;</span><br><span class="line">  <span class="keyword">var</span> myDiv1 = document.getElementById(<span class="string">"myDiv1"</span>);</span><br><span class="line">  angular.bootstrap(myDiv1, [<span class="string">"mainModule"</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> myDiv2 = document.getElementById(<span class="string">"myDiv2"</span>);</span><br><span class="line">  angular.bootstrap(myDiv2, [<span class="string">"anotherModule"</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Module<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"myDiv1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"myDiv2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过上述代码可以看到，我们可以使用AngularJS的<code>bootstrap</code>方法给HTML元素指定模块。这样感觉和模块化特性更加切合，模块的隔离性也比较好，但是这种方式依然有显著的弊端。首先从HTML页面中依然不能直观的看到模块在页面中使用和分布情况，再次这种方式将视图层的HTML代码与JS代码耦合在了一起，也有点违背了AngularJS的MVC设计模式，也许这也是AngularJS不推荐该方式的原因之一吧。</p>
<h3 id="u6A21_u5757_u7684_u751F_u547D_u5468_u671F"><a href="#u6A21_u5757_u7684_u751F_u547D_u5468_u671F" class="headerlink" title="模块的生命周期"></a>模块的生命周期</h3><p>在AngularJS中，模块有两个主要的生命周期方法，那就是<code>.config()</code>和<code>.run()</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module('mainModule', []);</span><br><span class="line">mainModule.config(function(injectables) &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.run(function(injectables) &#123; </span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>.config()</code>方法的作用是在模块运行加载之前对模块进行配置，比如创建各种服务、创建自定义指令、注册过滤器等。<code>.run()</code>方法相当于AngularJS应用的<code>main</code>方法，在该方法里进行的配置都是运行时态的，比如对已经创建好的服务实例在应用运行期进行修改。</p>
<blockquote>
<p><code>.config()</code>方法在后文还会涉及，服务、指令、过滤器也会在后文有详细的讲解。</p>
</blockquote>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC是软件工程中的一种设计模式，既把应用系统分为模型（Model）、视图（View）和控制器（Controller）三个基本部分，并且模型层与视图层之间是相互隔离的。简单的描述每个部分的职能：</p>
<ul>
<li>模型层：管理数据模型。</li>
<li>视图层：控制UI的展现更新等。</li>
<li>控制层：负责具体业务逻辑处理、请求处理转发等，是模型层和视图之间的桥梁。</li>
</ul>
<p>AngularJS是为数不多实现了MVC设计模式的前端框架，为前端应用在开发时期的功能职责切分、代码复用及后期的维护提供了极大的便利。</p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>在AngularJS中，模块是万源之本，所以AngularJS中的所有东西都是通过模块创建的，Controller也不例外。我们可以使用模块对象的<code>.controller()</code>方法创建控制器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"GreetingController"</span>, [<span class="string">"$scope"</span>, function($scope) &#123;</span><br><span class="line">  $scope.greeting = <span class="string">"Hello!"</span>;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看到，<code>.controller()</code>方法有两个参数：</p>
<ul>
<li>第一个参数类型为字符串，为Controller的名称。</li>
<li>第二个参数类型为数组，该数组用于注入当前Controller要用到的服务及实现业务逻辑的函数，这里要注意的是实现逻辑的函数始终是作为数组的最后一个元素，并且要将前面注入的服务作为该函数的参数传入。</li>
</ul>
<p>这里先简单描述一下<code>$scope</code>，在AngularJS中有一个重要的概念是服务，而<code>$scope</code>就是一个AngularJS内置的服务，在后面的章节中会详细讲解服务。那么<code>$scope</code>服务从字面理解是作用域的意思，其实也差不太多，如果用OO的思想将AngularJS的Controller看作是一个类，那么<code>$scope</code>服务就代表了这个类的作用域，那么就可以通过<code>$scope</code>服务给这个类添加属性或者方法，上面的代码示例中通过<code>$scope</code>服务给<code>GreetingController</code>控制器添加了字符串属性<code>greeting</code>及对象属性<code>person</code>。</p>
<p>所以上面代码的含义是，首先创建了名为<code>mainModule</code>的模块，然后在<code>mainModule</code>模块中创建了名为<code>GreetingController</code>的控制器，并使用<code>$scope</code>服务给该控制器添加了名为<code>greeting</code>和<code>person</code>的属性。</p>
<p>创建好Controller后，来看看如何使用它：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Controller<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"GreetingController"</span>&gt;</span></span><br><span class="line">      &#123;&#123; greeting &#125;&#125; &#123;&#123; person.name &#125;&#125; !</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>前文中介绍过在HTML页面中，通过使用<code>ng-app</code>指令给标签绑定模块。同理，我们可以使用<code>ng-controller</code>指令给标签及它的子标签绑定Controller，绑定了Controller的标签及它的子标签都可以使用Controller中的属性或者方法。我们可以使用双花括号语法访问Controller的属性或调用方法。运行效果很简单，就是将这两个属性的值输出到页面。</p>
<p>我们再来看看如何在Controller中添加方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"GreetingController"</span>, [<span class="string">"$scope"</span>, function($scope) &#123;</span><br><span class="line">  $scope.personName = <span class="string">"Everyone"</span>;</span><br><span class="line"></span><br><span class="line">  $scope.welcomeJason = function() &#123;</span><br><span class="line">    $scope.personName = <span class="string">"Jason"</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  $scope.welcomeGreen = function() &#123;</span><br><span class="line">    $scope.personName = <span class="string">"Green"</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们给<code>GreetingController</code>添加了<code>personName</code>属性和<code>welcomeJason()</code>、<code>welcomeGreen()</code>两个方法，并在这两个方法中分别对<code>personName</code>属性的值进行修改。再来看看HTML的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Controller<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"GreetingController"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"welcomeJason()"</span>&gt;</span>Jason<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"welcomeGreen()"</span>&gt;</span>Green<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">        Welcome &#123;&#123; personName &#125;&#125; !</span><br><span class="line">      <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在HTML代码中，添加了两个按钮，此时我们又看到了一个新的AngularJS指令<code>ng-click</code>，这个指令很好理解，就是给按钮绑定点击事件，当点击按钮时调用<code>GreetingController</code>中对应的方法，然后在<code>p</code>标签中显示<code>personName</code>属性。所以Controller中的方法不仅可以通过双花括号语法调用，也可以通过<code>ng-click</code>指令调用。我们来看看运行的效果：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-2.gif" alt="Demo for Controller"></p>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>Model指的是数据模型，在AngularJS中使用<code>$scope</code>服务给Controller添加的属性就是数据模型:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"GreetingController"</span>, [<span class="string">"$scope"</span>, function($scope) &#123;</span><br><span class="line">  $scope.person = &#123;</span><br><span class="line">    name: <span class="string">"Jason"</span>,</span><br><span class="line">    job: <span class="string">"Developer"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>上述代码示例中的<code>person</code>属性就是数据模型，下面看看如何使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Model<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"GreetingController"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">ng-model</span>=<span class="value">"person.name"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">ng-model</span>=<span class="value">"person.job"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">        Welcome &#123;&#123; person.name &#125;&#125;, He is a &#123;&#123; person.job &#125;&#125;!</span><br><span class="line">      <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述HTML代码示例中，我们又看到了新的指令<code>ng-model</code>，顾名思义，该指令就是用来将数据模型与HTML标签元素进行绑定的。上面的代码中分别将两个输入框与<code>person</code>对象的<code>name</code>和<code>job</code>属性进行了绑定，然后在<code>p</code>标签中输出，我们来看看运行效果：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-3.gif" alt="Demo for Model"></p>
<p>不难看出，当我们将<code>person</code>对象的属性与输入框绑定后，<code>person</code>对象属性的默认值就会显示在输入框里了，当我们修改输入框里的内容时会自动将数据通过Controller同步到<code>person</code>对象的相应属性上，所以<code>p</code>标签中的内容会实时跟着输入框的内容进行变化。</p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View层自然就是HTML中的DOM元素了，通过AngularJS提供的各个指令将DOM元素与Controller和Model进行绑定。由Controller负责将数据模型的内容通过双花括号语法或<code>ng-model</code>指令展现在DOM元素上，而当DOM元素中的值发生变化时会由Controller捕获到，并更新对应的数据模型。</p>
<h2 id="u6570_u636E_u53CC_u5411_u7ED1_u5B9A"><a href="#u6570_u636E_u53CC_u5411_u7ED1_u5B9A" class="headerlink" title="数据双向绑定"></a>数据双向绑定</h2><p>在MVC一节中，通过几个示例介绍了如何创建和使用Controller、Model，如何与View层交互，其实也引出了AngularJS的一个重要特性。在Controller小节的例子中，通过点击按钮由Controller更改数据模型并将其展示在页面中，这是通过数据模型的变化从而影响视图层的显示。在Model小节的例子中，通过修改输入框中的值，由Controller捕获并更新对应的数据模型，这是通过视图层的变化从而影响数据模型的值。这就是AngularJS的数据双向绑定特性。</p>
<h2 id="u670D_u52A1_uFF08Services_uFF09"><a href="#u670D_u52A1_uFF08Services_uFF09" class="headerlink" title="服务（Services）"></a>服务（Services）</h2><p>AngularJS中一个重要的概念是服务，这个服务的概念比较宽泛，比如一个常量值也算做一个服务，既提供一个不可变值的服务。变量、对象、函数都算做是服务。在AngularJS中内置了好几十个服务，这些内置的服务都以<strong>$</strong>符号开头，比如<code>$scope</code>、<code>$http</code>、<code>$log</code>、<code>$timeout</code>、<code>$interval</code>等等，从字面意思都不难理解它们的作用，更多的内置服务可以去AngularJS官网查看<a href="https://docs.angularjs.org/api" target="_blank" rel="external">API文档</a>。</p>
<h3 id="u670D_u52A1_u7279_u5F81"><a href="#u670D_u52A1_u7279_u5F81" class="headerlink" title="服务特征"></a>服务特征</h3><p>AngularJS中的服务有两个主要特点：</p>
<ul>
<li>延迟加载，当应用中的其他组建使用服务时才会实例化。</li>
<li>单例，在应用的整个生命周期中，一个服务只存在一份实例，所以服务一般用来共享可复用的代码逻辑或者数据。</li>
</ul>
<h3 id="u81EA_u5B9A_u4E49_u670D_u52A1"><a href="#u81EA_u5B9A_u4E49_u670D_u52A1" class="headerlink" title="自定义服务"></a>自定义服务</h3><p>除了内置的服务，我们还可以创建自己的服务，在AngularJS中我们可以通过<code>$provide</code>这个内置的服务来创建我们的自定义服务，<code>$provide</code>服务提供了五个方法供我们创建不同应用场景的自定义服务，这五个方法分别是<code>provider(name, provider)</code>、<code>factory(name, $getFn)</code>、<code>service(name, constructor)</code>、<code>value(name, value)</code>、<code>constant(name, value)</code>。</p>
<h4 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h4><p>我们先从<code>value(name, value)</code>这个方法看起，该方法有两个参数：</p>
<ul>
<li>第一个参数为服务的名称，类型为字符串。</li>
<li>第二个参数可以是字符串、数字、数组、对象或者函数。</li>
</ul>
<p>假设在我们的应用中，多个Controller中都使用了相同的属性，比如都需要用到客户端ID这个属性，那么我们可以将其抽象为一个服务，该服务就专门用来获取客户端ID，来看看如何创建这个服务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.value(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的示例代码创建了名为<code>clientId</code>的服务，该服务其实就是一个字符串。不过这和<code>$provide</code>服务有什么关系呢？其实上面这种写法并不是完整的写法，只是一个语法糖而已，真正完整的写法是在模块的<code>.config()</code>方法中通过<code>$provide</code>服务去创建：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.config(function($provide) &#123;</span><br><span class="line">    $provide.value(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>创建好服务后通过AngularJS的注入机制将其注入到Controller中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, [<span class="string">"$scope"</span>, <span class="string">"clientId"</span>, function($scope, clientId) &#123;</span><br><span class="line">  $scope.clientId = clientId;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"SecondController"</span>, [<span class="string">"$scope"</span>, <span class="string">"clientId"</span>, function($scope, clientId) &#123;</span><br><span class="line">  $scope.clientId = clientId;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>然后在HTML页面中正常使用Controller就可以了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Value Service<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"FirstController"</span>&gt;</span></span><br><span class="line">      Client ID in FirstController: &#123;&#123; clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"SecondController"</span>&gt;</span></span><br><span class="line">      Client ID in SecondController: &#123;&#123; clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上文中说过<code>$scope</code>服务的其中一个作用就是给Controller添加属性和方法，然后可以在绑定Controller的DOM中使用双花括号语法直接访问添加的属性或调用方法。然而就<code>$scope</code>服务的这一功能而言，AngularJS还提供了另一种方式，我们先来看看Controller的写法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, [<span class="string">"clientId"</span>, function(clientId) &#123;</span><br><span class="line">  this.clientId = clientId;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"SecondController"</span>, [<span class="string">"clientId"</span>, function(clientId) &#123;</span><br><span class="line">  this.clientId = clientId;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>上述代码中我们并没有将<code>$scope</code>服务注入到这两个Controller中，而是使用<code>this</code>创建了<code>clientId</code>属性，<code>this</code>代表Controller的实例。使用这种方式后在HTML页面中使用Controller也有点变化：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Value Service<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"FirstController as first"</span>&gt;</span></span><br><span class="line">      Client ID in FirstController: &#123;&#123; first.clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"SecondController as second"</span>&gt;</span></span><br><span class="line">      Client ID in SecondController: &#123;&#123; second.clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们看到在<code>ng-conroller</code>标签中不再是直接写Controller名称了，而是使用<code>as</code>关键字声明了Controller的实例，然后在双花括号中使用Controller的实例去访问属性或者调用方法。</p>
<blockquote>
<p>使用<code>$scope</code>服务和<code>this</code>给Controller添加属性或方法的效果是一样的，所以不存在谁好谁坏的概念，只不过使用<code>this</code>的方式更贴合OO的思想，而且在HTML代码中对使用的属性或方法有更直观的可读性，能一眼看到使用了哪个Controller的属性或方法，所以使用哪种方式按个人喜好，但是不建议混用这两种方式。</p>
</blockquote>
<p>这里在介绍另外一个语法糖，那就是在注入服务的时候不用繁复的在数组中和函数参数中都声明，只需要在函数的参数里声明就可以了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function($scope, clientId) &#123;</span><br><span class="line">  $scope.clientId = clientId;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function(clientId) &#123;</span><br><span class="line">  this.clientId = clientId;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant</h4><p>我们再来看看<code>constant(name, value)</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.constant(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br></pre></td></tr></table></figure>
<p>该方法和<code>value(name, value)</code>在创建的服务内容形式上来说是一样的，但是两者创建的服务在功能性上还是有区别的：</p>
<ul>
<li>从名称就可以看出用<code>constant(name, value)</code>方法创建的服务是不可修改的。</li>
<li>使用<code>constant(name, value)</code>创建的服务可以在模块的<code>.config()</code>方法中注入，也就是可以在创建其他服务时使用，而使用<code>value(name, value)</code>创建的服务不可以。</li>
</ul>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>现在又有一个需求，希望能获取到当前时间添加在客户端ID后面，那么我们可以使用<code>service(name, constructor)</code>方法来创建获取当前时间的服务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.value(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line"></span><br><span class="line">mainModule.service(<span class="string">"currentDate"</span>, <span class="type">Date</span>);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function(clientId, currentDate) &#123;</span><br><span class="line">  this.clientId = clientId + <span class="string">"-"</span> + currentDate;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Service Service<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"FirstController as first"</span>&gt;</span></span><br><span class="line">      Client ID in FirstController: &#123;&#123; first.clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出结果：<br><code>Client ID in FirstController: qazxsw123456-Thu Sep 08 2016 17:05:30 GMT+0800 (CST)</code></p>
<p><code>service(name, constructor)</code>方法的第二个参数是函数构造器，也就是函数的实例，所以<code>currentDate</code>服务的实体其实就是<code>new Date()</code>。</p>
<h4 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h4><p>现在，我们希望通过一个服务就可以完成客户端ID和当前时间的拼接，不需要给Controller注入两个服务，来看看如何用<code>factory(name, $getFn)</code>方法来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.constant(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line"></span><br><span class="line">mainModule.factory(<span class="string">"clientIdAndCurrentDate"</span>, function(clientId) &#123;</span><br><span class="line">  <span class="keyword">return</span> clientId + <span class="string">"-"</span> + new <span class="type">Date</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function(clientIdAndCurrentDate) &#123;</span><br><span class="line">  this.clientId = clientIdAndCurrentDate;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先我们需要用<code>constant(name, value)</code>方法创建<code>clientId</code>服务，因为需要将它注入到新的服务中，前文也介绍过<code>constant(name, value)</code>和<code>value(name, value)</code>方法的区别。然后使用<code>factory(name, $getFn)</code>方法创建<code>clientIdAndCurrentDate</code>服务，该函数的第二个参数类型是函数，我们在该函数中将<code>clientId</code>服务返回的客户端ID与<code>Date</code>构造器返回的时间进行拼接然后返回，当然运行结果还是一样的：<br><code>Client ID in FirstController: qazxsw123456-Thu Sep 08 2016 17:05:30 GMT+0800 (CST)</code></p>
<p>其实这个服务还可以写成这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.constant(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line"></span><br><span class="line">mainModule.service(<span class="string">"currentDate"</span>, <span class="type">Date</span>);</span><br><span class="line"></span><br><span class="line">mainModule.factory(<span class="string">"clientIdAndCurrentDate"</span>, function(clientId, currentDate) &#123;</span><br><span class="line">  <span class="keyword">return</span> clientId + <span class="string">"-"</span> + currentDate;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这相当于<code>clientIdAndCurrentDate</code>服务对<code>currentDate</code>服务进行了进一步的配置或者说增加了功能，那么也就是说<code>factory(name, $getFn)</code>方法相比<code>service(name, constructor)</code>方法可以创建更复杂一些的服务。</p>
<h4 id="Povider"><a href="#Povider" class="headerlink" title="Povider"></a>Povider</h4><p>现在又有新的需求，希望对<code>clientId</code>后面的时间进行格式化，但假设我们没有权限去更改<code>clientIdAndCurrentDate</code>服务，那么这时我们需要使用<code>provider(name, provider)</code>方法创建另外一个服务，然后对<code>clientIdAndCurrentDate</code>服务进行配置，来看看如何实现这个服务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.constant(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line"></span><br><span class="line">mainModule.service(<span class="string">"currentDate"</span>, <span class="type">Date</span>);</span><br><span class="line"></span><br><span class="line">mainModule.factory(<span class="string">"clientIdAndCurrentDate"</span>, function(clientId, currentDate) &#123;</span><br><span class="line">  <span class="keyword">return</span> clientId + <span class="string">"-"</span> + currentDate;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.provider(<span class="string">"clientIdAndCurrentDateByFormat"</span>, function() &#123;</span><br><span class="line">  this.formatFunc = function(str) &#123;</span><br><span class="line">    <span class="keyword">var</span> clientId = str.substring(<span class="number">0</span>, str.indexOf(<span class="string">"-"</span>));</span><br><span class="line">    <span class="keyword">var</span> dateStr = str.substring(str.indexOf(<span class="string">"-"</span>), str.length);</span><br><span class="line">    <span class="keyword">var</span> dateObj = new <span class="type">Date</span>(dateStr);</span><br><span class="line">    <span class="keyword">var</span> year = dateObj.getFullYear().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> month = (dateObj.getMonth() + <span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> day = dateObj.getDate().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> hour = dateObj.getHours().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> minute = dateObj.getMinutes().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> second = dateObj.getSeconds().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">return</span> clientId + <span class="string">"-"</span> + [year, (month &gt;= <span class="number">10</span> ? month : <span class="number">0</span> + month), (day &gt; <span class="number">10</span> ? day : <span class="number">0</span> + day), hour, minute, second].<span class="built_in">join</span>(<span class="string">""</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  this.$<span class="keyword">get</span> = function(clientIdAndCurrentDate) &#123;</span><br><span class="line">    <span class="keyword">return</span> this.formatFunc(clientIdAndCurrentDate);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function(clientIdAndCurrentDateByFormat) &#123;</span><br><span class="line">  this.clientId = clientIdAndCurrentDateByFormat;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先我们创建了<code>formatFunc()</code>辅助配置函数，然后实现了<code>$get</code>方法，通过<code>formatFunc()</code>辅助函数配置<code>clientIdAndCurrentDate</code>服务，我们来看运行结果：<br><code>Client ID in FirstController: qazxsw123456-20160909113523</code></p>
<p>要注意的一点是，通过<code>provider(name, provider)</code>方法创建服务时必须要<strong>显式</strong>的实现<code>$get</code>方法，并且只有在<code>$get</code>方法中才能注入其他服务。在AngularJS中服务仅指<code>$get</code>返回的东西，所以前四种创建服务的方法其实都是<code>provider(name, provider)</code>方法根据不同应用场景实现的语法糖，比如<code>factory</code>方法其实就是把一个函数当作了<code>$get</code>方法，<code>service</code>方法其实是将一个函数构造方法或者说函数实例当作了<code>$get</code>方法，<code>value</code>和<code>constant</code>方法其实又是对<code>factory</code>方法的语法糖实现。所以在自定义服务时可按需选择不同的方法创建服务。</p>
<h2 id="u6307_u4EE4_uFF08Directive_uFF09"><a href="#u6307_u4EE4_uFF08Directive_uFF09" class="headerlink" title="指令（Directive）"></a>指令（Directive）</h2><p>指令是AngularJS中另一个主要的特性，指令的作用可以用一句话描述，就是可以给HTML元素赋予特殊或自定义的行为，比如监听事件、视图模板代理等。在上文中我们使用过的<code>ng-app</code>、<code>ng-controller</code>、<code>ng-model</code>就是AngularJS中的指令。</p>
<h3 id="u6307_u4EE4_u7684_u547D_u540D"><a href="#u6307_u4EE4_u7684_u547D_u540D" class="headerlink" title="指令的命名"></a>指令的命名</h3><p>指令的命名和使用写法比较有意思，一般情况下在定义指令时推荐使用驼峰命名法，比如<code>ngModel</code>、<code>ngApp</code>，但是在HTML中大小写是不敏感的，所以在HTML中使用指令时推荐使用小写字母加破折号的形式，比如<code>ng-model</code>、<code>ng-app</code>。除了使用小写破折号这种方式，还有以下几种使用写法：</p>
<ul>
<li><code>ng:model</code></li>
<li><code>ng_model</code></li>
<li><code>data-ng-bind</code></li>
<li><code>x-ng-bind</code></li>
</ul>
<p>大家可以根据自己喜好选择使用写法，但是尽量保持写法统一。</p>
<h3 id="u6307_u4EE4_u7684_u5F62_u5F0F"><a href="#u6307_u4EE4_u7684_u5F62_u5F0F" class="headerlink" title="指令的形式"></a>指令的形式</h3><p>在AngularJS中，指令有四种表现形式，既标签形式、标签属性形式、标签class名称形式、注释形式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">my-dir</span>&gt;</span><span class="tag">&lt;/<span class="title">my-dir</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">my-dir</span>=<span class="value">"exp"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- directive: my-dir exp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"my-dir: exp;"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般情况下，推荐使用标签形式和标签属性形式。</p>
<h3 id="u4F7F_u7528_u6307_u4EE4"><a href="#u4F7F_u7528_u6307_u4EE4" class="headerlink" title="使用指令"></a>使用指令</h3><p>与Controller一样，指令也是通过AngularJS的Model创建的，使用<code>directive(name, directiveFactory)</code>方法创建指令，该方法有两个参数：</p>
<ul>
<li>第一个参数为指令名称，命名规范在上文中已经说过了。</li>
<li>第二个参数是一个工厂函数，该函数需要返回一个对象，我们通过配置该对象中的不同属性从而告诉AngularJS内置的<code>$compile</code>服务实现指令的不同功能。</li>
</ul>
<h4 id="u6307_u4EE4_u7C7B_u578B"><a href="#u6307_u4EE4_u7C7B_u578B" class="headerlink" title="指令类型"></a>指令类型</h4><p>上文中说过指令的实现是通过工厂函数返回对象，然后通过配置对象的不同属性实现不同功能，所以设置指令的类型也是通过配置属性对象完成的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"A"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective1"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective2"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"AE"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">my-directive1</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">my-directive2</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;div my-directive2&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看出，可以通过配置返回对象的<code>restrict</code>属性设置指令的类型，可配置的值分别为：</p>
<ul>
<li><code>&quot;A&quot;</code>：代表且仅可代表标签属性类型的指令。</li>
<li><code>&quot;E&quot;</code>：代表且仅可代表标签类型的指令。</li>
<li><code>&quot;C&quot;</code>：代表且仅可代表class名称类型的指令。</li>
<li><code>&quot;M&quot;</code>：代表且仅可代表注释类型的指令。</li>
</ul>
<p>如果想设置一个多类型的指令，那么可以将类型标识写在一起，比如<code>&quot;AEC&quot;</code>代表既是标签属性类型，又是标签类型，还是class名称类型。如果不配置<code>restrict</code>属性，那么表示指令的类型为默认的<code>&quot;AE&quot;</code>类型。</p>
<h4 id="u901A_u8FC7_u6307_u4EE4_u5C01_u88C5UI_u6A21_u677F"><a href="#u901A_u8FC7_u6307_u4EE4_u5C01_u88C5UI_u6A21_u677F" class="headerlink" title="通过指令封装UI模板"></a>通过指令封装UI模板</h4><p>在前端应用的开发过程中，不同的页面常有很多一样的UI元素，如果每个页面都写一遍，那么在维护时就常会牵一发而动全身，AngularJS中的指令可以很好的解决这个问题，它可以将UI片段封装为一个指令，从而可以在不同的页面中复用，那么在维护时就是四两拨千斤的效果。下面来看看如何实现模板指令：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function() &#123;</span><br><span class="line">  this.name = <span class="string">"Jason"</span>;</span><br><span class="line">  this.job = <span class="string">"Developer"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    template: <span class="string">"Name: &#123;&#123;mc.name&#125;&#125;, Job: &#123;&#123;mc.job&#125;&#125;"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController as mc"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;div my-directive&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码示例中，我们将本该写在HTML中的展示代码设置给了返回对象的<code>template</code>属性。为了能更好的管理UI模板，我们还可以将UI展示代码提炼成单独的HTML模板文件，并可以使用指令的<code>templateUrl</code>属性设置HTML模板文件名称，这样便可以大大降低指令和UI模板的耦合度：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    templateUrl: <span class="string">"myTemplate.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- myTemplate.html --&gt;</span></span><br><span class="line">Name: &#123;&#123;mc.name&#125;&#125;, Job: &#123;&#123;mc.job&#125;&#125;</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>那么问题来了，如果UI模板文件很多的话，按上面的方法就要写很多个对应的指令，而且只是UI模板文件名称不一样而已，实在有点冗余。AngularJS提供了另外一种解决方法，那就是可以通过给模板指令设置相关属性，从而动态的加载UI模板文件，我们来看看如何实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function() &#123;</span><br><span class="line">  this.name = <span class="string">"Jason"</span>;</span><br><span class="line">  this.job = <span class="string">"Developer"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    templateUrl: function(elem, attr) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"myTemplate-"</span> + attr.type + <span class="string">".html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController as mc"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">type</span>=<span class="value">"name"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">type</span>=<span class="value">"job"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;div my-directive type="name"&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;div my-directive type="job"&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- myTemplate-name.html --&gt;</span></span><br><span class="line">Name: &#123;&#123;mc.name&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- myTemplate-job.html --&gt;</span></span><br><span class="line">Job: &#123;&#123;mc.job&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看出，<code>template</code>和<code>templateUrl</code>两个属性的值不只是接受字符串，还接受函数。要注意的是该函数默认带两个参数：</p>
<ul>
<li>第一个参数代表当前的HTML DOM元素。</li>
<li>第二个参数代表当前HTML DOM元素的属性对象，在函数体内可以为该对象设置任何属性。</li>
</ul>
<p>在上面的示例中，我们给代表当前DOM元素的属性对象设置了<code>type</code>属性，用于标识UI模板文件名称，这样我们就可以通过一个专有的模板指令来控制所有的UI模板文件了。</p>
<h4 id="u6307_u4EE4_u7684_u4F5C_u7528_u57DF"><a href="#u6307_u4EE4_u7684_u4F5C_u7528_u57DF" class="headerlink" title="指令的作用域"></a>指令的作用域</h4><p>上面的示例中，我们通过配置可以实现动态加载UI模板文件，但是我们无法动态指定UI模板文件中显示的内容。这一节我们来了解一下如何通过指令的隔离域达到在同一个指令中动态指定UI模板文件中要显示的内容，先看看代码示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function() &#123;</span><br><span class="line">  this.jason = &#123; name: <span class="string">"Jason"</span>, job: <span class="string">"Developer"</span> &#125;;</span><br><span class="line">  this.green = &#123; name: <span class="string">"Green"</span>, job: <span class="string">"Doctor"</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span>,</span><br><span class="line">    scope: &#123;</span><br><span class="line">      personInfo: <span class="string">"=person"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    templateUrl: <span class="string">"myTemplate.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController as mc"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">person</span>=<span class="value">"mc.jason"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">hr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">person</span>=<span class="value">"mc.green"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- myTemplate.html --&gt;</span></span><br><span class="line">Name: &#123;&#123;personInfo.name&#125;&#125;, Job: &#123;&#123;personInfo.job&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>从示例中可以看到，我们给指令的返回对象又添加了一个属性<code>scope</code>，这就是指令的作用域属性，<code>scope</code>属性有三种可设置的值：</p>
<ul>
<li><code>false</code>：默认值，这表示指令共享它父节点的Controller的作用域，也就是可以使用双花括号语法直接访问父节点Controller作用域中的属性。</li>
<li><code>true</code>：创建指令自己的作用域，但是该作用域继承父节点Controller的作用域。</li>
<li><code>{}</code>：第三种是设置一个对象，表示创建了指令自己独立的作用域，与父节点Controller的作用是完全隔离的。</li>
</ul>
<p>如果我们希望指令的隔离作用域和父节点Controller的作用域之间进行交互，那么就需要将两者进行绑定，这里有三种绑定方式：</p>
<ul>
<li>使用<code>@</code>实现单向数据绑定，但是只限于绑定Controller作用域中值为字符串的属性，因为是单向绑定，所以父节点Controller修改绑定的属性可影响到指令作用域中对应的属性，反之则不可以。在HTML中使用双花括号语法取值，比如<code>person=&quot;&quot;</code>。</li>
<li>使用<code>=</code>实现双向数据绑定，在父节点Controller中修改属性和在指令中修改属性可相互影响。在HTML中直接使用属性名称，比如<code>person=&quot;jasonObj&quot;</code>。</li>
<li>使用<code>&amp;</code>实现函数绑定，用于绑定Controller中值为函数的属性，在HTML中直接调用函数，比如<code>action=&quot;click()&quot;</code>。</li>
</ul>
<p>上面的示例中我们给<code>myDirective</code>指令设置了隔离域并添加了名为<code>personInfo</code>的属性，并与父节点的<code>MyController</code>进行数据双向绑定，在HTML代码中，就可以通过<code>&lt;my-directive&gt;</code>指令标签的<code>person</code>属性与<code>MyController</code>的数据绑定了。另外，在进行绑定时还有一种简写的方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">scope: &#123;</span><br><span class="line">  personInfo: <span class="string">"="</span></span><br><span class="line">  <span class="comment">// personInfo: "@"</span></span><br><span class="line">  <span class="comment">// personInfo: "&amp;"</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">scope: &#123;</span><br><span class="line">  personInfo: <span class="string">"=personInfo"</span></span><br><span class="line">  <span class="comment">// personInfo: "@personInfo"</span></span><br><span class="line">  <span class="comment">// personInfo: "&amp;personInfo"</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="u6307_u4EE4_u7684Controller"><a href="#u6307_u4EE4_u7684Controller" class="headerlink" title="指令的Controller"></a>指令的Controller</h4><p>在指令中也可以创建Controller，和在Module中创建Controller很类似，既定义函数，在参数中注入需要的AngularJS服务既可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function($scope) &#123;</span><br><span class="line">  $scope.green = &#123; name: <span class="string">"Green"</span>, job: <span class="string">"Doctor"</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span>,</span><br><span class="line">    scope: &#123;</span><br><span class="line">      person: <span class="string">"="</span></span><br><span class="line">    &#125;,</span><br><span class="line">    controller: function($scope) &#123;</span><br><span class="line">      $scope.jason = &#123; name: <span class="string">"Jason"</span>, job: <span class="string">"Developer"</span> &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    templateUrl: <span class="string">"myTemplate.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">person</span>=<span class="value">"green"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- myTemplate.html --&gt;</span></span><br><span class="line">Name: &#123;&#123;jason.name&#125;&#125;, Job: &#123;&#123;jason.job&#125;&#125;</span><br><span class="line">Name: &#123;&#123;person.name&#125;&#125;, Job: &#123;&#123;person.job&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们给<code>myDirective</code>指令添加了Controller，有一点不同的是在添加Controller时不能设置名称，指令的Controller名称默认与指令名称一样，如果需要另外指定名称，需要配置<code>controllerAs</code>指定Controller的名称：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">controller: function($scope) &#123;</span><br><span class="line">  $scope.jason = &#123; name: <span class="string">"Jason"</span>, job: <span class="string">"Developer"</span> &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">controllerAs: <span class="string">"directiveController"</span>,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在上面示例的UI模板文件中可以看出，既可以使用指令隔离域中与父节点Controller绑定的属性，也可以使用在指令自己的Controller中定义在隔离域的属性。</p>
<h4 id="u6307_u4EE4_u4E4B_u95F4_u7684_u4EA4_u4E92"><a href="#u6307_u4EE4_u4E4B_u95F4_u7684_u4EA4_u4E92" class="headerlink" title="指令之间的交互"></a>指令之间的交互</h4><p>指令之间的交互主要是以指令的Controller为桥梁来实现的，这里的交互指的是子指令与父指令之间的交互，我们可以使用指令的<code>require</code>属性设置要引用的父指令的Controller，这里有几种配置方式：</p>
<ul>
<li><code>require: &quot;controllerName&quot;</code>：只查找指令自己的Controller。</li>
<li><code>require: &quot;^controllerName&quot;</code>：查找指令自己的Controller以及父指令的Controller。</li>
<li><code>require: &quot;^^controllerName&quot;</code>：只查找父指令的Controller。</li>
<li><code>require: [&quot;^controllerName1&quot;, &quot;^controllerName2&quot;]</code>：引用多个Controller。</li>
</ul>
<p>如果指令查找到引用的Controller后该如何使用呢，这就要使用指令的另一个重要的属性<code>link</code>函数了。<code>link</code>函数主要用来为DOM元素添加事件监听、监视模型属性变化、以及更新DOM，该函数共有五个参数：</p>
<ul>
<li><code>scope</code>：指令的作用域，默认是父节点Controller的作用域，如果指令有创建自己的作用域，那么则指指令自己的作用域。</li>
<li><code>element</code>：指令的jQLite(jQuery的子集)包装的DOM元素，可以通过该参数操作指令所在的DOM元素。</li>
<li><code>attrs</code>：指令所在DOM元素的属性对象，通过<code>.</code>语法可以获取到给DOM元素添加的属性。</li>
<li><code>controller</code>：指令通过<code>require</code>属性引用的Controller实例。</li>
<li><code>transcludeFn</code>：嵌入函数。</li>
</ul>
<p><code>link</code>函数的其他几个参数后面文章中都会讲到，当指令找到通过<code>require</code>属性引用的Controller后，我们就可以通过<code>link</code>函数的第四个参数访问引用的Controller了。来看一个示例：</p>
<h4 id="u901A_u8FC7_u6307_u4EE4_u64CD_u4F5CDOM_u5143_u7D20"><a href="#u901A_u8FC7_u6307_u4EE4_u64CD_u4F5CDOM_u5143_u7D20" class="headerlink" title="通过指令操作DOM元素"></a>通过指令操作DOM元素</h4><p>我们了解了<code>link</code>函数后就可以使用该函数实现各种有用的指令了，比如通过指令操作DOM元素：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function($interval) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"A"</span>,</span><br><span class="line">    link: function(scope, element, attrs) &#123;</span><br><span class="line">      $interval(function() &#123;</span><br><span class="line">        element.text(new <span class="type">Date</span>());</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">      Current Date is: <span class="tag">&lt;<span class="title">span</span> <span class="attribute">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例中，首先我们限定了<code>myDirective</code>指令只能以标签属性的形式使用，然后注入了AngularJS的内置服务<code>$interval</code>，通过<code>link</code>函数的第二个参数获取到指令所在的DOM元素，然后周期性更新DOM元素显示的内容。<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-4.gif" alt=""></p>
<h4 id="u6307_u4EE4_u7684_u5185_u5D4C_u673A_u5236"><a href="#u6307_u4EE4_u7684_u5185_u5D4C_u673A_u5236" class="headerlink" title="指令的内嵌机制"></a>指令的内嵌机制</h4><p>大家都知道HTML中的DOM元素是具有层级关系的，一般情况下我们使用指令封装的UI模板颗粒度都会比较小，所以就会出现指令嵌套的现象，这几需要用到指令的内嵌机制了，指令的<code>transclude</code>属性默认为<code>false</code>，如果将其设置为<code>true</code>，那么该指令就开启了内嵌机制，也就是说指令标签之间的内容可以被指定嵌入UI模板中被<code>ng-transclude</code>内置指令标记过的DOM元素中，结合之前说过的父子指令交互的内容来实现一个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myTabs"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span>,</span><br><span class="line">    transclude: <span class="literal">true</span>,</span><br><span class="line">    controller: function($scope) &#123;</span><br><span class="line">      $scope.panes = [];</span><br><span class="line">      <span class="keyword">var</span> panes = $scope.panes;</span><br><span class="line">      this.addPane = function(pane) &#123;</span><br><span class="line">        <span class="keyword">if</span>(panes.length == <span class="number">0</span>) &#123;</span><br><span class="line">          $scope.select(pane);</span><br><span class="line">        &#125;;</span><br><span class="line">        panes.push(pane);</span><br><span class="line">      &#125;;</span><br><span class="line">      $scope.select = function(pane) &#123;</span><br><span class="line">        angular.forEach(panes, function(pane) &#123;</span><br><span class="line">          pane.selected = <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        pane.selected = <span class="literal">true</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    templateUrl: <span class="string">"myTabs.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myPane"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span>,</span><br><span class="line">    require: <span class="string">"^^myTabs"</span>,</span><br><span class="line">    scope: &#123;</span><br><span class="line">      name: <span class="string">"@"</span>,</span><br><span class="line">      job: <span class="string">"@"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    link: function(scope, element, attrs, controller) &#123;</span><br><span class="line">      controller.addPane(scope);</span><br><span class="line">    &#125;,</span><br><span class="line">    templateUrl: <span class="string">"myPane.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了两个指令，<code>myTabs</code>和<code>myPane</code>，在<code>myTabs</code>指令中，我们限定它只能以标签形式使用，开启了内嵌机制，并定义了它自己的Controller，在Controller中定义了<code>panes</code>变量和<code>addPane(pane)</code>，<code>select(pane)</code>两个方法，方法的具体实现内容这里就不解释了，都很简单，最后指定了UI模板文件<code>myTabs.html</code>。</p>
<p>在<code>myPane</code>指令中同样限定只能以标签形式使用，指定了要引用的父节点的Controller名称，后创建了自己的隔离域，定义了<code>name</code>，<code>job</code>两个属性，并进行了字符串的单向绑定，然后定义了<code>link</code>函数，通过第四个参数访问到了父节点的<code>myTabs</code>Controller，并调用<code>addPane(pane)</code>函数，将自己的隔离域作为参数传入，最后指定了UI模板文件<code>myPane.html</code>。</p>
<p>再来看看<code>index.html</code>和<code>myTabs.html</code>，<code>myPane.html</code>这两个模板文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">my-tabs</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-pane</span> <span class="attribute">name</span>=<span class="value">"Jason"</span> <span class="attribute">job</span>=<span class="value">"Developer"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-pane</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-pane</span> <span class="attribute">name</span>=<span class="value">"Green"</span> <span class="attribute">job</span>=<span class="value">"Doctor"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-pane</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">my-tabs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--myTabs.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"pane in panes"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">""</span> <span class="attribute">ng-click</span>=<span class="value">"select(pane)"</span>&gt;</span>&#123;&#123;pane.name&#125;&#125;<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"paneContainer"</span> <span class="attribute">ng-transclude</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--myPane.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-show</span>=<span class="value">"selected"</span>&gt;</span></span><br><span class="line">  I am &#123;&#123;name&#125;&#125;, my job is &#123;&#123;job&#125;&#125;!</span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>index.html</code>中，<code>myTabs</code>指令包含两个<code>myPane</code>指令，这两个<code>myPane</code>指令所显示的内容将嵌入在<code>myTabs.html</code>中id为<code>paneContainer</code>的DIV中，也就是<code>myPane.html</code>中的内容会被嵌入在这个DIV里。</p>
<p>上面这三个文件中有几个点需要注意：</p>
<ul>
<li>因为在<code>myPane</code>指令的隔离域中定义了<code>name</code>和<code>job</code>属性，并进行了字符串绑定，所以在<code>index.html</code>文件中，可以对<code>myPane</code>标签里的<code>name</code>，<code>job</code>属性直接进行字符串赋值。</li>
<li>因为在<code>myPane</code>指令中引用了<code>myTabs</code>指令的Controller，并在<code>link</code>函数中将隔离域作为参数传给了<code>myTabs</code>，既<code>myTabs</code>指令的Controller中的<code>select(pane)</code>和<code>addPane(pane)</code>函数的参数均为<code>myPane</code>指令的隔离域，所以在<code>myTabs.html</code>文件中可以直接使用<code>pane</code>访问<code>myPane</code>指令隔离域中定义的属性，比如<code></code>，并且也可以在<code>myTabs</code>指令在<code>myPane</code>的隔离域中定义属性，比如<code>pane.selected = true</code>，给隔离域定义了<code>selected</code>的属性，然后可以在<code>myPane</code>指令中使用。</li>
<li><code>ng-show</code>是AngularJS内置的指令，用于显示或隐藏指定的DOM元素。</li>
</ul>
<p>看看运行效果：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-5.gif" alt=""></p>
<p><code>link</code>函数的第五个参数<code>transcludeFn</code>是一个函数，该函数常用的有两个参数<code>scope</code>和<code>function(clone){}</code>，既<code>transcludeFn(scope, function(clone){})</code>。前者是嵌入内容的作用域，与指令的隔离作用域是平行的，后者函数的参数<code>clone</code>是嵌入的内容的jquery封装，可以通过它对嵌入的内容进行DOM操作。</p>
<h4 id="u6307_u4EE4_u7684_u5176_u4ED6_u5C5E_u6027"><a href="#u6307_u4EE4_u7684_u5176_u4ED6_u5C5E_u6027" class="headerlink" title="指令的其他属性"></a>指令的其他属性</h4><p><strong>priority</strong>用于指定指令的优先级，该属性的值从1开始。当有多个指令定义在同一个DOM元素中时就需要通过该属性明确它们的执行顺序。</p>
<p><strong>replace</strong>用于判定是否将UI模板的内容替换掉指令标签本身，该属性默认值为<code>false</code>，既保留指令标签本身，若设置为<code>true</code>则替换指令标签。</p>
<h2 id="u7EC4_u5EFA_uFF08Component_uFF09"><a href="#u7EC4_u5EFA_uFF08Component_uFF09" class="headerlink" title="组建（Component）"></a>组建（Component）</h2><p>在AngularJS 1.5中新加了组建的概念，它的意图是希望从AngularJS 1.x向AngularJS 2.0迁移时能更加平顺，AngularJS团队也提倡使用组建化模式开发Web应用。那么组建是什么呢？其实组建就是指令的一种特性形式，它规避了一些指令中晦涩难理解的东西，比如<code>compile</code>函数，<code>link</code>函数，<code>scope</code>，<code>restrict</code>等，所以组建的目的就是能让我们更为傻瓜式的创建指令，能更好的遵循组建化的开发模式，提高性能以及更容易向AngularJS 2.0迁移。</p>
<h3 id="u521B_u5EFA_u7EC4_u5EFA"><a href="#u521B_u5EFA_u7EC4_u5EFA" class="headerlink" title="创建组建"></a>创建组建</h3><p>我们可以使用Module的<code>component</code>方法创建组建：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    name: <span class="string">"="</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>component</code>方法的第一个参数是组建名称，命名规则和使用方法与指令一样，第二个参数和创建指令有点不同，它并不是一个函数，而是一个对象，在该对象中对组建的配置和在指令中的配置方式很类似。</p>
<p>我们先来看看组建和指令之间有哪些区别：</p>
<ul>
<li>组建中不提供手动配置作用域，默认的作用域就是隔离域。</li>
<li>组建中通过<code>bindings</code>属性进行数据绑定，除了<code>=</code>，<code>@</code>，<code>&amp;</code>三种绑定方式以外还增加了一种<code>&lt;</code>方式，既单向绑定，但不限于字符串。从而保证了组建有自己的清晰的输入输出API。并且通过<code>bindings</code>对象绑定的属性直接绑定在组建的Controller上。</li>
<li>组建的Controller默认名称为<code>$ctrl</code>，当然也可以使用<code>controllerAs</code>属性指定Controller的名称。</li>
<li>组建只能以标签形式使用。</li>
<li>组建中没有<code>link</code>函数，<code>compile</code>函数，<code>priority</code>属性，<code>restrict</code>属性。</li>
<li>组件只能控制自身的输入输出，组建不允许修改属于自己隔离域以外的任何数据和DOM元素。一般情况下，AngularJS通过作用域（Scope）继承的特性支持跨层级修改数据的能力，但是如果当修改数据职责不清晰或不恰当的时候就会导致各种问题，所以这也就是组建的作用域默认都是隔离域的原因。</li>
</ul>
<p>使用起来和指令比较类似：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function() &#123;</span><br><span class="line">  this.person = &#123;</span><br><span class="line">    name: <span class="string">"Jason"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    person: <span class="string">"="</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Component<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController as mc"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-component</span> <span class="attribute">person</span>=<span class="value">"mc.person"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--myTemplate.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">span</span>&gt;</span>Name: &#123;&#123;$ctrl.person.name&#125;&#125;<span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="u7EC4_u5EFA_u7684_u751F_u547D_u5468_u671F"><a href="#u7EC4_u5EFA_u7684_u751F_u547D_u5468_u671F" class="headerlink" title="组建的生命周期"></a>组建的生命周期</h3><p>在组建的整个生命周期里，AngularJS提供了五个关键点的方法，可供我们监听到组建的运行状态：</p>
<ul>
<li><code>$onInit()</code>：该方法在组件及其所有 binding 初始化之后被调用，从而我们就有了一个清晰的地方统一存放数据初始化的逻辑：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.name = <span class="string">"jason"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将初始化数据的逻辑放在onInit方法中</span></span><br><span class="line"></span><br><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.$onInit = function() &#123;</span><br><span class="line">      this.name = <span class="string">"jason"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$onChanges(changesObj)</code>：当组建中单向绑定的属性值发生变化时被调用，这里要注意的是只有绑定属性值的引用发生变化时才能监听到，如果只是在指令内对属性进行修改，该方法是无法监听到的。通过该方法的参数可以获取到被修改数据当前的值、修改之前的值、是否时第一次修改：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.$onChanges = function(changesObj) &#123;</span><br><span class="line">      <span class="keyword">if</span>(changesObj.name) &#123;</span><br><span class="line">        <span class="comment">// name当前的值</span></span><br><span class="line">        <span class="keyword">var</span> nameCurrentValue = changesObj.name.currentValue;</span><br><span class="line">        <span class="comment">// name修改前的值</span></span><br><span class="line">        <span class="keyword">var</span> namePreviousValue = changesObj.name.previousValue;</span><br><span class="line">        <span class="comment">// 是否是第一次修改</span></span><br><span class="line">        <span class="keyword">var</span> isFirstChange = changesObj.name.isFirstChange();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    name: <span class="string">"&lt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$doCheck()</code>：该方法和<code>$onChanges(changesObj)</code>作用类似，但是该方法可以监听到在指令内对属性进行修改的行为： </li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    <span class="comment">// 当name在指令内修改时</span></span><br><span class="line">    this.name = <span class="string">"Green"</span>;</span><br><span class="line">    this.$doCheck = function() &#123;</span><br><span class="line">      <span class="comment">// doCheck方法会被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    name: <span class="string">"&lt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$onDestroy()</code>：当作用域被销毁时调用该方法。</li>
<li><code>$postLink()</code>：当指令所在标签与子标签链接时调用该方法。</li>
</ul>
<h3 id="u7EC4_u5EFA_u5316_u5F00_u53D1"><a href="#u7EC4_u5EFA_u5316_u5F00_u53D1" class="headerlink" title="组建化开发"></a>组建化开发</h3><p>我们先来看看示例效果：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-6.gif" alt=""></p>
<p>既然是组建化开发，那么我们来看看上面这个示例有几个组建：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-7.png" alt=""><br>从上图可以看到，整个示例一共用了三个组建，其中有两个组建进行了复用，下面我们来看看每个组建是如何定义的。</p>
<h4 id="personList_u7EC4_u5EFA"><a href="#personList_u7EC4_u5EFA" class="headerlink" title="personList组建"></a>personList组建</h4><p>该组建主要用来初始化数据源，定义对数据源操作的函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"personList"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"personList.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.$onInit = function() &#123;</span><br><span class="line">      this.list = [&#123;</span><br><span class="line">        name: <span class="string">"Jason"</span>,</span><br><span class="line">        job: <span class="string">"Developer"</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        name: <span class="string">"Green"</span>,</span><br><span class="line">        job: <span class="string">"Doctor"</span></span><br><span class="line">      &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.updatePerson = function(person, job, value) &#123;</span><br><span class="line">      person[job] = value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.deletePerson = function(person) &#123;</span><br><span class="line">      <span class="keyword">var</span> idx = this.list.indexOf(person);</span><br><span class="line">      <span class="keyword">if</span>(idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        this.list.splice(idx, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先在<code>$onInit</code>函数中初始化数据源，定义了<code>Person</code>对象数组，然后定义了更新指定<code>Person</code>对象的方法<code>updatePerson</code>及删除指定<code>Person</code>对象的方法<code>deletePerson</code>。</p>
<p>再来看看它的UI模板文件<code>personList.html</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">b</span>&gt;</span>Person<span class="tag">&lt;/<span class="title">b</span>&gt;</span><span class="tag">&lt;<span class="title">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">person-detail</span> <span class="attribute">ng-repeat</span>=<span class="value">"person in $ctrl.list"</span> <span class="attribute">person</span>=<span class="value">"person"</span> <span class="attribute">on-update</span>=<span class="value">"$ctrl.updatePerson(person, job, value)"</span> <span class="attribute">on-delete</span>=<span class="value">"$ctrl.deletePerson(person)"</span>&gt;</span><span class="tag">&lt;/<span class="title">person-detail</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该文件共有两部分，第一部分是用原生HTML标签定义了标题，第二部分是使用了另外一个组建<code>personDetail</code>。<code>ng-repeat</code>指令是AngularJS内置的指令，作用不言而喻，就是循环数据源，同时组建也跟据循环次数增加。<code>person</code>，<code>on-update</code>，<code>on-delete</code>是在<code>personDetail</code>组建中定义的数据绑定属性，用大白话解释就是，<code>personDetail</code>组建中的<code>person</code>变量与<code>personList</code>组建中的<code>Person</code>对象进行了绑定，<code>personDetail</code>组建中的<code>onUpdate</code>和<code>onDelete</code>方法分别与<code>personList</code>组建中的<code>updatePerson</code>和<code>deletePerson</code>方法进行了绑定。</p>
<h4 id="personDetail_u7EC4_u5EFA"><a href="#personDetail_u7EC4_u5EFA" class="headerlink" title="personDetail组建"></a>personDetail组建</h4><p>该组建主要用于展示Person对象的具体内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"personDetail"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"personDetail.html"</span>,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    person: <span class="string">"&lt;"</span>,</span><br><span class="line">    onUpdate: <span class="string">"&amp;"</span>,</span><br><span class="line">    onDelete: <span class="string">"&amp;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.update = function(job, value) &#123;</span><br><span class="line">      this.onUpdate(&#123;person: this.person, job: job, value: value&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.delete = function() &#123;</span><br><span class="line">      this.onDelete(this.person);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">  Name: &#123;&#123;$ctrl.person.name&#125;&#125;<span class="tag">&lt;<span class="title">br</span>&gt;</span></span><br><span class="line">  Job: <span class="tag">&lt;<span class="title">editable-field</span> <span class="attribute">field-value</span>=<span class="value">"$ctrl.person.job"</span> <span class="attribute">on-update</span>=<span class="value">"$ctrl.update('job', value)"</span>&gt;</span><span class="tag">&lt;/<span class="title">editable-field</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"$ctrl.delete()"</span>&gt;</span>Delete<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>personDetail.html</code>文件里，首先访问了<code>person</code>对象的<code>name</code>属性，将其展示出来，注意，这里由<code>$ctrl.preson</code>访问到的其实是单向绑定的<code>personList</code>组建中的<code>person</code>对象。而且在<code>update</code>函数中调用了与<code>personList</code>组建的<code>updatePerson</code>函数绑定的<code>onUpdate</code>函数，也就是子组建调用了父组建的方法。然后使用了第三个组建<code>editableField</code>，该组建同样有一些属性和方法和<code>personDetail</code>组建中对应的属性和方法进行了绑定。最后增加了一个按钮，并使用<code>ng-click</code>指令指定了按钮的点击事件。 </p>
<h4 id="editableField_u7EC4_u5EFA"><a href="#editableField_u7EC4_u5EFA" class="headerlink" title="editableField组建"></a>editableField组建</h4><p>该组建的主要作用是展示并修改<code>person</code>对象中的<code>job</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"editableField"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"editableField.html"</span>,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    fieldValue: <span class="string">"&lt;"</span>,</span><br><span class="line">    onUpdate: <span class="string">"&amp;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.$onInit = function() &#123;</span><br><span class="line">      this.editMode = <span class="literal">false</span>;</span><br><span class="line">      this.fieldValueCopy = this.fieldValue;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.handModelChange = function() &#123;</span><br><span class="line">      <span class="keyword">if</span>(this.editMode) &#123;</span><br><span class="line">        this.onUpdate(&#123;job: <span class="string">"job"</span>, value: this.fieldValue&#125;);</span><br><span class="line">        this.fieldValueCopy = this.fieldValue;</span><br><span class="line">      &#125;</span><br><span class="line">      this.editMode = !this.editMode;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.reset = function() &#123;</span><br><span class="line">      this.fieldValue = this.fieldValueCopy;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从最开始的运行效果中可以看到<code>editableField</code>是有形态变化的，所以在<code>$onInit</code>函数中定义了是否为编辑模式的标识符<code>editMode</code>以及代表输入框内容的<code>fieldValue</code>变量，因为有<code>reset</code>功能，所以还定义存储修改之前值的变量<code>fieldValueCopy</code>。然后定义了点击<code>Edit</code>或<code>Save</code>按钮触发的函数<code>handModelChange</code>，并在该函数中调用了和<code>personDetail</code>组建的<code>update</code>函数绑定的<code>onUpdate</code>函数，同样由子组建调用了父组建的方法。还定义了点击<code>Reset</code>按钮触发的函数<code>reset</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&lt;span ng-<span class="keyword">switch</span>=<span class="string">"$ctrl.editMode"</span>&gt;</span><br><span class="line">  &lt;input ng-<span class="keyword">switch</span>-when=<span class="string">"true"</span> type=<span class="string">"text"</span> ng-model=<span class="string">"$ctrl.fieldValue"</span>&gt;</span><br><span class="line">  &lt;span ng-<span class="keyword">switch</span>-<span class="keyword">default</span>&gt;&#123;&#123;$ctrl.fieldValue&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;button ng-click=<span class="string">"$ctrl.handModelChange()"</span>&gt;&#123;&#123;$ctrl.editMode ? <span class="string">"Save"</span> : <span class="string">"Edit"</span>&#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;button ng-<span class="keyword">if</span>=<span class="string">"$ctrl.editMode"</span> ng-click=<span class="string">"$ctrl.reset()"</span>&gt;<span class="type">Reset</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>在<code>editableField.html</code>文件中展示了<code>person</code>对象的<code>job</code>属性，定义了修改<code>job</code>属性的输入框以及两个按钮。这里出现了一组之前没见过的AngularJS内置指令，<code>ng-switch</code>、<code>ng-switch-when</code>、<code>ng-switch-default</code>，这三个指令一般组合使用，作用类似<code>if else</code>语句，通过这组指令和<code>deitMode</code>变量就可以达到动态变换DOM元素的功能。</p>
<p>最后来看看简单的<code>index.html</code>文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">person-list</span>&gt;</span><span class="tag">&lt;/<span class="title">person-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的这个示例中可以看出在<code>editableField</code>和<code>personDetail</code>组建中都没有真正意义上去修改数据源，而是通过函数绑定一路将修改数据源的行为传递到了定义数据源的组建<code>personList</code>中，由它最后真正完成对数据源的修改，这也遵循了组建不允许修改属于自己隔离域以外的任何数据和DOM元素的原则。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这篇文章是对AngularJS 1.x的入门学习小记，对一些基本概念的介绍，如果想要深入了解AngularJS可以去读官方的<a href="https://docs.angularjs.org/guide" target="_blank" rel="external">文档</a>和<a href="https://docs.angularjs.org/api" target="_blank" rel="external">API</a>。此刻AngularJS 2.0已正式发布，掌握AngularJS 1.x的基本知识能更快的帮助我们迈入AngularJS 2.0的怀抱，让我们不忘AngularJS 1.x初心，去拥抱AngularJS 2.0的美好未来。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/shadowsocks-guide/" itemprop="url">
                  使用ShadowSocks科学上网及突破公司内网
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-08-19T00:00:00+08:00" content="2016-08-19">
              2016-08-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/shadowsocks-guide/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/shadowsocks-guide/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h1 id="u4EC0_u4E48_u662FShadowSocks"><a href="#u4EC0_u4E48_u662FShadowSocks" class="headerlink" title="什么是ShadowSocks"></a>什么是ShadowSocks</h1><p>ShadowSocks是基于Socks5协议，使用类似SSH隧道的方式收发网络请求的一款开源软件，该软件由<a href="https://twitter.com/clowwindy" title="clowwindy" target="_blank" rel="external"> @clowwindy </a>开发，最初只有Python版本，随后出现C++、C#、Go等多语言版本。ShadowSocks最大的特点是可以保护网络流量、加密数据传输，可有效防止GFW（Great Firewall of China）封杀网络请求。</p>
<h1 id="u7528ShadowSocks_u79D1_u5B66_u4E0A_u7F51_u7684_u6982_u5FF5"><a href="#u7528ShadowSocks_u79D1_u5B66_u4E0A_u7F51_u7684_u6982_u5FF5" class="headerlink" title="用ShadowSocks科学上网的概念"></a>用ShadowSocks科学上网的概念</h1><p>在以前，我们访问互联网的资源都是简单而直接的，用户的请求发送到资源服务方，比如Google、Facebook等，然后资源服务方直接将内容响应给用户，世界多么美好。</p>
<p> <img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-9.png" alt=""></p>
<p>但是，在1998年时候，中国创建了互联网边界审查系统，称之为中国国家防火墙（GFW），这堵墙横在了用户和互联网资源服务方之间，用于监控和过滤互联网国际出口上的内容，监控国际网关的通讯，对认为不匹配国家官方要求的传输内容，进行干扰、阻断、屏蔽。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shaodwsocksss-10.png" alt=""></p>
<p>从此之后好多有价值的网站就被堵在了墙后。</p>
<p>但是由于对知识的渴望，人们想到了绕过GFW的办法，那就是在境外搭建一个国内用户的代理，国内用户与代理之间建立加密的通道，由境外代理请求被墙的网络资源，再通过加密通道返回给国内用户。代理的类型也有多种，像HTTP、Socks、VPN、SSH等。以SSH隧道为例：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-11.png" alt=""></p>
<p>因为SSH本身基于RSA加密技术，所以GFW就无法对数据传输过程加密的数据进行分析，从而避免被重置链接、阻断、屏蔽等问题。</p>
<p>但是GFW也不会懵B一世，人家也会学习，由于在创建SSH隧道的过程中有较为明显的特性，所以GFW还是可以通过分析连接的特性进行干扰。此时ShadowSocks横空出世，先看看图示：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-12.png" alt=""></p>
<p>简单来说，ShadowSocks分为客户端和服务端，用户发出的请求基于Socks5协议与ShadowSocks客户端进行通信，一般情况下SS客户端都在本机，通过ShadowSocksX、GoAgentX等应用启动，所以这一步是不会经过GFW的，然后ShadowSocks提供了多种加密方式供客户端和服务端之间进行通信，并且在经过GFW时是普通的TCP协议数据包，没有明显的特征，而且GFW也无法解密分析，从而实现绕墙访问资源。</p>
<h1 id="u642D_u5EFAShadowSocks_u670D_u52A1_u5668"><a href="#u642D_u5EFAShadowSocks_u670D_u52A1_u5668" class="headerlink" title="搭建ShadowSocks服务器"></a>搭建ShadowSocks服务器</h1><p>根据上文描述的ShadowSocks的实现原理，我们首先需要搭建一个境外的ShadowSocks服务器，这部分也是唯一需要我们花点小钱的地方。</p>
<blockquote>
<p>以下文章内容均在MacOS下实践。</p>
</blockquote>
<h2 id="u8D2D_u4E70VPS"><a href="#u8D2D_u4E70VPS" class="headerlink" title="购买VPS"></a>购买VPS</h2><p>我使用的是<a href="http://www.vultr.com" target="_blank" rel="external">Vultr</a>的VPS，他家的VPS可选的地域较为丰富，而且有日本东京，这对于家里是联通网络的比较亲和，速度较好：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-1.png" alt="" title="Server Location"><br>在系统和应用方面Vultr提供的种类也比较丰富：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-2.png" alt="" title="Server Type"><br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-3.png" alt="" title="Application"><br>在价格方面，Vultr提供的最低价格为每月5美元，对应的性能足够满足ShadowSocks服务端的需求：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-4.png" alt="" title="Server Price"><br>注册Vultr账号，绑定信用卡，选择自己中意的系统和价格后立即就会为你部署好VPS：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-5.png" alt=""><br>当VPS的状态为Running后，就表示VPS已经启动了，然后为该VPS配置我们的SSH公钥：<br> <img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-6.png" alt=""><br>大家可以看看北京联通ping东京VPS的速度，还是很给力的：<br> <img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-7.png" alt=""></p>
<blockquote>
<p>使用该<a href="http://www.vultr.com/?ref=6955175-3B" target="_blank" rel="external">链接</a>注册可获得20美元的优惠卷。</p>
</blockquote>
<h2 id="u5B89_u88C5ShadowSocks"><a href="#u5B89_u88C5ShadowSocks" class="headerlink" title="安装ShadowSocks"></a>安装ShadowSocks</h2><p>我们使用Python版的ShadowSocks进行安装，首先需要下载<a href="https://pypi.python.org/pypi/pip#downloads" target="_blank" rel="external">pip-8.1.2.tar.gz</a>，然后使用工具将其上传至VPS，我使用的是Commander One，通过SFTP连接VPS：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-8.png" alt=""><br>使用Terminal连接VPS，一步一步输入以下命令解压安装pip：</p>
<pre><code>tar -xzvf pip-8.1.2.tar.gz
cd pip-8.1.2
python setup.py install
</code></pre><p>然后通过pip安装ShadowSocks：</p>
<pre><code>pip install shadowsocks
</code></pre><p>成功后可以看到如下信息：</p>
<pre><code>Collecting shadowsocks
  Downloading shadowsocks-2.8.2.tar.gz
Installing collected packages: shadowsocks
  Running setup.py install for shadowsocks ... done
Successfully installed shadowsocks-2.8.2
</code></pre><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h2 id="u914D_u7F6EShadowSocks"><a href="#u914D_u7F6EShadowSocks" class="headerlink" title="配置ShadowSocks"></a>配置ShadowSocks</h2><p>进入到etc目录下，创建shadowsocks.json文件，并添加如下内容：</p>
<pre><code>{
    &quot;server&quot;:&quot;你的VPS的IP&quot;,
    &quot;server_port&quot;:8388,
    &quot;local_port&quot;:1080,
    &quot;password&quot;:&quot;设置一个连接密码&quot;,
    &quot;timeout&quot;:600,
    &quot;method&quot;:&quot;aes-256-cfb&quot;,
    &quot;auth&quot;: true
}
</code></pre><p>该文件就是ShadowSocks的配置文件。<br>然后输入如下命令启动ShadowSocks服务：</p>
<pre><code>ssserver -c /etc/shadowsocks.json -d start
</code></pre><p>最后清空防火墙规则：</p>
<pre><code>iptables -F
</code></pre><p>至此ShadowSocks服务端就配置完成并可以使用了。</p>
<h1 id="ShadowSocks_u5BA2_u6237_u7AEF"><a href="#ShadowSocks_u5BA2_u6237_u7AEF" class="headerlink" title="ShadowSocks客户端"></a>ShadowSocks客户端</h1><p>Mac上ShadowSocks客户端的选择无非就是ShadowSocksX、GoAgentX、Surge这三个，前两者配置起来都大同小异，ShadowSocksX本身就是专门开启SS客户端服务的应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-14.png" alt=""></p>
<p>GoAgentX提供的服务类型更多，包括SS服务：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-13.png" alt=""></p>
<p>配置项都是一样的，把ShadowSocks服务端的配置信息一一对应就可以了。</p>
<p>Surge启SS服务的方式有点不同，因为应用在界面操作上没有提供创建SS服务的选项，但其实它是支持SS服务的，可能因为怕被请喝茶吧。所以需要在Surge的配置文件里添加SS服务相关的信息，如何配置网上有很多，这里就不再累赘了。</p>
<p>至此就打通了ShadowSocks客户端与服务端的通道，可以畅游墙外的世界了。</p>
<h1 id="u7A81_u7834_u516C_u53F8_u5185_u7F51"><a href="#u7A81_u7834_u516C_u53F8_u5185_u7F51" class="headerlink" title="突破公司内网"></a>突破公司内网</h1><p>一般情况在家我们在本机启着ShadowSocks客户端就可以了，但是如果在公司上外网需要走HTTP代理的话就不行了，因为ShadowSocks客户端需要走公司提供的代理才能连接到服务端，而上文中的客户端应用统统不支持额外代理功能，所以此时就需要用到另外一个工具<a href="https://www.proxifier.com" target="_blank" rel="external">Proxifier</a>，该工具的作用就是接管运行中的所有应用发出的所有请求，然后通过代理进行转发，这样就可以让不支持代理的应用也可以走代理了。</p>
<p>打开Proxifier，选择Proxies选项卡设置公司的HTTP代理以及本地Socks5代理：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-15.png" alt=""><br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-16.png" alt=""></p>
<p>然后启动ShadowSocks客户端，比如启动GoAgentX，此时选择Proxifier的Rules选项卡，就会发现Proxifier自动捕获到了名为ss-local的应用，就是由GoAgentX开启的SS客户端，将其的代理规则设置为之前创建好的公司代理：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-17.png" alt=""></p>
<p>然后将Default的代理规则设置为之前创建好的本地Socks5代理：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-18.png" alt=""></p>
<p>这样就可以让ShadowSocks客户端通过公司代理连接服务端了：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-19.png" alt=""></p>
<p>你还可以设置其他的规则，让特定的应用走特定的代理，比如我让Git还是走了公司代理，这样Git服务就会从Default规则里剔除掉，相当于加了走SS服务的例外。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p><link rel="stylesheet" href="http://7xpp8a.com1.z0.glb.clouddn.com/tomorrow.css"></p>
<script src="http://7xpp8a.com1.z0.glb.clouddn.com/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/read-concurrency-programming-guide-3/" itemprop="url">
                  读 Concurrency Programming Guide 笔记（三）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-04-21T00:00:00+08:00" content="2016-04-21">
              2016-04-21
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/read-concurrency-programming-guide-3/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/read-concurrency-programming-guide-3/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/69122" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="u901A_u8FC7Dispatch_Queue_u6267_u884C_u4EFB_u52A1"><a href="#u901A_u8FC7Dispatch_Queue_u6267_u884C_u4EFB_u52A1" class="headerlink" title="通过Dispatch Queue执行任务"></a>通过Dispatch Queue执行任务</h2><p>如果想让Dispatch Queue执行任务，首先就是得将任务放入队列中，我们可以异步的将任务加入队列，也可以同步的将任务加入队列，可以一个任务一个任务的加，也可以一组一组的加。这节我们就来看看将任务加入队列的那些事。</p>
<h3 id="u5411_u961F_u5217_u6DFB_u52A0_u4EFB_u52A1"><a href="#u5411_u961F_u5217_u6DFB_u52A0_u4EFB_u52A1" class="headerlink" title="向队列添加任务"></a>向队列添加任务</h3><p>我们可以使用<code>dispatch_async</code>或者<code>dispatch_async_f</code>函数异步的向队列中添加任务，也就是说当我们添加完任务后该函数会立即返回，我们不需要等待任务执行完成，而且我们也不会知道队列到底何时开始执行任务。<code>dispatch_async</code>函数有两个参数，一个是目标队列，类型为<code>dispatch_queue_t</code>，另一个是闭包，类型为<code>dispatch_block_t</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_async(serialQueue, &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task in the queue..."</span>)</span><br><span class="line">        </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>dispatch_async_f</code>函数有三个参数，第一个是类型为<code>dispatch_queue_t</code>的目标队列，第二个是队列上下文指针，第三个是类型为<code>dispatch_function_t</code>的任务函数，队列上下文指针为该函数的唯一参数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTaskToQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in the queue..."</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async_f(serialQueue, <span class="built_in">unsafeBitCast</span>(<span class="number">0</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>), taskFunction())</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">taskFunction</span><span class="params">()</span></span> -&gt; dispatch_function_t &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123; context <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Do some work with context..."</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addTaskToQueue = <span class="type">AddTaskToQueue</span>()</span><br><span class="line">addTaskToQueue.launch()</span><br></pre></td></tr></table></figure>
<p>除了这两个函数，我们还可以使用<code>dispatch_sync</code>和<code>dispatch_sync_f</code>函数同步的向队列中添加任务，并且我们要等待直到任务执行完成。这两个函数和上面的异步添加任务函数用法完全一致。</p>
<p>那么什么时候用异步什么时候用同步呢，大多数情况下我们都是在主线程中使用GCD分派任务，为了避免阻塞主线程，影响用户体验，所以通常情况下我们都使用异步添加任务的方式。当然为了避免任务与主线程中产生资源竞争的问题，有时候酌情也会使用同步添加任务的方式。</p>
<h3 id="Dispatch_Queue_u7684Completion_Block"><a href="#Dispatch_Queue_u7684Completion_Block" class="headerlink" title="Dispatch Queue的Completion Block"></a>Dispatch Queue的Completion Block</h3><p>还记得<code>NSOperation</code>的<code>completionBlock</code>属性吗，这个回调函数在任务执行完成后调用，用于处理有些后续工作或者消息通知。在Dispatch Queue中并没有类似的属性，但是我们可以通过其他方式来实现。举一个很常见的应用场景，我们在主线程中分派一个下载图片的任务，让其在二级线程中执行，当图片下载完成后通知主线程，并由主线程将图片显示出来，我们看看简单的代码片段：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadImage</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dispatchTaskInMainThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), downloadImage())</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">downloadImage</span><span class="params">()</span></span> -&gt; (() -&gt; ()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Downloading image in <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">            dispatch_async(dispatch_get_main_queue()) &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Handle image and display in <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看上面代码都做了些什么，首先在<code>dispatchTaskInMainThread</code>方法中，我们使用<code>dispatch_get_global_queue</code>函数获取到全局并发队列，然后将<code>downloadImage</code>下载图片的方法作为任务添加到该全局队列中。在<code>downloadImage</code>方法里，当图片下载完成后通过<code>dispatch_get_main_queue</code>函数获取到主队列，也就是在主线程中对图片进行处理，这样我们就达到了Completion Block的效果。</p>
<h3 id="u5728_u961F_u5217_u4E2D_u5FAA_u73AF_u6267_u884C_u4EFB_u52A1"><a href="#u5728_u961F_u5217_u4E2D_u5FAA_u73AF_u6267_u884C_u4EFB_u52A1" class="headerlink" title="在队列中循环执行任务"></a>在队列中循环执行任务</h3><p>在我们的日常开发中，经常会使用到for循环来处理一些任务，而且这些任务之间也并没有先后顺序的关联，每个任务相对比较独立。遇到这种情况，我们可以用<code>dispatch_apply</code>或<code>dispatch_apply_f</code>函数让任务在队列中循环执行，并且可以是并发执行，这样相比for循环的串行执行要更加效率：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>, <span class="string">"Java"</span>, <span class="string">"Delphi"</span>, <span class="string">"C++"</span>]</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> arr &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Handle element. the element is <span class="subst">\(element)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dispatch_apply</span></span><br><span class="line">dispatch_apply(arr.<span class="built_in">count</span>, dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>))&#123; index <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Handle element. the element is <span class="subst">\(arr[index])</span>. Current thread is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面示例代码片段中可以看到，<code>dispatch_apply</code>函数有三个参数，第一个参数是循环次数，第二个参数是目标队列，第三个则是要执行的闭包任务，循环次数是该闭包的唯一参数。</p>
<h3 id="u6682_u505C_u548C_u91CD_u542F_u961F_u5217"><a href="#u6682_u505C_u548C_u91CD_u542F_u961F_u5217" class="headerlink" title="暂停和重启队列"></a>暂停和重启队列</h3><p>在Dispatch Queue执行任务时，如果我们想暂停队列，可以使用<code>dispatch_suspend</code>函数，重新让队列执行任务可以使用<code>dispatch_resume</code>。这里要注意的是暂停队列只是让队列暂时停止执行下一个任务，而不是中断当前正在执行的任务。</p>
<h3 id="Dispatch_Group_u7684_u4F7F_u7528"><a href="#Dispatch_Group_u7684_u4F7F_u7528" class="headerlink" title="Dispatch Group的使用"></a>Dispatch Group的使用</h3><p>在实际开发中，为了提升性能我们或许会经常使用<code>dispatch_async</code>异步的将任务添加进队列去执行，但有些时候需要之前队列中的多个任务都执行完成之后，才能获取到正确的或者说想要的结果供后续逻辑代码使用，遇到这种情况，就可以使用Dispatch Group，将多个任务在队列中归为一个组，并可以使用<code>dispatch_group_wait</code>函数让之后的逻辑代码等待，直到该组的任务都执行完成后再执行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> concurrentQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_async(concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task1 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_async(concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task2 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_async(concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task3 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"I expect the count is 3, and the factual count is <span class="subst">\(<span class="built_in">count</span>)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码片段就是我刚才描述的场景，因为使用的是并发队列，也不好在每个任务里进行回调处理，所以我们永远不会得到正确的<code>count</code>。如果我们使用Dispatch Group事情就简单多了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> concurrentQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dispatchGroup = dispatch_group_create()</span><br><span class="line">        </span><br><span class="line">dispatch_group_async(dispatchGroup, concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task1 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_group_async(dispatchGroup, concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task2 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_group_async(dispatchGroup, concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task3 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_group_wait(dispatchGroup, <span class="type">DISPATCH_TIME_FOREVER</span>)</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"I expect the count is 3, and the factual count is <span class="subst">\(<span class="built_in">count</span>)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码中，先使用<code>dispatch_group_create</code>函数创建Dispatch Group，然后使用<code>dispatch_group_async</code>函数将任务分进组里，然后再添加进队列中。该函数有三个参数，分别是Dispatch Group、Dispatch Queue和要执行任务的闭包。当添加完任务后使用<code>dispatch_group_wait</code>函数等待，直到指定组的任务全部完成，才会继续执行后面的打印语句，该函数有两个参数，第一个是目标组，第二个是等待时间<code>DISPATCH_TIME_NOW</code>或<code>DISPATCH_TIME_FOREVER</code>。</p>
<h2 id="Dispatch_Source"><a href="#Dispatch_Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h2><p>前面的文章中介绍过Dispatch Source：</p>
<blockquote>
<p>Dispatch Source是GCD中的一个基本类型，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。我们来看看它都有哪些类型：</p>
<ul>
<li>Timer Dispatch Source：定时调度源。</li>
<li>Signal Dispatch Source：监听UNIX信号调度源，比如监听代表挂起指令的SIGSTOP信号。</li>
<li>Descriptor Dispatch Source：监听文件相关操作和Socket相关操作的调度源。</li>
<li>Process Dispatch Source：监听进程相关状态的调度源。</li>
<li>Mach port Dispatch Source：监听Mach相关事件的调度源。</li>
<li>Custom Dispatch Source：监听自定义事件的调度源。</li>
</ul>
</blockquote>
<p>这一节就来看看如何使用Dispatch Source。</p>
<p>用通俗一点的话说就是用GCD的函数指定一个希望监听的系统事件类型，再指定一个捕获到事件后进行逻辑处理的闭包或者函数作为回调函数，然后再指定一个该回调函数执行的Dispatch Queue即可，当监听到指定的系统事件发生时会调用回调函数，将该回调函数作为一个任务放入指定的队列中执行。也就是说当监听到系统事件后就会触发一个任务，并自动将其加入队列执行，这里与之前手动添加任务的模式不同，一旦将Diaptach Source与Dispatch Queue关联后，只要监听到系统事件，Dispatch Source就会自动将任务（回调函数）添加到关联的队列中。</p>
<p>有些时候回调函数执行的时间较长，在这段时间内Dispatch Source又监听到多个系统事件，理论上就会形成事件积压，但好在Dispatch Source有很好的机制解决这个问题，当有多个事件积压时会根据事件类型，将它们进行关联和结合，形成一个新的事件。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u76D1_u542C_u4E8B_u4EF6_u7C7B_u578B"><a href="#u76D1_u542C_u4E8B_u4EF6_u7C7B_u578B" class="headerlink" title="监听事件类型"></a>监听事件类型</h3><p>Dispatch Source一共可以监听六类事件，分为11个类型，我们来看看都是什么：</p>
<ul>
<li><code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>：属于自定义事件，可以通过<code>dispatch_source_get_data</code>函数获取事件变量数据，在我们自定义的方法中可以调用<code>dispatch_source_merge_data</code>函数向Dispatch Source设置数据，下文中会有详细的演示。</li>
<li><code>DISPATCH_SOURCE_TYPE_DATA_OR</code>：属于自定义事件，用法同上面的类型一样。</li>
<li><code>DISPATCH_SOURCE_TYPE_MACH_SEND</code>：Mach端口发送事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_MACH_RECV</code>：Mach端口接收事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_PROC</code>：与进程相关的事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_READ</code>：读文件事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_WRITE</code>：写文件事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_VNODE</code>：文件属性更改事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_SIGNAL</code>：接收信号事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_TIMER</code>：定时器事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_MEMORYPRESSURE</code>：内存压力事件。</li>
</ul>
<h3 id="u521B_u5EFADispatch_Source"><a href="#u521B_u5EFADispatch_Source" class="headerlink" title="创建Dispatch Source"></a>创建Dispatch Source</h3><p>我们可以使用<code>dispatch_source_create</code>函数创建Dispatch Source，该函数有四个参数：</p>
<ul>
<li><code>type</code>：第一个参数用于标识Dispatch Source要监听的事件类型，共有11个类型。</li>
<li><code>handle</code>：第二个参数是取决于要监听的事件类型，比如如果是监听Mach端口相关的事件，那么该参数就是<code>mach_port_t</code>类型的Mach端口号，如果是监听事件变量数据类型的事件那么该参数就不需要，设置为0就可以了。</li>
<li><code>mask</code>：第三个参数同样取决于要监听的事件类型，比如如果是监听文件属性更改的事件，那么该参数就标识文件的哪个属性，比如<code>DISPATCH_VNODE_RENAME</code>。</li>
<li><code>queue</code>：第四个参数设置回调函数所在的队列。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatchQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dispatchSource = dispatch_source_create(<span class="type">DISPATCH_SOURCE_TYPE_DATA_ADD</span>, <span class="number">0</span>, <span class="number">0</span>, dispatchQueue)</span><br></pre></td></tr></table></figure>
<p>上面的代码就是创建Dispatch Source的简单示例。</p>
<h3 id="u8BBE_u7F6E_u4E8B_u4EF6_u5904_u7406_u5668"><a href="#u8BBE_u7F6E_u4E8B_u4EF6_u5904_u7406_u5668" class="headerlink" title="设置事件处理器"></a>设置事件处理器</h3><p>前文中提到过，当Dispatch Source监听到事件时会调用指定的回调函数或闭包，该回调函数或闭包就是Dispatch Source的事件处理器。我们可以使用<code>dispatch_source_set_event_handler</code>或<code>dispatch_source_set_event_handler_f</code>函数给创建好的Dispatch Source设置处理器，前者是设置闭包形式的处理器，后者是设置函数形式的处理器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dispatch_source_set_event_handler(dispatchSource, &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Dispatch Source 事件处理器..."</span>)</span><br><span class="line">        </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据闭包尾随的特性，还可以有下面的写法</span></span><br><span class="line"></span><br><span class="line">dispatch_source_set_event_handler(dispatchSource) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Dispatch Source 事件处理器..."</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面示例代码中可以看到，该函数有两个参数，第一个是设置目标Dispatch Source，第二个参数就是设置处理器了。</p>
<p>既然是事件处理器，那么肯定需要获取一些Dispatch Source的信息，GCD提供了三个在处理器中获取Dispatch Source相关信息的函数，比如<code>handle</code>、<code>mask</code>。而且针对不同类型的Dispatch Source，这三个函数返回数据的值和类型都会不一样，下面来看看这三个函数：</p>
<ul>
<li><code>dispatch_source_get_handle</code>：这个函数用于获取在创建Dispatch Source时设置的第二个参数<code>handle</code>。<ul>
<li>如果是读写文件的Dispatch Source，返回的就是描述符。</li>
<li>如果是信号类型的Dispatch Source，返回的是<code>int</code>类型的信号数。</li>
<li>如果是进程类型的Dispatch Source，返回的是<code>pid_t</code>类型的进程id。</li>
<li>如果是Mach端口类型的Dispatch Source，返回的是<code>mach_port_t</code>类型的Mach端口。</li>
</ul>
</li>
<li><code>dispatch_source_get_data</code>：该函数用于获取Dispatch Source监听到事件的相关数据。<ul>
<li>如果是读文件类型的Dispatch Source，返回的是读到文件内容的字节数。</li>
<li>如果是写文件类型的Dispatch Source，返回的是文件是否可写的标识符，正数表示可写，负数表示不可写。</li>
<li>如果是监听文件属性更改类型的Dispatch Source，返回的是监听到的有更改的文件属性，用常量表示，比如<code>DISPATCH_VNODE_RENAME</code>等。</li>
<li>如果是进程类型的Dispatch Source，返回监听到的进程状态，用常量表示，比如<code>DISPATCH_PROC_EXIT</code>等。</li>
<li>如果是Mach端口类型的Dispatch Source，返回Mach端口的状态，用常量表示，比如<code>DISPATCH_MACH_SEND_DEAD</code>等。</li>
<li>如果是自定义事件类型的Dispatch Source，返回使用<code>dispatch_source_merge_data</code>函数设置的数据。</li>
</ul>
</li>
<li><code>dispatch_source_get_mask</code>：该函数用于获取在创建Dispatch Source时设置的第三个参数<code>mask</code>。在进程类型，文件属性更改类型，Mach端口类型的Dispatch Source下该函数返回的结果与<code>dispatch_source_get_data</code>一样。</li>
</ul>
<h3 id="u6CE8_u518CCancellation_Handler"><a href="#u6CE8_u518CCancellation_Handler" class="headerlink" title="注册Cancellation Handler"></a>注册Cancellation Handler</h3><p>Cancellation Handler就是当Dispatch Source被释放时用来处理一些后续事情，比如关闭文件描述符或者释放Mach端口等。我们可以使用<code>dispatch_source_set_cancel_handler</code>函数或者<code>dispatch_source_set_cancel_handler_f</code>函数给Dispatch Source注册Cancellation Handler：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dispatch_source_set_cancel_handler(dispatchSource) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"进行善后处理..."</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数有两个参数，第一个参数是目标Dispatch Source，第二个参数就是要进行善后处理的闭包或者函数。</p>
<h3 id="u66F4_u6539Dispatch_Source_u7684_u76EE_u6807_u961F_u5217"><a href="#u66F4_u6539Dispatch_Source_u7684_u76EE_u6807_u961F_u5217" class="headerlink" title="更改Dispatch Source的目标队列"></a>更改Dispatch Source的目标队列</h3><p>在上文中，我们说过可以使用<code>dispatch_source_create</code>函数创建Dispatch Source，并且在创建时会指定回调函数执行的队列，那么如果事后想更改队列，比如说想更改队列的优先级，这时我们可以使用<code>dispatch_set_target_queue</code>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatchQueueDefaultPriority = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dispatchSource = dispatch_source_create(<span class="type">DISPATCH_SOURCE_TYPE_DATA_ADD</span>, <span class="number">0</span>, <span class="number">0</span>, dispatchQueueDefaultPriority)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dispatchQueueLowPriority = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_LOW</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_set_target_queue(dispatchSource, dispatchQueueLowPriority)</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，如果在更改目标队列时，Dispatch Source已经监听到相关事件，并且回调函数已经在之前的队列中执行了，那么会一直在旧的队列中执行完成，不会转移到新的队列中去。</p>
<h3 id="u6682_u505C_u6062_u590DDispatch_Source"><a href="#u6682_u505C_u6062_u590DDispatch_Source" class="headerlink" title="暂停恢复Dispatch Source"></a>暂停恢复Dispatch Source</h3><p>暂停和恢复Dispatch Source与Dispatch Queue一样，都适用<code>dispatch_suspend</code>和<code>dispatch_resume</code>函数。这里需要注意的是刚创建好的Dispatch Source是处于暂停状态的，所以使用时需要用<code>dispatch_resume</code>函数将其启动。</p>
<h3 id="u5E9F_u9664Dispatch_Source"><a href="#u5E9F_u9664Dispatch_Source" class="headerlink" title="废除Dispatch Source"></a>废除Dispatch Source</h3><p>如果我们不再需要使用某个Dispatch Source时，可以使用<code>dispatch_source_cancel</code>函数废除，该函数只有一个参数，那就是目标Dispatch Source。</p>
<h3 id="Dispatch_Source_u5B9E_u8DF5"><a href="#Dispatch_Source_u5B9E_u8DF5" class="headerlink" title="Dispatch Source实践"></a>Dispatch Source实践</h3><p>说了这么多，这一节来看看Dispatch Source到底怎么用。</p>
<h4 id="u7528Dispatch_Source_u76D1_u542C_u5B9A_u65F6_u5668"><a href="#u7528Dispatch_Source_u76D1_u542C_u5B9A_u65F6_u5668" class="headerlink" title="用Dispatch Source监听定时器"></a>用Dispatch Source监听定时器</h4><p>Dispatch Source能监听的事件中有一个类型就是定时器，我们来看看如何实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchSource</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> dispatchQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> timer = createTimerDispatchSource(dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="number">0</span>), interval: <span class="type">NSEC_PER_SEC</span> * <span class="number">5</span>, leeway: <span class="number">0</span>, queue: dispatchQueue) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"处理定时任务，该任务每5秒执行一次..."</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch_resume(timer)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">30</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">createTimerDispatchSource</span><span class="params">(startTime: dispatch_time_t, interval: UInt64, leeway: UInt64, queue: dispatch_queue_t, handler: dispatch_block_t)</span></span> -&gt; dispatch_source_t &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> timerDispatchSource = dispatch_source_create(<span class="type">DISPATCH_SOURCE_TYPE_TIMER</span>, <span class="number">0</span>, <span class="number">0</span>, queue)</span><br><span class="line">        </span><br><span class="line">        dispatch_source_set_timer(timerDispatchSource, startTime, interval, leeway)</span><br><span class="line">        </span><br><span class="line">        dispatch_source_set_event_handler(timerDispatchSource, handler)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> timerDispatchSource</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码示例中一个新的函数<code>dispatch_source_set_timer</code>，该函数的作用就是给监听事件类型为<code>DISPATCH_SOURCE_TYPE_TIMER</code>的Dispatch Source设置相关属性，该函数有四个参数：</p>
<ul>
<li><code>source</code>：该参数为目标Dispatch Source，类型为<code>dispatch_source_t</code>.</li>
<li><code>start</code>：该参数为定时器的起始时间，类型为<code>dispatch_time_t</code>。</li>
<li><code>interval</code>：该参数为定时器的间隔时间，类型为<code>UInt64</code>，间隔时间的单位是纳秒。</li>
<li><code>leeway</code>：该参数为间隔时间的精度，类型为<code>UInt64</code>，时间单位也是纳秒。</li>
</ul>
<h4 id="u7528Dispatch_Source_u76D1_u542C_u81EA_u5B9A_u4E49_u4E8B_u4EF6"><a href="#u7528Dispatch_Source_u76D1_u542C_u81EA_u5B9A_u4E49_u4E8B_u4EF6" class="headerlink" title="用Dispatch Source监听自定义事件"></a>用Dispatch Source监听自定义事件</h4><p>Dispatch Source能监听的事件中有一个类型是自定义事件，下面我们来看看如何使用:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchSource</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> totalProcess = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> dispatchSource = dispatch_source_create(<span class="type">DISPATCH_SOURCE_TYPE_DATA_ADD</span>, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue())</span><br><span class="line">        </span><br><span class="line">        dispatch_source_set_event_handler(dispatchSource) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> process = dispatch_source_get_data(dispatchSource)</span><br><span class="line">            </span><br><span class="line">            totalProcess += <span class="type">Int</span>(process)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"这里可以在主线程更新UI，显示进度条...进度为<span class="subst">\(totalProcess)</span>%"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch_resume(dispatchSource)</span><br><span class="line">        </span><br><span class="line">        generateCustomEvent(dispatchSource)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">generateCustomEvent</span><span class="params">(dispatchSource: dispatch_source_t)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>...<span class="number">100</span> &#123;</span><br><span class="line">            </span><br><span class="line">            dispatch_sync(queue) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"模拟自定义事件...进度为<span class="subst">\(index)</span>%"</span>)</span><br><span class="line">                </span><br><span class="line">                dispatch_source_merge_data(dispatchSource, <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                sleep(<span class="number">2</span>)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看<code>generateCustomEvent(dispatchSource: dispatch_source_t)</code>方法，该方法的作用的是模拟自定义事件，首先创建一个全局并发队列，然后循环让其执行任务，在执行的任务里调用<code>dispatch_source_merge_data</code>函数，就可以触发监听类型为<code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>或者<code>DISPATCH_SOURCE_TYPE_DATA_OR</code>的Dispatch Source。该函数有两个参数，第一个参数是目标Dispatch Source，第二个参数的类型是无符号长整型，用于向目标Dispatch Source中的对应变量追加指定的数。</p>
<p>我们再来看看如何监听自定义时间，首先创建类型为<code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>的Dispatch Source，然后设置回调闭包，在闭包中使用<code>dispatch_source_get_data</code>获取追加的变量值，该函数只有一个参数，就是目标Dispatch Source，这里需要注意的是通过<code>dispatch_source_get_data</code>函数获取的变量值并不是累加值，而是每次调用<code>dispatch_source_merge_data</code>函数时设置的值，所以在上面的示例中用<code>totalProcess</code>变量累加每次获取到的值。</p>
<p>上面的示例可以用来模拟后台进行下载，根据下载的数据量使用<code>dispatch_source_merge_data</code>函数给目标Dispatch Source设置相应的变量值，然后在主线程中监听到Dispatch Source的自定义事件，通过<code>dispatch_source_get_data</code>函数获取到变量，用于更新显示进度条的UI。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/read-concurrency-programming-guide-2/" itemprop="url">
                  读 Concurrency Programming Guide 笔记（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-03-23T00:00:00+08:00" content="2016-03-23">
              2016-03-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/read-concurrency-programming-guide-2/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/read-concurrency-programming-guide-2/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/63001" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="Operation_u5BF9_u8C61_u7684_u76F8_u5173_u8BBE_u7F6E"><a href="#Operation_u5BF9_u8C61_u7684_u76F8_u5173_u8BBE_u7F6E" class="headerlink" title="Operation对象的相关设置"></a>Operation对象的相关设置</h2><p>Operation对象除了上文中讲到到基本使用方法外还有一些其他的特性，这些特性需要根据我们的应用场景去设置，设置的时机在创建Operation对象之后和运行它或者将其放入操作队列之前，下面让我们来看看Operation对象还有哪些特性。</p>
<h3 id="Operation_u5BF9_u8C61_u4E4B_u95F4_u7684_u4F9D_u8D56"><a href="#Operation_u5BF9_u8C61_u4E4B_u95F4_u7684_u4F9D_u8D56" class="headerlink" title="Operation对象之间的依赖"></a>Operation对象之间的依赖</h3><p>与GCD不同，Operation Queue不遵循先进先出的原则，而且Operation Queue始终是并发执行Operation对象的，所以想让Operation对象串行执行就需要用它的Operation对象依赖特性，该特性可以让Operation对象将自己与另外一个Operation对象进行关联，并且当关联的Operation对象执行完成后才可以执行，这样就达到了串行执行Operation对象的目的。</p>
<p>我们可以用<code>NSOperation</code>的<code>addDependency</code>方法添加依赖的Operation对象，而且产生依赖的这两个Operation对象并不要求必须在相同的操作队列中，但是这种依赖只能是单向的，不能相互依赖。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestOperationDependency</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> blockOperationA = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in blockOperationA..."</span>)</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> blockOperationB = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in blockOperationB..."</span>)</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        blockOperationA.addDependency(blockOperationB)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> operationQueue = <span class="type">NSOperationQueue</span>()</span><br><span class="line">        </span><br><span class="line">        operationQueue.addOperation(blockOperationA)</span><br><span class="line">        </span><br><span class="line">        operationQueue.addOperation(blockOperationB)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testOperationDependency = <span class="type">TestOperationDependency</span>()</span><br><span class="line"></span><br><span class="line">testOperationDependency.launch()</span><br></pre></td></tr></table></figure>
<p>上面的示例代码展示了如何给Operation对象添加依赖，大家可以注释掉<code>blockOperationA.addDependency(blockOperationB)</code>这一行看看打印结果有什么区别。</p>
<h3 id="Operation_u5BF9_u8C61_u7684_u4F18_u5148_u7EA7"><a href="#Operation_u5BF9_u8C61_u7684_u4F18_u5148_u7EA7" class="headerlink" title="Operation对象的优先级"></a>Operation对象的优先级</h3><p>上文中说了，操作队列里的Operation对象都是并发执行的，如果一个操作队列中有多个Operation对象，那么谁先执行谁后执行取决于Operation对象的依赖Operation对象是否已执行完成，也就是是否处于准备执行的状态。其实Operation对象自身也有优先级的属性，如果有两个都处于准备执行状态的Operation对象，那么优先级高的会先执行，优先级低的后执行。每个Operation对象默认的优先级是<code>NSOperationQueuePriority.Normal</code>级别，我们可以通过设置<code>queuePriority</code>属性更改Operation的在队列中执行的优先级，优先级别有以下五种：</p>
<ul>
<li><code>NSOperationQueuePriority.Normal</code>：正常优先级</li>
<li><code>NSOperationQueuePriority.Low</code>：低优先级</li>
<li><code>NSOperationQueuePriority.VeryLow</code>：非常低优先级</li>
<li><code>NSOperationQueuePriority.High</code>：高优先级</li>
<li><code>NSOperationQueuePriority.VeryHigh</code>：非常高优先级</li>
</ul>
<p>这里我们需要注意一下Operation对象优先级的作用域，它只能作用于相同的操作队列中，不同操作队列中的Operation对象是不受优先级影响的。另外需要注意的是，如果有两个Operation对象，一个处于准备执行状态，但优先级比较低，另一个处于等待状态，但优先级比较高，那么此时仍然是处于准备执行状态的低优先级Operation对象先执行。可见Operation对象的优先级相互影响需要满足两个条件，一是必须处在同一个操作队列中，另一个是Operation对象都处于准备执行状态。</p>
<h3 id="u901A_u8FC7Operation_u5BF9_u8C61_u4FEE_u6539_u7EBF_u7A0B_u4F18_u5148_u7EA7"><a href="#u901A_u8FC7Operation_u5BF9_u8C61_u4FEE_u6539_u7EBF_u7A0B_u4F18_u5148_u7EA7" class="headerlink" title="通过Operation对象修改线程优先级"></a>通过Operation对象修改线程优先级</h3><p>通常情况下，线程的优先级由内核自己管理，不过在OS X v10.6及以后的版本和iOS4到iOS7期间，<code>NSOperation</code>多了一个<code>threadPriority</code>属性，我们可以通过该属性设置Operation对象运行所在线程的优先级，数值范围为0.0到1.0，数字越高优先级越高。不过可能是出于线程安全等方面的考虑，Apple从iOS8开始废除了该属性。</p>
<h3 id="u8BBE_u7F6ECompletion_Block"><a href="#u8BBE_u7F6ECompletion_Block" class="headerlink" title="设置Completion Block"></a>设置Completion Block</h3><p>上篇文章中说过，Operation对象其中的一个特别好的特性就是完成时回调闭包Completion Block。它的作用不言而喻，就是当主要任务执行完成之后做一些收尾的处理工作，我们可以设置<code>completionBlock</code>属性给Operation对象添加完成时回调闭包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">blockOperationA.completionBlock = &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"blockOperationA has finished..."</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6267_u884COperation_u5BF9_u8C61"><a href="#u6267_u884COperation_u5BF9_u8C61" class="headerlink" title="执行Operation对象"></a>执行Operation对象</h2><p>虽然前面文章的示例中已经包含了对Operation对象的执行，但是并没详细说明，这节就说说Operation对象的执行。</p>
<h3 id="u4F7F_u7528Operation_Queue"><a href="#u4F7F_u7528Operation_Queue" class="headerlink" title="使用Operation Queue"></a>使用Operation Queue</h3><p>使用Operation Queue操作队列执行Operation对象已然是标配选项了，操作队列在Cocoa框架中对应的类是<code>NSOperationQueue</code>，一个操作队列中可以添加多个Operation对象，但一次到底添加多少Operation对象得根据实际情况而定，比如应用程序对内存的消耗情况、内核的空闲情况等，所以说凡事得有度，不然反而会适得其反。另外需要注意的一点是不论有多少个操作队列，它们都受制于系统的负载、内核空闲等运行情况，所以说并不是说再创建一个操作队列就能执行更多的Operation对象。</p>
<p>在使用操作队列时，我们首先要创建<code>NSOperationQueue</code>的实例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> operationQueue = <span class="type">NSOperationQueue</span>()</span><br></pre></td></tr></table></figure>
<p>然后通过<code>NSOperationQueue</code>的<code>addOperation</code>方法添加Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operationQueue.addOperation(blockOperationA)</span><br><span class="line">        </span><br><span class="line">operationQueue.addOperation(blockOperationB)</span><br></pre></td></tr></table></figure>
<p>在OS X v10.6之后和iOS4之后，我们还可以用<code>addOperations:waitUntilFinished:</code>方法添加一组Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operationQueue.addOperations([blockOperationA, blockOperationB], waitUntilFinished: <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>该方法有两个参数：</p>
<ul>
<li><code>ops: [NSOperation]</code>：Operation对象数组。</li>
<li><code>waitUntilFinished wait: Bool</code>：该参数标示这个操作队列在执行Operation对象时是否会阻塞当前线程。</li>
</ul>
<p>我们还可以通过<code>addOperationWithBlock</code>方法向操作队列中直接添加闭包，而不需要去创建Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operationQueue.addOperationWithBlock(&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The block is running in Operation Queue..."</span>)</span><br><span class="line">            </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>除了以上这几种添加Operation对象的方法外，还可以通过<code>NSOperationQueue</code>的<code>maxConcurrentOperationCount</code>属性设置同时执行Operation对象的最大数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operationQueue.maxConcurrentOperationCount = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果设置为1，那么不管该操作队列中添加了多少Operation对象，每次都只运行一个，而且会按照添加Operation对象的顺序去执行。所以如果遇到添加到操作的队列的Operation对象延迟执行了，那么通常会有两个原因：</p>
<ul>
<li>添加的Operation对象数超过了操作队列设置的同时执行Operation对象的最大数。</li>
<li>延迟执行的Operation对象在等待它依赖的Operation对象执行完成。</li>
</ul>
<p>另外需要的注意的是当Operation对象添加到操作队列中后，不要再更改它任务中涉及到的任何属性或者它的依赖，因为到操作队列中的Operation对象随时会被执行，所以如果你自以为它还没有被执行而去修改它，可能并不会达到你想要的结果。</p>
<h3 id="u624B_u52A8_u6267_u884COperation_u5BF9_u8C61"><a href="#u624B_u52A8_u6267_u884COperation_u5BF9_u8C61" class="headerlink" title="手动执行Operation对象"></a>手动执行Operation对象</h3><p>除了用操作队列来执行Operation对象以外，我们还可以手动执行某个Operation对象，但是这需要我们注意更多的细节问题，也要写更多的代码去确保Operation对象能正确执行。在上篇文章中，我们创建过自定义的Operation对象，其中我们知道有几个属性特别需要我们注意，那就是<code>ready</code>、<code>concurrent</code>、<code>executing</code>、<code>finished</code>、<code>cancelled</code>，对应Operation对象是否出于准备执行状态、是否为异步并发执行的、是否正在执行、是否已经执行完成、是否已被终止。这些状态在我们使用操作队列时都不需要理会，都有操作队列帮我们把控判断，确保Operation对象的正确执行，我们只需要在必要的时候获取状态信息查看而已。但是如果手动执行Operation对象，那么这些状态都需要我们来把控，因为你手动执行一个Operation对象时要判断它的依赖对象是否执行完成，是否被终止了等等，所以并不是简单的调用<code>start</code>方法，下面来看看如果正确的手动执行Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performOperation</span><span class="params">(operation: NSOperation)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> operation.ready &amp;&amp; !operation.cancelled &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> operation.concurrent &#123;</span><br><span class="line">                </span><br><span class="line">            operation.start()</span><br><span class="line">                </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">            <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"start"</span>, toTarget: operation, withObject: <span class="literal">nil</span>)</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        result = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u7EC8_u6B62Operation_u5BF9_u8C61_u6267_u884C"><a href="#u7EC8_u6B62Operation_u5BF9_u8C61_u6267_u884C" class="headerlink" title="终止Operation对象执行"></a>终止Operation对象执行</h3><p>一旦Operation对象被添加到操作队列中，这个Operation对象就属于这个操作队列了，并且不能被移除，唯一能让Operation对象失效的方法就是通过<code>NSOperation</code>的<code>cancel</code>方法终止它执行，或者也可以通过<code>NSOperationQueue</code>的<code>cancelAllOperations</code>方法终止在队列中的所有Operation对象。</p>
<h3 id="u6682_u505C_u548C_u6062_u590D_u64CD_u4F5C_u961F_u5217"><a href="#u6682_u505C_u548C_u6062_u590D_u64CD_u4F5C_u961F_u5217" class="headerlink" title="暂停和恢复操作队列"></a>暂停和恢复操作队列</h3><p>在实际运用中，如果我们希望暂停操作队列执行Operation对象，可以通过设置<code>NSOperationQueue</code>的<code>suspended</code>属性为<code>false</code>来实现，不过这里要注意的是暂停操作队列只是暂停执行下一个Operation对象，而不是暂停当前正在执行的Operation对象，将<code>suspended</code>属性设置为<code>true</code>后，操作队列则恢复执行。</p>
<h2 id="Dispatch_Queues"><a href="#Dispatch_Queues" class="headerlink" title="Dispatch Queues"></a>Dispatch Queues</h2><p>Dispatch Queue是GCD中的核心功能，它能让我们很方便的异步或同步执行任何被封装为闭包的任务，它的运作模式与Operation Queue很相似，但是有一点不同的是Dispatch Queue是一种先进先出的数据结构，也就是执行任务的顺序永远等同于添加任务时的顺序。GCD中已经为我们提供了几种类型的Dispatch Queue，当然我们也可以根据需求自己创建Dispatch Queue，下面我们先来看看Dispatch Queue的类型：</p>
<ul>
<li>串行Dispatch Queue：该类型的队列一次只能执行一个任务，当前任务完成之后才能执行下一个任务，而且可依任务的不同而在不同的线程中执行，这类队列通常作为私有队列使用。这里需要注意的是虽然该类型的队列一次只能执行一个任务，但是可以让多个串行队列同时开始执行任务，达到并发执行的任务的目的。</li>
<li>并行Dispatch Queue：该类队列可同时执行多个任务，但是执行任务的顺序依然是遵循先进先出的原则，同样可依任务的不同而在不同的线程中执行，这类队列通常作为全局队列使用。</li>
<li>主Dispatch Queue：该类队列实质上也是一个串行队列，但是该队列是一个全局队列，在该队列中执行的任务都是在当前应用的主线程中执行的。通常情况下我们不需要自己创建此类队列。</li>
</ul>
<p>Dispatch Queue与Operation Queue相似，都能让我们更方便的实现并发任务的编程工作，并且能提供更优的性能，因为我们不再需要编写关于线程管理相关的一大堆代码，这些完全都有系统接管，我们只需要将注意力放在要执行的任务即可。举个简单的例子，如果有两个任务需要在不同的线程中执行，但是他们之间存在资源竞争的情况，所以需要保证执行的先后顺序，如果我们自己创建线程实现该场景，那么就务必要用的线程锁机制，确保任务有正确的执行顺序，这势必对系统资源的开销会非常大，如果使用Dispatch Queue，我们只需要将任务安正确的顺序添加到串行队列中即可，省时省力省资源。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u4EFB_u52A1_u7684_u8F7D_u4F53_u662F_u95ED_u5305"><a href="#u4EFB_u52A1_u7684_u8F7D_u4F53_u662F_u95ED_u5305" class="headerlink" title="任务的载体是闭包"></a>任务的载体是闭包</h3><p>在使用Dispatch Queue时，需要将任务封装为闭包。闭包就是一个函数，或者一个指向函数的指针，加上这个函数执行的非局部变量，闭包最大的一个特性就是可以访问父作用域中的局部变量。我们在将任务封装为闭包进行使用时要注意以下这几点：</p>
<ul>
<li>虽然在闭包中可以使用父作用域中的变量，但是尽可能少的使用父作用域中比较大的变量以及不要在闭包中做类似删除清空父作用域中变量的行为。</li>
<li>当将一个封装好任务的闭包添加至Dispatch Qeueu中，Dispatch Queue会自动复制该闭包，并且在执行完成后释放该闭包，所以不同担心闭包中一些值的变化问题，以及资源释放问题。</li>
<li>虽然使用Dispatch Queue执行并发异步任务很方便，但是创建和执行闭包还是有一定资源开销的，所以尽量不要使用Dispatch Queue执行一些很小的任务，要物有所值。如果确实有很小的任务需要并发异步执行，那么使用<code>NSThread</code>的<code>detachNewThreadSelector</code>方法或<code>NSObject</code>的<code>performSelectorInBackground</code>方法去执行也未必不可。</li>
<li>如果同一个队列中的多个任务之间需要共享数据，那么应该使用队列上下文去存储数据，供不同的任务访问。</li>
<li>如果闭包中的任务创建了不少对象，那么应该考虑将整个任务逻辑代码放在<code>autoreleasepool</code>中，虽然Dispatch Queue中也有自动释放池，但是你不能保证它每次释放的时间，所以咱们自己再加一个要来的更保险一些。</li>
</ul>
<h2 id="u521B_u5EFA_u4E0E_u7BA1_u7406Dispatch_Queues"><a href="#u521B_u5EFA_u4E0E_u7BA1_u7406Dispatch_Queues" class="headerlink" title="创建与管理Dispatch Queues"></a>创建与管理Dispatch Queues</h2><p>在使用Dispatch Queue之前，我们首先需要考虑应该创建什么类型的Dispatch Queue，如何进行配置等，这一节就来说一说如何创建和管理Dispatch Queue。</p>
<h3 id="u5168_u5C40_u5E76_u53D1Dispatch_Queue"><a href="#u5168_u5C40_u5E76_u53D1Dispatch_Queue" class="headerlink" title="全局并发Dispatch Queue"></a>全局并发Dispatch Queue</h3><p>并发队列的好处人人皆知，可以方便的同时处理多个任务，在GCD中并发Dispatch Queue同样遵循先进先出的原则，但这只是在运行时适用，如果有个任务在并发队列中还没轮到它执行，那么此时完全可以移除它，而不必等它前面的任务执行完成之后。至于并发队列中没次有多少个任务在执行，这个恐怖在每一秒都在变化，因为影响它的因素有很多，所以之前说过，尽量不要移除移除已经添加进队列的任务。</p>
<p>OS X和iOS系统为我们提供了四种全局并发Dispatch Queue，所谓全局队列，就是我们不需要理会它们的保留和释放问题，而且不需要专门创建它。与其说是四种不如说是一种全局并发队列的四种不同优先级，因为它们之间唯一的不同之处就是队列优先级不同。与Operation Queue不同，在GCD中，Dispatch Queue只有四种优先级：</p>
<ul>
<li><code>DISPATCH_QUEUE_PRIORITY_HIGH</code>：高优先级。</li>
<li><code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>：默认优先级，低于高优先级。</li>
<li><code>DISPATCH_QUEUE_PRIORITY_LOW</code>：低优先级，低于高优先级和默认优先级。</li>
<li><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>：后台优先级，低于高优先级和后台线程执行的任务。</li>
</ul>
<p>我们可以通过<code>dispatch_get_global_queue</code>函数再根据不同的优先级获取不同的全局并发队列，类型为<code>dispatch_queue_t</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> highPriorityQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_HIGH</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> defaultPriorityQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>我们在使用全局并发队列的时候不需要保留队列的引用，随时要用随时用该函数获取即可。当然我们也可以通过<code>dispatch_queue_create</code>函数自己创建队列：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.example.MyConcurrentQueue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，<code>dispatch_queue_create</code>函数有两个参数，第一个为队列的名称，第二个为队列类型，串行队列为<code>DISPATCH_QUEUE_SERIAL</code>，并发队列为<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>
<h3 id="u4E32_u884CDispatch_Queue"><a href="#u4E32_u884CDispatch_Queue" class="headerlink" title="串行Dispatch Queue"></a>串行Dispatch Queue</h3><p>串行队列可以让我们将任务按照一定顺序执行，能更优的处理多个任务之间的资源竞争问题，比线程锁机制有更小的资源开销和更好的性能，并且不会产生死锁的问题。</p>
<p>系统也为我们提供了一个串行队列，我们可以通过<code>dispatch_get_main_queue</code>函数获取：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mainQueue = dispatch_get_main_queue()</span><br></pre></td></tr></table></figure>
<p>该队列与当前应用的主线程相关联。当然我们也可以自己创建串行队列：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueueA = dispatch_queue_create(<span class="string">"com.example.MySerialQueueA"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> serialQueueB = dispatch_queue_create(<span class="string">"com.example.MySerialQueueB"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p><code>dispatch_queue_create</code>函数的第二个参数如果为<code>nil</code>则默认创建串行队列。当我们创建好串行队列后，系统会自动将创建好的队列与当前应用的主线程进行关联。</p>
<h3 id="u83B7_u53D6_u5F53_u524D_u961F_u5217"><a href="#u83B7_u53D6_u5F53_u524D_u961F_u5217" class="headerlink" title="获取当前队列"></a>获取当前队列</h3><p>如果需要验证或者测试当前队列，我们可以通过<code>dispatch_get_current_queue</code>函数获取当前队列。如果在闭包中调用，返回的是该闭包所在的队列，如果在闭包外调用，返回的则是默认的并发队列。不过该函数在OS X v10.10中和Swift中都不能使用了，取而代之的是通过<code>DISPATCH_CURRENT_QUEUE_LABEL</code>属性的<code>get</code>方法。</p>
<h3 id="u64C5_u7528_u961F_u5217_u4E0A_u4E0B_u6587"><a href="#u64C5_u7528_u961F_u5217_u4E0A_u4E0B_u6587" class="headerlink" title="擅用队列上下文"></a>擅用队列上下文</h3><p>很多情况下，同一个队列中的不同任务之间需要共享数据，尤其像串行队列中的任务，可能由多个任务对某个变量进行处理，或者都需要使用到某个对象，这时就要用到队列上下文:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">        </span><br><span class="line">        dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(<span class="number">0</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> taskCount = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            taskCount++</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"TaskA in the dispatch queue...and The number of task in queue is <span class="subst">\(taskCount)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(taskCount, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> taskCount = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            taskCount++</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"TaskB in the dispatch queue...and The number of task in queue is <span class="subst">\(taskCount)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(taskCount, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testDispatchQueue = <span class="type">TestDispatchQueue</span>()</span><br><span class="line">testDispatchQueue.launch()</span><br></pre></td></tr></table></figure>
<p>从上面的代码示例中可以看到，在执行代码点，我们用<code>dispatch_set_context</code>函数向<code>serialQueue</code>队列的上下文环境中设置了一个<code>Int</code>类型的变量，初始值为0。该函数有两个参数，第一个是目标队列，第二个参数是上下文数据的指针。然后在闭包中我们使用<code>dispatch_get_context</code>函数获取上下文数据进行进一步的处理。除了基本类型，我们也可以将自定义的类放入队列上下文中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"DevTalking"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> mobile = <span class="string">"10010"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> contact = <span class="type">Contact</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">        </span><br><span class="line">        dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(contact, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.name)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.mobile)</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testDispatchQueue = <span class="type">TestDispatchQueue</span>()</span><br><span class="line">testDispatchQueue.launch()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于<code>unsafeBitCast</code>函数和Swift中指针的用法在<a href="http://www.devtalking.com/articles/read-threading-programming-guide-3/">这里</a>可以有所参考。</p>
</blockquote>
<h3 id="u961F_u5217_u7684_u6536_u5C3E_u5DE5_u4F5C"><a href="#u961F_u5217_u7684_u6536_u5C3E_u5DE5_u4F5C" class="headerlink" title="队列的收尾工作"></a>队列的收尾工作</h3><p>虽然在ARC时代，资源释放的工作已经基本不需要我们手动去做了，但有些时候因为系统释放资源并不是很及时，也会造成内存移除等问题，所以在一些情况下我们还是需要进行手动释放资源的工作，必入添加<code>autoreleasepool</code>保证资源及时释放等。Dispatch Queue也给我们提供了这样的机会（机会针对于ARC时代，在MRC时代是必须要做的），那就是Clean Up  Function清理扫尾函数，当队列被释放时，或者说引用计数为0时会调用该函数，并且将上下文指针也传到了该函数，以便进行清理工作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"DevTalking"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> mobile = <span class="string">"10010"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> contact = <span class="type">Contact</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">testCleanUpFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        launch()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">15</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"></span><br><span class="line">        dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(contact, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">        </span><br><span class="line">        dispatch_set_finalizer_f(serialQueue, myFinalizerFunction())</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.name)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.mobile)</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">myFinalizerFunction</span><span class="params">()</span></span> -&gt; dispatch_function_t &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123; context <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(context, <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.name)</span> and the mobile is <span class="subst">\(contact.mobile)</span>, The serialQueue has been released and we need clean up context data."</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// TODO...</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testDispatchQueue = <span class="type">TestDispatchQueue</span>()</span><br><span class="line">testDispatchQueue.testCleanUpFunction()</span><br></pre></td></tr></table></figure>
<p>从上面的代码示例中可以看到当给队列设置完上下文时，我们使用了<code>dispatch_set_finalizer_f</code>函数给队列设置清理函数，<code>dispatch_set_finalizer_f</code>函数有两个参数，第一个是目标队列，第二个参数是类型为<code>dispatch_function_t</code>的函数指针，也就是清理函数，上下文数据指针是该函数唯一的参数。在上面代码中，我们添加了<code>myFinalizerFunction</code>函数作为清理函数，在该函数中获得上下文数据，然后进行后续的清理工作。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/read-concurrency-programming-guide-1/" itemprop="url">
                  读 Concurrency Programming Guide 笔记（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-03-11T00:00:00+08:00" content="2016-03-11">
              2016-03-11
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/read-concurrency-programming-guide-1/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/read-concurrency-programming-guide-1/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/60236" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>并发任务是指多个任务在某一时刻同时运行。在过去，一提到并发执行任务，首当其冲的解决方案就是在程序中创建多个线程来实现，但是线程本身较为底层，而且管理的难度比较大，如果想做倒最优的线程数量、最恰当的线程创建销毁时机是很难的，以至于虽然达到了并发执行任务的目的，但却以降低程序性能为代价，所以往往得不偿失。</p>
<p>鉴于上述的原因，于是一些实现并发任务的其他方案出现了。在OS X和iOS系统中采用了多种实现并发执行任务的方法，与直接创建线程不同，这些方法让开发者只需要关注要执行的任务，然后让系统执行它们即可，不需要关心线程管理的问题，为开发者提供了一个简单而高效的并发任务编程模式。</p>
<p>其中一种实现任务异步执行的技术就是Grand Central Dispatch（GCD），该技术封提供了系统级别的线程管理功能，我们在使用它时只需要定义我们希望执行的任务，然后将任务添加到对应的分派执行队列中即可。另外一个技术是Operation queues，具体的实现是Objective-C中的<code>NSOperationQueue</code>对象，它的作用和GCD很相似，同样只需要我们定义好任务，然后添加到对应的操作队列中即可，其他与线程管理相关的事都由<code>NSOperationQueue</code>帮我们完成。</p>
<h2 id="Dispatch_Queues_u7B80_u8FF0"><a href="#Dispatch_Queues_u7B80_u8FF0" class="headerlink" title="Dispatch Queues简述"></a>Dispatch Queues简述</h2><p>Dispatch Queues是基于C语言的，执行自定义任务的技术，从字面意思理解其实就是执行任务的队列，使用GCD执行的任务都是放在这个队列中执行的，当然队列的数量可以有多个，类型也不止一种。一个Dispatch queue可以串行的执行任务，也可以并行的执行任务，但不管哪种执行任务的方式，都遵循先进先出的原则。串行队列一次只能执行一个任务，当前任务执行完后才能执行下一个任务，并且执行任务的顺序和添加任务的顺序是一致的。并行队列自然是可同时执行多个任务，不需要等待上个任务完成后才执行下个任务。我们来看看Dispatch queue还有哪些好的特性：</p>
<ul>
<li>有简单宜用，通俗易懂的编程接口。</li>
<li>提供了自动管理的线程池。</li>
<li>可自动调节队列装载任务的速度。</li>
<li>更优的内存使用率。</li>
<li>使用户不用担心死锁的问题。</li>
<li>提供了比线程锁更优的同步机制。</li>
</ul>
<p>使用Dispatch Queue时，需要将任务封装为一个函数或者一个<code>block</code>，<code>block</code>是Objective-C中对闭包的实现，在OS X 10.6和iOS 4.0时引入的，在Swift中直接为闭包。</p>
<h2 id="Dispatch_Sources_u7B80_u8FF0"><a href="#Dispatch_Sources_u7B80_u8FF0" class="headerlink" title="Dispatch Sources简述"></a>Dispatch Sources简述</h2><p>Dispatch Source是GCD中的一个基本类型，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。我们来看看它都有哪些类型：</p>
<ul>
<li>Timer Dispatch Source：定时调度源。</li>
<li>Signal Dispatch Source：监听UNIX信号调度源，比如监听代表挂起指令的SIGSTOP信号。</li>
<li>Descriptor Dispatch Source：监听文件相关操作和Socket相关操作的调度源。</li>
<li>Process Dispatch Source：监听进程相关状态的调度源。</li>
<li>Mach port Dispatch Source：监听Mach相关事件的调度源。</li>
<li>Custom Dispatch Source：监听自定义事件的调度源。</li>
</ul>
<p>Dispatch Source是GCD中很有意思也很有用的一个特性，根据不同类型的调度源，我们可以监听较为底层的系统行为，不论在实现功能方面还是调试功能方面都非常游有用，后文中会再详细讲述。</p>
<h2 id="Operation_Queues_u7B80_u8FF0"><a href="#Operation_Queues_u7B80_u8FF0" class="headerlink" title="Operation Queues简述"></a>Operation Queues简述</h2><p>Operation Queue与Dispatch Queue很类似，都是有任务队列或操作队列的概念，只不过它是由Cocoa框架中的<code>NSOperationQueue</code>类实现的，它俩最主要的区别是任务的执行顺序，在Dispatch Queue中，任务永远都是遵循先进先出的原则，而Operation Queue加入了其他的任务执行顺序特性，使下一个任务的开始不再取决于上个任务是否已完成。</p>
<p>上文说过，使用Dispatch Queue时，需要将任务封装为一个函数或者闭包。而在Operation Queue中，需要将任务封装为一个<code>NSOpertaion</code>对象，然后放入操作队列执行。同时该对象还自带键值观察（KVO）通知特性，可以很方便的监听任务的执行进程。</p>
<h2 id="u8BBE_u8BA1_u5E76_u53D1_u4EFB_u52A1_u65F6_u5E94_u8BE5_u6CE8_u610F_u7684_u4E8B_u9879"><a href="#u8BBE_u8BA1_u5E76_u53D1_u4EFB_u52A1_u65F6_u5E94_u8BE5_u6CE8_u610F_u7684_u4E8B_u9879" class="headerlink" title="设计并发任务时应该注意的事项"></a>设计并发任务时应该注意的事项</h2><p>虽然并发执行任务可以提高程序对用户操作的响应速度，最大化使用内核，提升应用的效率，但是这些都是建立在正确合理使用并发任务技术，以及应用程序确实需要使用这类技术的前提下。如果使用不得当，或者对简单的应用程序画蛇添足，那么反而会因为使用了并发任务技术而导致应用程序性能下降，另一方面开发人员面对的代码复杂度也会增加，维护成本同样会上升。所以在准备使用这类技术前一定要三思而行，从性能、开发成本、维护成本等多个方面去考虑是否需要使用并发任务技术。</p>
<p>考虑是否需要用只是第一步，当确定使用后更不能盲目的就开始开发，因为并发任务技术的使用需要侵入应用程序的整个开发生命周期，所以在应用开发之初，就是考虑如何根据这类技术去设计并发任务，考虑应用中任务的类型、任务中使用的数据结构等等，否则亡羊补牢也为时已晚。这一节主要说说在设计并发任务时应该注意哪些事。</p>
<h3 id="u68B3_u7406_u5E94_u7528_u7A0B_u5E8F_u4E2D_u7684_u4EFB_u52A1"><a href="#u68B3_u7406_u5E94_u7528_u7A0B_u5E8F_u4E2D_u7684_u4EFB_u52A1" class="headerlink" title="梳理应用程序中的任务"></a>梳理应用程序中的任务</h3><p>在动手写代码前，尽量根据需求，穷举应用中的任务以及在任务中涉及到的对象何数据结构，然后分析这些任务的优先级和触发类型，比如罗列出哪些任务是由用户操作触发的，哪些是任务是无需用户参与触发的。</p>
<p>当把任务根据优先级梳理好后，就可以从高优先级的任务开始逐个分析，考虑任务在执行过程中涉及到哪些对象和数据结构，是否会修改变量，被修改的变量是否会对其他变量产生影响，以及任务的执行结果对整个程序产生什么影响等。举个简单的例子，如果一个任务中对某个变量进行了修改，并且这个变量不会对其他变量产生影响，而且任务的执行结果也相对比较独立，那么像这种任务就最合适让它异步去执行。</p>
<h3 id="u8FDB_u4E00_u6B65_u7EC6_u5206_u4EFB_u52A1_u4E2D_u7684_u6267_u884C_u5355_u5143"><a href="#u8FDB_u4E00_u6B65_u7EC6_u5206_u4EFB_u52A1_u4E2D_u7684_u6267_u884C_u5355_u5143" class="headerlink" title="进一步细分任务中的执行单元"></a>进一步细分任务中的执行单元</h3><p>任务可以是一个方法，也可以是一个方法中的一段逻辑，不论是一个方法还是一段逻辑，我们都可以从中拆分出若干个执行单元，然后进一步分析这些执行单元，如果多个执行单元必须得按照特定得顺序执行，而且这一组执行单元的执行结果想对独立，那么可以将这若干执行单元视为执行单元组，可以考虑让该执行单元组异步执行，其他不需要按照特定顺序的执行单元可以分别让它们异步执行。可以使用的技术可以用GCD或者Operation Queue。</p>
<p>在拆分执行单元时，尽量拆的细一点，不要担心执行单元的数量过多，因为GCD和Operation Queue有着高性能的线程管理机制，不需要担心过多的使用任务队列会造成性能损耗。</p>
<h3 id="u786E_u5B9A_u5408_u9002_u7684_u961F_u5217"><a href="#u786E_u5B9A_u5408_u9002_u7684_u961F_u5217" class="headerlink" title="确定合适的队列"></a>确定合适的队列</h3><p>当我们将任务分解为一个个执行单元并分析之后，下一步就是将这些执行单元封装在<code>block</code>中或者封装为<code>NSOperation</code>对象来使用GCD或Operation Queues，但在这之前还需要我们根据执行单元确定好适合的队列，不管是Dispatch queue还是Operation queue，都需要明确是使用串行队列还是并行队列，确定是将多个执行单元放入一个队列中还是分别放入多个队列中，以及使用正确优先级的队列。</p>
<h3 id="u63D0_u9AD8_u6548_u7387_u7684_u5176_u4ED6_u6280_u5DE7"><a href="#u63D0_u9AD8_u6548_u7387_u7684_u5176_u4ED6_u6280_u5DE7" class="headerlink" title="提高效率的其他技巧"></a>提高效率的其他技巧</h3><p>在使用任务队列时注意以下几点，可以有效的提高执行效率：</p>
<ul>
<li>如果应用比较吃内存，那么建议在任务中直接计算一些需要的值，这样比从主存中加载要来的快。</li>
<li>尽早确定顺序执行的任务，尽量将其改为并行任务，比如说有多个任务存在资源竞争问题，那么可以根据情况分别为每个任务拷贝一份该资源，从而避免顺序执行任务，以提高执行效率。</li>
<li>避免使用线程锁机制。在使用GCD或Operation Queues技术时基本不需要使用线程锁，因为有串行队列的存在。</li>
<li>尽量使用系统提供的框架达到并发任务的目的，一些系统提供的框架本身就有一些方法函数可以让任务并发执行，比如<code>UIView</code>提供的一系列动画的方法等。</li>
</ul>
<h2 id="Operation_Queues"><a href="#Operation_Queues" class="headerlink" title="Operation Queues"></a>Operation Queues</h2><p>Operation Queue技术由Cocoa框架提供，用于实现任务并发异步执行的技术，该技术基于面向对象概念。该技术中最主要的两个元素就是Operation对象和Operation队列，我们先来看看Operation对象。</p>
<h3 id="Operation_Objects"><a href="#Operation_Objects" class="headerlink" title="Operation Objects"></a>Operation Objects</h3><p>Operation对象的具体实现是Foundation框架中的<code>NSOperation</code>类，它的主要作用就是将我们希望执行的任务封装起来，然后去执行。<code>NSOperation</code>类本身是一个抽象类，在使用时需要我们创建子类去继承它，实现一些父类的方法，以达到我们使用的需求。同时Foundation框架也提供了两个已经实现好的<code>NSOperation</code>子类，供我们方便的使用：</p>
<ul>
<li><code>NSInvocationOperation</code>：当我们已经有一个方法需要异步去执行，此时显然没有必要为了这一个方法再去创建一个<code>NSOperation</code>的子类，所以我们就可以用<code>NSInvocationOperation</code>类来封装这个方法，然后放入操作队列去执行，以满足我们的需求。</li>
<li><code>NSBlockOperation</code>：该类可以让我们同时执行多个<code>block</code>对象或闭包。</li>
</ul>
<p>同时所有继承<code>NSOperation</code>的子类都会具有如下特性：</p>
<ul>
<li>可自动管理Operation对象之间的依赖关系，举个例子，当一个Operation对象执行之前发现它包含的任务中有依赖其他的Operation对象，并且该Operation对象还没有执行完成，那么当前的Operation对象会等待它的依赖执行完成后才会执行。</li>
<li>支持可选的完成时回调闭包，该闭包可以在Operation对象包含的主要任务执行完之后执行。</li>
<li>自带键值观察（KVO）通知特性，可以监听任务的执行状态。</li>
<li>可在运行时终止任务执行。</li>
</ul>
<p>虽然Operation Queues技术主要是通过将Operation对象放入队列中，实现并发异步的执行任务，但是我们也可以直接通过<code>NSOperation</code>类的<code>start</code>方法让其执行任务，但这样就属于同步执行任务了，我们还可以通过<code>NSOperation</code>类的<code>isConcurrent</code>方法来确定当前任务正在异步执行还是同步执行。</p>
<h3 id="u521B_u5EFANSInvocationOperation_u5BF9_u8C61"><a href="#u521B_u5EFANSInvocationOperation_u5BF9_u8C61" class="headerlink" title="创建NSInvocationOperation对象"></a>创建NSInvocationOperation对象</h3><p>上文中已经提到过，<code>NSInvocationOperation</code>对象是Foundation框架提供的<code>NSOperation</code>抽象类的实现，主要作用是方便我们将已有对象和方法封装为Operation对象，然后放入操作队列执行目标方法，同时该对象的好处是可以避免我们为已有的对象的方法逐个创建Operation对象，避免冗余代码。不过，由于<code>NSInvocationOperation</code>不是类型安全的，所以从Xcode 6.1开始，在Swift中就不能再使用该对象了。我们可以看看在Objective-c中如何创建该对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyCustomClass</span> </span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSOperation</span>*)taskWithData:(<span class="keyword">id</span>)data &#123; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInvocationOperation</span>* theOp = [[<span class="built_in">NSInvocationOperation</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(myTaskMethod:) object:data];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> theOp;</span><br><span class="line">    </span><br><span class="line">｝</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)myTaskMethod:(<span class="keyword">id</span>)data &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform the task. </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>当<code>NSInvocationOperation</code>对象创建好后，可以调用它父类<code>NSOperation</code>的<code>start</code>方法执行任务，但是这种不放在操作队列中的执行方式都是在当前线程，也就是主线程中同步执行的。</p>
<h3 id="u521B_u5EFANSBlockOperation_u5BF9_u8C61"><a href="#u521B_u5EFANSBlockOperation_u5BF9_u8C61" class="headerlink" title="创建NSBlockOperation对象"></a>创建NSBlockOperation对象</h3><p><code>NSBlockOperation</code>是另外一个由Foundation框架提供的<code>NSOperation</code>抽象类的实现类，该类的作用是将一个或多个block或闭包封装为一个Operation对象。在第一次创建<code>NSBlockOperation</code>时至少要添加一个block：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBlockOperation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">createBlockOperationObject</span><span class="params">()</span></span> -&gt; <span class="type">NSOperation</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The main thread num is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> nsBlockOperation = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in first closure. The thread num is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nsBlockOperation</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testBlockOperation = <span class="type">TestBlockOperation</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nsBlockOperation = testBlockOperation.createBlockOperationObject()</span><br><span class="line">nsBlockOperation.start()</span><br></pre></td></tr></table></figure>
<p>上面的代码中我们首先打印了主线程的线程号，然后通过<code>createBlockOperationObject</code>方法创建了一个<code>NSBlockOperation</code>对象，在初始化时的block中同样打印了当前线程的线程号，调用它父类的方法<code>start</code>后，可以看到这个block中的任务是在主线程中执行的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">The</span> main thread id <span class="keyword">is</span> &lt;<span class="type">NSThread</span>: <span class="number">0x101502e40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="type">Task</span> <span class="keyword">in</span> first closure. <span class="type">The</span> thread id <span class="keyword">is</span> &lt;<span class="type">NSThread</span>: <span class="number">0x101502e40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br></pre></td></tr></table></figure>
<p>然而我们也也可以通过<code>NSBlockOperation</code>对象的方法<code>addExecutionBlock</code>添加其他的block或者说任务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestBlockOperation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">createBlockOperationObject</span><span class="params">()</span></span> -&gt; <span class="type">NSOperation</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"The main thread num is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> nsBlockOperation = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in first closure. The thread num is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一种写法</span></span><br><span class="line">        nsBlockOperation.addExecutionBlock(&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in second closure. The thread num is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第二种写法</span></span><br><span class="line">        nsBlockOperation.addExecutionBlock&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in third closure. The thread num is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nsBlockOperation</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testBlockOperation = <span class="type">TestBlockOperation</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nsBlockOperation = testBlockOperation.createBlockOperationObject()</span><br><span class="line">nsBlockOperation.start()</span><br></pre></td></tr></table></figure>
<p>当我们再执行<code>NSBlockOperation</code>时，可以看到后面添加的两个任务都在不同的二级线程中执行，此时个任务为并发异步执行：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">The</span> main thread id <span class="keyword">is</span> &lt;<span class="type">NSThread</span>: <span class="number">0x101502e40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="type">Task</span> <span class="keyword">in</span> first closure. <span class="type">The</span> thread id <span class="keyword">is</span> &lt;<span class="type">NSThread</span>: <span class="number">0x101502e40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</span><br><span class="line"><span class="type">Task</span> <span class="keyword">in</span> third closure. <span class="type">The</span> thread id <span class="keyword">is</span> &lt;<span class="type">NSThread</span>: <span class="number">0x101009190</span>&gt;&#123;number = <span class="number">2</span>, name = (null)&#125;</span><br><span class="line"><span class="type">Task</span> <span class="keyword">in</span> second closure. <span class="type">The</span> thread id <span class="keyword">is</span> &lt;<span class="type">NSThread</span>: <span class="number">0x101505110</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面两段代码可以观察到，当<code>NSBlockOperation</code>中只有一个block时，在调用<code>start</code>方法执行任务时不会为其另开线程，而是在当前线程中同步执行，只有当<code>NSBlockOperation</code>包含多个block时，才会为其另开二级线程，使任务并发异步执行。另外，当<code>NSBlockOperation</code>执行时，它会等待所有的block都执行完成后才会返回执行完成的状态，所以我们可以用<code>NSBloxkOperation</code>跟踪一组block的执行情况。</p>
<h3 id="u81EA_u5B9A_u4E49Operation_u5BF9_u8C61"><a href="#u81EA_u5B9A_u4E49Operation_u5BF9_u8C61" class="headerlink" title="自定义Operation对象"></a>自定义Operation对象</h3><p>如果<code>NSInvocationOperation</code>对象和<code>NSBlockOperation</code>对象都不能满足我们的需求，那么我们可以自己写一个类去继承<code>NSOperation</code>，然后实现我们的需求。在实现自定义Operation对象时，分并发执行任务的Operation对象和非并发执行任务的Operation对象。</p>
<h4 id="u81EA_u5B9A_u4E49_u975E_u5E76_u53D1Operation_u5BF9_u8C61"><a href="#u81EA_u5B9A_u4E49_u975E_u5E76_u53D1Operation_u5BF9_u8C61" class="headerlink" title="自定义非并发Operation对象"></a>自定义非并发Operation对象</h4><p>实现非并发Operation对象相对要简单一些，通常，我们最少要实现两个方法：</p>
<ul>
<li>自定义初始化方法：主要用于在初始化自定义Operation对象时传递必要的参数。</li>
<li><code>main</code>方法：该方法就是处理主要任务的地方，你需要执行的任务都在这个方法里。</li>
</ul>
<p>当然除了上面两个必须的方法外，也可以有被<code>main</code>方法调用的私有方法，或者属性的<code>get</code>、<code>set</code>方法。下面以一个网络请求的例子展示如何创建自定义的Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNonconcurrentOperation</span>: <span class="title">NSOperation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(withURL url: <span class="type">String</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.url = url</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> strURL = <span class="keyword">self</span>.url <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">var</span> nsurl = <span class="type">NSURL</span>(string: strURL)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.</span></span><br><span class="line">        <span class="keyword">var</span> session: <span class="type">NSURLSession</span>? = <span class="type">NSURLSession</span>.sharedSession()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.</span></span><br><span class="line">        <span class="keyword">var</span> dataTask: <span class="type">NSURLSessionDataTask</span>? = session!.dataTaskWithURL(nsurl!, completionHandler: &#123; (nsdata, nsurlrespond, nserror) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error = nserror &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"出现异常：<span class="subst">\(error.localizedDescription)</span>"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">let</span> dict = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(nsdata!, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">MutableContainers</span>)</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">print</span>(dict)</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"出现异常"</span>)</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5.</span></span><br><span class="line">        dataTask!.resume()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myNonconcurrentOperation = <span class="type">MyNonconcurrentOperation</span>(withURL: <span class="string">"http://www.baidu.com/s?wd=ios"</span>)</span><br><span class="line">myNonconcurrentOperation.start()</span><br></pre></td></tr></table></figure>
<p>我们创建了自定义的Operation类<code>MyNonconcurrentOperation</code>，让其继承<code>NSOperation</code>，在<code>MyNonconcurrentOperation</code>中可以看到只有两个方法<code>init</code>和<code>main</code>，前者是该类的初始化方法，主要作用是初始化<code>url</code>这个参数，后者包含了任务的主体逻辑代码，我们来分析一下代码：</p>
<ol>
<li>我们在初始化<code>MyNonconcurrentOperation</code>时，传入了我们希望请求的网络地址，改地址正确与否关系着我们这个任务是否还值得继续往下走，所以在<code>main</code>方法一开始先判断一下<code>url</code>的合法性，示例代码中判断的很简单，实际中应该使用正则表达式去判断一下。</li>
<li>将字符串URL转换为<code>NSURL</code>。</li>
<li>创建<code>NSURLSession</code>实例。</li>
<li>调用<code>NSURLSession</code>实例的<code>dataTaskWithURL</code>方法，创建<code>NSURLSessionDataTask</code>类的实例，用于请求网络。在<code>completionHandler</code>的闭包中去判断请求是否成功，返回数据是否正确以及解析数据等操作。</li>
<li>执行<code>NSURLSessionDataTask</code>请求网络。</li>
</ol>
<p>当我们调用<code>MyNonconcurrentOperation</code>的<code>start</code>方法时，就会执行<code>main</code>方法里的逻辑了，这就是一个简单的非并发自定义Operation对象，之所以说它是非并发，因为它一般都在当前线程中执行任务，既如果你在主线程中初始化它，调用它的<code>start</code>方法，那么它就在主线程中执行，如果在二级线程中进行这些操作，那么就在二级线程中执行。</p>
<blockquote>
<p>注：如果在二级线程中使用非并发自定义Operation对象，那么<code>main</code>方法中的内容应该使用<code>autoreleasepool{}</code>包起来。因为如果在二级线程中，没有主线程的自动释放池，一些资源没法被回收，所以需要加一个自动释放池，如果在主线程中就不需要了。</p>
</blockquote>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h4 id="u54CD_u5E94_u53D6_u6D88_u4E8B_u4EF6"><a href="#u54CD_u5E94_u53D6_u6D88_u4E8B_u4EF6" class="headerlink" title="响应取消事件"></a>响应取消事件</h4><p>一般情况下，当Operation对象开始执行时，就会一直执行任务，不会中断执行，但是有时需要在任务执行一半时终止任务，这时就需要Operation对象有响应任务终止命令的能力。理论上，在Operation对象执行任务的任何时间点都可以调用<code>NSOperation</code>类的<code>cancel</code>方法终止任务，那么在我们自定义的Operation对象中如何实现响应任务终止呢？我们看看下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNonconcurrentOperation</span>: <span class="title">NSOperation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(withURL url: <span class="type">String</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.url = url</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> strURL = <span class="keyword">self</span>.url <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> nsurl = <span class="type">NSURL</span>(string: strURL)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> session: <span class="type">NSURLSession</span>? = <span class="type">NSURLSession</span>.sharedSession()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">            </span><br><span class="line">            nsurl = <span class="literal">nil</span></span><br><span class="line">            </span><br><span class="line">            session = <span class="literal">nil</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> dataTask: <span class="type">NSURLSessionDataTask</span>? = session!.dataTaskWithURL(nsurl!, completionHandler: &#123; (nsdata, nsurlrespond, nserror) <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error = nserror &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"出现异常：<span class="subst">\(error.localizedDescription)</span>"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 4.</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">                    </span><br><span class="line">                    nsurl = <span class="literal">nil</span></span><br><span class="line">                    </span><br><span class="line">                    session = <span class="literal">nil</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">let</span> dict = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(nsdata!, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">MutableContainers</span>)</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">print</span>(dict)</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"出现异常"</span>)</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">            </span><br><span class="line">            nsurl = <span class="literal">nil</span></span><br><span class="line">            </span><br><span class="line">            session = <span class="literal">nil</span></span><br><span class="line">            </span><br><span class="line">            dataTask = <span class="literal">nil</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dataTask!.resume()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myNonconcurrentOperation = <span class="type">MyNonconcurrentOperation</span>(withURL: <span class="string">"http://www.baidu.com/s?wd=ios"</span>)</span><br><span class="line">myNonconcurrentOperation.start()</span><br><span class="line">myNonconcurrentOperation.cancel()</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看到，在<code>main</code>方法里加了很多对<code>self.cancelled</code>值的判断，没错，这就是响应终止执行任务的关键，因为当调用了<code>NSOperation</code>的<code>cancel</code>方法后，<code>cancelled</code>属性就会被置为<code>flase</code>，当判断到该属性的值为<code>false</code>时，代表当前任务已经被取消，我们只需释放资源返回即可。我们只有在整个任务逻辑代码中尽可以细的去判断<code>cancelled</code>属性，才可以达到较为实时的终止效果。上面代码中我分别在四个地方判断了<code>cancelled</code>属性：</p>
<ol>
<li>在任务开始之前。</li>
<li>任务开始不久，这里刚创建了<code>NSURL</code>和<code>NSURLSession</code>，所以如果判断出任务已被取消，则要释放它们的内存地址。</li>
<li>开始请求网络之前，这里同样要释放已经创建的变量内存地址。</li>
<li>网络请求期间。</li>
</ol>
<h4 id="u81EA_u5B9A_u4E49_u5E76_u53D1Operation_u5BF9_u8C61"><a href="#u81EA_u5B9A_u4E49_u5E76_u53D1Operation_u5BF9_u8C61" class="headerlink" title="自定义并发Operation对象"></a>自定义并发Operation对象</h4><p>自定义并发Operation对象其主要实现的就是让任务在当前线程以外的线程执行，相对于非并发Operation对象注意的事项要更多一些，我们先来看要实现的两个方法：</p>
<ul>
<li><code>init</code>：该方法和非并发Operation对象中的作用一样，用于初始化一些属性。</li>
<li><code>start</code>：该方法是自定义并发Operation对象必须要重写父类的一个方法，通常就在这个方法里创建二级线程，让任务运行在当前线程以外的线程中，从而达到并发异步执行任务的目的，所以这个方法中绝对不能调用父类的<code>start</code>方法。</li>
<li><code>main</code>：该方法在非并发Operation对象中就说过，这里的作用的也是一样的，只不过在并发Operation对象中，该方法并不是必须要实现的方法，因为在<code>start</code>方法中就可以完成所有的事情，包括创建线程，配置执行环境以及任务逻辑，但我还是建议将任务相关的逻辑代码都写在该方法中，让<code>start</code>方法只负责执行环境的设置。</li>
</ul>
<p>除了上述这三个方法以外，还有三个属性需要我们重写，就是<code>NSOperation</code>类中的<code>executing</code>、<code>finished</code>、<code>concurrent</code>三个属性，这三个属性分别表示Operation对象是否在执行，是否执行完成以及是否是并发状态。因为并发异步执行的Operation对象并不会阻塞主线程，所以使用它的对象需要知道它的执行情况和状态，所以这三个状态是必须要设置的，下面来看看示例代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConcurrentOperation</span>: <span class="title">NSOperation</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> url: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> ifFinished: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> ifExecuting: <span class="type">Bool</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> concurrent: <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> finished: <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.ifFinished &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> executing: <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span>.ifExecuting &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(withURL url: <span class="type">String</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.url = url</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.ifFinished = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.ifExecuting = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.willChangeValueForKey(<span class="string">"finished"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.ifFinished = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.didChangeValueForKey(<span class="string">"finished"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.willChangeValueForKey(<span class="string">"executing"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"main"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.ifExecuting = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.didChangeValueForKey(<span class="string">"executing"</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        autoreleasepool&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> strURL = <span class="keyword">self</span>.url <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> nsurl = <span class="type">NSURL</span>(string: strURL)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> session: <span class="type">NSURLSession</span>? = <span class="type">NSURLSession</span>.sharedSession()</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">                </span><br><span class="line">                nsurl = <span class="literal">nil</span></span><br><span class="line">                </span><br><span class="line">                session = <span class="literal">nil</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">self</span>.completeOperation()</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> dataTask: <span class="type">NSURLSessionDataTask</span>? = session!.dataTaskWithURL(nsurl!, completionHandler: &#123; (nsdata, nsurlrespond, nserror) <span class="keyword">in</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> error = nserror &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"出现异常：<span class="subst">\(error.localizedDescription)</span>"</span>)</span><br><span class="line">                    </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">                        </span><br><span class="line">                        nsurl = <span class="literal">nil</span></span><br><span class="line">                        </span><br><span class="line">                        session = <span class="literal">nil</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">self</span>.completeOperation()</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">let</span> dict = <span class="keyword">try</span> <span class="type">NSJSONSerialization</span>.<span class="type">JSONObjectWithData</span>(nsdata!, options: <span class="type">NSJSONReadingOptions</span>.<span class="type">MutableContainers</span>)</span><br><span class="line">                        </span><br><span class="line">                        <span class="built_in">print</span>(dict)</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">self</span>.completeOperation()</span><br><span class="line">                        </span><br><span class="line">                    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">"出现异常"</span>)</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">self</span>.completeOperation()</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.cancelled &#123;</span><br><span class="line">                </span><br><span class="line">                nsurl = <span class="literal">nil</span></span><br><span class="line">                </span><br><span class="line">                session = <span class="literal">nil</span></span><br><span class="line">                </span><br><span class="line">                dataTask = <span class="literal">nil</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">self</span>.completeOperation()</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            dataTask!.resume()</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">completeOperation</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.willChangeValueForKey(<span class="string">"finished"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.willChangeValueForKey(<span class="string">"executing"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.ifFinished = <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.ifExecuting = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.didChangeValueForKey(<span class="string">"finished"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.didChangeValueForKey(<span class="string">"executing"</span>)</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>NSOperation</code>的<code>finished</code>、<code>executing</code>、<code>concurrent</code>这三个属性都是只读的，我们无法重写它们的<code>setter</code>方法，所以我们只能靠新建的私有属性去重写它们的<code>getter</code>方法。为了自定义的Operation对象更像原生的<code>NSOperation</code>子类，我们需要通过<code>willChangeValueForKey</code>和<code>didChangeValueForKey</code>方法手动为<code>ifFinished</code>和<code>ifExecuting</code>这两个属性生成KVO通知，将<code>keyPath</code>设置为原生的<code>finished</code>和<code>executing</code>。</p>
<p>上面的代码示例中有几个关键点：</p>
<ul>
<li>在<code>start</code>方法开始之初就要判断一下Operation对象是否被终止任务。</li>
<li><code>main</code>方法中的内容要放在<code>autoreleasepool</code>中，解决在二级线程中的内存释放问题。</li>
<li>如果判断出Operation对象的任务已经被终止，要及时修改<code>ifFinished</code>和<code>ifExecuting</code>属性。</li>
</ul>
<p>我们可以测试一下这个自定义的Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> myContext = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> myConcurrentOperation = <span class="type">MyConcurrentOperation</span>(withURL: <span class="string">"http://www.baidu.com/s?wd=ios"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        myConcurrentOperation.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"finished"</span>, options: .<span class="type">New</span>, context: &amp;myContext)</span><br><span class="line">        myConcurrentOperation.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"executing"</span>, options: .<span class="type">New</span>, context: &amp;myContext)</span><br><span class="line">        </span><br><span class="line">        myConcurrentOperation.start()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(myConcurrentOperation.executing)</span><br><span class="line">        <span class="built_in">print</span>(myConcurrentOperation.finished)</span><br><span class="line">        <span class="built_in">print</span>(myConcurrentOperation.concurrent)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">observeValueForKeyPath</span><span class="params">(keyPath: String?, ofObject object: AnyObject?, change: [String : AnyObject]?, context: UnsafeMutablePointer&lt;Void&gt;)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> change = change <span class="keyword">where</span> context == &amp;myContext &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> keyPath == <span class="string">"finished"</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Finish status has been changed, The new value is <span class="subst">\(change[NSKeyValueChangeNewKey]!)</span>"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> keyPath == <span class="string">"executing"</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Executing status has been changed, The new value is <span class="subst">\(change[NSKeyValueChangeNewKey]!)</span>"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        </span><br><span class="line">        myConcurrentOperation.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"finished"</span>, context: &amp;myContext)</span><br><span class="line">        </span><br><span class="line">        myConcurrentOperation.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">"executing"</span>, context: &amp;myContext)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = <span class="type">Test</span>()</span><br><span class="line">test.launch()</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://www.devtalking.com/devtalking.png" alt="DevTalking" itemprop="image"/>
          <p class="site-author-name" itemprop="name">DevTalking</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">74</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

         <!-- <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分類</span>
              
          </div> -->

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">36</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jacefu" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:jace.fu@icloud.com" target="_blank">
                  
                    <i class="fa fa-envelope"></i> Email
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.devtalking.com/qrcode.jpg" target="_blank">
                  
                    <i class="fa fa-qrcode"></i> 微信公众号
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DevTalking</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'jacefu';
      var disqus_identifier = 'index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/lib/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
