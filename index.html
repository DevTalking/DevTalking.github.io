<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>




  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="程序员说" type="application/atom+xml" />



  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="程序员说">
<meta property="og:url" content="http://www.devtalking.com/index.html">
<meta property="og:site_name" content="程序员说">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员说">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> 程序员说 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?980738dc41a50d91861a17ad4b768a1f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">程序员说</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/devops-guide/" itemprop="url">
                  产品经理的DevOps自我修养
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-11-16T00:00:00+08:00" content="2016-11-16">
              2016-11-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/devops-guide/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/devops-guide/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/122666" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>作为一名产品经理，首先要知道产品对于所属公司来说意味着什么，要探寻这个问题，我们又得知道和公司息息相关的是什么，在我的理解来看，与公司状况相关的因素有以下这些：</p>
<ul>
<li>市场份额</li>
<li>平均订单金额</li>
<li>盈利能力</li>
<li>资产回报率</li>
<li>从订单转化为现金的周期</li>
<li>应收账款</li>
<li>借贷成本</li>
</ul>
<p>从这些因素体现出来的最直接的就是公司收入，公司的财务状况，进而可以得出公司的经营状况，如果这些指标一塌糊涂，那么这个公司离倒闭也就不远了。那么现在我们再来看产品对公司意味着什么，应该不难发现上面这些指标都离不开产品，产品的市场份额、产品的平均订单金额、产品的盈利能力、产品的回报率、产品订单转化为现金的周期、产品的应收账款、投入产品时的借贷成本。好的产品就能创造出好的这些指标，反之亦然，所以往大了说，产品经理在某种程度上对公司的生存有着一定决定因素，尤其规模不是很大的公司。那么作为产品管理者，如何能帮公司打造出好的产品呢？</p>
<h1 id="u6B66_u88C5_u81EA_u5DF1"><a href="#u6B66_u88C5_u81EA_u5DF1" class="headerlink" title="武装自己"></a>武装自己</h1><p>首先我们需要能让我们打造出好产品的方法论来武装自己，所谓方法论，就是一门学问所采用的方法、规则与公理，放在软件工程中，它便指一系列编撰好的建议方法、训练方法及材料、使用的各种工具。在当今的IT领域，这种方法论莫过于DevOps了，我用它武装为自己的铠甲。</p>
<p>我不打算就DevOps做概念上的解释，我要说的是为什么我要选择DevOps，它能给公司和产品带来哪些好处，概括来说有以下五点：</p>
<ul>
<li>它能使产品更快的投入市场。</li>
<li>它能提升客户满意度。</li>
<li>它能提升产品的市场份额。</li>
<li>它能提升员工生产力及工作成就感和幸福感。</li>
<li>它能给公司在市场中创造出巨大的竞争优势。</li>
</ul>
<h2 id="u6253_u9020_u5229_u5251"><a href="#u6253_u9020_u5229_u5251" class="headerlink" title="打造利剑"></a>打造利剑</h2><p>产品的产出过程就是开发过程，在开发方法上我选择敏捷开发作为我的利剑，虽然这不是什么新鲜东西，但是它却是经过长期千锤百炼，经得起考验的开发方法，就像使用千锻、万锻后的精钢打造的利剑一般，首先在材质上就不会轻易损坏，只是你能否耍好剑的问题。</p>
<p>从理论上来说，敏捷开发在当今湍流的IT领域中好处不言而喻，积极甚至激进的个体互动、时刻有可交付的成果、紧密的客户合作、快速的响应变化都完胜传统瀑布式开发那套冗长的过程、冗余的事无巨细的文档、漫长的合同谈判和循规蹈矩的拖沓计划。</p>
<p>有了利剑，我门要学习剑术，敏捷开发有若干方法可供我们使用，比如Scrum、特性驱动开发（FDD）、测试驱动该开发（TDD）、行为驱动开发（BDD）、精益开发等，但是敏捷开发不存在官方的方法，没有完整的方法列表，也不存在最好的方法一说，只有最合适的方法。我选择了Scrum，理由很简单，它同样经历了多年的历练，已去其糟粕。</p>
<h3 id="u4E2A_u4F53_u4E92_u52A8"><a href="#u4E2A_u4F53_u4E92_u52A8" class="headerlink" title="个体互动"></a>个体互动</h3><p>我们先来看看个体互动，首先要明确的是你的组员，不论是开发人员、测试人员还是运维人员，他们绝对不是你的工具，不是你的枪，更不是你枪里的子弹，他们是你的伙伴，一起战斗的伙伴，只是分工不同而已。所以我们要了解他们，和他们建立互信互助的关系，建立团队沟通习惯，围绕斗志高昂的团队成员开展工作，这也是敏捷开发的原则和成功要素之一。那么我们该如何做到这些呢？这就需要使用Scrum剑术中的这几个技能：</p>
<ul>
<li>每日立会：每天不论早晚，抽15分钟时间，团队每人都要发言，汇报工作完成情况以及遇到的问题，让大家都彼此了解对方的工作内容和进度。</li>
<li>每周代码评审会：团队成员之间互相对代码质量进行评审，提出意见和建议。但是要确保的是每个人都要放下自尊，虚心接受和诚恳的评价。</li>
<li>每月畅谈会：团队成员之间勇于互相展现出自己脆弱的一面，可促使团队达成互相信任。每人发言，说说自己遇到的最困难的事，或觉得自己做的比较差劲的事，虽然这种方式一开始会有点残忍，但一旦团队成员彼此之间成为了倾诉对象，那么团队的团结互信将达到另一个境界。</li>
<li>每月回顾会议：也称为总结会议，每月进行总结并讨论在各方面需要改进的地方。</li>
<li>不定期技术交流会：我们鼓励团队中的每个人都向着专家的目标去努力，尽可能去专精自己擅长的技术，有一定积累后，无私的与大家分享交流，我很乐于看到团队成员彼此都称为对方老师。这有利于促进团队整体实力的提升。</li>
</ul>
<h3 id="u65F6_u523B_u6709_u53EF_u4EA4_u4ED8_u7684_u6210_u679C"><a href="#u65F6_u523B_u6709_u53EF_u4EA4_u4ED8_u7684_u6210_u679C" class="headerlink" title="时刻有可交付的成果"></a>时刻有可交付的成果</h3><p>何为可交付的成果，这里的成果指的不仅是产品，每一个开发人员完成的功能模块甚至与一个功能都算是是成果。那么可交付的成果既对功能模块有用的功能、对产品有用的功能模块、对客户有用的产品。那么所谓有用又如何定义呢，它在这里指的不仅是代码逻辑无误并测试通过这么简单，而是让客户买账。那么我们要如何从源头就做到有用呢？这里需要用到Scrum剑术中的几个技能以及另外一个剑术，我们先来看看这个剑术。</p>
<h4 id="u533A_u5206_u201C_u76F8_u5173_u201D_u4E0E_u201C_u65E0_u5173_u201D_u7684_u5DE5_u4F5C"><a href="#u533A_u5206_u201C_u76F8_u5173_u201D_u4E0E_u201C_u65E0_u5173_u201D_u7684_u5DE5_u4F5C" class="headerlink" title="区分“相关”与“无关”的工作"></a>区分“相关”与“无关”的工作</h4><p>这个剑术用一句话来概括就是弄清楚与实现公司目标息息相关的是什么。具体的技能以下三个：</p>
<ul>
<li>把公司上层的评估指标作为前提条件与具体的业务部门和开发部门的任务关联起来。只要能说明IT风险会对业务绩效指标产生多大的影响，就能着手指定更好的业务决策。</li>
<li>与各指标对应的业务流程负责人进行访谈，理解客户的需求与期望、产品系列、上市时间、销售渠道等分出项目优先级。</li>
<li>冻结低优先级的产品，保留高优先级的产品，形成相对单一的工作流。</li>
</ul>
<p>从这个剑术可以看出，它不仅适用于产品层面的管理，也适用于公司层面的运营。但不管是作为产品经理还是作为公司运营者，我们都得有一个列表，那就是公司的远期目标，也就是公司上层的评估指标：</p>
<ul>
<li>我们要创建什么？</li>
<li>我们有正确的产品吗？</li>
<li>我们能有效的创建产品吗？</li>
<li>我们能尽快把产品推向市场占有一席之地吗？</li>
<li>我的产品能带来感兴趣的潜在客户吗？</li>
<li>我们遵守了对客户的承诺吗？</li>
<li>我们是在获得客户还是在流失客户？</li>
<li>我们的销售预测准确率靠谱吗？</li>
</ul>
<p>与此对应的是：</p>
<ul>
<li>了解客户的需求和期望。</li>
<li>根据市场和客户确定产品系列。</li>
<li>提高研发效能。</li>
<li>缩短产品交付周期。</li>
<li>研究销售时机和销售渠道。</li>
<li>保证按时交货。</li>
<li>提高客户留存率。</li>
<li>保证市场和销售报告数据的精准性。</li>
</ul>
<p>以上八点其实是环环相扣的。当把这些问题都搞清楚后，自然而然就可以区分出哪些工作是“相关”的，哪些是“无关”的。</p>
<h4 id="u7EC6_u5206_u4EFB_u52A1"><a href="#u7EC6_u5206_u4EFB_u52A1" class="headerlink" title="细分任务"></a>细分任务</h4><p>当我们确定了一堆相关的工作后，需要使用Scrum中的另外几个技能将这些工作根据优先级进一步的细分：</p>
<ul>
<li>确定产品需求列表（Product Backlog）。</li>
<li>开发团队根据产品需求列表作出整体工作量的预估。</li>
<li>通过迭代计划会议（Sprint Planning Meeting）根据优先级及资源情况从产品需求列表中筛选出用户故事（User Story），作为本次迭代要完成的目标，一般周期在1-4个星期内。</li>
<li>将用户故事再进行细化，形成迭代需求列表（Sprint Backlog），通过看板将其可视化。</li>
</ul>
<p>我们通过确定出的“相关”工作，根据优先级进一步确定产品需求列表，这要注意的是，<strong>现在的产品需求列表中的内容已经是和公司的评估指标相关链的任务</strong>，所以都是极有价值的，现将这个需求列表评估出整体的大致工作量，然后通过迭代计划会议从中筛选出用户故事，也就是确定团队的短期目标，最后再将用户故事细化为更小的简单任务，一般周期保证在2天以内，分配给每个团队成员，在必要的时候还可以使用计划纸牌工具进行周期确认。Scrum中的这4个技能干的事就是能让整个团队清楚我们的最终目标和每一个短期目标，以及对整个目标的时间把控，在不断分解的过程中消除团队对庞大目标的恐惧感，并建立信心。</p>
<blockquote>
<p>计划纸牌工具的作用是确认探讨最小任务的具体周期。比如A程序员开发一个功能要5个小时，而B程序员认为只需要2个小时，那么他们各自取出有相应时间的牌藏在手中，最后摊牌，如果时间差距很大，那么A和B就可以对这两个时间进行讨论，最后确定最合适的任务周期。</p>
</blockquote>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h4 id="u6301_u7EED_u96C6_u6210"><a href="#u6301_u7EED_u96C6_u6210" class="headerlink" title="持续集成"></a>持续集成</h4><p>持续集成也是Scrum剑术中的技能之一，持续集成也就是每日集成部署，保证每天都要有一个可以成功编译，并可以演示的版本，要做到这一点，传统的集成部署方式显然是无法实现的，所以我们需要使用自动化集成部署方案。</p>
<p>持续集成一般分为四个阶段，也是通过不断摸索实践，从历史长河演化而来，但这四个阶段的方式没有谁好谁坏，只有我们的现状适合哪个阶段。</p>
<ul>
<li>代码级别的集成：这个阶段不依赖独立的集成工具，一般使用IDE内置的编译工具。同时代码风格检查、单元测试、测试覆盖率都有开发人员在本机人工执行。接下来的交付准备环境、运行测试、备份旧版本、新版本打标签以及反馈机制等其他重复的事情都由手工完成。</li>
<li>集成工作流：这个阶段整个开发流程的重心从代码级别的集成转移到了更自动化地编译和更完善的测试验证，致力于在最短时间内发现问题，缩短开发周期，提高软件质量。具体的形式是先进行代码编译，触发单元测试，集成测试，打包测试，自动部署到测试环境。循环往复，形成编译-构建-测试-集成-部署的工作流。</li>
<li>持续交付与部署：在上个阶段，自动部署只是最终部署在测试环境，还需要手动部署到生产环境，因为产品从需求到部署的过程中会经历若干个不同的环境，如开发环境、QA环境、自动化测试环境、生产环境等。所以在这个阶段要建立标准化的环境部署顺序，在工作流中增加部署预生产环境，并执行灰度集成测试，做好线上环境部署后的回归测试。持续交付并不是指软件每一个改动都要尽快部署的产品环境中，而是指任何的代码修改都可以在任何时候实施部署。而持续部署，指的是自动部署到生产环境中。</li>
<li>基于Docker的持续集成：这个阶段是上个阶段的进化，主要解决的问题是通过Docker统一部署环境。具体形式是开发者提交代码，触发单元测试，集成测试，打包测试，产品构建，触发Docker镜像构建，构建镜像上传至私有仓库，镜像下载至执行机器，镜像运行。</li>
</ul>
<p>通过持续集成我们就可以大幅缩短成果的交付周期，从而达到不断交付有价值的成果以满足客户需求的先决条件。</p>
<p>至此，我们有互相高度信任的团队，有条不紊的做着正确的事，不过我们只完成了计划内工作流的第一步，既<strong>优化工作优先级</strong>。目前我们只是有了让产品更快的投入市场的先决条件，想要真正实现，那么还需要提高计划内工作流的流量吞吐率及流速。</p>
<h2 id="u5BFB_u89C5_u5750_u9A91"><a href="#u5BFB_u89C5_u5750_u9A91" class="headerlink" title="寻觅坐骑"></a>寻觅坐骑</h2><p>首先我们要明确在我们的所有工作中一共有四种类型的工作：</p>
<ul>
<li>业务工作：也就是我们需要完成的和产品相关的工作。</li>
<li>内部工作：团队内部做的一些改进工作，比如搭建自动化部署框架等。</li>
<li>变更工作：由上面两种工作引起的工作，比如开发向测试交接时引起的问题，业务工作的需求改变引起的问题，内部的改进工作引起的问题等。</li>
<li>计划外工作：一般都由上面三种工作导致，尤其是变更工作引起的需要补救的工作，而且往往优先级都相对较高。</li>
</ul>
<p>业务工作和内部工作我们又称之为计划内工作，变更工作往往也是我们无法避免的，而计划外工作是最为可怕的，如恶魔一般，我们要以牺牲计划内工作为代价去消灭它。</p>
<p>所以我们知道了影响计划内工作流流速的其中一个因素就是计划外工作，那么影响流量吞吐率的因素是什么呢？那就是<strong>约束点</strong>。</p>
<p>我们将产品从需求到交付的过程想象为一个加工工厂的加工流水线过程，产品需求看作是加工原料，开发、测试、运维等看作是工厂流水线上每一环节的机器，原料从流水线起始位置流入，经过一个个加工机器，最终加工为一个成品。但是当其中的某个机器工作效率很低的时候，在该机器处就会堆积越来越多从上游传来的半成品，而下游的机器则闲置着，或者使用率极低，这种情况下这个工厂的生产效率可想而知。那么这个效率很低的机器就是整个工厂流水线的约束点，不但影响了流速也影响了吞吐率。那么这个机器相当于我们产品开发中的什么呢？是不同分工的个人还是不同分工的团队呢？</p>
<p>带着这个问题我们继续回到这个工厂，仔细观察可以我们可以看出加工流水线上的每个加工环节都有四个部分组成，那就是机器、人员、方法、测评。机器是工具，人员按照方法操作工具，然后根据测评细则检查加工的半成品在这一环节是否合格。这四部分组成的就叫工作中心，工作中心就是产品开发中不同分工的团队，所以某个团队的效率低下就会称为整个工作流的约束点。</p>
<p>那么团队为什么会成为约束点呢？因为团队里也有约束点。我们来继续看这个工厂，如果操作某个机器的人操作不熟练，或者一个人要兼顾好几个机器的话，那么这个人员就可能成为这个工作中心的约束点，甚至是多个工作中心的约束点。所以，解决约束点的问题是至关重要的，所有在非约束点所做的改进都是假象。</p>
<h3 id="u6D88_u9664_u6216_u4FDD_u62A4_u7EA6_u675F_u70B9"><a href="#u6D88_u9664_u6216_u4FDD_u62A4_u7EA6_u675F_u70B9" class="headerlink" title="消除或保护约束点"></a>消除或保护约束点</h3><p>有些约束点是因为自身能力问题导致的，这种情况下我们可以先调整他的任务，将优先级相对低的任务分配给他，同时通过技术交流会或者师带徒快速提升他的能力，从而消除约束点。另一种情况的约束点恰恰是因为这个人能力很强或者他的工作牵连着别的工作中心，从而参与了多个工作中心，反而使他自己的工作中心效率低下，这种情况我们就要采取保护约束点的措施：</p>
<ul>
<li>永远不要让这种约束点迁就别的工作中心，我们的做法应该完善每个工作中心的方法，使之标准化和自动化，我们的持续集成技能就能改善这一点。</li>
<li>将这种约束点着力于完成优先级相对比较高的任务。</li>
</ul>
<p>所以我们要善于识别约束点，然后消除或保护约束点，最后寻找下一个约束点，以此反复。</p>
<h3 id="u675C_u7EDD_u8BA1_u5212_u5916_u5DE5_u4F5C"><a href="#u675C_u7EDD_u8BA1_u5212_u5916_u5DE5_u4F5C" class="headerlink" title="杜绝计划外工作"></a>杜绝计划外工作</h3><p>为什么计划外工作会影响工作流流速呢？因为它增大了工作流中的某个工作中心，或者工作中心里某个人员的等待执行计划内工作的时间。等待时间怎么算的呢？等待时间等于忙碌百分比除以空闲百分比。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">等待时间 = 忙碌百分比 / 空闲百分比</span><br></pre></td></tr></table></figure>
<p>因为计划内工作，在前期都指定好了合理的周期，所以团队成员的忙碌百分比一般不会超过50%，所以空闲百分比也是50%，那么等待时间就是1。如果有大量的计划外工作涌进来，那团队成员的忙碌百分比就有可能达到70%或80%，甚至更高，假如忙碌百分比达到了80%，那么空闲百分比为20%，等待时间将增加到4。所以从这个公式可以看到，超负荷的工作任务其实是产生约束点的罪魁祸首，而计划外工作又是超负荷工作的始作俑者。</p>
<p>那么我们该如何杜绝计划外工作呢？我们知道计划外工作一般都是有变更工作引起的补救工作，因为80%的计划外工作都是由20%的变更工作造成的。既然变更工作是不可避免的，那么就尽量做到不引起补救工作，也就是要干净利落的完成变更工作，防止因变更工作导致其他问题发生。所以要想有效的杜绝加化外工作，那就需要建立起<strong>变更管理系统</strong>。</p>
<p>变更管理系统的主要作用是确保能正确实施变更确认、分析、评估、计划、实施、检查的过程。它的相关干系人可分为三个角色：</p>
<ul>
<li>客户：发起变更工作的源头，这个客户指的不仅是用我们产品的真实客户，在产品生命周期中，测试团队可能是开发团队的客户，开发团队可能是运维团队的客户，因为他们都有可能给上游或下游发起变更。</li>
<li>变更委员会委员：既对变更进行分析、评估、计划及决定变更优先级和变更实施者的人。</li>
<li>变更实施者：既具体实施变更的人或团队。</li>
</ul>
<p>这三种角色的人参与整个变更流程，基本的变更流程如下：</p>
<ul>
<li>产生变更：客户有新的需求或者更改原有需求。产品生命周期中，上下游的工作中心发起变更，比如发现Bug，或者修改部署环境配置等。</li>
<li>分析变更：变更委员会确定变更请求的技术可行性以及变更成本和变更收益，暂时过滤涉及约束点的变更。</li>
<li>评估变更：评估变更影响范围，既实施了变更后会对产品的哪些地方产生什么样的影响，明确变更影响和确定防范措施。</li>
<li>计划变更：根据分析变更和评估变更的结果，确定可实施的变更，既变更优先级，然后分配变更实施者。最后将所有状态的变更使用看板将其可视化。</li>
<li>实施变更：变更实施者根据计划变更的结果，按计划执行变更、测试变更、完备变更文档、发布变更。</li>
<li>检查和关闭变更：对已完成的变更进行检查，根据变更文档和测试变更的结果决定是否认定变更成果完成并关闭变更。</li>
</ul>
<p>有了完善的变更管理系统，通过严格的变更流程，我们首先可以筛选变更，其次可以对变更了如指掌，可以通过计划内工作看板和变更工作看板分析出如何安排变更工作，安排给谁最为合适，最后我们可以确保更变工作在掌控中安全的完成，不会产生额外的需要补救的计划外工作。</p>
<p>所以消除或保护约束点以及变更管理系统可以帮助我们提高工作流吞吐量和流速，是提升我们速度的最好坐骑。</p>
<p>至此，我们就完成了计划内工作流的第二步<strong>识别保护约束点</strong>，并且基本实现了<strong>第一工作法</strong>，既帮助我们在工作到来时如何建立快速工作流，使需求-开发-测试-运维-客户整个自左向右的工作流流量最大化，不让缺陷流向下游工作中心，为了整体目标不断对工作流进行优化。在第一工作法的帮助下，我们似乎可以使产品更快的投入市场了。</p>
<h2 id="u88C5_u5907_u76FE_u724C"><a href="#u88C5_u5907_u76FE_u724C" class="headerlink" title="装备盾牌"></a>装备盾牌</h2><p>当拿着利剑乘骑着坐骑冲进战场后，其实战争才刚刚开始。根据我的经验，绝大多数产品在投入市场后依然会存在一些Bug，而且会被客户发现，哪怕之前已经经过了测试系统的测试，所以当产品快速投入市场后，客户的的各种新需求和Bug反馈会如猛兽一般砸向我们，我们要做的就是一边盾挡洪水般的新需求一边斩杀客户发现的Bug，但仍会让我们措手不及。然而客户的需求和要求是无穷无尽的，像填不满的沟壑，如果我们能及时进行预判，那么我们就能自如许多，逐渐和客户形成良性循环。</p>
<h3 id="u4E2A_u4F53_u4E4B_u95F4_u7684_u53CD_u9988_u56DE_u8DEF"><a href="#u4E2A_u4F53_u4E4B_u95F4_u7684_u53CD_u9988_u56DE_u8DEF" class="headerlink" title="个体之间的反馈回路"></a>个体之间的反馈回路</h3><p>我们在开发过程中，经常会遇到这种情况，A开发人员开发的某个功能流转到B开发人员使用，但是B开发人员发现这个功能开发的不完善，不能满足B的需求，于是B按照自己的需求修改了A开发的功能，而不会去考虑这个变更是否会影响到C的使用，于是这个功能在工作流上一直流转下去就有可能已经远悖与原始需求了，如果这个功能看作是工厂生产线中产品的一个零部件，那么这个四不像的零部件在组装成品时会带来什么呢？必然是零件不合规，于是20%的变更引起了80%的计划外工作，眼看交付日期降至，开发人员又开始奔命与修补工作，即使最后完成了成品的组装，或许还是会留下不可预知的隐患及Bug。解决这类问题的最好办法就是建立起个体之间的问题反馈回路，它能避免不必要的变更工作。</p>
<p>一般变更工作都是在事物相对成型的状态下动其内部细节的工作，这种变更工作往往能牵一发而动全身，一个不好就会像釜底抽薪一般，让整体摧枯拉朽的坍塌，所以我们要有变更系统来加以管理和约束。上面那个例子中，如果当B发现A开发的功能不合规时，能立即反馈给A，经商榷探讨后由A及时修正了这个功能，并且A的这个修正行为并不属于变更行为，那么也许后面一系列的问题都不会发生了。这就是个体与个体之间的反馈回路，这种反馈回路要尽可能的短，回路两头要能快速响应，工作流中的每个个体都应该要建立这种反馈回路，而且尽量不要跨个体建立。</p>
<h3 id="u5DE5_u4F5C_u4E2D_u5FC3_u4E4B_u95F4_u7684_u53CD_u9988_u56DE_u8DEF"><a href="#u5DE5_u4F5C_u4E2D_u5FC3_u4E4B_u95F4_u7684_u53CD_u9988_u56DE_u8DEF" class="headerlink" title="工作中心之间的反馈回路"></a>工作中心之间的反馈回路</h3><p>个体之间建立反馈回路，能有效保证单个工作中心能按照它的规格产出合格的成果，但也许这个成果与整个工作流对产品的规格来说还有差异，所以工作中心和工作中心之间也要建立反馈回路，开发团队和测试团队之间，开发团队和运维团队之间，每个工作中心要指定一个个人作为反馈信息接口人，这样从细节到整体都能有效降低变更工作的发生率，从而大大减少计划外工作的发生率。</p>
<p>然而，反馈回路反馈的不仅仅是各种问题，还有其他更重要的信息，那就是市场团队和产品团队之间的反馈回路承载的信息。我们能预判市场和客户的需求呢？市场团队通过反馈回路不断提供的各种销售统计和市场报告是良药，能使产品团队知道做哪些事能让公司利益最大化，做到对市场需求和客户需求的预判，从而能抢占先机的将迎合市场的新功能推向市场。</p>
<p>反馈机制就是我们的盾牌，有了这面盾牌，我们就能很好的完成计划内工作流的第三步<strong>按时高质量交付成果</strong>，做到不欠技术债务，减少变更工作，进一步杜绝计划外工作。同时这也是<strong>第二工作法</strong>的核心内容，那就是建立尽可能短的个体之间和工作中心之间的不间断反馈回路，在个体之间、工作中心之间建立共同的目标和共同的解决问题的机制，这使我们能在产品初始阶段就能筹划并保证产品质量问题，避免返工，并且能及时获取到市场数据，做到市场需求和客户需求的预判，从而提升客户满意度和提升产品在市场的份额。</p>
<h2 id="u8425_u9020_u73AF_u5883"><a href="#u8425_u9020_u73AF_u5883" class="headerlink" title="营造环境"></a>营造环境</h2><p><strong>第三工作法</strong>的核心是在团队或公司建立鼓励探索、不断从失败中吸取教训、理解反复的实践是精通工作的先决条件的文化。让团队形成敢于创新、敢于冒险以及高度信任彼此的文化，同时要让所有人知道非功能性需求对于产品同等重要，合理安排功能性需求实现和非功能性需求实现的计划。第三工作法精髓在于不断尝试和理解重复练习是熟练掌握的前提。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>我们以DevOps方法论为基础，以三步工作法为指导思想，使用敏捷开发、区分“相关”与“无关”工作法、变更管理系统、保护约束点、建立反馈机制等具体方法，经过不断的实践和优化最后形成的工作流称之为价值流，它是从需求获取到代码签入再到产品投产整个工作流中的关键路径。我们要将价值流上的所有东西进行版本控制，使价值流中的每个个体都共享一种文化，这种文化不仅重视彼此的时间和贡献，而且为了实现整体的持续改进，要勇于不断向自己的工作注入压力，同时使每个个体都要像重视功能性需求一样重视非功能性需求，比如产品质量、可扩展性、可维护性、可操作性、安全性等。</p>
<p>如果我们能建立起这种价值流，那么就能提升员的工生产力以及工作成就感和幸福感，让公司重塑生产能力，从库存型生产转变为订单型生产，从给公司在市场中创造出巨大的竞争优势。</p>
<h2 id="u53C2_u8003_u6587_u732E_uFF1A"><a href="#u53C2_u8003_u6587_u732E_uFF1A" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://www.amazon.cn/凤凰项目-一个IT运维的传奇故事-基恩·金/dp/B016VW1I6U/ref=sr_1_1?ie=UTF8&amp;qid=1479266484&amp;sr=8-1&amp;keywords=凤凰项目" target="_blank" rel="external">《凤凰项目》</a><br><a href="http://blog.fir.im/ci_advancedguide/" target="_blank" rel="external">不可错过的「持续集成」</a></p>
<h2 id="u63A8_u8350_u4E66_u5355_uFF1A"><a href="#u63A8_u8350_u4E66_u5355_uFF1A" class="headerlink" title="推荐书单："></a>推荐书单：</h2><p><a href="https://www.amazon.cn/凤凰项目-一个IT运维的传奇故事-基恩·金/dp/B016VW1I6U/ref=sr_1_1?ie=UTF8&amp;qid=1479266484&amp;sr=8-1&amp;keywords=凤凰项目" target="_blank" rel="external">《凤凰项目》</a><br><a href="https://www.amazon.cn/目标-艾利•高德拉特/dp/B007RZRNAQ/ref=sr_1_1?ie=UTF8&amp;qid=1479266518&amp;sr=8-1&amp;keywords=目标" target="_blank" rel="external">《目标》</a><br><a href="https://www.amazon.cn/持续交付-发布可靠软件的系统方法-Jez-Humble%E3%80%80David-Farley/dp/B005V9BB1M/ref=sr_1_1?ie=UTF8&amp;qid=1479266535&amp;sr=8-1&amp;keywords=持续交付" target="_blank" rel="external">《持续交付》</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/angularjs1x-guide/" itemprop="url">
                  温故而知新-AngularJS 1.x 小记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-09-19T00:00:00+08:00" content="2016-09-19">
              2016-09-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/angularjs1x-guide/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/angularjs1x-guide/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>本文首发<a href="http://geek.csdn.net/news/detail/102405" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h1 id="AngularJS_u662F_u4EC0_u4E48"><a href="#AngularJS_u662F_u4EC0_u4E48" class="headerlink" title="AngularJS是什么"></a>AngularJS是什么</h1><p>我们知道HTML是一种创建网页的静态标记语言，它很基础，但不失灵活，然而它自身并不提供对灵活性的具体实现，所以我们要创建具有可用性及赏心悦目的Web应用就需要使用其他语言与之结合去操控它的DOM、标签、标签属性、标签层级结构实现样式变换、动态数据变换、动态元素变换等，比如结合CSS和JavaScript语言。</p>
<p>但是越多的结合就意味着功能实现越复杂，我们需要写大量的代码去实现类似数据绑定、动态展现、远程服务请求等功能，所以jQuery这类的JS库、ember这类的框架应用而生。前者让我们在完成某些单一功能时调用它封装好的方法，从而减少代码量。后者让我们可以遵循它的规范去填充它设计好的代码结构，从而逐步完成完整的应用功能。</p>
<p>而AngularJS是JS库和框架的结合，它诞生于2009年，由Misko Hevery 等人创建，后为Google所收购并发扬光大。AngularJS通过为开发者呈现一个更高层次的抽象来简化应用的开发，提供了构建一个CRUD应用可能用到的全部内容包括：自定义HTML标签、事件绑定、数据绑定、基本模板标识符、表单验证、路由、深度链接、组件重用、依赖注入等。</p>
<blockquote>
<p>文章中的所有示例均可在<a href="https://github.com/DevTalking/AngularJS1.x-guide.git" target="_blank" rel="external">这里</a>下载。</p>
</blockquote>
<h1 id="AngularJS_u7684_u7279_u6027"><a href="#AngularJS_u7684_u7279_u6027" class="headerlink" title="AngularJS的特性"></a>AngularJS的特性</h1><p>AngularJS有着诸多的特性，但最为核心的是其Scope概念、MVC模式、路由、模块化、依赖注入、指令系统、双向数据绑定、Service、Provider等。</p>
<h2 id="u6A21_u5757_u5316"><a href="#u6A21_u5757_u5316" class="headerlink" title="模块化"></a>模块化</h2><p>我们先从AngularJS的模块化特性说起。什么是模块？既应用程序中不同功能的容器。在AngularJS中，我们可以按业务功能的不同将实现划分为不同的模块，这些模块可以在一个JS文件中，也可以将它们放在不同的JS文件中，既一个JS文件为一个模块。</p>
<h3 id="u6A21_u5757_u5316_u7684_u4F18_u52BF"><a href="#u6A21_u5757_u5316_u7684_u4F18_u52BF" class="headerlink" title="模块化的优势"></a>模块化的优势</h3><p>使用模块化在我们的编程阶段有着诸多的好处：</p>
<ul>
<li>可以使我们的代码结构非常清晰，有较好的可读性。</li>
<li>可以使我们复用代码。</li>
<li>在前端编程中，我们都知道JS的引用顺序是很重要的，但使用AngularJS的模块时我们不需要关系每个模块之间的顺序。</li>
<li>可以很好的实现单元测试。</li>
</ul>
<h3 id="u5B9A_u4E49_u6A21_u5757"><a href="#u5B9A_u4E49_u6A21_u5757" class="headerlink" title="定义模块"></a>定义模块</h3><p>定义一个模块很简单，在JS文件中申明一个模块：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mianModule = angular.module(<span class="string">"mianModule"</span>, []);</span><br></pre></td></tr></table></figure>
<p>使用AngularJS的<code>module</code>方法申明一个模块，该方法有两个参数：</p>
<ul>
<li>第一个参数为模块名称。</li>
<li>第二个参数为一个数组，该参数的含义为当前定义的模块所依赖的模块，如果有依赖模块则传入包含模块名称的数组，若无依赖则传入空数组。</li>
</ul>
<h3 id="u4F7F_u7528_u6A21_u5757"><a href="#u4F7F_u7528_u6A21_u5757" class="headerlink" title="使用模块"></a>使用模块</h3><p>在了解如何使用定义好的模块之前，需要先清楚在AngularJS中，模块与模块之间可以是相互独立，老死不相往来的关系，也可以是依赖关系，并且可以是嵌套依赖关系：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="comment">// 互相独立的模块</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"><span class="keyword">var</span> anotherModule = angular.module(<span class="string">"anotherModule"</span>, []);</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="comment">// 有依赖关系的模块</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, [<span class="string">"secondModule"</span>]);</span><br><span class="line"><span class="keyword">var</span> secondModule = angular.module(<span class="string">"secondModule"</span>, [<span class="string">"thirdModule"</span>]);</span><br><span class="line"><span class="keyword">var</span> thirdModule = angular.module(<span class="string">"thirdModule"</span>, []);</span><br></pre></td></tr></table></figure>
<p>在AngularJS中使用定义好的模块也有两种方式，对应两种不同的应用场景。</p>
<h4 id="ngApp_u65B9_u5F0F"><a href="#ngApp_u65B9_u5F0F" class="headerlink" title="ngApp方式"></a>ngApp方式</h4><p>这种方式是AngularJS团队比较推荐的使用方法，只需要在HTML标签中使用AngularJS的<code>ng-app</code>指令指定要使用的模块既可，一般指定的是应用的主模块，或者说是应用入口模块：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Module<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>ng-app</code>指令的含义类似Java中的<code>main</code>方法，是当前页面中应用的唯一主入口，所以<strong>一个页面中只能使用一次<code>np-app</code>指令</strong>。将<code>ng-app</code>指令定义在哪个HTML的标签中就表示该标签及它的所有子标签就会被AngularJS接管，这一部分HTML代码将可以使用AngularJS所有的功能和特性，也就是使用AngularJS开发的Web应用的主入口。通常情况下都会在<code>body</code>标签中使用<code>ng-app</code>指令。</p>
<p>因为使用这种方式只能指定一个应用入口模块，所以为了能使用多模块的特性，就需要抽象出一个主模块，然后将其他所有模块加入主模块的依赖关系中，这里要注意的是因为AngularJS中的模块依赖可以向下穿透，类似类的继承，所以加入主模块依赖关系中的模块并不是所有的模块，而只是处于依赖层级顶层的模块。<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-1.png" alt="主模块依赖关系"><br>如上图所示，在主模块中只需要添加<code>DataHandleModule</code>和<code>NetworkModule</code>两个模块既可。但是这种方式的弊端是在HTML页面中并不能直观的表现出页面的哪些部分使用了何种模块，而且本身提供了模块化的特性，但最终又要抽象到一个模块中去使用，始终有点不是很舒服。</p>
<h4 id="u624B_u52A8_u52A0_u8F7D_u65B9_u5F0F"><a href="#u624B_u52A8_u52A0_u8F7D_u65B9_u5F0F" class="headerlink" title="手动加载方式"></a>手动加载方式</h4><p>虽然使用<code>ng-app</code>的形式可以满足需求，但是还要考虑想抽象出主模块，然后依赖一大堆模块，如果更希望可以在HTML标签中指定使用的模块，此时就需要手动的加载模块了:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="comment">// 互相独立的模块</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"><span class="keyword">var</span> anotherModule = angular.module(<span class="string">"anotherModule"</span>, []);</span><br><span class="line"></span><br><span class="line">angular.element(document).ready(function() &#123;</span><br><span class="line">  <span class="keyword">var</span> myDiv1 = document.getElementById(<span class="string">"myDiv1"</span>);</span><br><span class="line">  angular.bootstrap(myDiv1, [<span class="string">"mainModule"</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> myDiv2 = document.getElementById(<span class="string">"myDiv2"</span>);</span><br><span class="line">  angular.bootstrap(myDiv2, [<span class="string">"anotherModule"</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Module<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"myDiv1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"myDiv2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过上述代码可以看到，我们可以使用AngularJS的<code>bootstrap</code>方法给HTML元素指定模块。这样感觉和模块化特性更加切合，模块的隔离性也比较好，但是这种方式依然有显著的弊端。首先从HTML页面中依然不能直观的看到模块在页面中使用和分布情况，再次这种方式将视图层的HTML代码与JS代码耦合在了一起，也有点违背了AngularJS的MVC设计模式，也许这也是AngularJS不推荐该方式的原因之一吧。</p>
<h3 id="u6A21_u5757_u7684_u751F_u547D_u5468_u671F"><a href="#u6A21_u5757_u7684_u751F_u547D_u5468_u671F" class="headerlink" title="模块的生命周期"></a>模块的生命周期</h3><p>在AngularJS中，模块有两个主要的生命周期方法，那就是<code>.config()</code>和<code>.run()</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module('mainModule', []);</span><br><span class="line">mainModule.config(function(injectables) &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.run(function(injectables) &#123; </span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>.config()</code>方法的作用是在模块运行加载之前对模块进行配置，比如创建各种服务、创建自定义指令、注册过滤器等。<code>.run()</code>方法相当于AngularJS应用的<code>main</code>方法，在该方法里进行的配置都是运行时态的，比如对已经创建好的服务实例在应用运行期进行修改。</p>
<blockquote>
<p><code>.config()</code>方法在后文还会涉及，服务、指令、过滤器也会在后文有详细的讲解。</p>
</blockquote>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC是软件工程中的一种设计模式，既把应用系统分为模型（Model）、视图（View）和控制器（Controller）三个基本部分，并且模型层与视图层之间是相互隔离的。简单的描述每个部分的职能：</p>
<ul>
<li>模型层：管理数据模型。</li>
<li>视图层：控制UI的展现更新等。</li>
<li>控制层：负责具体业务逻辑处理、请求处理转发等，是模型层和视图之间的桥梁。</li>
</ul>
<p>AngularJS是为数不多实现了MVC设计模式的前端框架，为前端应用在开发时期的功能职责切分、代码复用及后期的维护提供了极大的便利。</p>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>在AngularJS中，模块是万源之本，所以AngularJS中的所有东西都是通过模块创建的，Controller也不例外。我们可以使用模块对象的<code>.controller()</code>方法创建控制器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"GreetingController"</span>, [<span class="string">"$scope"</span>, function($scope) &#123;</span><br><span class="line">  $scope.greeting = <span class="string">"Hello!"</span>;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看到，<code>.controller()</code>方法有两个参数：</p>
<ul>
<li>第一个参数类型为字符串，为Controller的名称。</li>
<li>第二个参数类型为数组，该数组用于注入当前Controller要用到的服务及实现业务逻辑的函数，这里要注意的是实现逻辑的函数始终是作为数组的最后一个元素，并且要将前面注入的服务作为该函数的参数传入。</li>
</ul>
<p>这里先简单描述一下<code>$scope</code>，在AngularJS中有一个重要的概念是服务，而<code>$scope</code>就是一个AngularJS内置的服务，在后面的章节中会详细讲解服务。那么<code>$scope</code>服务从字面理解是作用域的意思，其实也差不太多，如果用OO的思想将AngularJS的Controller看作是一个类，那么<code>$scope</code>服务就代表了这个类的作用域，那么就可以通过<code>$scope</code>服务给这个类添加属性或者方法，上面的代码示例中通过<code>$scope</code>服务给<code>GreetingController</code>控制器添加了字符串属性<code>greeting</code>及对象属性<code>person</code>。</p>
<p>所以上面代码的含义是，首先创建了名为<code>mainModule</code>的模块，然后在<code>mainModule</code>模块中创建了名为<code>GreetingController</code>的控制器，并使用<code>$scope</code>服务给该控制器添加了名为<code>greeting</code>和<code>person</code>的属性。</p>
<p>创建好Controller后，来看看如何使用它：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Controller<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"GreetingController"</span>&gt;</span></span><br><span class="line">      &#123;&#123; greeting &#125;&#125; &#123;&#123; person.name &#125;&#125; !</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>前文中介绍过在HTML页面中，通过使用<code>ng-app</code>指令给标签绑定模块。同理，我们可以使用<code>ng-controller</code>指令给标签及它的子标签绑定Controller，绑定了Controller的标签及它的子标签都可以使用Controller中的属性或者方法。我们可以使用双花括号语法访问Controller的属性或调用方法。运行效果很简单，就是将这两个属性的值输出到页面。</p>
<p>我们再来看看如何在Controller中添加方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"GreetingController"</span>, [<span class="string">"$scope"</span>, function($scope) &#123;</span><br><span class="line">  $scope.personName = <span class="string">"Everyone"</span>;</span><br><span class="line"></span><br><span class="line">  $scope.welcomeJason = function() &#123;</span><br><span class="line">    $scope.personName = <span class="string">"Jason"</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  $scope.welcomeGreen = function() &#123;</span><br><span class="line">    $scope.personName = <span class="string">"Green"</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们给<code>GreetingController</code>添加了<code>personName</code>属性和<code>welcomeJason()</code>、<code>welcomeGreen()</code>两个方法，并在这两个方法中分别对<code>personName</code>属性的值进行修改。再来看看HTML的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Controller<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"GreetingController"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"welcomeJason()"</span>&gt;</span>Jason<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"welcomeGreen()"</span>&gt;</span>Green<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">        Welcome &#123;&#123; personName &#125;&#125; !</span><br><span class="line">      <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在HTML代码中，添加了两个按钮，此时我们又看到了一个新的AngularJS指令<code>ng-click</code>，这个指令很好理解，就是给按钮绑定点击事件，当点击按钮时调用<code>GreetingController</code>中对应的方法，然后在<code>p</code>标签中显示<code>personName</code>属性。所以Controller中的方法不仅可以通过双花括号语法调用，也可以通过<code>ng-click</code>指令调用。我们来看看运行的效果：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-2.gif" alt="Demo for Controller"></p>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>Model指的是数据模型，在AngularJS中使用<code>$scope</code>服务给Controller添加的属性就是数据模型:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"GreetingController"</span>, [<span class="string">"$scope"</span>, function($scope) &#123;</span><br><span class="line">  $scope.person = &#123;</span><br><span class="line">    name: <span class="string">"Jason"</span>,</span><br><span class="line">    job: <span class="string">"Developer"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>上述代码示例中的<code>person</code>属性就是数据模型，下面看看如何使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Model<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"GreetingController"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">ng-model</span>=<span class="value">"person.name"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">ng-model</span>=<span class="value">"person.job"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">        Welcome &#123;&#123; person.name &#125;&#125;, He is a &#123;&#123; person.job &#125;&#125;!</span><br><span class="line">      <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述HTML代码示例中，我们又看到了新的指令<code>ng-model</code>，顾名思义，该指令就是用来将数据模型与HTML标签元素进行绑定的。上面的代码中分别将两个输入框与<code>person</code>对象的<code>name</code>和<code>job</code>属性进行了绑定，然后在<code>p</code>标签中输出，我们来看看运行效果：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-3.gif" alt="Demo for Model"></p>
<p>不难看出，当我们将<code>person</code>对象的属性与输入框绑定后，<code>person</code>对象属性的默认值就会显示在输入框里了，当我们修改输入框里的内容时会自动将数据通过Controller同步到<code>person</code>对象的相应属性上，所以<code>p</code>标签中的内容会实时跟着输入框的内容进行变化。</p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>View层自然就是HTML中的DOM元素了，通过AngularJS提供的各个指令将DOM元素与Controller和Model进行绑定。由Controller负责将数据模型的内容通过双花括号语法或<code>ng-model</code>指令展现在DOM元素上，而当DOM元素中的值发生变化时会由Controller捕获到，并更新对应的数据模型。</p>
<h2 id="u6570_u636E_u53CC_u5411_u7ED1_u5B9A"><a href="#u6570_u636E_u53CC_u5411_u7ED1_u5B9A" class="headerlink" title="数据双向绑定"></a>数据双向绑定</h2><p>在MVC一节中，通过几个示例介绍了如何创建和使用Controller、Model，如何与View层交互，其实也引出了AngularJS的一个重要特性。在Controller小节的例子中，通过点击按钮由Controller更改数据模型并将其展示在页面中，这是通过数据模型的变化从而影响视图层的显示。在Model小节的例子中，通过修改输入框中的值，由Controller捕获并更新对应的数据模型，这是通过视图层的变化从而影响数据模型的值。这就是AngularJS的数据双向绑定特性。</p>
<h2 id="u670D_u52A1_uFF08Services_uFF09"><a href="#u670D_u52A1_uFF08Services_uFF09" class="headerlink" title="服务（Services）"></a>服务（Services）</h2><p>AngularJS中一个重要的概念是服务，这个服务的概念比较宽泛，比如一个常量值也算做一个服务，既提供一个不可变值的服务。变量、对象、函数都算做是服务。在AngularJS中内置了好几十个服务，这些内置的服务都以<strong>$</strong>符号开头，比如<code>$scope</code>、<code>$http</code>、<code>$log</code>、<code>$timeout</code>、<code>$interval</code>等等，从字面意思都不难理解它们的作用，更多的内置服务可以去AngularJS官网查看<a href="https://docs.angularjs.org/api" target="_blank" rel="external">API文档</a>。</p>
<h3 id="u670D_u52A1_u7279_u5F81"><a href="#u670D_u52A1_u7279_u5F81" class="headerlink" title="服务特征"></a>服务特征</h3><p>AngularJS中的服务有两个主要特点：</p>
<ul>
<li>延迟加载，当应用中的其他组建使用服务时才会实例化。</li>
<li>单例，在应用的整个生命周期中，一个服务只存在一份实例，所以服务一般用来共享可复用的代码逻辑或者数据。</li>
</ul>
<h3 id="u81EA_u5B9A_u4E49_u670D_u52A1"><a href="#u81EA_u5B9A_u4E49_u670D_u52A1" class="headerlink" title="自定义服务"></a>自定义服务</h3><p>除了内置的服务，我们还可以创建自己的服务，在AngularJS中我们可以通过<code>$provide</code>这个内置的服务来创建我们的自定义服务，<code>$provide</code>服务提供了五个方法供我们创建不同应用场景的自定义服务，这五个方法分别是<code>provider(name, provider)</code>、<code>factory(name, $getFn)</code>、<code>service(name, constructor)</code>、<code>value(name, value)</code>、<code>constant(name, value)</code>。</p>
<h4 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h4><p>我们先从<code>value(name, value)</code>这个方法看起，该方法有两个参数：</p>
<ul>
<li>第一个参数为服务的名称，类型为字符串。</li>
<li>第二个参数可以是字符串、数字、数组、对象或者函数。</li>
</ul>
<p>假设在我们的应用中，多个Controller中都使用了相同的属性，比如都需要用到客户端ID这个属性，那么我们可以将其抽象为一个服务，该服务就专门用来获取客户端ID，来看看如何创建这个服务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.value(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的示例代码创建了名为<code>clientId</code>的服务，该服务其实就是一个字符串。不过这和<code>$provide</code>服务有什么关系呢？其实上面这种写法并不是完整的写法，只是一个语法糖而已，真正完整的写法是在模块的<code>.config()</code>方法中通过<code>$provide</code>服务去创建：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.config(function($provide) &#123;</span><br><span class="line">    $provide.value(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>创建好服务后通过AngularJS的注入机制将其注入到Controller中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, [<span class="string">"$scope"</span>, <span class="string">"clientId"</span>, function($scope, clientId) &#123;</span><br><span class="line">  $scope.clientId = clientId;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"SecondController"</span>, [<span class="string">"$scope"</span>, <span class="string">"clientId"</span>, function($scope, clientId) &#123;</span><br><span class="line">  $scope.clientId = clientId;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>然后在HTML页面中正常使用Controller就可以了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Value Service<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"FirstController"</span>&gt;</span></span><br><span class="line">      Client ID in FirstController: &#123;&#123; clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"SecondController"</span>&gt;</span></span><br><span class="line">      Client ID in SecondController: &#123;&#123; clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上文中说过<code>$scope</code>服务的其中一个作用就是给Controller添加属性和方法，然后可以在绑定Controller的DOM中使用双花括号语法直接访问添加的属性或调用方法。然而就<code>$scope</code>服务的这一功能而言，AngularJS还提供了另一种方式，我们先来看看Controller的写法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, [<span class="string">"clientId"</span>, function(clientId) &#123;</span><br><span class="line">  this.clientId = clientId;</span><br><span class="line">&#125;]);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"SecondController"</span>, [<span class="string">"clientId"</span>, function(clientId) &#123;</span><br><span class="line">  this.clientId = clientId;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>
<p>上述代码中我们并没有将<code>$scope</code>服务注入到这两个Controller中，而是使用<code>this</code>创建了<code>clientId</code>属性，<code>this</code>代表Controller的实例。使用这种方式后在HTML页面中使用Controller也有点变化：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Value Service<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"FirstController as first"</span>&gt;</span></span><br><span class="line">      Client ID in FirstController: &#123;&#123; first.clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"SecondController as second"</span>&gt;</span></span><br><span class="line">      Client ID in SecondController: &#123;&#123; second.clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们看到在<code>ng-conroller</code>标签中不再是直接写Controller名称了，而是使用<code>as</code>关键字声明了Controller的实例，然后在双花括号中使用Controller的实例去访问属性或者调用方法。</p>
<blockquote>
<p>使用<code>$scope</code>服务和<code>this</code>给Controller添加属性或方法的效果是一样的，所以不存在谁好谁坏的概念，只不过使用<code>this</code>的方式更贴合OO的思想，而且在HTML代码中对使用的属性或方法有更直观的可读性，能一眼看到使用了哪个Controller的属性或方法，所以使用哪种方式按个人喜好，但是不建议混用这两种方式。</p>
</blockquote>
<p>这里在介绍另外一个语法糖，那就是在注入服务的时候不用繁复的在数组中和函数参数中都声明，只需要在函数的参数里声明就可以了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function($scope, clientId) &#123;</span><br><span class="line">  $scope.clientId = clientId;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function(clientId) &#123;</span><br><span class="line">  this.clientId = clientId;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Constant"><a href="#Constant" class="headerlink" title="Constant"></a>Constant</h4><p>我们再来看看<code>constant(name, value)</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.constant(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br></pre></td></tr></table></figure>
<p>该方法和<code>value(name, value)</code>在创建的服务内容形式上来说是一样的，但是两者创建的服务在功能性上还是有区别的：</p>
<ul>
<li>从名称就可以看出用<code>constant(name, value)</code>方法创建的服务是不可修改的。</li>
<li>使用<code>constant(name, value)</code>创建的服务可以在模块的<code>.config()</code>方法中注入，也就是可以在创建其他服务时使用，而使用<code>value(name, value)</code>创建的服务不可以。</li>
</ul>
<h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>现在又有一个需求，希望能获取到当前时间添加在客户端ID后面，那么我们可以使用<code>service(name, constructor)</code>方法来创建获取当前时间的服务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.value(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line"></span><br><span class="line">mainModule.service(<span class="string">"currentDate"</span>, <span class="type">Date</span>);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function(clientId, currentDate) &#123;</span><br><span class="line">  this.clientId = clientId + <span class="string">"-"</span> + currentDate;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Service Service<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"FirstController as first"</span>&gt;</span></span><br><span class="line">      Client ID in FirstController: &#123;&#123; first.clientId &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出结果：<br><code>Client ID in FirstController: qazxsw123456-Thu Sep 08 2016 17:05:30 GMT+0800 (CST)</code></p>
<p><code>service(name, constructor)</code>方法的第二个参数是函数构造器，也就是函数的实例，所以<code>currentDate</code>服务的实体其实就是<code>new Date()</code>。</p>
<h4 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h4><p>现在，我们希望通过一个服务就可以完成客户端ID和当前时间的拼接，不需要给Controller注入两个服务，来看看如何用<code>factory(name, $getFn)</code>方法来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.constant(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line"></span><br><span class="line">mainModule.factory(<span class="string">"clientIdAndCurrentDate"</span>, function(clientId) &#123;</span><br><span class="line">  <span class="keyword">return</span> clientId + <span class="string">"-"</span> + new <span class="type">Date</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function(clientIdAndCurrentDate) &#123;</span><br><span class="line">  this.clientId = clientIdAndCurrentDate;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先我们需要用<code>constant(name, value)</code>方法创建<code>clientId</code>服务，因为需要将它注入到新的服务中，前文也介绍过<code>constant(name, value)</code>和<code>value(name, value)</code>方法的区别。然后使用<code>factory(name, $getFn)</code>方法创建<code>clientIdAndCurrentDate</code>服务，该函数的第二个参数类型是函数，我们在该函数中将<code>clientId</code>服务返回的客户端ID与<code>Date</code>构造器返回的时间进行拼接然后返回，当然运行结果还是一样的：<br><code>Client ID in FirstController: qazxsw123456-Thu Sep 08 2016 17:05:30 GMT+0800 (CST)</code></p>
<p>其实这个服务还可以写成这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.constant(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line"></span><br><span class="line">mainModule.service(<span class="string">"currentDate"</span>, <span class="type">Date</span>);</span><br><span class="line"></span><br><span class="line">mainModule.factory(<span class="string">"clientIdAndCurrentDate"</span>, function(clientId, currentDate) &#123;</span><br><span class="line">  <span class="keyword">return</span> clientId + <span class="string">"-"</span> + currentDate;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这相当于<code>clientIdAndCurrentDate</code>服务对<code>currentDate</code>服务进行了进一步的配置或者说增加了功能，那么也就是说<code>factory(name, $getFn)</code>方法相比<code>service(name, constructor)</code>方法可以创建更复杂一些的服务。</p>
<h4 id="Povider"><a href="#Povider" class="headerlink" title="Povider"></a>Povider</h4><p>现在又有新的需求，希望对<code>clientId</code>后面的时间进行格式化，但假设我们没有权限去更改<code>clientIdAndCurrentDate</code>服务，那么这时我们需要使用<code>provider(name, provider)</code>方法创建另外一个服务，然后对<code>clientIdAndCurrentDate</code>服务进行配置，来看看如何实现这个服务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.constant(<span class="string">"clientId"</span>, <span class="string">"qazxsw123456"</span>);</span><br><span class="line"></span><br><span class="line">mainModule.service(<span class="string">"currentDate"</span>, <span class="type">Date</span>);</span><br><span class="line"></span><br><span class="line">mainModule.factory(<span class="string">"clientIdAndCurrentDate"</span>, function(clientId, currentDate) &#123;</span><br><span class="line">  <span class="keyword">return</span> clientId + <span class="string">"-"</span> + currentDate;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.provider(<span class="string">"clientIdAndCurrentDateByFormat"</span>, function() &#123;</span><br><span class="line">  this.formatFunc = function(str) &#123;</span><br><span class="line">    <span class="keyword">var</span> clientId = str.substring(<span class="number">0</span>, str.indexOf(<span class="string">"-"</span>));</span><br><span class="line">    <span class="keyword">var</span> dateStr = str.substring(str.indexOf(<span class="string">"-"</span>), str.length);</span><br><span class="line">    <span class="keyword">var</span> dateObj = new <span class="type">Date</span>(dateStr);</span><br><span class="line">    <span class="keyword">var</span> year = dateObj.getFullYear().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> month = (dateObj.getMonth() + <span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> day = dateObj.getDate().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> hour = dateObj.getHours().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> minute = dateObj.getMinutes().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">var</span> second = dateObj.getSeconds().<span class="built_in">toString</span>();</span><br><span class="line">    <span class="keyword">return</span> clientId + <span class="string">"-"</span> + [year, (month &gt;= <span class="number">10</span> ? month : <span class="number">0</span> + month), (day &gt; <span class="number">10</span> ? day : <span class="number">0</span> + day), hour, minute, second].<span class="built_in">join</span>(<span class="string">""</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  this.$<span class="keyword">get</span> = function(clientIdAndCurrentDate) &#123;</span><br><span class="line">    <span class="keyword">return</span> this.formatFunc(clientIdAndCurrentDate);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"FirstController"</span>, function(clientIdAndCurrentDateByFormat) &#123;</span><br><span class="line">  this.clientId = clientIdAndCurrentDateByFormat;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先我们创建了<code>formatFunc()</code>辅助配置函数，然后实现了<code>$get</code>方法，通过<code>formatFunc()</code>辅助函数配置<code>clientIdAndCurrentDate</code>服务，我们来看运行结果：<br><code>Client ID in FirstController: qazxsw123456-20160909113523</code></p>
<p>要注意的一点是，通过<code>provider(name, provider)</code>方法创建服务时必须要<strong>显式</strong>的实现<code>$get</code>方法，并且只有在<code>$get</code>方法中才能注入其他服务。在AngularJS中服务仅指<code>$get</code>返回的东西，所以前四种创建服务的方法其实都是<code>provider(name, provider)</code>方法根据不同应用场景实现的语法糖，比如<code>factory</code>方法其实就是把一个函数当作了<code>$get</code>方法，<code>service</code>方法其实是将一个函数构造方法或者说函数实例当作了<code>$get</code>方法，<code>value</code>和<code>constant</code>方法其实又是对<code>factory</code>方法的语法糖实现。所以在自定义服务时可按需选择不同的方法创建服务。</p>
<h2 id="u6307_u4EE4_uFF08Directive_uFF09"><a href="#u6307_u4EE4_uFF08Directive_uFF09" class="headerlink" title="指令（Directive）"></a>指令（Directive）</h2><p>指令是AngularJS中另一个主要的特性，指令的作用可以用一句话描述，就是可以给HTML元素赋予特殊或自定义的行为，比如监听事件、视图模板代理等。在上文中我们使用过的<code>ng-app</code>、<code>ng-controller</code>、<code>ng-model</code>就是AngularJS中的指令。</p>
<h3 id="u6307_u4EE4_u7684_u547D_u540D"><a href="#u6307_u4EE4_u7684_u547D_u540D" class="headerlink" title="指令的命名"></a>指令的命名</h3><p>指令的命名和使用写法比较有意思，一般情况下在定义指令时推荐使用驼峰命名法，比如<code>ngModel</code>、<code>ngApp</code>，但是在HTML中大小写是不敏感的，所以在HTML中使用指令时推荐使用小写字母加破折号的形式，比如<code>ng-model</code>、<code>ng-app</code>。除了使用小写破折号这种方式，还有以下几种使用写法：</p>
<ul>
<li><code>ng:model</code></li>
<li><code>ng_model</code></li>
<li><code>data-ng-bind</code></li>
<li><code>x-ng-bind</code></li>
</ul>
<p>大家可以根据自己喜好选择使用写法，但是尽量保持写法统一。</p>
<h3 id="u6307_u4EE4_u7684_u5F62_u5F0F"><a href="#u6307_u4EE4_u7684_u5F62_u5F0F" class="headerlink" title="指令的形式"></a>指令的形式</h3><p>在AngularJS中，指令有四种表现形式，既标签形式、标签属性形式、标签class名称形式、注释形式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">my-dir</span>&gt;</span><span class="tag">&lt;/<span class="title">my-dir</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">my-dir</span>=<span class="value">"exp"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- directive: my-dir exp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"my-dir: exp;"</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一般情况下，推荐使用标签形式和标签属性形式。</p>
<h3 id="u4F7F_u7528_u6307_u4EE4"><a href="#u4F7F_u7528_u6307_u4EE4" class="headerlink" title="使用指令"></a>使用指令</h3><p>与Controller一样，指令也是通过AngularJS的Model创建的，使用<code>directive(name, directiveFactory)</code>方法创建指令，该方法有两个参数：</p>
<ul>
<li>第一个参数为指令名称，命名规范在上文中已经说过了。</li>
<li>第二个参数是一个工厂函数，该函数需要返回一个对象，我们通过配置该对象中的不同属性从而告诉AngularJS内置的<code>$compile</code>服务实现指令的不同功能。</li>
</ul>
<h4 id="u6307_u4EE4_u7C7B_u578B"><a href="#u6307_u4EE4_u7C7B_u578B" class="headerlink" title="指令类型"></a>指令类型</h4><p>上文中说过指令的实现是通过工厂函数返回对象，然后通过配置对象的不同属性实现不同功能，所以设置指令的类型也是通过配置属性对象完成的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"A"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective1"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective2"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"AE"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">my-directive1</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">my-directive2</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;div my-directive2&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看出，可以通过配置返回对象的<code>restrict</code>属性设置指令的类型，可配置的值分别为：</p>
<ul>
<li><code>&quot;A&quot;</code>：代表且仅可代表标签属性类型的指令。</li>
<li><code>&quot;E&quot;</code>：代表且仅可代表标签类型的指令。</li>
<li><code>&quot;C&quot;</code>：代表且仅可代表class名称类型的指令。</li>
<li><code>&quot;M&quot;</code>：代表且仅可代表注释类型的指令。</li>
</ul>
<p>如果想设置一个多类型的指令，那么可以将类型标识写在一起，比如<code>&quot;AEC&quot;</code>代表既是标签属性类型，又是标签类型，还是class名称类型。如果不配置<code>restrict</code>属性，那么表示指令的类型为默认的<code>&quot;AE&quot;</code>类型。</p>
<h4 id="u901A_u8FC7_u6307_u4EE4_u5C01_u88C5UI_u6A21_u677F"><a href="#u901A_u8FC7_u6307_u4EE4_u5C01_u88C5UI_u6A21_u677F" class="headerlink" title="通过指令封装UI模板"></a>通过指令封装UI模板</h4><p>在前端应用的开发过程中，不同的页面常有很多一样的UI元素，如果每个页面都写一遍，那么在维护时就常会牵一发而动全身，AngularJS中的指令可以很好的解决这个问题，它可以将UI片段封装为一个指令，从而可以在不同的页面中复用，那么在维护时就是四两拨千斤的效果。下面来看看如何实现模板指令：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function() &#123;</span><br><span class="line">  this.name = <span class="string">"Jason"</span>;</span><br><span class="line">  this.job = <span class="string">"Developer"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    template: <span class="string">"Name: &#123;&#123;mc.name&#125;&#125;, Job: &#123;&#123;mc.job&#125;&#125;"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController as mc"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;div my-directive&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码示例中，我们将本该写在HTML中的展示代码设置给了返回对象的<code>template</code>属性。为了能更好的管理UI模板，我们还可以将UI展示代码提炼成单独的HTML模板文件，并可以使用指令的<code>templateUrl</code>属性设置HTML模板文件名称，这样便可以大大降低指令和UI模板的耦合度：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    templateUrl: <span class="string">"myTemplate.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- myTemplate.html --&gt;</span></span><br><span class="line">Name: &#123;&#123;mc.name&#125;&#125;, Job: &#123;&#123;mc.job&#125;&#125;</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>那么问题来了，如果UI模板文件很多的话，按上面的方法就要写很多个对应的指令，而且只是UI模板文件名称不一样而已，实在有点冗余。AngularJS提供了另外一种解决方法，那就是可以通过给模板指令设置相关属性，从而动态的加载UI模板文件，我们来看看如何实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function() &#123;</span><br><span class="line">  this.name = <span class="string">"Jason"</span>;</span><br><span class="line">  this.job = <span class="string">"Developer"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    templateUrl: function(elem, attr) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"myTemplate-"</span> + attr.type + <span class="string">".html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController as mc"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">type</span>=<span class="value">"name"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">type</span>=<span class="value">"job"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;div my-directive type="name"&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;div my-directive type="job"&gt;&lt;/div&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- myTemplate-name.html --&gt;</span></span><br><span class="line">Name: &#123;&#123;mc.name&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- myTemplate-job.html --&gt;</span></span><br><span class="line">Job: &#123;&#123;mc.job&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的示例代码可以看出，<code>template</code>和<code>templateUrl</code>两个属性的值不只是接受字符串，还接受函数。要注意的是该函数默认带两个参数：</p>
<ul>
<li>第一个参数代表当前的HTML DOM元素。</li>
<li>第二个参数代表当前HTML DOM元素的属性对象，在函数体内可以为该对象设置任何属性。</li>
</ul>
<p>在上面的示例中，我们给代表当前DOM元素的属性对象设置了<code>type</code>属性，用于标识UI模板文件名称，这样我们就可以通过一个专有的模板指令来控制所有的UI模板文件了。</p>
<h4 id="u6307_u4EE4_u7684_u4F5C_u7528_u57DF"><a href="#u6307_u4EE4_u7684_u4F5C_u7528_u57DF" class="headerlink" title="指令的作用域"></a>指令的作用域</h4><p>上面的示例中，我们通过配置可以实现动态加载UI模板文件，但是我们无法动态指定UI模板文件中显示的内容。这一节我们来了解一下如何通过指令的隔离域达到在同一个指令中动态指定UI模板文件中要显示的内容，先看看代码示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function() &#123;</span><br><span class="line">  this.jason = &#123; name: <span class="string">"Jason"</span>, job: <span class="string">"Developer"</span> &#125;;</span><br><span class="line">  this.green = &#123; name: <span class="string">"Green"</span>, job: <span class="string">"Doctor"</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span>,</span><br><span class="line">    scope: &#123;</span><br><span class="line">      personInfo: <span class="string">"=person"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    templateUrl: <span class="string">"myTemplate.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController as mc"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">person</span>=<span class="value">"mc.jason"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">hr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">person</span>=<span class="value">"mc.green"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- myTemplate.html --&gt;</span></span><br><span class="line">Name: &#123;&#123;personInfo.name&#125;&#125;, Job: &#123;&#123;personInfo.job&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>从示例中可以看到，我们给指令的返回对象又添加了一个属性<code>scope</code>，这就是指令的作用域属性，<code>scope</code>属性有三种可设置的值：</p>
<ul>
<li><code>false</code>：默认值，这表示指令共享它父节点的Controller的作用域，也就是可以使用双花括号语法直接访问父节点Controller作用域中的属性。</li>
<li><code>true</code>：创建指令自己的作用域，但是该作用域继承父节点Controller的作用域。</li>
<li><code>{}</code>：第三种是设置一个对象，表示创建了指令自己独立的作用域，与父节点Controller的作用是完全隔离的。</li>
</ul>
<p>如果我们希望指令的隔离作用域和父节点Controller的作用域之间进行交互，那么就需要将两者进行绑定，这里有三种绑定方式：</p>
<ul>
<li>使用<code>@</code>实现单向数据绑定，但是只限于绑定Controller作用域中值为字符串的属性，因为是单向绑定，所以父节点Controller修改绑定的属性可影响到指令作用域中对应的属性，反之则不可以。在HTML中使用双花括号语法取值，比如<code>person=&quot;&quot;</code>。</li>
<li>使用<code>=</code>实现双向数据绑定，在父节点Controller中修改属性和在指令中修改属性可相互影响。在HTML中直接使用属性名称，比如<code>person=&quot;jasonObj&quot;</code>。</li>
<li>使用<code>&amp;</code>实现函数绑定，用于绑定Controller中值为函数的属性，在HTML中直接调用函数，比如<code>action=&quot;click()&quot;</code>。</li>
</ul>
<p>上面的示例中我们给<code>myDirective</code>指令设置了隔离域并添加了名为<code>personInfo</code>的属性，并与父节点的<code>MyController</code>进行数据双向绑定，在HTML代码中，就可以通过<code>&lt;my-directive&gt;</code>指令标签的<code>person</code>属性与<code>MyController</code>的数据绑定了。另外，在进行绑定时还有一种简写的方式：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">scope: &#123;</span><br><span class="line">  personInfo: <span class="string">"="</span></span><br><span class="line">  <span class="comment">// personInfo: "@"</span></span><br><span class="line">  <span class="comment">// personInfo: "&amp;"</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">scope: &#123;</span><br><span class="line">  personInfo: <span class="string">"=personInfo"</span></span><br><span class="line">  <span class="comment">// personInfo: "@personInfo"</span></span><br><span class="line">  <span class="comment">// personInfo: "&amp;personInfo"</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="u6307_u4EE4_u7684Controller"><a href="#u6307_u4EE4_u7684Controller" class="headerlink" title="指令的Controller"></a>指令的Controller</h4><p>在指令中也可以创建Controller，和在Module中创建Controller很类似，既定义函数，在参数中注入需要的AngularJS服务既可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function($scope) &#123;</span><br><span class="line">  $scope.green = &#123; name: <span class="string">"Green"</span>, job: <span class="string">"Doctor"</span> &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span>,</span><br><span class="line">    scope: &#123;</span><br><span class="line">      person: <span class="string">"="</span></span><br><span class="line">    &#125;,</span><br><span class="line">    controller: function($scope) &#123;</span><br><span class="line">      $scope.jason = &#123; name: <span class="string">"Jason"</span>, job: <span class="string">"Developer"</span> &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    templateUrl: <span class="string">"myTemplate.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-directive</span> <span class="attribute">person</span>=<span class="value">"green"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-directive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- myTemplate.html --&gt;</span></span><br><span class="line">Name: &#123;&#123;jason.name&#125;&#125;, Job: &#123;&#123;jason.job&#125;&#125;</span><br><span class="line">Name: &#123;&#123;person.name&#125;&#125;, Job: &#123;&#123;person.job&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们给<code>myDirective</code>指令添加了Controller，有一点不同的是在添加Controller时不能设置名称，指令的Controller名称默认与指令名称一样，如果需要另外指定名称，需要配置<code>controllerAs</code>指定Controller的名称：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">controller: function($scope) &#123;</span><br><span class="line">  $scope.jason = &#123; name: <span class="string">"Jason"</span>, job: <span class="string">"Developer"</span> &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">controllerAs: <span class="string">"directiveController"</span>,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在上面示例的UI模板文件中可以看出，既可以使用指令隔离域中与父节点Controller绑定的属性，也可以使用在指令自己的Controller中定义在隔离域的属性。</p>
<h4 id="u6307_u4EE4_u4E4B_u95F4_u7684_u4EA4_u4E92"><a href="#u6307_u4EE4_u4E4B_u95F4_u7684_u4EA4_u4E92" class="headerlink" title="指令之间的交互"></a>指令之间的交互</h4><p>指令之间的交互主要是以指令的Controller为桥梁来实现的，这里的交互指的是子指令与父指令之间的交互，我们可以使用指令的<code>require</code>属性设置要引用的父指令的Controller，这里有几种配置方式：</p>
<ul>
<li><code>require: &quot;controllerName&quot;</code>：只查找指令自己的Controller。</li>
<li><code>require: &quot;^controllerName&quot;</code>：查找指令自己的Controller以及父指令的Controller。</li>
<li><code>require: &quot;^^controllerName&quot;</code>：只查找父指令的Controller。</li>
<li><code>require: [&quot;^controllerName1&quot;, &quot;^controllerName2&quot;]</code>：引用多个Controller。</li>
</ul>
<p>如果指令查找到引用的Controller后该如何使用呢，这就要使用指令的另一个重要的属性<code>link</code>函数了。<code>link</code>函数主要用来为DOM元素添加事件监听、监视模型属性变化、以及更新DOM，该函数共有五个参数：</p>
<ul>
<li><code>scope</code>：指令的作用域，默认是父节点Controller的作用域，如果指令有创建自己的作用域，那么则指指令自己的作用域。</li>
<li><code>element</code>：指令的jQLite(jQuery的子集)包装的DOM元素，可以通过该参数操作指令所在的DOM元素。</li>
<li><code>attrs</code>：指令所在DOM元素的属性对象，通过<code>.</code>语法可以获取到给DOM元素添加的属性。</li>
<li><code>controller</code>：指令通过<code>require</code>属性引用的Controller实例。</li>
<li><code>transcludeFn</code>：嵌入函数。</li>
</ul>
<p><code>link</code>函数的其他几个参数后面文章中都会讲到，当指令找到通过<code>require</code>属性引用的Controller后，我们就可以通过<code>link</code>函数的第四个参数访问引用的Controller了。来看一个示例：</p>
<h4 id="u901A_u8FC7_u6307_u4EE4_u64CD_u4F5CDOM_u5143_u7D20"><a href="#u901A_u8FC7_u6307_u4EE4_u64CD_u4F5CDOM_u5143_u7D20" class="headerlink" title="通过指令操作DOM元素"></a>通过指令操作DOM元素</h4><p>我们了解了<code>link</code>函数后就可以使用该函数实现各种有用的指令了，比如通过指令操作DOM元素：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myDirective"</span>, function($interval) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"A"</span>,</span><br><span class="line">    link: function(scope, element, attrs) &#123;</span><br><span class="line">      $interval(function() &#123;</span><br><span class="line">        element.text(new <span class="type">Date</span>());</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">      Current Date is: <span class="tag">&lt;<span class="title">span</span> <span class="attribute">my-directive</span>&gt;</span><span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的示例中，首先我们限定了<code>myDirective</code>指令只能以标签属性的形式使用，然后注入了AngularJS的内置服务<code>$interval</code>，通过<code>link</code>函数的第二个参数获取到指令所在的DOM元素，然后周期性更新DOM元素显示的内容。<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-4.gif" alt=""></p>
<h4 id="u6307_u4EE4_u7684_u5185_u5D4C_u673A_u5236"><a href="#u6307_u4EE4_u7684_u5185_u5D4C_u673A_u5236" class="headerlink" title="指令的内嵌机制"></a>指令的内嵌机制</h4><p>大家都知道HTML中的DOM元素是具有层级关系的，一般情况下我们使用指令封装的UI模板颗粒度都会比较小，所以就会出现指令嵌套的现象，这几需要用到指令的内嵌机制了，指令的<code>transclude</code>属性默认为<code>false</code>，如果将其设置为<code>true</code>，那么该指令就开启了内嵌机制，也就是说指令标签之间的内容可以被指定嵌入UI模板中被<code>ng-transclude</code>内置指令标记过的DOM元素中，结合之前说过的父子指令交互的内容来实现一个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myTabs"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span>,</span><br><span class="line">    transclude: <span class="literal">true</span>,</span><br><span class="line">    controller: function($scope) &#123;</span><br><span class="line">      $scope.panes = [];</span><br><span class="line">      <span class="keyword">var</span> panes = $scope.panes;</span><br><span class="line">      this.addPane = function(pane) &#123;</span><br><span class="line">        <span class="keyword">if</span>(panes.length == <span class="number">0</span>) &#123;</span><br><span class="line">          $scope.select(pane);</span><br><span class="line">        &#125;;</span><br><span class="line">        panes.push(pane);</span><br><span class="line">      &#125;;</span><br><span class="line">      $scope.select = function(pane) &#123;</span><br><span class="line">        angular.forEach(panes, function(pane) &#123;</span><br><span class="line">          pane.selected = <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        pane.selected = <span class="literal">true</span>;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    templateUrl: <span class="string">"myTabs.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mainModule.directive(<span class="string">"myPane"</span>, function() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    restrict: <span class="string">"E"</span>,</span><br><span class="line">    require: <span class="string">"^^myTabs"</span>,</span><br><span class="line">    scope: &#123;</span><br><span class="line">      name: <span class="string">"@"</span>,</span><br><span class="line">      job: <span class="string">"@"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    link: function(scope, element, attrs, controller) &#123;</span><br><span class="line">      controller.addPane(scope);</span><br><span class="line">    &#125;,</span><br><span class="line">    templateUrl: <span class="string">"myPane.html"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了两个指令，<code>myTabs</code>和<code>myPane</code>，在<code>myTabs</code>指令中，我们限定它只能以标签形式使用，开启了内嵌机制，并定义了它自己的Controller，在Controller中定义了<code>panes</code>变量和<code>addPane(pane)</code>，<code>select(pane)</code>两个方法，方法的具体实现内容这里就不解释了，都很简单，最后指定了UI模板文件<code>myTabs.html</code>。</p>
<p>在<code>myPane</code>指令中同样限定只能以标签形式使用，指定了要引用的父节点的Controller名称，后创建了自己的隔离域，定义了<code>name</code>，<code>job</code>两个属性，并进行了字符串的单向绑定，然后定义了<code>link</code>函数，通过第四个参数访问到了父节点的<code>myTabs</code>Controller，并调用<code>addPane(pane)</code>函数，将自己的隔离域作为参数传入，最后指定了UI模板文件<code>myPane.html</code>。</p>
<p>再来看看<code>index.html</code>和<code>myTabs.html</code>，<code>myPane.html</code>这两个模板文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">my-tabs</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-pane</span> <span class="attribute">name</span>=<span class="value">"Jason"</span> <span class="attribute">job</span>=<span class="value">"Developer"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-pane</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-pane</span> <span class="attribute">name</span>=<span class="value">"Green"</span> <span class="attribute">job</span>=<span class="value">"Doctor"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-pane</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">my-tabs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--myTabs.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"pane in panes"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">""</span> <span class="attribute">ng-click</span>=<span class="value">"select(pane)"</span>&gt;</span>&#123;&#123;pane.name&#125;&#125;<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"paneContainer"</span> <span class="attribute">ng-transclude</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--myPane.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-show</span>=<span class="value">"selected"</span>&gt;</span></span><br><span class="line">  I am &#123;&#123;name&#125;&#125;, my job is &#123;&#123;job&#125;&#125;!</span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>index.html</code>中，<code>myTabs</code>指令包含两个<code>myPane</code>指令，这两个<code>myPane</code>指令所显示的内容将嵌入在<code>myTabs.html</code>中id为<code>paneContainer</code>的DIV中，也就是<code>myPane.html</code>中的内容会被嵌入在这个DIV里。</p>
<p>上面这三个文件中有几个点需要注意：</p>
<ul>
<li>因为在<code>myPane</code>指令的隔离域中定义了<code>name</code>和<code>job</code>属性，并进行了字符串绑定，所以在<code>index.html</code>文件中，可以对<code>myPane</code>标签里的<code>name</code>，<code>job</code>属性直接进行字符串赋值。</li>
<li>因为在<code>myPane</code>指令中引用了<code>myTabs</code>指令的Controller，并在<code>link</code>函数中将隔离域作为参数传给了<code>myTabs</code>，既<code>myTabs</code>指令的Controller中的<code>select(pane)</code>和<code>addPane(pane)</code>函数的参数均为<code>myPane</code>指令的隔离域，所以在<code>myTabs.html</code>文件中可以直接使用<code>pane</code>访问<code>myPane</code>指令隔离域中定义的属性，比如<code></code>，并且也可以在<code>myTabs</code>指令在<code>myPane</code>的隔离域中定义属性，比如<code>pane.selected = true</code>，给隔离域定义了<code>selected</code>的属性，然后可以在<code>myPane</code>指令中使用。</li>
<li><code>ng-show</code>是AngularJS内置的指令，用于显示或隐藏指定的DOM元素。</li>
</ul>
<p>看看运行效果：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-5.gif" alt=""></p>
<p><code>link</code>函数的第五个参数<code>transcludeFn</code>是一个函数，该函数常用的有两个参数<code>scope</code>和<code>function(clone){}</code>，既<code>transcludeFn(scope, function(clone){})</code>。前者是嵌入内容的作用域，与指令的隔离作用域是平行的，后者函数的参数<code>clone</code>是嵌入的内容的jquery封装，可以通过它对嵌入的内容进行DOM操作。</p>
<h4 id="u6307_u4EE4_u7684_u5176_u4ED6_u5C5E_u6027"><a href="#u6307_u4EE4_u7684_u5176_u4ED6_u5C5E_u6027" class="headerlink" title="指令的其他属性"></a>指令的其他属性</h4><p><strong>priority</strong>用于指定指令的优先级，该属性的值从1开始。当有多个指令定义在同一个DOM元素中时就需要通过该属性明确它们的执行顺序。</p>
<p><strong>replace</strong>用于判定是否将UI模板的内容替换掉指令标签本身，该属性默认值为<code>false</code>，既保留指令标签本身，若设置为<code>true</code>则替换指令标签。</p>
<h2 id="u7EC4_u5EFA_uFF08Component_uFF09"><a href="#u7EC4_u5EFA_uFF08Component_uFF09" class="headerlink" title="组建（Component）"></a>组建（Component）</h2><p>在AngularJS 1.5中新加了组建的概念，它的意图是希望从AngularJS 1.x向AngularJS 2.0迁移时能更加平顺，AngularJS团队也提倡使用组建化模式开发Web应用。那么组建是什么呢？其实组建就是指令的一种特性形式，它规避了一些指令中晦涩难理解的东西，比如<code>compile</code>函数，<code>link</code>函数，<code>scope</code>，<code>restrict</code>等，所以组建的目的就是能让我们更为傻瓜式的创建指令，能更好的遵循组建化的开发模式，提高性能以及更容易向AngularJS 2.0迁移。</p>
<h3 id="u521B_u5EFA_u7EC4_u5EFA"><a href="#u521B_u5EFA_u7EC4_u5EFA" class="headerlink" title="创建组建"></a>创建组建</h3><p>我们可以使用Module的<code>component</code>方法创建组建：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    name: <span class="string">"="</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>component</code>方法的第一个参数是组建名称，命名规则和使用方法与指令一样，第二个参数和创建指令有点不同，它并不是一个函数，而是一个对象，在该对象中对组建的配置和在指令中的配置方式很类似。</p>
<p>我们先来看看组建和指令之间有哪些区别：</p>
<ul>
<li>组建中不提供手动配置作用域，默认的作用域就是隔离域。</li>
<li>组建中通过<code>bindings</code>属性进行数据绑定，除了<code>=</code>，<code>@</code>，<code>&amp;</code>三种绑定方式以外还增加了一种<code>&lt;</code>方式，既单向绑定，但不限于字符串。从而保证了组建有自己的清晰的输入输出API。并且通过<code>bindings</code>对象绑定的属性直接绑定在组建的Controller上。</li>
<li>组建的Controller默认名称为<code>$ctrl</code>，当然也可以使用<code>controllerAs</code>属性指定Controller的名称。</li>
<li>组建只能以标签形式使用。</li>
<li>组建中没有<code>link</code>函数，<code>compile</code>函数，<code>priority</code>属性，<code>restrict</code>属性。</li>
<li>组件只能控制自身的输入输出，组建不允许修改属于自己隔离域以外的任何数据和DOM元素。一般情况下，AngularJS通过作用域（Scope）继承的特性支持跨层级修改数据的能力，但是如果当修改数据职责不清晰或不恰当的时候就会导致各种问题，所以这也就是组建的作用域默认都是隔离域的原因。</li>
</ul>
<p>使用起来和指令比较类似：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.controller(<span class="string">"MyController"</span>, function() &#123;</span><br><span class="line">  this.person = &#123;</span><br><span class="line">    name: <span class="string">"Jason"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    person: <span class="string">"="</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Component<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">ng-controller</span>=<span class="value">"MyController as mc"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">my-component</span> <span class="attribute">person</span>=<span class="value">"mc.person"</span>&gt;</span><span class="tag">&lt;/<span class="title">my-component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--myTemplate.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">span</span>&gt;</span>Name: &#123;&#123;$ctrl.person.name&#125;&#125;<span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="u7EC4_u5EFA_u7684_u751F_u547D_u5468_u671F"><a href="#u7EC4_u5EFA_u7684_u751F_u547D_u5468_u671F" class="headerlink" title="组建的生命周期"></a>组建的生命周期</h3><p>在组建的整个生命周期里，AngularJS提供了五个关键点的方法，可供我们监听到组建的运行状态：</p>
<ul>
<li><code>$onInit()</code>：该方法在组件及其所有 binding 初始化之后被调用，从而我们就有了一个清晰的地方统一存放数据初始化的逻辑：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mainModule = angular.module(<span class="string">"mainModule"</span>, []);</span><br><span class="line"></span><br><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.name = <span class="string">"jason"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将初始化数据的逻辑放在onInit方法中</span></span><br><span class="line"></span><br><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.$onInit = function() &#123;</span><br><span class="line">      this.name = <span class="string">"jason"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$onChanges(changesObj)</code>：当组建中单向绑定的属性值发生变化时被调用，这里要注意的是只有绑定属性值的引用发生变化时才能监听到，如果只是在指令内对属性进行修改，该方法是无法监听到的。通过该方法的参数可以获取到被修改数据当前的值、修改之前的值、是否时第一次修改：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.$onChanges = function(changesObj) &#123;</span><br><span class="line">      <span class="keyword">if</span>(changesObj.name) &#123;</span><br><span class="line">        <span class="comment">// name当前的值</span></span><br><span class="line">        <span class="keyword">var</span> nameCurrentValue = changesObj.name.currentValue;</span><br><span class="line">        <span class="comment">// name修改前的值</span></span><br><span class="line">        <span class="keyword">var</span> namePreviousValue = changesObj.name.previousValue;</span><br><span class="line">        <span class="comment">// 是否是第一次修改</span></span><br><span class="line">        <span class="keyword">var</span> isFirstChange = changesObj.name.isFirstChange();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    name: <span class="string">"&lt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$doCheck()</code>：该方法和<code>$onChanges(changesObj)</code>作用类似，但是该方法可以监听到在指令内对属性进行修改的行为： </li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"myComponent"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"myTemplate.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    <span class="comment">// 当name在指令内修改时</span></span><br><span class="line">    this.name = <span class="string">"Green"</span>;</span><br><span class="line">    this.$doCheck = function() &#123;</span><br><span class="line">      <span class="comment">// doCheck方法会被调用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    name: <span class="string">"&lt;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>$onDestroy()</code>：当作用域被销毁时调用该方法。</li>
<li><code>$postLink()</code>：当指令所在标签与子标签链接时调用该方法。</li>
</ul>
<h3 id="u7EC4_u5EFA_u5316_u5F00_u53D1"><a href="#u7EC4_u5EFA_u5316_u5F00_u53D1" class="headerlink" title="组建化开发"></a>组建化开发</h3><p>我们先来看看示例效果：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-6.gif" alt=""></p>
<p>既然是组建化开发，那么我们来看看上面这个示例有几个组建：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/angularjs/angularjs-guide-7.png" alt=""><br>从上图可以看到，整个示例一共用了三个组建，其中有两个组建进行了复用，下面我们来看看每个组建是如何定义的。</p>
<h4 id="personList_u7EC4_u5EFA"><a href="#personList_u7EC4_u5EFA" class="headerlink" title="personList组建"></a>personList组建</h4><p>该组建主要用来初始化数据源，定义对数据源操作的函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"personList"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"personList.html"</span>,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.$onInit = function() &#123;</span><br><span class="line">      this.list = [&#123;</span><br><span class="line">        name: <span class="string">"Jason"</span>,</span><br><span class="line">        job: <span class="string">"Developer"</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        name: <span class="string">"Green"</span>,</span><br><span class="line">        job: <span class="string">"Doctor"</span></span><br><span class="line">      &#125;];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.updatePerson = function(person, job, value) &#123;</span><br><span class="line">      person[job] = value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.deletePerson = function(person) &#123;</span><br><span class="line">      <span class="keyword">var</span> idx = this.list.indexOf(person);</span><br><span class="line">      <span class="keyword">if</span>(idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        this.list.splice(idx, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>首先在<code>$onInit</code>函数中初始化数据源，定义了<code>Person</code>对象数组，然后定义了更新指定<code>Person</code>对象的方法<code>updatePerson</code>及删除指定<code>Person</code>对象的方法<code>deletePerson</code>。</p>
<p>再来看看它的UI模板文件<code>personList.html</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">b</span>&gt;</span>Person<span class="tag">&lt;/<span class="title">b</span>&gt;</span><span class="tag">&lt;<span class="title">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">person-detail</span> <span class="attribute">ng-repeat</span>=<span class="value">"person in $ctrl.list"</span> <span class="attribute">person</span>=<span class="value">"person"</span> <span class="attribute">on-update</span>=<span class="value">"$ctrl.updatePerson(person, job, value)"</span> <span class="attribute">on-delete</span>=<span class="value">"$ctrl.deletePerson(person)"</span>&gt;</span><span class="tag">&lt;/<span class="title">person-detail</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该文件共有两部分，第一部分是用原生HTML标签定义了标题，第二部分是使用了另外一个组建<code>personDetail</code>。<code>ng-repeat</code>指令是AngularJS内置的指令，作用不言而喻，就是循环数据源，同时组建也跟据循环次数增加。<code>person</code>，<code>on-update</code>，<code>on-delete</code>是在<code>personDetail</code>组建中定义的数据绑定属性，用大白话解释就是，<code>personDetail</code>组建中的<code>person</code>变量与<code>personList</code>组建中的<code>Person</code>对象进行了绑定，<code>personDetail</code>组建中的<code>onUpdate</code>和<code>onDelete</code>方法分别与<code>personList</code>组建中的<code>updatePerson</code>和<code>deletePerson</code>方法进行了绑定。</p>
<h4 id="personDetail_u7EC4_u5EFA"><a href="#personDetail_u7EC4_u5EFA" class="headerlink" title="personDetail组建"></a>personDetail组建</h4><p>该组建主要用于展示Person对象的具体内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"personDetail"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"personDetail.html"</span>,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    person: <span class="string">"&lt;"</span>,</span><br><span class="line">    onUpdate: <span class="string">"&amp;"</span>,</span><br><span class="line">    onDelete: <span class="string">"&amp;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.update = function(job, value) &#123;</span><br><span class="line">      this.onUpdate(&#123;person: this.person, job: job, value: value&#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.delete = function() &#123;</span><br><span class="line">      this.onDelete(this.person);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span>&gt;</span></span><br><span class="line">  Name: &#123;&#123;$ctrl.person.name&#125;&#125;<span class="tag">&lt;<span class="title">br</span>&gt;</span></span><br><span class="line">  Job: <span class="tag">&lt;<span class="title">editable-field</span> <span class="attribute">field-value</span>=<span class="value">"$ctrl.person.job"</span> <span class="attribute">on-update</span>=<span class="value">"$ctrl.update('job', value)"</span>&gt;</span><span class="tag">&lt;/<span class="title">editable-field</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">button</span> <span class="attribute">ng-click</span>=<span class="value">"$ctrl.delete()"</span>&gt;</span>Delete<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>personDetail.html</code>文件里，首先访问了<code>person</code>对象的<code>name</code>属性，将其展示出来，注意，这里由<code>$ctrl.preson</code>访问到的其实是单向绑定的<code>personList</code>组建中的<code>person</code>对象。而且在<code>update</code>函数中调用了与<code>personList</code>组建的<code>updatePerson</code>函数绑定的<code>onUpdate</code>函数，也就是子组建调用了父组建的方法。然后使用了第三个组建<code>editableField</code>，该组建同样有一些属性和方法和<code>personDetail</code>组建中对应的属性和方法进行了绑定。最后增加了一个按钮，并使用<code>ng-click</code>指令指定了按钮的点击事件。 </p>
<h4 id="editableField_u7EC4_u5EFA"><a href="#editableField_u7EC4_u5EFA" class="headerlink" title="editableField组建"></a>editableField组建</h4><p>该组建的主要作用是展示并修改<code>person</code>对象中的<code>job</code>属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">mainModule.component(<span class="string">"editableField"</span>, &#123;</span><br><span class="line">  templateUrl: <span class="string">"editableField.html"</span>,</span><br><span class="line">  bindings: &#123;</span><br><span class="line">    fieldValue: <span class="string">"&lt;"</span>,</span><br><span class="line">    onUpdate: <span class="string">"&amp;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  controller: function() &#123;</span><br><span class="line">    this.$onInit = function() &#123;</span><br><span class="line">      this.editMode = <span class="literal">false</span>;</span><br><span class="line">      this.fieldValueCopy = this.fieldValue;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.handModelChange = function() &#123;</span><br><span class="line">      <span class="keyword">if</span>(this.editMode) &#123;</span><br><span class="line">        this.onUpdate(&#123;job: <span class="string">"job"</span>, value: this.fieldValue&#125;);</span><br><span class="line">        this.fieldValueCopy = this.fieldValue;</span><br><span class="line">      &#125;</span><br><span class="line">      this.editMode = !this.editMode;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.reset = function() &#123;</span><br><span class="line">      this.fieldValue = this.fieldValueCopy;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>从最开始的运行效果中可以看到<code>editableField</code>是有形态变化的，所以在<code>$onInit</code>函数中定义了是否为编辑模式的标识符<code>editMode</code>以及代表输入框内容的<code>fieldValue</code>变量，因为有<code>reset</code>功能，所以还定义存储修改之前值的变量<code>fieldValueCopy</code>。然后定义了点击<code>Edit</code>或<code>Save</code>按钮触发的函数<code>handModelChange</code>，并在该函数中调用了和<code>personDetail</code>组建的<code>update</code>函数绑定的<code>onUpdate</code>函数，同样由子组建调用了父组建的方法。还定义了点击<code>Reset</code>按钮触发的函数<code>reset</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">&lt;span ng-<span class="keyword">switch</span>=<span class="string">"$ctrl.editMode"</span>&gt;</span><br><span class="line">  &lt;input ng-<span class="keyword">switch</span>-when=<span class="string">"true"</span> type=<span class="string">"text"</span> ng-model=<span class="string">"$ctrl.fieldValue"</span>&gt;</span><br><span class="line">  &lt;span ng-<span class="keyword">switch</span>-<span class="keyword">default</span>&gt;&#123;&#123;$ctrl.fieldValue&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;button ng-click=<span class="string">"$ctrl.handModelChange()"</span>&gt;&#123;&#123;$ctrl.editMode ? <span class="string">"Save"</span> : <span class="string">"Edit"</span>&#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;button ng-<span class="keyword">if</span>=<span class="string">"$ctrl.editMode"</span> ng-click=<span class="string">"$ctrl.reset()"</span>&gt;<span class="type">Reset</span>&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>在<code>editableField.html</code>文件中展示了<code>person</code>对象的<code>job</code>属性，定义了修改<code>job</code>属性的输入框以及两个按钮。这里出现了一组之前没见过的AngularJS内置指令，<code>ng-switch</code>、<code>ng-switch-when</code>、<code>ng-switch-default</code>，这三个指令一般组合使用，作用类似<code>if else</code>语句，通过这组指令和<code>deitMode</code>变量就可以达到动态变换DOM元素的功能。</p>
<p>最后来看看简单的<code>index.html</code>文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Demo for Directive<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"../angular-1.5.8.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"modules.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">body</span> <span class="attribute">ng-app</span>=<span class="value">"mainModule"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">person-list</span>&gt;</span><span class="tag">&lt;/<span class="title">person-list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的这个示例中可以看出在<code>editableField</code>和<code>personDetail</code>组建中都没有真正意义上去修改数据源，而是通过函数绑定一路将修改数据源的行为传递到了定义数据源的组建<code>personList</code>中，由它最后真正完成对数据源的修改，这也遵循了组建不允许修改属于自己隔离域以外的任何数据和DOM元素的原则。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>这篇文章是对AngularJS 1.x的入门学习小记，对一些基本概念的介绍，如果想要深入了解AngularJS可以去读官方的<a href="https://docs.angularjs.org/guide" target="_blank" rel="external">文档</a>和<a href="https://docs.angularjs.org/api" target="_blank" rel="external">API</a>。此刻AngularJS 2.0已正式发布，掌握AngularJS 1.x的基本知识能更快的帮助我们迈入AngularJS 2.0的怀抱，让我们不忘AngularJS 1.x初心，去拥抱AngularJS 2.0的美好未来。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/shadowsocks-guide/" itemprop="url">
                  使用ShadowSocks科学上网及突破公司内网
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-08-19T00:00:00+08:00" content="2016-08-19">
              2016-08-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/shadowsocks-guide/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/shadowsocks-guide/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h1 id="u4EC0_u4E48_u662FShadowSocks"><a href="#u4EC0_u4E48_u662FShadowSocks" class="headerlink" title="什么是ShadowSocks"></a>什么是ShadowSocks</h1><p>ShadowSocks是基于Socks5协议，使用类似SSH隧道的方式收发网络请求的一款开源软件，该软件由<a href="https://twitter.com/clowwindy" title="clowwindy" target="_blank" rel="external"> @clowwindy </a>开发，最初只有Python版本，随后出现C++、C#、Go等多语言版本。ShadowSocks最大的特点是可以保护网络流量、加密数据传输，可有效防止GFW（Great Firewall of China）封杀网络请求。</p>
<h1 id="u7528ShadowSocks_u79D1_u5B66_u4E0A_u7F51_u7684_u6982_u5FF5"><a href="#u7528ShadowSocks_u79D1_u5B66_u4E0A_u7F51_u7684_u6982_u5FF5" class="headerlink" title="用ShadowSocks科学上网的概念"></a>用ShadowSocks科学上网的概念</h1><p>在以前，我们访问互联网的资源都是简单而直接的，用户的请求发送到资源服务方，比如Google、Facebook等，然后资源服务方直接将内容响应给用户，世界多么美好。</p>
<p> <img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-9.png" alt=""></p>
<p>但是，在1998年时候，中国创建了互联网边界审查系统，称之为中国国家防火墙（GFW），这堵墙横在了用户和互联网资源服务方之间，用于监控和过滤互联网国际出口上的内容，监控国际网关的通讯，对认为不匹配国家官方要求的传输内容，进行干扰、阻断、屏蔽。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shaodwsocksss-10.png" alt=""></p>
<p>从此之后好多有价值的网站就被堵在了墙后。</p>
<p>但是由于对知识的渴望，人们想到了绕过GFW的办法，那就是在境外搭建一个国内用户的代理，国内用户与代理之间建立加密的通道，由境外代理请求被墙的网络资源，再通过加密通道返回给国内用户。代理的类型也有多种，像HTTP、Socks、VPN、SSH等。以SSH隧道为例：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-11.png" alt=""></p>
<p>因为SSH本身基于RSA加密技术，所以GFW就无法对数据传输过程加密的数据进行分析，从而避免被重置链接、阻断、屏蔽等问题。</p>
<p>但是GFW也不会懵B一世，人家也会学习，由于在创建SSH隧道的过程中有较为明显的特性，所以GFW还是可以通过分析连接的特性进行干扰。此时ShadowSocks横空出世，先看看图示：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-12.png" alt=""></p>
<p>简单来说，ShadowSocks分为客户端和服务端，用户发出的请求基于Socks5协议与ShadowSocks客户端进行通信，一般情况下SS客户端都在本机，通过ShadowSocksX、GoAgentX等应用启动，所以这一步是不会经过GFW的，然后ShadowSocks提供了多种加密方式供客户端和服务端之间进行通信，并且在经过GFW时是普通的TCP协议数据包，没有明显的特征，而且GFW也无法解密分析，从而实现绕墙访问资源。</p>
<h1 id="u642D_u5EFAShadowSocks_u670D_u52A1_u5668"><a href="#u642D_u5EFAShadowSocks_u670D_u52A1_u5668" class="headerlink" title="搭建ShadowSocks服务器"></a>搭建ShadowSocks服务器</h1><p>根据上文描述的ShadowSocks的实现原理，我们首先需要搭建一个境外的ShadowSocks服务器，这部分也是唯一需要我们花点小钱的地方。</p>
<blockquote>
<p>以下文章内容均在MacOS下实践。</p>
</blockquote>
<h2 id="u8D2D_u4E70VPS"><a href="#u8D2D_u4E70VPS" class="headerlink" title="购买VPS"></a>购买VPS</h2><p>我使用的是<a href="http://www.vultr.com" target="_blank" rel="external">Vultr</a>的VPS，他家的VPS可选的地域较为丰富，而且有日本东京，这对于家里是联通网络的比较亲和，速度较好：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-1.png" alt="" title="Server Location"><br>在系统和应用方面Vultr提供的种类也比较丰富：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-2.png" alt="" title="Server Type"><br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-3.png" alt="" title="Application"><br>在价格方面，Vultr提供的最低价格为每月5美元，对应的性能足够满足ShadowSocks服务端的需求：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-4.png" alt="" title="Server Price"><br>注册Vultr账号，绑定信用卡，选择自己中意的系统和价格后立即就会为你部署好VPS：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-5.png" alt=""><br>当VPS的状态为Running后，就表示VPS已经启动了，然后为该VPS配置我们的SSH公钥：<br> <img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-6.png" alt=""><br>大家可以看看北京联通ping东京VPS的速度，还是很给力的：<br> <img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-7.png" alt=""></p>
<blockquote>
<p>使用该<a href="http://www.vultr.com/?ref=6955175-3B" target="_blank" rel="external">链接</a>注册可获得20美元的优惠卷。</p>
</blockquote>
<h2 id="u5B89_u88C5ShadowSocks"><a href="#u5B89_u88C5ShadowSocks" class="headerlink" title="安装ShadowSocks"></a>安装ShadowSocks</h2><p>我们使用Python版的ShadowSocks进行安装，首先需要下载<a href="https://pypi.python.org/pypi/pip#downloads" target="_blank" rel="external">pip-8.1.2.tar.gz</a>，然后使用工具将其上传至VPS，我使用的是Commander One，通过SFTP连接VPS：<br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-8.png" alt=""><br>使用Terminal连接VPS，一步一步输入以下命令解压安装pip：</p>
<pre><code>tar -xzvf pip-8.1.2.tar.gz
cd pip-8.1.2
python setup.py install
</code></pre><p>然后通过pip安装ShadowSocks：</p>
<pre><code>pip install shadowsocks
</code></pre><p>成功后可以看到如下信息：</p>
<pre><code>Collecting shadowsocks
  Downloading shadowsocks-2.8.2.tar.gz
Installing collected packages: shadowsocks
  Running setup.py install for shadowsocks ... done
Successfully installed shadowsocks-2.8.2
</code></pre><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h2 id="u914D_u7F6EShadowSocks"><a href="#u914D_u7F6EShadowSocks" class="headerlink" title="配置ShadowSocks"></a>配置ShadowSocks</h2><p>进入到etc目录下，创建shadowsocks.json文件，并添加如下内容：</p>
<pre><code>{
    &quot;server&quot;:&quot;你的VPS的IP&quot;,
    &quot;server_port&quot;:8388,
    &quot;local_port&quot;:1080,
    &quot;password&quot;:&quot;设置一个连接密码&quot;,
    &quot;timeout&quot;:600,
    &quot;method&quot;:&quot;aes-256-cfb&quot;,
    &quot;auth&quot;: true
}
</code></pre><p>该文件就是ShadowSocks的配置文件。<br>然后输入如下命令启动ShadowSocks服务：</p>
<pre><code>ssserver -c /etc/shadowsocks.json -d start
</code></pre><p>最后清空防火墙规则：</p>
<pre><code>iptables -F
</code></pre><p>至此ShadowSocks服务端就配置完成并可以使用了。</p>
<h1 id="ShadowSocks_u5BA2_u6237_u7AEF"><a href="#ShadowSocks_u5BA2_u6237_u7AEF" class="headerlink" title="ShadowSocks客户端"></a>ShadowSocks客户端</h1><p>Mac上ShadowSocks客户端的选择无非就是ShadowSocksX、GoAgentX、Surge这三个，前两者配置起来都大同小异，ShadowSocksX本身就是专门开启SS客户端服务的应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-14.png" alt=""></p>
<p>GoAgentX提供的服务类型更多，包括SS服务：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-13.png" alt=""></p>
<p>配置项都是一样的，把ShadowSocks服务端的配置信息一一对应就可以了。</p>
<p>Surge启SS服务的方式有点不同，因为应用在界面操作上没有提供创建SS服务的选项，但其实它是支持SS服务的，可能因为怕被请喝茶吧。所以需要在Surge的配置文件里添加SS服务相关的信息，如何配置网上有很多，这里就不再累赘了。</p>
<p>至此就打通了ShadowSocks客户端与服务端的通道，可以畅游墙外的世界了。</p>
<h1 id="u7A81_u7834_u516C_u53F8_u5185_u7F51"><a href="#u7A81_u7834_u516C_u53F8_u5185_u7F51" class="headerlink" title="突破公司内网"></a>突破公司内网</h1><p>一般情况在家我们在本机启着ShadowSocks客户端就可以了，但是如果在公司上外网需要走HTTP代理的话就不行了，因为ShadowSocks客户端需要走公司提供的代理才能连接到服务端，而上文中的客户端应用统统不支持额外代理功能，所以此时就需要用到另外一个工具<a href="https://www.proxifier.com" target="_blank" rel="external">Proxifier</a>，该工具的作用就是接管运行中的所有应用发出的所有请求，然后通过代理进行转发，这样就可以让不支持代理的应用也可以走代理了。</p>
<p>打开Proxifier，选择Proxies选项卡设置公司的HTTP代理以及本地Socks5代理：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-15.png" alt=""><br><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-16.png" alt=""></p>
<p>然后启动ShadowSocks客户端，比如启动GoAgentX，此时选择Proxifier的Rules选项卡，就会发现Proxifier自动捕获到了名为ss-local的应用，就是由GoAgentX开启的SS客户端，将其的代理规则设置为之前创建好的公司代理：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-17.png" alt=""></p>
<p>然后将Default的代理规则设置为之前创建好的本地Socks5代理：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-18.png" alt=""></p>
<p>这样就可以让ShadowSocks客户端通过公司代理连接服务端了：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/shadowsocksss-19.png" alt=""></p>
<p>你还可以设置其他的规则，让特定的应用走特定的代理，比如我让Git还是走了公司代理，这样Git服务就会从Default规则里剔除掉，相当于加了走SS服务的例外。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p><link rel="stylesheet" href="http://7xpp8a.com1.z0.glb.clouddn.com/tomorrow.css"></p>
<script src="http://7xpp8a.com1.z0.glb.clouddn.com/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/read-concurrency-programming-guide-3/" itemprop="url">
                  读 Concurrency Programming Guide 笔记（三）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-04-21T00:00:00+08:00" content="2016-04-21">
              2016-04-21
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/read-concurrency-programming-guide-3/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/read-concurrency-programming-guide-3/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/69122" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="u901A_u8FC7Dispatch_Queue_u6267_u884C_u4EFB_u52A1"><a href="#u901A_u8FC7Dispatch_Queue_u6267_u884C_u4EFB_u52A1" class="headerlink" title="通过Dispatch Queue执行任务"></a>通过Dispatch Queue执行任务</h2><p>如果想让Dispatch Queue执行任务，首先就是得将任务放入队列中，我们可以异步的将任务加入队列，也可以同步的将任务加入队列，可以一个任务一个任务的加，也可以一组一组的加。这节我们就来看看将任务加入队列的那些事。</p>
<h3 id="u5411_u961F_u5217_u6DFB_u52A0_u4EFB_u52A1"><a href="#u5411_u961F_u5217_u6DFB_u52A0_u4EFB_u52A1" class="headerlink" title="向队列添加任务"></a>向队列添加任务</h3><p>我们可以使用<code>dispatch_async</code>或者<code>dispatch_async_f</code>函数异步的向队列中添加任务，也就是说当我们添加完任务后该函数会立即返回，我们不需要等待任务执行完成，而且我们也不会知道队列到底何时开始执行任务。<code>dispatch_async</code>函数有两个参数，一个是目标队列，类型为<code>dispatch_queue_t</code>，另一个是闭包，类型为<code>dispatch_block_t</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_async(serialQueue, &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task in the queue..."</span>)</span><br><span class="line">        </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>dispatch_async_f</code>函数有三个参数，第一个是类型为<code>dispatch_queue_t</code>的目标队列，第二个是队列上下文指针，第三个是类型为<code>dispatch_function_t</code>的任务函数，队列上下文指针为该函数的唯一参数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTaskToQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in the queue..."</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async_f(serialQueue, <span class="built_in">unsafeBitCast</span>(<span class="number">0</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>), taskFunction())</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">taskFunction</span><span class="params">()</span></span> -&gt; dispatch_function_t &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123; context <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Do some work with context..."</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addTaskToQueue = <span class="type">AddTaskToQueue</span>()</span><br><span class="line">addTaskToQueue.launch()</span><br></pre></td></tr></table></figure>
<p>除了这两个函数，我们还可以使用<code>dispatch_sync</code>和<code>dispatch_sync_f</code>函数同步的向队列中添加任务，并且我们要等待直到任务执行完成。这两个函数和上面的异步添加任务函数用法完全一致。</p>
<p>那么什么时候用异步什么时候用同步呢，大多数情况下我们都是在主线程中使用GCD分派任务，为了避免阻塞主线程，影响用户体验，所以通常情况下我们都使用异步添加任务的方式。当然为了避免任务与主线程中产生资源竞争的问题，有时候酌情也会使用同步添加任务的方式。</p>
<h3 id="Dispatch_Queue_u7684Completion_Block"><a href="#Dispatch_Queue_u7684Completion_Block" class="headerlink" title="Dispatch Queue的Completion Block"></a>Dispatch Queue的Completion Block</h3><p>还记得<code>NSOperation</code>的<code>completionBlock</code>属性吗，这个回调函数在任务执行完成后调用，用于处理有些后续工作或者消息通知。在Dispatch Queue中并没有类似的属性，但是我们可以通过其他方式来实现。举一个很常见的应用场景，我们在主线程中分派一个下载图片的任务，让其在二级线程中执行，当图片下载完成后通知主线程，并由主线程将图片显示出来，我们看看简单的代码片段：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadImage</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">dispatchTaskInMainThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), downloadImage())</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">downloadImage</span><span class="params">()</span></span> -&gt; (() -&gt; ()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Downloading image in <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">            dispatch_async(dispatch_get_main_queue()) &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Handle image and display in <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看上面代码都做了些什么，首先在<code>dispatchTaskInMainThread</code>方法中，我们使用<code>dispatch_get_global_queue</code>函数获取到全局并发队列，然后将<code>downloadImage</code>下载图片的方法作为任务添加到该全局队列中。在<code>downloadImage</code>方法里，当图片下载完成后通过<code>dispatch_get_main_queue</code>函数获取到主队列，也就是在主线程中对图片进行处理，这样我们就达到了Completion Block的效果。</p>
<h3 id="u5728_u961F_u5217_u4E2D_u5FAA_u73AF_u6267_u884C_u4EFB_u52A1"><a href="#u5728_u961F_u5217_u4E2D_u5FAA_u73AF_u6267_u884C_u4EFB_u52A1" class="headerlink" title="在队列中循环执行任务"></a>在队列中循环执行任务</h3><p>在我们的日常开发中，经常会使用到for循环来处理一些任务，而且这些任务之间也并没有先后顺序的关联，每个任务相对比较独立。遇到这种情况，我们可以用<code>dispatch_apply</code>或<code>dispatch_apply_f</code>函数让任务在队列中循环执行，并且可以是并发执行，这样相比for循环的串行执行要更加效率：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">"Swift"</span>, <span class="string">"Objective-C"</span>, <span class="string">"Java"</span>, <span class="string">"Delphi"</span>, <span class="string">"C++"</span>]</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> arr &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Handle element. the element is <span class="subst">\(element)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dispatch_apply</span></span><br><span class="line">dispatch_apply(arr.<span class="built_in">count</span>, dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>))&#123; index <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Handle element. the element is <span class="subst">\(arr[index])</span>. Current thread is <span class="subst">\(NSThread.currentThread()</span>)"</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面示例代码片段中可以看到，<code>dispatch_apply</code>函数有三个参数，第一个参数是循环次数，第二个参数是目标队列，第三个则是要执行的闭包任务，循环次数是该闭包的唯一参数。</p>
<h3 id="u6682_u505C_u548C_u91CD_u542F_u961F_u5217"><a href="#u6682_u505C_u548C_u91CD_u542F_u961F_u5217" class="headerlink" title="暂停和重启队列"></a>暂停和重启队列</h3><p>在Dispatch Queue执行任务时，如果我们想暂停队列，可以使用<code>dispatch_suspend</code>函数，重新让队列执行任务可以使用<code>dispatch_resume</code>。这里要注意的是暂停队列只是让队列暂时停止执行下一个任务，而不是中断当前正在执行的任务。</p>
<h3 id="Dispatch_Group_u7684_u4F7F_u7528"><a href="#Dispatch_Group_u7684_u4F7F_u7528" class="headerlink" title="Dispatch Group的使用"></a>Dispatch Group的使用</h3><p>在实际开发中，为了提升性能我们或许会经常使用<code>dispatch_async</code>异步的将任务添加进队列去执行，但有些时候需要之前队列中的多个任务都执行完成之后，才能获取到正确的或者说想要的结果供后续逻辑代码使用，遇到这种情况，就可以使用Dispatch Group，将多个任务在队列中归为一个组，并可以使用<code>dispatch_group_wait</code>函数让之后的逻辑代码等待，直到该组的任务都执行完成后再执行。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> concurrentQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_async(concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task1 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_async(concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task2 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_async(concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task3 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"I expect the count is 3, and the factual count is <span class="subst">\(<span class="built_in">count</span>)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码片段就是我刚才描述的场景，因为使用的是并发队列，也不好在每个任务里进行回调处理，所以我们永远不会得到正确的<code>count</code>。如果我们使用Dispatch Group事情就简单多了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> concurrentQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dispatchGroup = dispatch_group_create()</span><br><span class="line">        </span><br><span class="line">dispatch_group_async(dispatchGroup, concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task1 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_group_async(dispatchGroup, concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task2 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_group_async(dispatchGroup, concurrentQueue) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Task3 in dispatchGroup..."</span>)</span><br><span class="line">            </span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">dispatch_group_wait(dispatchGroup, <span class="type">DISPATCH_TIME_FOREVER</span>)</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"I expect the count is 3, and the factual count is <span class="subst">\(<span class="built_in">count</span>)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码中，先使用<code>dispatch_group_create</code>函数创建Dispatch Group，然后使用<code>dispatch_group_async</code>函数将任务分进组里，然后再添加进队列中。该函数有三个参数，分别是Dispatch Group、Dispatch Queue和要执行任务的闭包。当添加完任务后使用<code>dispatch_group_wait</code>函数等待，直到指定组的任务全部完成，才会继续执行后面的打印语句，该函数有两个参数，第一个是目标组，第二个是等待时间<code>DISPATCH_TIME_NOW</code>或<code>DISPATCH_TIME_FOREVER</code>。</p>
<h2 id="Dispatch_Source"><a href="#Dispatch_Source" class="headerlink" title="Dispatch Source"></a>Dispatch Source</h2><p>前面的文章中介绍过Dispatch Source：</p>
<blockquote>
<p>Dispatch Source是GCD中的一个基本类型，从字面意思可称为调度源，它的作用是当有一些特定的较底层的系统事件发生时，调度源会捕捉到这些事件，然后可以做其他的逻辑处理，调度源有多种类型，分别监听对应类型的系统事件。我们来看看它都有哪些类型：</p>
<ul>
<li>Timer Dispatch Source：定时调度源。</li>
<li>Signal Dispatch Source：监听UNIX信号调度源，比如监听代表挂起指令的SIGSTOP信号。</li>
<li>Descriptor Dispatch Source：监听文件相关操作和Socket相关操作的调度源。</li>
<li>Process Dispatch Source：监听进程相关状态的调度源。</li>
<li>Mach port Dispatch Source：监听Mach相关事件的调度源。</li>
<li>Custom Dispatch Source：监听自定义事件的调度源。</li>
</ul>
</blockquote>
<p>这一节就来看看如何使用Dispatch Source。</p>
<p>用通俗一点的话说就是用GCD的函数指定一个希望监听的系统事件类型，再指定一个捕获到事件后进行逻辑处理的闭包或者函数作为回调函数，然后再指定一个该回调函数执行的Dispatch Queue即可，当监听到指定的系统事件发生时会调用回调函数，将该回调函数作为一个任务放入指定的队列中执行。也就是说当监听到系统事件后就会触发一个任务，并自动将其加入队列执行，这里与之前手动添加任务的模式不同，一旦将Diaptach Source与Dispatch Queue关联后，只要监听到系统事件，Dispatch Source就会自动将任务（回调函数）添加到关联的队列中。</p>
<p>有些时候回调函数执行的时间较长，在这段时间内Dispatch Source又监听到多个系统事件，理论上就会形成事件积压，但好在Dispatch Source有很好的机制解决这个问题，当有多个事件积压时会根据事件类型，将它们进行关联和结合，形成一个新的事件。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u76D1_u542C_u4E8B_u4EF6_u7C7B_u578B"><a href="#u76D1_u542C_u4E8B_u4EF6_u7C7B_u578B" class="headerlink" title="监听事件类型"></a>监听事件类型</h3><p>Dispatch Source一共可以监听六类事件，分为11个类型，我们来看看都是什么：</p>
<ul>
<li><code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>：属于自定义事件，可以通过<code>dispatch_source_get_data</code>函数获取事件变量数据，在我们自定义的方法中可以调用<code>dispatch_source_merge_data</code>函数向Dispatch Source设置数据，下文中会有详细的演示。</li>
<li><code>DISPATCH_SOURCE_TYPE_DATA_OR</code>：属于自定义事件，用法同上面的类型一样。</li>
<li><code>DISPATCH_SOURCE_TYPE_MACH_SEND</code>：Mach端口发送事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_MACH_RECV</code>：Mach端口接收事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_PROC</code>：与进程相关的事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_READ</code>：读文件事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_WRITE</code>：写文件事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_VNODE</code>：文件属性更改事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_SIGNAL</code>：接收信号事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_TIMER</code>：定时器事件。</li>
<li><code>DISPATCH_SOURCE_TYPE_MEMORYPRESSURE</code>：内存压力事件。</li>
</ul>
<h3 id="u521B_u5EFADispatch_Source"><a href="#u521B_u5EFADispatch_Source" class="headerlink" title="创建Dispatch Source"></a>创建Dispatch Source</h3><p>我们可以使用<code>dispatch_source_create</code>函数创建Dispatch Source，该函数有四个参数：</p>
<ul>
<li><code>type</code>：第一个参数用于标识Dispatch Source要监听的事件类型，共有11个类型。</li>
<li><code>handle</code>：第二个参数是取决于要监听的事件类型，比如如果是监听Mach端口相关的事件，那么该参数就是<code>mach_port_t</code>类型的Mach端口号，如果是监听事件变量数据类型的事件那么该参数就不需要，设置为0就可以了。</li>
<li><code>mask</code>：第三个参数同样取决于要监听的事件类型，比如如果是监听文件属性更改的事件，那么该参数就标识文件的哪个属性，比如<code>DISPATCH_VNODE_RENAME</code>。</li>
<li><code>queue</code>：第四个参数设置回调函数所在的队列。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatchQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dispatchSource = dispatch_source_create(<span class="type">DISPATCH_SOURCE_TYPE_DATA_ADD</span>, <span class="number">0</span>, <span class="number">0</span>, dispatchQueue)</span><br></pre></td></tr></table></figure>
<p>上面的代码就是创建Dispatch Source的简单示例。</p>
<h3 id="u8BBE_u7F6E_u4E8B_u4EF6_u5904_u7406_u5668"><a href="#u8BBE_u7F6E_u4E8B_u4EF6_u5904_u7406_u5668" class="headerlink" title="设置事件处理器"></a>设置事件处理器</h3><p>前文中提到过，当Dispatch Source监听到事件时会调用指定的回调函数或闭包，该回调函数或闭包就是Dispatch Source的事件处理器。我们可以使用<code>dispatch_source_set_event_handler</code>或<code>dispatch_source_set_event_handler_f</code>函数给创建好的Dispatch Source设置处理器，前者是设置闭包形式的处理器，后者是设置函数形式的处理器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dispatch_source_set_event_handler(dispatchSource, &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Dispatch Source 事件处理器..."</span>)</span><br><span class="line">        </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据闭包尾随的特性，还可以有下面的写法</span></span><br><span class="line"></span><br><span class="line">dispatch_source_set_event_handler(dispatchSource) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Dispatch Source 事件处理器..."</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面示例代码中可以看到，该函数有两个参数，第一个是设置目标Dispatch Source，第二个参数就是设置处理器了。</p>
<p>既然是事件处理器，那么肯定需要获取一些Dispatch Source的信息，GCD提供了三个在处理器中获取Dispatch Source相关信息的函数，比如<code>handle</code>、<code>mask</code>。而且针对不同类型的Dispatch Source，这三个函数返回数据的值和类型都会不一样，下面来看看这三个函数：</p>
<ul>
<li><code>dispatch_source_get_handle</code>：这个函数用于获取在创建Dispatch Source时设置的第二个参数<code>handle</code>。<ul>
<li>如果是读写文件的Dispatch Source，返回的就是描述符。</li>
<li>如果是信号类型的Dispatch Source，返回的是<code>int</code>类型的信号数。</li>
<li>如果是进程类型的Dispatch Source，返回的是<code>pid_t</code>类型的进程id。</li>
<li>如果是Mach端口类型的Dispatch Source，返回的是<code>mach_port_t</code>类型的Mach端口。</li>
</ul>
</li>
<li><code>dispatch_source_get_data</code>：该函数用于获取Dispatch Source监听到事件的相关数据。<ul>
<li>如果是读文件类型的Dispatch Source，返回的是读到文件内容的字节数。</li>
<li>如果是写文件类型的Dispatch Source，返回的是文件是否可写的标识符，正数表示可写，负数表示不可写。</li>
<li>如果是监听文件属性更改类型的Dispatch Source，返回的是监听到的有更改的文件属性，用常量表示，比如<code>DISPATCH_VNODE_RENAME</code>等。</li>
<li>如果是进程类型的Dispatch Source，返回监听到的进程状态，用常量表示，比如<code>DISPATCH_PROC_EXIT</code>等。</li>
<li>如果是Mach端口类型的Dispatch Source，返回Mach端口的状态，用常量表示，比如<code>DISPATCH_MACH_SEND_DEAD</code>等。</li>
<li>如果是自定义事件类型的Dispatch Source，返回使用<code>dispatch_source_merge_data</code>函数设置的数据。</li>
</ul>
</li>
<li><code>dispatch_source_get_mask</code>：该函数用于获取在创建Dispatch Source时设置的第三个参数<code>mask</code>。在进程类型，文件属性更改类型，Mach端口类型的Dispatch Source下该函数返回的结果与<code>dispatch_source_get_data</code>一样。</li>
</ul>
<h3 id="u6CE8_u518CCancellation_Handler"><a href="#u6CE8_u518CCancellation_Handler" class="headerlink" title="注册Cancellation Handler"></a>注册Cancellation Handler</h3><p>Cancellation Handler就是当Dispatch Source被释放时用来处理一些后续事情，比如关闭文件描述符或者释放Mach端口等。我们可以使用<code>dispatch_source_set_cancel_handler</code>函数或者<code>dispatch_source_set_cancel_handler_f</code>函数给Dispatch Source注册Cancellation Handler：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">dispatch_source_set_cancel_handler(dispatchSource) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"进行善后处理..."</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数有两个参数，第一个参数是目标Dispatch Source，第二个参数就是要进行善后处理的闭包或者函数。</p>
<h3 id="u66F4_u6539Dispatch_Source_u7684_u76EE_u6807_u961F_u5217"><a href="#u66F4_u6539Dispatch_Source_u7684_u76EE_u6807_u961F_u5217" class="headerlink" title="更改Dispatch Source的目标队列"></a>更改Dispatch Source的目标队列</h3><p>在上文中，我们说过可以使用<code>dispatch_source_create</code>函数创建Dispatch Source，并且在创建时会指定回调函数执行的队列，那么如果事后想更改队列，比如说想更改队列的优先级，这时我们可以使用<code>dispatch_set_target_queue</code>函数实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatchQueueDefaultPriority = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dispatchSource = dispatch_source_create(<span class="type">DISPATCH_SOURCE_TYPE_DATA_ADD</span>, <span class="number">0</span>, <span class="number">0</span>, dispatchQueueDefaultPriority)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> dispatchQueueLowPriority = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_LOW</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">dispatch_set_target_queue(dispatchSource, dispatchQueueLowPriority)</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是，如果在更改目标队列时，Dispatch Source已经监听到相关事件，并且回调函数已经在之前的队列中执行了，那么会一直在旧的队列中执行完成，不会转移到新的队列中去。</p>
<h3 id="u6682_u505C_u6062_u590DDispatch_Source"><a href="#u6682_u505C_u6062_u590DDispatch_Source" class="headerlink" title="暂停恢复Dispatch Source"></a>暂停恢复Dispatch Source</h3><p>暂停和恢复Dispatch Source与Dispatch Queue一样，都适用<code>dispatch_suspend</code>和<code>dispatch_resume</code>函数。这里需要注意的是刚创建好的Dispatch Source是处于暂停状态的，所以使用时需要用<code>dispatch_resume</code>函数将其启动。</p>
<h3 id="u5E9F_u9664Dispatch_Source"><a href="#u5E9F_u9664Dispatch_Source" class="headerlink" title="废除Dispatch Source"></a>废除Dispatch Source</h3><p>如果我们不再需要使用某个Dispatch Source时，可以使用<code>dispatch_source_cancel</code>函数废除，该函数只有一个参数，那就是目标Dispatch Source。</p>
<h3 id="Dispatch_Source_u5B9E_u8DF5"><a href="#Dispatch_Source_u5B9E_u8DF5" class="headerlink" title="Dispatch Source实践"></a>Dispatch Source实践</h3><p>说了这么多，这一节来看看Dispatch Source到底怎么用。</p>
<h4 id="u7528Dispatch_Source_u76D1_u542C_u5B9A_u65F6_u5668"><a href="#u7528Dispatch_Source_u76D1_u542C_u5B9A_u65F6_u5668" class="headerlink" title="用Dispatch Source监听定时器"></a>用Dispatch Source监听定时器</h4><p>Dispatch Source能监听的事件中有一个类型就是定时器，我们来看看如何实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchSource</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> dispatchQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> timer = createTimerDispatchSource(dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="number">0</span>), interval: <span class="type">NSEC_PER_SEC</span> * <span class="number">5</span>, leeway: <span class="number">0</span>, queue: dispatchQueue) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"处理定时任务，该任务每5秒执行一次..."</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch_resume(timer)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">30</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">createTimerDispatchSource</span><span class="params">(startTime: dispatch_time_t, interval: UInt64, leeway: UInt64, queue: dispatch_queue_t, handler: dispatch_block_t)</span></span> -&gt; dispatch_source_t &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> timerDispatchSource = dispatch_source_create(<span class="type">DISPATCH_SOURCE_TYPE_TIMER</span>, <span class="number">0</span>, <span class="number">0</span>, queue)</span><br><span class="line">        </span><br><span class="line">        dispatch_source_set_timer(timerDispatchSource, startTime, interval, leeway)</span><br><span class="line">        </span><br><span class="line">        dispatch_source_set_event_handler(timerDispatchSource, handler)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> timerDispatchSource</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码示例中一个新的函数<code>dispatch_source_set_timer</code>，该函数的作用就是给监听事件类型为<code>DISPATCH_SOURCE_TYPE_TIMER</code>的Dispatch Source设置相关属性，该函数有四个参数：</p>
<ul>
<li><code>source</code>：该参数为目标Dispatch Source，类型为<code>dispatch_source_t</code>.</li>
<li><code>start</code>：该参数为定时器的起始时间，类型为<code>dispatch_time_t</code>。</li>
<li><code>interval</code>：该参数为定时器的间隔时间，类型为<code>UInt64</code>，间隔时间的单位是纳秒。</li>
<li><code>leeway</code>：该参数为间隔时间的精度，类型为<code>UInt64</code>，时间单位也是纳秒。</li>
</ul>
<h4 id="u7528Dispatch_Source_u76D1_u542C_u81EA_u5B9A_u4E49_u4E8B_u4EF6"><a href="#u7528Dispatch_Source_u76D1_u542C_u81EA_u5B9A_u4E49_u4E8B_u4EF6" class="headerlink" title="用Dispatch Source监听自定义事件"></a>用Dispatch Source监听自定义事件</h4><p>Dispatch Source能监听的事件中有一个类型是自定义事件，下面我们来看看如何使用:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchSource</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> totalProcess = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> dispatchSource = dispatch_source_create(<span class="type">DISPATCH_SOURCE_TYPE_DATA_ADD</span>, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue())</span><br><span class="line">        </span><br><span class="line">        dispatch_source_set_event_handler(dispatchSource) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> process = dispatch_source_get_data(dispatchSource)</span><br><span class="line">            </span><br><span class="line">            totalProcess += <span class="type">Int</span>(process)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"这里可以在主线程更新UI，显示进度条...进度为<span class="subst">\(totalProcess)</span>%"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dispatch_resume(dispatchSource)</span><br><span class="line">        </span><br><span class="line">        generateCustomEvent(dispatchSource)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">generateCustomEvent</span><span class="params">(dispatchSource: dispatch_source_t)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> queue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>...<span class="number">100</span> &#123;</span><br><span class="line">            </span><br><span class="line">            dispatch_sync(queue) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"模拟自定义事件...进度为<span class="subst">\(index)</span>%"</span>)</span><br><span class="line">                </span><br><span class="line">                dispatch_source_merge_data(dispatchSource, <span class="number">1</span>)</span><br><span class="line">                </span><br><span class="line">                sleep(<span class="number">2</span>)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看<code>generateCustomEvent(dispatchSource: dispatch_source_t)</code>方法，该方法的作用的是模拟自定义事件，首先创建一个全局并发队列，然后循环让其执行任务，在执行的任务里调用<code>dispatch_source_merge_data</code>函数，就可以触发监听类型为<code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>或者<code>DISPATCH_SOURCE_TYPE_DATA_OR</code>的Dispatch Source。该函数有两个参数，第一个参数是目标Dispatch Source，第二个参数的类型是无符号长整型，用于向目标Dispatch Source中的对应变量追加指定的数。</p>
<p>我们再来看看如何监听自定义时间，首先创建类型为<code>DISPATCH_SOURCE_TYPE_DATA_ADD</code>的Dispatch Source，然后设置回调闭包，在闭包中使用<code>dispatch_source_get_data</code>获取追加的变量值，该函数只有一个参数，就是目标Dispatch Source，这里需要注意的是通过<code>dispatch_source_get_data</code>函数获取的变量值并不是累加值，而是每次调用<code>dispatch_source_merge_data</code>函数时设置的值，所以在上面的示例中用<code>totalProcess</code>变量累加每次获取到的值。</p>
<p>上面的示例可以用来模拟后台进行下载，根据下载的数据量使用<code>dispatch_source_merge_data</code>函数给目标Dispatch Source设置相应的变量值，然后在主线程中监听到Dispatch Source的自定义事件，通过<code>dispatch_source_get_data</code>函数获取到变量，用于更新显示进度条的UI。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/read-concurrency-programming-guide-2/" itemprop="url">
                  读 Concurrency Programming Guide 笔记（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-03-23T00:00:00+08:00" content="2016-03-23">
              2016-03-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/read-concurrency-programming-guide-2/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/read-concurrency-programming-guide-2/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/63001" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<h2 id="Operation_u5BF9_u8C61_u7684_u76F8_u5173_u8BBE_u7F6E"><a href="#Operation_u5BF9_u8C61_u7684_u76F8_u5173_u8BBE_u7F6E" class="headerlink" title="Operation对象的相关设置"></a>Operation对象的相关设置</h2><p>Operation对象除了上文中讲到到基本使用方法外还有一些其他的特性，这些特性需要根据我们的应用场景去设置，设置的时机在创建Operation对象之后和运行它或者将其放入操作队列之前，下面让我们来看看Operation对象还有哪些特性。</p>
<h3 id="Operation_u5BF9_u8C61_u4E4B_u95F4_u7684_u4F9D_u8D56"><a href="#Operation_u5BF9_u8C61_u4E4B_u95F4_u7684_u4F9D_u8D56" class="headerlink" title="Operation对象之间的依赖"></a>Operation对象之间的依赖</h3><p>与GCD不同，Operation Queue不遵循先进先出的原则，而且Operation Queue始终是并发执行Operation对象的，所以想让Operation对象串行执行就需要用它的Operation对象依赖特性，该特性可以让Operation对象将自己与另外一个Operation对象进行关联，并且当关联的Operation对象执行完成后才可以执行，这样就达到了串行执行Operation对象的目的。</p>
<p>我们可以用<code>NSOperation</code>的<code>addDependency</code>方法添加依赖的Operation对象，而且产生依赖的这两个Operation对象并不要求必须在相同的操作队列中，但是这种依赖只能是单向的，不能相互依赖。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestOperationDependency</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> blockOperationA = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in blockOperationA..."</span>)</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> blockOperationB = <span class="type">NSBlockOperation</span>(block: &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Task in blockOperationB..."</span>)</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        blockOperationA.addDependency(blockOperationB)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> operationQueue = <span class="type">NSOperationQueue</span>()</span><br><span class="line">        </span><br><span class="line">        operationQueue.addOperation(blockOperationA)</span><br><span class="line">        </span><br><span class="line">        operationQueue.addOperation(blockOperationB)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testOperationDependency = <span class="type">TestOperationDependency</span>()</span><br><span class="line"></span><br><span class="line">testOperationDependency.launch()</span><br></pre></td></tr></table></figure>
<p>上面的示例代码展示了如何给Operation对象添加依赖，大家可以注释掉<code>blockOperationA.addDependency(blockOperationB)</code>这一行看看打印结果有什么区别。</p>
<h3 id="Operation_u5BF9_u8C61_u7684_u4F18_u5148_u7EA7"><a href="#Operation_u5BF9_u8C61_u7684_u4F18_u5148_u7EA7" class="headerlink" title="Operation对象的优先级"></a>Operation对象的优先级</h3><p>上文中说了，操作队列里的Operation对象都是并发执行的，如果一个操作队列中有多个Operation对象，那么谁先执行谁后执行取决于Operation对象的依赖Operation对象是否已执行完成，也就是是否处于准备执行的状态。其实Operation对象自身也有优先级的属性，如果有两个都处于准备执行状态的Operation对象，那么优先级高的会先执行，优先级低的后执行。每个Operation对象默认的优先级是<code>NSOperationQueuePriority.Normal</code>级别，我们可以通过设置<code>queuePriority</code>属性更改Operation的在队列中执行的优先级，优先级别有以下五种：</p>
<ul>
<li><code>NSOperationQueuePriority.Normal</code>：正常优先级</li>
<li><code>NSOperationQueuePriority.Low</code>：低优先级</li>
<li><code>NSOperationQueuePriority.VeryLow</code>：非常低优先级</li>
<li><code>NSOperationQueuePriority.High</code>：高优先级</li>
<li><code>NSOperationQueuePriority.VeryHigh</code>：非常高优先级</li>
</ul>
<p>这里我们需要注意一下Operation对象优先级的作用域，它只能作用于相同的操作队列中，不同操作队列中的Operation对象是不受优先级影响的。另外需要注意的是，如果有两个Operation对象，一个处于准备执行状态，但优先级比较低，另一个处于等待状态，但优先级比较高，那么此时仍然是处于准备执行状态的低优先级Operation对象先执行。可见Operation对象的优先级相互影响需要满足两个条件，一是必须处在同一个操作队列中，另一个是Operation对象都处于准备执行状态。</p>
<h3 id="u901A_u8FC7Operation_u5BF9_u8C61_u4FEE_u6539_u7EBF_u7A0B_u4F18_u5148_u7EA7"><a href="#u901A_u8FC7Operation_u5BF9_u8C61_u4FEE_u6539_u7EBF_u7A0B_u4F18_u5148_u7EA7" class="headerlink" title="通过Operation对象修改线程优先级"></a>通过Operation对象修改线程优先级</h3><p>通常情况下，线程的优先级由内核自己管理，不过在OS X v10.6及以后的版本和iOS4到iOS7期间，<code>NSOperation</code>多了一个<code>threadPriority</code>属性，我们可以通过该属性设置Operation对象运行所在线程的优先级，数值范围为0.0到1.0，数字越高优先级越高。不过可能是出于线程安全等方面的考虑，Apple从iOS8开始废除了该属性。</p>
<h3 id="u8BBE_u7F6ECompletion_Block"><a href="#u8BBE_u7F6ECompletion_Block" class="headerlink" title="设置Completion Block"></a>设置Completion Block</h3><p>上篇文章中说过，Operation对象其中的一个特别好的特性就是完成时回调闭包Completion Block。它的作用不言而喻，就是当主要任务执行完成之后做一些收尾的处理工作，我们可以设置<code>completionBlock</code>属性给Operation对象添加完成时回调闭包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">blockOperationA.completionBlock = &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"blockOperationA has finished..."</span>)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6267_u884COperation_u5BF9_u8C61"><a href="#u6267_u884COperation_u5BF9_u8C61" class="headerlink" title="执行Operation对象"></a>执行Operation对象</h2><p>虽然前面文章的示例中已经包含了对Operation对象的执行，但是并没详细说明，这节就说说Operation对象的执行。</p>
<h3 id="u4F7F_u7528Operation_Queue"><a href="#u4F7F_u7528Operation_Queue" class="headerlink" title="使用Operation Queue"></a>使用Operation Queue</h3><p>使用Operation Queue操作队列执行Operation对象已然是标配选项了，操作队列在Cocoa框架中对应的类是<code>NSOperationQueue</code>，一个操作队列中可以添加多个Operation对象，但一次到底添加多少Operation对象得根据实际情况而定，比如应用程序对内存的消耗情况、内核的空闲情况等，所以说凡事得有度，不然反而会适得其反。另外需要注意的一点是不论有多少个操作队列，它们都受制于系统的负载、内核空闲等运行情况，所以说并不是说再创建一个操作队列就能执行更多的Operation对象。</p>
<p>在使用操作队列时，我们首先要创建<code>NSOperationQueue</code>的实例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> operationQueue = <span class="type">NSOperationQueue</span>()</span><br></pre></td></tr></table></figure>
<p>然后通过<code>NSOperationQueue</code>的<code>addOperation</code>方法添加Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operationQueue.addOperation(blockOperationA)</span><br><span class="line">        </span><br><span class="line">operationQueue.addOperation(blockOperationB)</span><br></pre></td></tr></table></figure>
<p>在OS X v10.6之后和iOS4之后，我们还可以用<code>addOperations:waitUntilFinished:</code>方法添加一组Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operationQueue.addOperations([blockOperationA, blockOperationB], waitUntilFinished: <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
<p>该方法有两个参数：</p>
<ul>
<li><code>ops: [NSOperation]</code>：Operation对象数组。</li>
<li><code>waitUntilFinished wait: Bool</code>：该参数标示这个操作队列在执行Operation对象时是否会阻塞当前线程。</li>
</ul>
<p>我们还可以通过<code>addOperationWithBlock</code>方法向操作队列中直接添加闭包，而不需要去创建Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operationQueue.addOperationWithBlock(&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The block is running in Operation Queue..."</span>)</span><br><span class="line">            </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>除了以上这几种添加Operation对象的方法外，还可以通过<code>NSOperationQueue</code>的<code>maxConcurrentOperationCount</code>属性设置同时执行Operation对象的最大数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">operationQueue.maxConcurrentOperationCount = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果设置为1，那么不管该操作队列中添加了多少Operation对象，每次都只运行一个，而且会按照添加Operation对象的顺序去执行。所以如果遇到添加到操作的队列的Operation对象延迟执行了，那么通常会有两个原因：</p>
<ul>
<li>添加的Operation对象数超过了操作队列设置的同时执行Operation对象的最大数。</li>
<li>延迟执行的Operation对象在等待它依赖的Operation对象执行完成。</li>
</ul>
<p>另外需要的注意的是当Operation对象添加到操作队列中后，不要再更改它任务中涉及到的任何属性或者它的依赖，因为到操作队列中的Operation对象随时会被执行，所以如果你自以为它还没有被执行而去修改它，可能并不会达到你想要的结果。</p>
<h3 id="u624B_u52A8_u6267_u884COperation_u5BF9_u8C61"><a href="#u624B_u52A8_u6267_u884COperation_u5BF9_u8C61" class="headerlink" title="手动执行Operation对象"></a>手动执行Operation对象</h3><p>除了用操作队列来执行Operation对象以外，我们还可以手动执行某个Operation对象，但是这需要我们注意更多的细节问题，也要写更多的代码去确保Operation对象能正确执行。在上篇文章中，我们创建过自定义的Operation对象，其中我们知道有几个属性特别需要我们注意，那就是<code>ready</code>、<code>concurrent</code>、<code>executing</code>、<code>finished</code>、<code>cancelled</code>，对应Operation对象是否出于准备执行状态、是否为异步并发执行的、是否正在执行、是否已经执行完成、是否已被终止。这些状态在我们使用操作队列时都不需要理会，都有操作队列帮我们把控判断，确保Operation对象的正确执行，我们只需要在必要的时候获取状态信息查看而已。但是如果手动执行Operation对象，那么这些状态都需要我们来把控，因为你手动执行一个Operation对象时要判断它的依赖对象是否执行完成，是否被终止了等等，所以并不是简单的调用<code>start</code>方法，下面来看看如果正确的手动执行Operation对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performOperation</span><span class="params">(operation: NSOperation)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">var</span> result = <span class="literal">false</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> operation.ready &amp;&amp; !operation.cancelled &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> operation.concurrent &#123;</span><br><span class="line">                </span><br><span class="line">            operation.start()</span><br><span class="line">                </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">            <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"start"</span>, toTarget: operation, withObject: <span class="literal">nil</span>)</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        result = <span class="literal">true</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="u7EC8_u6B62Operation_u5BF9_u8C61_u6267_u884C"><a href="#u7EC8_u6B62Operation_u5BF9_u8C61_u6267_u884C" class="headerlink" title="终止Operation对象执行"></a>终止Operation对象执行</h3><p>一旦Operation对象被添加到操作队列中，这个Operation对象就属于这个操作队列了，并且不能被移除，唯一能让Operation对象失效的方法就是通过<code>NSOperation</code>的<code>cancel</code>方法终止它执行，或者也可以通过<code>NSOperationQueue</code>的<code>cancelAllOperations</code>方法终止在队列中的所有Operation对象。</p>
<h3 id="u6682_u505C_u548C_u6062_u590D_u64CD_u4F5C_u961F_u5217"><a href="#u6682_u505C_u548C_u6062_u590D_u64CD_u4F5C_u961F_u5217" class="headerlink" title="暂停和恢复操作队列"></a>暂停和恢复操作队列</h3><p>在实际运用中，如果我们希望暂停操作队列执行Operation对象，可以通过设置<code>NSOperationQueue</code>的<code>suspended</code>属性为<code>false</code>来实现，不过这里要注意的是暂停操作队列只是暂停执行下一个Operation对象，而不是暂停当前正在执行的Operation对象，将<code>suspended</code>属性设置为<code>true</code>后，操作队列则恢复执行。</p>
<h2 id="Dispatch_Queues"><a href="#Dispatch_Queues" class="headerlink" title="Dispatch Queues"></a>Dispatch Queues</h2><p>Dispatch Queue是GCD中的核心功能，它能让我们很方便的异步或同步执行任何被封装为闭包的任务，它的运作模式与Operation Queue很相似，但是有一点不同的是Dispatch Queue是一种先进先出的数据结构，也就是执行任务的顺序永远等同于添加任务时的顺序。GCD中已经为我们提供了几种类型的Dispatch Queue，当然我们也可以根据需求自己创建Dispatch Queue，下面我们先来看看Dispatch Queue的类型：</p>
<ul>
<li>串行Dispatch Queue：该类型的队列一次只能执行一个任务，当前任务完成之后才能执行下一个任务，而且可依任务的不同而在不同的线程中执行，这类队列通常作为私有队列使用。这里需要注意的是虽然该类型的队列一次只能执行一个任务，但是可以让多个串行队列同时开始执行任务，达到并发执行的任务的目的。</li>
<li>并行Dispatch Queue：该类队列可同时执行多个任务，但是执行任务的顺序依然是遵循先进先出的原则，同样可依任务的不同而在不同的线程中执行，这类队列通常作为全局队列使用。</li>
<li>主Dispatch Queue：该类队列实质上也是一个串行队列，但是该队列是一个全局队列，在该队列中执行的任务都是在当前应用的主线程中执行的。通常情况下我们不需要自己创建此类队列。</li>
</ul>
<p>Dispatch Queue与Operation Queue相似，都能让我们更方便的实现并发任务的编程工作，并且能提供更优的性能，因为我们不再需要编写关于线程管理相关的一大堆代码，这些完全都有系统接管，我们只需要将注意力放在要执行的任务即可。举个简单的例子，如果有两个任务需要在不同的线程中执行，但是他们之间存在资源竞争的情况，所以需要保证执行的先后顺序，如果我们自己创建线程实现该场景，那么就务必要用的线程锁机制，确保任务有正确的执行顺序，这势必对系统资源的开销会非常大，如果使用Dispatch Queue，我们只需要将任务安正确的顺序添加到串行队列中即可，省时省力省资源。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u4EFB_u52A1_u7684_u8F7D_u4F53_u662F_u95ED_u5305"><a href="#u4EFB_u52A1_u7684_u8F7D_u4F53_u662F_u95ED_u5305" class="headerlink" title="任务的载体是闭包"></a>任务的载体是闭包</h3><p>在使用Dispatch Queue时，需要将任务封装为闭包。闭包就是一个函数，或者一个指向函数的指针，加上这个函数执行的非局部变量，闭包最大的一个特性就是可以访问父作用域中的局部变量。我们在将任务封装为闭包进行使用时要注意以下这几点：</p>
<ul>
<li>虽然在闭包中可以使用父作用域中的变量，但是尽可能少的使用父作用域中比较大的变量以及不要在闭包中做类似删除清空父作用域中变量的行为。</li>
<li>当将一个封装好任务的闭包添加至Dispatch Qeueu中，Dispatch Queue会自动复制该闭包，并且在执行完成后释放该闭包，所以不同担心闭包中一些值的变化问题，以及资源释放问题。</li>
<li>虽然使用Dispatch Queue执行并发异步任务很方便，但是创建和执行闭包还是有一定资源开销的，所以尽量不要使用Dispatch Queue执行一些很小的任务，要物有所值。如果确实有很小的任务需要并发异步执行，那么使用<code>NSThread</code>的<code>detachNewThreadSelector</code>方法或<code>NSObject</code>的<code>performSelectorInBackground</code>方法去执行也未必不可。</li>
<li>如果同一个队列中的多个任务之间需要共享数据，那么应该使用队列上下文去存储数据，供不同的任务访问。</li>
<li>如果闭包中的任务创建了不少对象，那么应该考虑将整个任务逻辑代码放在<code>autoreleasepool</code>中，虽然Dispatch Queue中也有自动释放池，但是你不能保证它每次释放的时间，所以咱们自己再加一个要来的更保险一些。</li>
</ul>
<h2 id="u521B_u5EFA_u4E0E_u7BA1_u7406Dispatch_Queues"><a href="#u521B_u5EFA_u4E0E_u7BA1_u7406Dispatch_Queues" class="headerlink" title="创建与管理Dispatch Queues"></a>创建与管理Dispatch Queues</h2><p>在使用Dispatch Queue之前，我们首先需要考虑应该创建什么类型的Dispatch Queue，如何进行配置等，这一节就来说一说如何创建和管理Dispatch Queue。</p>
<h3 id="u5168_u5C40_u5E76_u53D1Dispatch_Queue"><a href="#u5168_u5C40_u5E76_u53D1Dispatch_Queue" class="headerlink" title="全局并发Dispatch Queue"></a>全局并发Dispatch Queue</h3><p>并发队列的好处人人皆知，可以方便的同时处理多个任务，在GCD中并发Dispatch Queue同样遵循先进先出的原则，但这只是在运行时适用，如果有个任务在并发队列中还没轮到它执行，那么此时完全可以移除它，而不必等它前面的任务执行完成之后。至于并发队列中没次有多少个任务在执行，这个恐怖在每一秒都在变化，因为影响它的因素有很多，所以之前说过，尽量不要移除移除已经添加进队列的任务。</p>
<p>OS X和iOS系统为我们提供了四种全局并发Dispatch Queue，所谓全局队列，就是我们不需要理会它们的保留和释放问题，而且不需要专门创建它。与其说是四种不如说是一种全局并发队列的四种不同优先级，因为它们之间唯一的不同之处就是队列优先级不同。与Operation Queue不同，在GCD中，Dispatch Queue只有四种优先级：</p>
<ul>
<li><code>DISPATCH_QUEUE_PRIORITY_HIGH</code>：高优先级。</li>
<li><code>DISPATCH_QUEUE_PRIORITY_DEFAULT</code>：默认优先级，低于高优先级。</li>
<li><code>DISPATCH_QUEUE_PRIORITY_LOW</code>：低优先级，低于高优先级和默认优先级。</li>
<li><code>DISPATCH_QUEUE_PRIORITY_BACKGROUND</code>：后台优先级，低于高优先级和后台线程执行的任务。</li>
</ul>
<p>我们可以通过<code>dispatch_get_global_queue</code>函数再根据不同的优先级获取不同的全局并发队列，类型为<code>dispatch_queue_t</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> highPriorityQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_HIGH</span>, <span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> defaultPriorityQueue = dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>我们在使用全局并发队列的时候不需要保留队列的引用，随时要用随时用该函数获取即可。当然我们也可以通过<code>dispatch_queue_create</code>函数自己创建队列：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.example.MyConcurrentQueue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>)</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，<code>dispatch_queue_create</code>函数有两个参数，第一个为队列的名称，第二个为队列类型，串行队列为<code>DISPATCH_QUEUE_SERIAL</code>，并发队列为<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>
<h3 id="u4E32_u884CDispatch_Queue"><a href="#u4E32_u884CDispatch_Queue" class="headerlink" title="串行Dispatch Queue"></a>串行Dispatch Queue</h3><p>串行队列可以让我们将任务按照一定顺序执行，能更优的处理多个任务之间的资源竞争问题，比线程锁机制有更小的资源开销和更好的性能，并且不会产生死锁的问题。</p>
<p>系统也为我们提供了一个串行队列，我们可以通过<code>dispatch_get_main_queue</code>函数获取：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mainQueue = dispatch_get_main_queue()</span><br></pre></td></tr></table></figure>
<p>该队列与当前应用的主线程相关联。当然我们也可以自己创建串行队列：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> serialQueueA = dispatch_queue_create(<span class="string">"com.example.MySerialQueueA"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> serialQueueB = dispatch_queue_create(<span class="string">"com.example.MySerialQueueB"</span>, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p><code>dispatch_queue_create</code>函数的第二个参数如果为<code>nil</code>则默认创建串行队列。当我们创建好串行队列后，系统会自动将创建好的队列与当前应用的主线程进行关联。</p>
<h3 id="u83B7_u53D6_u5F53_u524D_u961F_u5217"><a href="#u83B7_u53D6_u5F53_u524D_u961F_u5217" class="headerlink" title="获取当前队列"></a>获取当前队列</h3><p>如果需要验证或者测试当前队列，我们可以通过<code>dispatch_get_current_queue</code>函数获取当前队列。如果在闭包中调用，返回的是该闭包所在的队列，如果在闭包外调用，返回的则是默认的并发队列。不过该函数在OS X v10.10中和Swift中都不能使用了，取而代之的是通过<code>DISPATCH_CURRENT_QUEUE_LABEL</code>属性的<code>get</code>方法。</p>
<h3 id="u64C5_u7528_u961F_u5217_u4E0A_u4E0B_u6587"><a href="#u64C5_u7528_u961F_u5217_u4E0A_u4E0B_u6587" class="headerlink" title="擅用队列上下文"></a>擅用队列上下文</h3><p>很多情况下，同一个队列中的不同任务之间需要共享数据，尤其像串行队列中的任务，可能由多个任务对某个变量进行处理，或者都需要使用到某个对象，这时就要用到队列上下文:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">        </span><br><span class="line">        dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(<span class="number">0</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> taskCount = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            taskCount++</span><br><span class="line">        </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"TaskA in the dispatch queue...and The number of task in queue is <span class="subst">\(taskCount)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(taskCount, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> taskCount = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            taskCount++</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"TaskB in the dispatch queue...and The number of task in queue is <span class="subst">\(taskCount)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(taskCount, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testDispatchQueue = <span class="type">TestDispatchQueue</span>()</span><br><span class="line">testDispatchQueue.launch()</span><br></pre></td></tr></table></figure>
<p>从上面的代码示例中可以看到，在执行代码点，我们用<code>dispatch_set_context</code>函数向<code>serialQueue</code>队列的上下文环境中设置了一个<code>Int</code>类型的变量，初始值为0。该函数有两个参数，第一个是目标队列，第二个参数是上下文数据的指针。然后在闭包中我们使用<code>dispatch_get_context</code>函数获取上下文数据进行进一步的处理。除了基本类型，我们也可以将自定义的类放入队列上下文中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"DevTalking"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> mobile = <span class="string">"10010"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> contact = <span class="type">Contact</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line">        </span><br><span class="line">        dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(contact, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.name)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.mobile)</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testDispatchQueue = <span class="type">TestDispatchQueue</span>()</span><br><span class="line">testDispatchQueue.launch()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于<code>unsafeBitCast</code>函数和Swift中指针的用法在<a href="http://www.devtalking.com/articles/read-threading-programming-guide-3/">这里</a>可以有所参考。</p>
</blockquote>
<h3 id="u961F_u5217_u7684_u6536_u5C3E_u5DE5_u4F5C"><a href="#u961F_u5217_u7684_u6536_u5C3E_u5DE5_u4F5C" class="headerlink" title="队列的收尾工作"></a>队列的收尾工作</h3><p>虽然在ARC时代，资源释放的工作已经基本不需要我们手动去做了，但有些时候因为系统释放资源并不是很及时，也会造成内存移除等问题，所以在一些情况下我们还是需要进行手动释放资源的工作，必入添加<code>autoreleasepool</code>保证资源及时释放等。Dispatch Queue也给我们提供了这样的机会（机会针对于ARC时代，在MRC时代是必须要做的），那就是Clean Up  Function清理扫尾函数，当队列被释放时，或者说引用计数为0时会调用该函数，并且将上下文指针也传到了该函数，以便进行清理工作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Contact</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">"DevTalking"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> mobile = <span class="string">"10010"</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDispatchQueue</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> contact = <span class="type">Contact</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">testCleanUpFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        launch()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">15</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> serialQueue = dispatch_queue_create(<span class="string">"com.example.MySerialQueue"</span>, <span class="type">DISPATCH_QUEUE_SERIAL</span>)</span><br><span class="line"></span><br><span class="line">        dispatch_set_context(serialQueue, <span class="built_in">unsafeBitCast</span>(contact, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>))</span><br><span class="line">        </span><br><span class="line">        dispatch_set_finalizer_f(serialQueue, myFinalizerFunction())</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.name)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        dispatch_async(serialQueue, &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(dispatch_get_context(serialQueue), <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.mobile)</span>"</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">myFinalizerFunction</span><span class="params">()</span></span> -&gt; dispatch_function_t &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123; context <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">let</span> contact = <span class="built_in">unsafeBitCast</span>(context, <span class="type">Contact</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"The name is <span class="subst">\(contact.name)</span> and the mobile is <span class="subst">\(contact.mobile)</span>, The serialQueue has been released and we need clean up context data."</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// TODO...</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testDispatchQueue = <span class="type">TestDispatchQueue</span>()</span><br><span class="line">testDispatchQueue.testCleanUpFunction()</span><br></pre></td></tr></table></figure>
<p>从上面的代码示例中可以看到当给队列设置完上下文时，我们使用了<code>dispatch_set_finalizer_f</code>函数给队列设置清理函数，<code>dispatch_set_finalizer_f</code>函数有两个参数，第一个是目标队列，第二个参数是类型为<code>dispatch_function_t</code>的函数指针，也就是清理函数，上下文数据指针是该函数唯一的参数。在上面代码中，我们添加了<code>myFinalizerFunction</code>函数作为清理函数，在该函数中获得上下文数据，然后进行后续的清理工作。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://www.devtalking.com/devtalking.png" alt="DevTalking" itemprop="image"/>
          <p class="site-author-name" itemprop="name">DevTalking</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">75</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

         <!-- <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分類</span>
              
          </div> -->

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">37</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jacefu" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:jace.fu@icloud.com" target="_blank">
                  
                    <i class="fa fa-envelope"></i> Email
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.devtalking.com/qrcode.jpg" target="_blank">
                  
                    <i class="fa fa-qrcode"></i> 微信公众号
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DevTalking</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'jacefu';
      var disqus_identifier = 'index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/lib/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
