<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-121973094-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-121973094-1');
</script>


<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
 <script type="text/x-mathjax-config">
 MathJax.Hub.Config({tex2jax: {inlineMath:[['$','$']]}});
 </script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #272822; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #272822, 0 0 5px #272822; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #272822;    /*上边框颜色*/
        border-left-color: #272822;    /*左边框颜色*/
    }
</style>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>




  <meta name="keywords" content="Swift,Thread," />



  <link rel="alternate" href="/atom.xml" title="程序员说" type="application/atom+xml" />



  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description" content="&amp;lt;!-- DevTalking Banner1 --&amp;gt;


(adsbygoogle = window.adsbygoogle || []).push({});



本文首发CSDN，如需转载请与CSDN联系。

记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文">
<meta property="og:type" content="article">
<meta property="og:title" content="读 Threading Programming Guide 笔记（三）">
<meta property="og:url" content="http://www.devtalking.com/articles/read-threading-programming-guide-3/index.html">
<meta property="og:site_name" content="程序员说">
<meta property="og:description" content="&amp;lt;!-- DevTalking Banner1 --&amp;gt;


(adsbygoogle = window.adsbygoogle || []).push({});



本文首发CSDN，如需转载请与CSDN联系。

记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文">
<meta property="og:image" content="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-5.gif">
<meta property="og:image" content="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-6-new.png">
<meta property="og:updated_time" content="2016-08-19T01:01:35.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读 Threading Programming Guide 笔记（三）">
<meta name="twitter:description" content="&amp;lt;!-- DevTalking Banner1 --&amp;gt;


(adsbygoogle = window.adsbygoogle || []).push({});



本文首发CSDN，如需转载请与CSDN联系。

记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> 读 Threading Programming Guide 笔记（三） | 程序员说 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?980738dc41a50d91861a17ad4b768a1f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>


  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">程序员说</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                读 Threading Programming Guide 笔记（三）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-02-18T00:00:00+08:00" content="2016-02-18">
              2016-02-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/read-threading-programming-guide-3/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/read-threading-programming-guide-3/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/56056" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文章中有对官方文档的翻译，也有自己的理解，官方文档中代码片段的示例在这篇文章中都进行了完整的重写，还有一些文档中没有的代码示例，并且都使用Swift完成，给大家一些Objc与Swift转换的参考。<br>官方文档地址：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></p>
</blockquote>
<h2 id="u4F55_u65F6_u4F7F_u7528Run_Loop"><a href="#u4F55_u65F6_u4F7F_u7528Run_Loop" class="headerlink" title="何时使用Run Loop"></a>何时使用Run Loop</h2><p>前文中多次提到过，在主线程中Run Loop是随着应用程序一起启动的，也就是说当我们打开一个应用时，主线程中的Run Loop就已经启动了，尤其现在我们都使用Xcode中的项目模版创建项目，更是不用考虑主线程中Run Loop的状体。所以只有在二级线程中，也就是我们自己创建的线程中才有机会手动的创建的Run Loop，并对其进行配置的操作。</p>
<p>在前文中还提到过，Run Loop在线程中的主要作用就是帮助线程常驻在进程中，并且不会过多消耗资源。所以说Run Loop在二级线程中也不是必须需要的，要根据该线程执行的任务类型以及在整个应用中担任何作用而决定是否需要使用Run Loop。比如说，如果你创建一个二级线程只是为了执行一个不会频繁执行的一次性任务，或者需要执行很长时间的任务，那么可能就不需要使用Run Loop了。如果你需要一个线程执行周期性的定时任务，或者需要较为频繁的与主线程之间进行交互，那么就需要使用Run Loop。归纳一下需要使用Run Loop的情况大概有以下四点：</p>
<ul>
<li>通过基于端口或自定义的数据源与其他线程进行交互。</li>
<li>在线程中执行定时事件源的任务。</li>
<li>使用Cocoa框架提供的<code>performSelector…</code>系列方法。</li>
<li>在线程中执行较为频繁的，具有周期性的任务。</li>
</ul>
<p>光说不练假把式，下面就让我们来看看如何具体创建、配置、操作Run Loop。</p>
<h2 id="Run_Loop_u5BF9_u8C61"><a href="#Run_Loop_u5BF9_u8C61" class="headerlink" title="Run Loop对象"></a>Run Loop对象</h2><p>要想操作配置Run Loop，那自然需要通过Run Loop对象来完成，它提供了一系列接口，可帮助我们便捷的添加Input sources、timers以及观察者。较高级别的Cocoa框架提供了<code>NSRunLoop</code>类，较底层级别的Core Foundation框架提供了指向<code>CFRunloopRef</code>的指针。</p>
<h3 id="u83B7_u53D6Run_Loop_u5BF9_u8C61"><a href="#u83B7_u53D6Run_Loop_u5BF9_u8C61" class="headerlink" title="获取Run Loop对象"></a>获取Run Loop对象</h3><p>前文中提到过，在Cocoa和Core Foundation框架中都没有提供创建Run Loop的方法，只有从当前线程获取Run Loop的方法：</p>
<ul>
<li>在Cocoa框架中，<code>NSRunLoop</code>类提供了类方法<code>currentRunLoop()</code>获取<code>NSRunLoop</code>对象。<br>> 该方法是获取当前线程中已存在的Run Loop，如果不存在，那其实还是会创建一个Run Loop对象返回，只是Cocoa框架没有向我们暴露该接口。</li>
<li>在Core Foundation框架中提供了<code>CFRunLoopGetCurrent()</code>函数获取<code>CFRunLoop</code>对象。</li>
</ul>
<p>虽然这两个Run Loop对象并不完全等价，它们之间还是可以转换的，我们可以通过<code>NSRunLoop</code>对象提供的<code>getCFRunLoop()</code>方法获取<code>CFRunLoop</code>对象。因为<code>NSRunLoop</code>和<code>CFRunLoop</code>指向的都是当前线程中同一个Run Loop，所以在使用时它们可以混用，比如说要给Run Loop添加观察者时就必须得用<code>CFRunLoop</code>了。</p>
<h3 id="u914D_u7F6ERun_Loop_u89C2_u5BDF_u8005"><a href="#u914D_u7F6ERun_Loop_u89C2_u5BDF_u8005" class="headerlink" title="配置Run Loop观察者"></a>配置Run Loop观察者</h3><p>前文中提到过，可以向Run Loop中添加各种事件源和观察者，这里事件源是必填项，也就是说Run Loop中至少要有一种事件源，不论是Input source还是timer，如果Run Loop中没有事件源的话，那么在启动Run Loop后就会立即退出。而观察者是可选项，如果没有监控Run Loop各运行状态的需求，可以不配置观察者，这一节先看看如何向Run Loop中添加观察者。</p>
<p>在Cocoa框架中，并没有提供创建配置Run Loop观察者的相关接口，所以我们只能通过Core Foundation框架中提供的对象和方法创建并配置Run Loop观察者，下面我们看看示例代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"createAndConfigObserverInSecondaryThread"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="type">NSThread</span>.isMultiThreaded())</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">createAndConfigObserverInSecondaryThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        autoreleasepool&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">let</span> runloop = <span class="type">NSRunLoop</span>.currentRunLoop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">var</span> _self = <span class="keyword">self</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">var</span> observerContext = <span class="type">CFRunLoopObserverContext</span>(version: <span class="number">0</span>, info: &amp;_self, retain: <span class="literal">nil</span>, release: <span class="literal">nil</span>, copyDescription: <span class="literal">nil</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">let</span> observer = <span class="type">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, <span class="type">CFRunLoopActivity</span>.<span class="type">AllActivities</span>.rawValue, <span class="literal">true</span>, <span class="number">0</span>, <span class="keyword">self</span>.observerCallbackFunc(), &amp;observerContext)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(observer != <span class="literal">nil</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 5</span></span><br><span class="line">                <span class="keyword">let</span> cfRunloop = runloop.getCFRunLoop()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 6</span></span><br><span class="line">                <span class="type">CFRunLoopAddObserver</span>(cfRunloop, observer, kCFRunLoopDefaultMode)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 7</span></span><br><span class="line">            <span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(<span class="number">0.5</span>, target: <span class="keyword">self</span>, selector: <span class="string">"fireTimer"</span>, userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> loopCount = <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">repeat</span> &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 8</span></span><br><span class="line">                runloop.runUntilDate(<span class="type">NSDate</span>(timeIntervalSinceNow: <span class="number">1</span>))</span><br><span class="line">                </span><br><span class="line">                loopCount--</span><br><span class="line">            </span><br><span class="line">            &#125; <span class="keyword">while</span>(loopCount &gt; <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">observerCallbackFunc</span><span class="params">()</span></span> -&gt; <span class="type">CFRunLoopObserverCallBack</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;(observer, activity, context) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">switch</span>(activity) &#123;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">Entry</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop已经启动"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">BeforeTimers</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop分配定时任务前"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">BeforeSources</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop分配输入事件源前"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">BeforeWaiting</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop休眠前"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">AfterWaiting</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop休眠后"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">Exit</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop退出后"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">fireTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>下面解读一下上述代码示例，<code>launch()</code>方法在主线程中，通过<code>NSThread</code>类的类方法<code>detachNewThreadSelector:toTarget:withObject:</code>创建并启动一个二级线程，将<code>createAndConfigObserverInSecondaryThread()</code>方法作为事件消息传入该二级线程，这个方法的主要作用就是在二级线程中创建配置Run Loop观察者并启动Run Loop，然后让主线程持续3秒，以便二级线程有足够的时间执行任务。</p>
<p>在<code>createAndConfigObserverInSecondaryThread()</code>中共有8个关键步骤，下面一一进行说明：</p>
<ul>
<li><strong>第一步</strong>：通过<code>NSRunLoop</code>类的类方法<code>currentRunLoop()</code>获取当前线程的Run Loop，这里获取到的Run Loop对象是<code>NSRunLoop</code>对象。</li>
<li><strong>第二步</strong>：申明当前对象的变量，至于为什么要这么做，在下一步中会有说明。</li>
<li><strong>第三步</strong>：通过Core Foundation框架的<code>CFRunLoopObserverContext</code>结构体构造Run Loop观察者上下文，大家需要注意前两个参数，我们先看看这个结构体：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">CFRunLoopObserverContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> version: <span class="type">CFIndex</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> info: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> retain: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;)!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> release: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> copyDescription: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!)!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(version: <span class="type">CFIndex</span>, info: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, retain: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;)!, release: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)!, copyDescription: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!)!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>version</code>：结构体版本号，必须设置为0。</li>
<li><code>info</code>：上下文中<code>retain</code>、<code>release</code>、<code>copyDescription</code>三个回调函数以及Run Loop观察者的回调函数所有者对象的指针。在Swift中，<code>UnsafePointer</code>结构体代表C系语言中申明为常量的指针，<code>UnsafeMutablePoinger</code>结构体代表C系语言中申明为非常量的指针，比如说：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">C</span>:</span><br><span class="line">void functionWithConstArg(const int *constIntPointer);</span><br><span class="line"></span><br><span class="line"><span class="type">Swift</span>:</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">functionWithConstArg</span><span class="params">(constIntPointer: UnsafePointer&lt;Int32&gt;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">C</span>:</span><br><span class="line">void functionWithNotConstArg(unsigned int *unsignedIntPointer);</span><br><span class="line"></span><br><span class="line"><span class="type">Swift</span>:</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">functionWithNotConstArg</span><span class="params">(unsignedIntPointer: UnsafeMutablePointer&lt;UInt32&gt;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">C</span>:</span><br><span class="line">void functionWithNoReturnArg(void *voidPointer);</span><br><span class="line"></span><br><span class="line"><span class="type">Swift</span>:</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">functionWithNoReturnArg</span><span class="params">(voidPointer: UnsafeMutablePointer&lt;Void&gt;)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>第四步</strong>：通过Core Foundation框架的<code>CFRunLoopObserverCreate</code>函数创建<code>CFRunLoopObserver</code>对象：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopObserverCreate</span><span class="params">(allocator: CFAllocator!, <span class="number">_</span> activities: CFOptionFlags, <span class="number">_</span> repeats: Bool, <span class="number">_</span> order: CFIndex, <span class="number">_</span> callout: CFRunLoopObserverCallBack!, <span class="number">_</span> context: UnsafeMutablePointer&lt;CFRunLoopObserverContext&gt;)</span></span> -&gt; <span class="type">CFRunLoopObserver</span>!</span><br></pre></td></tr></table></figure>
<ol>
<li><code>allocator</code>：该参数为对象内存分配器，一般使用默认的分配器<code>kCFAllocatorDefault</code>。</li>
<li><code>activities</code>：该参数配置观察者监听Run Loop的哪种运行状态。在示例中，我们让观察者监听Run Loop的所有运行状态。</li>
<li><code>repeats</code>：该参数标识观察者只监听一次还是每次Run Loop运行时都监听。</li>
<li><code>order</code>：观察者优先级，当Run Loop中有多个观察者监听同一个运行状态时，那么就根据该优先级判断，0为最高优先级别。</li>
<li><code>callout</code>：观察者的回调函数，在Core Foundation框架中用<code>CFRunLoopObserverCallBack</code>重定义了回调函数的闭包。</li>
<li><code>context</code>：观察者的上下文。</li>
</ol>
<ul>
<li><strong>第五步</strong>：因为<code>NSRunLoop</code>没有提供操作观察者的接口，所以我们需要<code>getCFRunLoop()</code>方法获取到<code>CFRunLoop</code>对象。</li>
<li><strong>第六步</strong>：通过<code>CFRunLoopAddObserver</code>函数向当前线程的Run Loop中添加创建好的观察者：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopAddObserver</span><span class="params">(<span class="number">_</span> rl: CFRunLoop!, <span class="number">_</span> observer: CFRunLoopObserver!, <span class="number">_</span> mode: CFString!)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>rl</code>：当前线程的<code>CFRunLoop</code>对象。</li>
<li><code>observer</code>：创建好的观察者。</li>
<li><code>mode</code>：设置将观察者添加到哪个Run Loop模式中。</li>
</ol>
<blockquote>
<p>这里需要注意的是，一个观察者只能被添加到一个Run Loop中，但是可以被添加到Run Loop中的多个模式中。</p>
</blockquote>
<ul>
<li><strong>第七步</strong>：通过Timer事件源向当前线程发送重复执行的定时任务，时间间隔为0.5秒，因为只是为了测试观察者，所以<code>fireTimer()</code>是一个空任务。另外前文中提到过，如果Run Loop中没有任何数据源，那么Run Loop启动后会立即退出，所以大家可以把这行注释了运行看看会有什么效果。</li>
<li><strong>第八步</strong>：通过<code>NSRunLoop</code>对象的<code>runUntilDate(limitDate: NSDate)</code>方法启动Run Loop，设置Run Loop的运行时长为1秒。这里将其放在一个循环里，最大循环次数为10次，也就是说，如果不考虑主线程的运行时间，该二级线程的Run Loop可运行10次。</li>
</ul>
<p>再来看看观察者的回调方法<code>observerCallbackFunc()</code>，上面在介绍<code>CFRunLoopObserverCreate</code>函数时提到观察者的回调函数是<code>CFRunLoopObserverCallBack</code>重定义的一个闭包，我们来看看这个闭包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">CFRunLoopObserverCallBack</span> = (<span class="type">CFRunLoopObserver</span>!, <span class="type">CFRunLoopActivity</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span></span><br></pre></td></tr></table></figure>
<p>这个闭包没有返回值，第一个参数是触发监听的观察者，第二个参数是观察者监听的Run Loop运行状态，第三个参数是观察者的运行上下文环境。所以在回调方法中，我们只需要根据第二个参数的值即可判断观察者监听到的Run Loop状态。大家可以拷贝上面的代码，建一个Command Application运行看看结果。</p>
<h3 id="u542F_u52A8Run_Loop"><a href="#u542F_u52A8Run_Loop" class="headerlink" title="启动Run Loop"></a>启动Run Loop</h3><p>在启动Run Loop前务必要保证已添加一种类型的事件源，原因在前文中已提到多次。在Cocoa框架和Core Foundation框架中启动Run Loop大体有三种形式，分别是无条件启动、设置时间限制启动、指定特定模式启动。</p>
<h4 id="u65E0_u6761_u4EF6_u542F_u52A8"><a href="#u65E0_u6761_u4EF6_u542F_u52A8" class="headerlink" title="无条件启动"></a>无条件启动</h4><p><code>NSRunLoop</code>对象的<code>run()</code>方法和Core Foundation框架中的<code>CFRunLoopRun()</code>函数都是无条件启动Run Loop的方式。这种方式虽然是最简单的启动方式，但也是最不推荐使用的一个方式，因为这种方式将Run Loop置于一个永久运行并且不可控的状态，它使Run Loop只能在默认模式下运行，无法给Run Loop设置特定的或自定义的模式，而且以这种模式启动的Run Loop只能通过<code>CFRunLoopStop(_ rl: CFRunLoop!)</code>函数强制停止。</p>
<h4 id="u8BBE_u7F6E_u65F6_u95F4_u9650_u5236_u542F_u52A8"><a href="#u8BBE_u7F6E_u65F6_u95F4_u9650_u5236_u542F_u52A8" class="headerlink" title="设置时间限制启动"></a>设置时间限制启动</h4><p>该方式对应的方法是<code>NSRunLoop</code>对象的<code>runUntilDate(_ limitDate: NSDate)</code>方法，在启动Run Loop时设置超时时间，一旦超时那么Run Loop则自动退出。该方法的好处是可以在循环中反复启动Run Loop处理相关任务，而且可控制运行时长。</p>
<h4 id="u6307_u5B9A_u7279_u5B9A_u6A21_u5F0F_u542F_u52A8"><a href="#u6307_u5B9A_u7279_u5B9A_u6A21_u5F0F_u542F_u52A8" class="headerlink" title="指定特定模式启动"></a>指定特定模式启动</h4><p>该方式对应的方法是<code>NSRunLoop</code>对象的<code>runMode(_ mode: String, beforeDate limitDate: NSDate)</code>方法和Core Foundation框架的<code>CFRunLoopRunInMode(_ mode: CFString!, _ seconds: CFTimeInterval, _ returnAfterSourceHandled: Bool)</code>函数。前者有两个参数，第一个参数是Run Loop模式，第二个参数仍然是超时时间，该方法使Run Loop只处理指定模式中的事件源事件，当处理完事件或超时Run Loop会退出，该方法的返回值类型是<code>Bool</code>，如果返回<code>true</code>则表示Run Loop启动成功，并分派执行了任务或者达到超时时间，若返回<code>false</code>则表示Run Loop启动失败。后者有三个参数，前两个参数的作用一样，第三个参数的意思是Run Loop是否在执行完任务后就退出，如果设置为<code>false</code>，那么代表Run Loop在执行完任务后不退出，而是一直等到超时后才退出。该方法返回Run Loop的退出状态：</p>
<ul>
<li><code>CFRunLoopRunResult.Finished</code>：表示Run Loop已分派执行完任务，并且再无任务执行的情况下退出。</li>
<li><code>CFRunLoopRunResult.Stopped</code>：表示Run Loop通过<code>CFRunLoopStop(_ rl: CFRunLoop!)</code>函数强制退出。</li>
<li><code>CFRunLoopRunResult.TimedOut</code>：表示Run Loop因为超时时间到而退出。</li>
<li><code>CFRunLoopRunResult.HandledSource</code>：表示Run Loop已执行完任务而退出，改状态只有在<code>returnAfterSourceHandled</code>设置为<code>true</code>时才会出现。</li>
</ul>
<h3 id="u9000_u51FARun_Loop"><a href="#u9000_u51FARun_Loop" class="headerlink" title="退出Run Loop"></a>退出Run Loop</h3><p>退出Run Loop的方式总体来说有三种：</p>
<ul>
<li>启动Run Loop时设置超时时间。</li>
<li>强制退出Run Loop。</li>
<li>移除Run Loop中的事件源，从而使Run Loop退出。</li>
</ul>
<p>第一种方式是推荐使用的方式，因为可以给Run Loop设置可控的运行时间，让它执行完所有的任务以及给观察者发送通知。第二种强制退出Run Loop主要是应对无条件启动Run Loop的情况。第三种方式是最不推荐的方式，虽然在理论上说当Run Loop中没有任何数据源时会立即退出，但是在实际情况中我们创建的二级线程除了执行我们指定的任务外，有可能系统还会让其执行一些系统层面的任务，而且这些任务我们一般无法知晓，所以用这种方式退出Run Loop往往会存在延迟退出。</p>
<h3 id="Run_Loop_u5BF9_u8C61_u7684_u7EBF_u7A0B_u5B89_u5168_u6027"><a href="#Run_Loop_u5BF9_u8C61_u7684_u7EBF_u7A0B_u5B89_u5168_u6027" class="headerlink" title="Run Loop对象的线程安全性"></a>Run Loop对象的线程安全性</h3><p>Run Loop对象的线程安全性取决于我们使用哪种API去操作。Core Foundation框架中的<code>CFRunLoop</code>对象是线程安全的，我们可以在任何线程中使用。Cocoa框架的<code>NSRunLoop</code>对象是线程不安全的，我们必须在拥有Run Loop的当前线程中操作Run Loop，如果操作了不属于当前线程的Run loop，会导致异常和各种潜在的问题发生。</p>
<h2 id="u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90"><a href="#u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90" class="headerlink" title="自定义Run Loop事件源"></a>自定义Run Loop事件源</h2><p>Cocoa框架因为是较为高层的框架，所以没有提供操作较为底层的Run Loop事件源相关的接口和对象，所以我们只能使用Core Foundation框架中的对象和函数创建事件源并给Run Loop设置事件源。</p>
<h3 id="u521B_u5EFARun_Loop_u4E8B_u4EF6_u6E90_u5BF9_u8C61"><a href="#u521B_u5EFARun_Loop_u4E8B_u4EF6_u6E90_u5BF9_u8C61" class="headerlink" title="创建Run Loop事件源对象"></a>创建Run Loop事件源对象</h3><p>我们定义自己的Run Loop事件源首先就是需要创建事件源，我们来看看创建事件源的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopSourceCreate</span><span class="params">(<span class="number">_</span> allocator: CFAllocator!, <span class="number">_</span> order: CFIndex, <span class="number">_</span> context: UnsafeMutablePointer&lt;CFRunLoopSourceContext&gt;)</span></span> -&gt; <span class="type">CFRunLoopSource</span>!</span><br></pre></td></tr></table></figure>
<ol>
<li><code>allocator</code>：该参数为对象内存分配器，一般使用默认的分配器<code>kCFAllocatorDefault</code>。</li>
<li><code>order</code>：事件源优先级，当Run Loop中有多个接收相同事件的事件源被标记为待执行时，那么就根据该优先级判断，0为最高优先级别。</li>
<li><code>context</code>：事件源上下文。</li>
</ol>
<p>Run Loop事件源上下文很重要，我们来看看它的结构：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CFRunLoopSourceContext</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> version: <span class="type">CFIndex</span> </span><br><span class="line">    <span class="keyword">var</span> info: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt; </span><br><span class="line">    <span class="keyword">var</span> retain: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;)! </span><br><span class="line">    <span class="keyword">var</span> release: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)! </span><br><span class="line">    <span class="keyword">var</span> copyDescription: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!)! </span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">equal</span>: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">DarwinBoolean</span>)! </span><br><span class="line">    <span class="keyword">var</span> hash: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">CFHashCode</span>)! </span><br><span class="line">    <span class="keyword">var</span> schedule: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span>)! </span><br><span class="line">    <span class="keyword">var</span> cancel: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span>)! </span><br><span class="line">    <span class="keyword">var</span> perform: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)! </span><br><span class="line">    <span class="keyword">init</span>() </span><br><span class="line">    <span class="keyword">init</span>(version version: <span class="type">CFIndex</span>, info info: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, retain retain: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;)!, release release: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)!, copyDescription copyDescription: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!)!, <span class="built_in">equal</span> <span class="built_in">equal</span>: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">DarwinBoolean</span>)!, hash hash: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">CFHashCode</span>)!, schedule schedule: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span>)!, cancel cancel: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span>)!, perform perform: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)!) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该结构体中我们需要关注的是前两个和后三个属性：</p>
<ol>
<li><code>version</code>：事件源上下文的版本，必须设置为0。</li>
<li><code>info</code>：上下文中<code>retain</code>、<code>release</code>、<code>copyDescription</code>、<code>equal</code>、<code>hash</code>、<code>schedule</code>、<code>cancel</code>、<code>perform</code>这八个回调函数所有者对象的指针。</li>
<li><code>schedule</code>：该回调函数的作用是将该事件源与给它发送事件消息的线程进行关联，也就是说如果主线程想要给该事件源发送事件消息，那么首先主线程得能获取到该事件源。</li>
<li><code>cancel</code>：该回调函数的作用是使该事件源失效。</li>
<li><code>perform</code>：该回调函数的作用是执行其他线程或当前线程给该事件源发来的事件消息。</li>
</ol>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u5C06_u4E8B_u4EF6_u6E90_u6DFB_u52A0_u81F3Run_Loop"><a href="#u5C06_u4E8B_u4EF6_u6E90_u6DFB_u52A0_u81F3Run_Loop" class="headerlink" title="将事件源添加至Run Loop"></a>将事件源添加至Run Loop</h3><p>事件源创建好之后，接下来就是将其添加到指定某个模式的Run Loop中，我们来看看这个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopAddSource</span><span class="params">(<span class="number">_</span> rl: CFRunLoop!, <span class="number">_</span> source: CFRunLoopSource!, <span class="number">_</span> mode: CFString!)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>rl</code>：希望添加事件源的Run Loop对象，类型是<code>CFRunLoop</code>。</li>
<li><code>source</code>：我们创建好的事件源。</li>
<li><code>mode</code>：Run Loop的模式。（可以回顾之前文章）</li>
</ol>
<p>我们再来看看这个方法都干了些什么：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">void <span class="type">CFRunLoopAddSource</span>(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopSourceRef</span> rls, <span class="type">CFStringRef</span> modeName) &#123;</span><br><span class="line">  </span><br><span class="line">    .....</span><br><span class="line">  </span><br><span class="line">    __CFRunLoopSourceSchedule(rls, rl, rlm);</span><br><span class="line">  </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __CFRunLoopSourceSchedule(<span class="type">CFRunLoopSourceRef</span> rls, <span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm) &#123;  </span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="type">NULL</span> != rls-&gt;_context.version0.schedule) &#123;</span><br><span class="line">             rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, rlm-&gt;_name);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述的代码片段可以看出，在<code>CFRunLoopAddSource</code>中调用了<code>__CFRunLoopSourceSchedule</code>内部函数，而该函数中正是执行了Run Loop事件源上下文中的<code>schedule</code>回调函数。也就是说当把事件源添加到Run Loop中后就会将事件源与给它发送事件消息的线程进行关联。</p>
<h3 id="u6807_u8BB0_u4E8B_u4EF6_u6E90_u53CA_u5524_u9192Run_Loop"><a href="#u6807_u8BB0_u4E8B_u4EF6_u6E90_u53CA_u5524_u9192Run_Loop" class="headerlink" title="标记事件源及唤醒Run Loop"></a>标记事件源及唤醒Run Loop</h3><p>前面的文章中说过，srouce0类型，也就是非port类型的事件源都需要进行手动标记，标记完还需要手动唤醒Run Loop，下面我们来看看这两个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopSourceSignal</span><span class="params">(<span class="number">_</span> source: CFRunLoopSource!)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopWakeUp</span><span class="params">(<span class="number">_</span> rl: CFRunLoop!)</span></span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是唤醒Run Loop并不等价与启动Run Loop，因为启动Run Loop时需要对Run Loop进行模式、时限的设置，而唤醒Run Loop只是当已启动的Run Loop休眠时重新让其运行。</p>
<h3 id="u6267_u884CRun_Loop_u4E8B_u4EF6_u6E90_u7684_u4EFB_u52A1"><a href="#u6267_u884CRun_Loop_u4E8B_u4EF6_u6E90_u7684_u4EFB_u52A1" class="headerlink" title="执行Run Loop事件源的任务"></a>执行Run Loop事件源的任务</h3><p>唤醒Run Loop意味着让休眠的Run Loop重新运行，那么我们就从启动Run Loop，让其开始运行的方法看起：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSRunLoop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">runUntilDate</span><span class="params">(limitDate: NSDate)</span></span> &#123;</span><br><span class="line">        <span class="keyword">while</span> runMode(<span class="type">NSDefaultRunLoopMode</span>, beforeDate: limitDate) &amp;&amp; limitDate.timeIntervalSinceReferenceDate &gt; <span class="type">CFAbsoluteTimeGetCurrent</span>() &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">runMode</span><span class="params">(mode: String, beforeDate limitDate: NSDate)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        .....</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> limitTime = limitDate.timeIntervalSinceReferenceDate</span><br><span class="line">        <span class="keyword">let</span> ti = limitTime - <span class="type">CFAbsoluteTimeGetCurrent</span>()</span><br><span class="line">        <span class="type">CFRunLoopRunInMode</span>(modeArg, ti, <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">SInt32</span> <span class="type">CFRunLoopRunInMode</span>(<span class="type">CFStringRef</span> modeName, <span class="type">CFTimeInterval</span> seconds, <span class="type">Boolean</span> returnAfterSourceHandled) &#123;     </span><br><span class="line">    <span class="type">CHECK_FOR_FORK</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="type">CFRunLoopRunSpecific</span>(<span class="type">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">SInt32</span> <span class="type">CFRunLoopRunSpecific</span>(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFStringRef</span> modeName, <span class="type">CFTimeInterval</span> seconds, <span class="type">Boolean</span> returnAfterSourceHandled) &#123;     </span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int32_t __CFRunLoopRun(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm, <span class="type">CFTimeInterval</span> seconds, <span class="type">Boolean</span> stopAfterHandle, <span class="type">Boolean</span> waitIfEmpty) &#123;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">Boolean</span> __CFRunLoopDoSources0(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm, <span class="type">Boolean</span> stopAfterHandle) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">CFTypeRef</span> sources = <span class="type">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopSourceIsSignaled(rls)) &#123;</span><br><span class="line">    </span><br><span class="line">        .....</span><br><span class="line">    </span><br><span class="line">        rls-&gt;_context.version0.perform(rls-&gt;_context.version0.info);</span><br><span class="line">        </span><br><span class="line">        .....</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码片段中可以看出，当Run Loop运行后会调用内部函数<code>__CFRunLoopDoSources0</code>执行自定义事件源的任务，在执行之前会通过内部函数<code>__CFRunLoopSourceIsSignaled(rls)</code>判断事件源是否已被标记为待执行，然后执行Run Loop事件上下文中的<code>perform</code>回调函数。</p>
<h3 id="u79FB_u9664Run_Loop_u4E8B_u4EF6_u6E90"><a href="#u79FB_u9664Run_Loop_u4E8B_u4EF6_u6E90" class="headerlink" title="移除Run Loop事件源"></a>移除Run Loop事件源</h3><p>当我们自定义的事件源完成使命后就可以将其从Run Loop中移除，我们来看看对应的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopRemoveSource</span><span class="params">(<span class="number">_</span> rl: CFRunLoop!, <span class="number">_</span> source: CFRunLoopSource!, <span class="number">_</span> mode: CFString!)</span></span></span><br><span class="line"></span><br><span class="line">void <span class="type">CFRunLoopRemoveSource</span>(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopSourceRef</span> rls, <span class="type">CFStringRef</span> modeName) &#123;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    __CFRunLoopSourceCancel(rls, rl, rlm);</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __CFRunLoopSourceCancel(<span class="type">CFRunLoopSourceRef</span> rls, <span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="type">NULL</span> != rls-&gt;_context.version0.cancel) &#123;</span><br><span class="line">              rls-&gt;_context.version0.cancel(rls-&gt;_context.version0.info, rl, rlm-&gt;_name);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码片段可以看出，当我们调用了<code>CFRunLoopRemoveSource</code>方法后，其实是执行了Run Loop事件源上下文中的<code>cancel</code>回调函数。</p>
<h3 id="u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90_u7684_u5B9E_u9645_u8FD0_u7528"><a href="#u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90_u7684_u5B9E_u9645_u8FD0_u7528" class="headerlink" title="自定义Run Loop事件源的实际运用"></a>自定义Run Loop事件源的实际运用</h3><p>在讲解示例之前，我们先来看看示例Demo的效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-5.gif" alt="LearnThread-5"></p>
<p>在这个示例中，创建了两个自定义事件源，一个添加到主线程中，另一个添加到二级线程中。主线程给二级线程中的自定义事件源发送事件消息，目的是让其改变所有<code>UICollectionViewCell</code>的透明度，当二级线程收到事件消息后执行计算每个<code>UICollectionViewCell</code>透明度的任务，然后再给主线程的自定义事件源发送事件消息，让其更新<code>UICollectionViewCell</code>的透明度并显示。下面来看看类图：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-6-new.png" alt="LearnThread-6"></p>
<p>整个工程一共就这六个类：</p>
<ul>
<li><code>MainCollectionViewController</code>：程序主控制器，启动程序、展示UI及计算<code>UICollectionViewCell</code>透明度的相关方法。</li>
<li><code>MainThreadRunLoopSource</code>：主线程自定义事件源管理对象，负责初始化事件源，将事件源添加至指定线程，标记事件源并唤醒指定Run Loop以及包含上文中说过的事件源最主要的三个回调方法。</li>
<li><code>MainThreadRunLoopSourceContext</code>：主线程自定义事件源上下文，可获取到对应的事件源及添加了该事件源的Run Loop。</li>
<li><code>SecondaryThreadRunLoopSource</code>：二级线程自定义事件源管理对象，负责初始化事件源，将事件源添加至指定线程，标记事件源并唤醒指定Run Loop以及包含上文中说过的事件源最主要的三个回调方法。</li>
<li><code>SecondaryThreadRunLoopSourceContext</code>：二级线程自定义事件源上下文，可获取到对应的事件源及添加了该事件源的Run Loop。</li>
<li><code>AppDelegate</code>：应用程序代理类，这里零时充当为各自定义事件源回调方法执行内容的管理类。</li>
</ul>
<p>下面我按照程序的运行顺序一一对这些类及属性和方法进行简单说明。</p>
<h4 id="u7A0B_u5E8F_u5F00_u59CB_u8FD0_u884C"><a href="#u7A0B_u5E8F_u5F00_u59CB_u8FD0_u884C" class="headerlink" title="程序开始运行"></a>程序开始运行</h4><p><code>MainCollectionViewController</code>类中与UI展示相关的方法在这里就不再累赘了。点击<strong>Start</strong>按钮，调用<code>start()</code>方法，初始化<code>MainThreadRunLoopSource</code>对象，在这个过程中初始化了<code>CFRunLoopSourceContext</code>对象并且创建<code>CFRunLoopSource</code>对象以及初始化该事件源的指令池：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mainThreadRunLoopSource = <span class="type">MainThreadRunLoopSource</span>()</span><br><span class="line">        </span><br><span class="line">mainThreadRunLoopSource.addToCurrentRunLoop()</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> runloopSourceContext = <span class="type">CFRunLoopSourceContext</span>(version: <span class="number">0</span>, info: <span class="built_in">unsafeBitCast</span>(<span class="keyword">self</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>), retain: <span class="literal">nil</span>, release: <span class="literal">nil</span>, copyDescription: <span class="literal">nil</span>, <span class="built_in">equal</span>: <span class="literal">nil</span>, hash: <span class="literal">nil</span>, schedule: runloopSourceScheduleRoutine(), cancel: runloopSourceCancelRoutine(), perform: runloopSourcePerformRoutine())</span><br><span class="line">        </span><br><span class="line">runloopSource = <span class="type">CFRunLoopSourceCreate</span>(kCFAllocatorDefault, <span class="number">0</span>, &amp;runloopSourceContext)</span><br><span class="line">        </span><br><span class="line">commandBuffer = <span class="type">Array</span>&lt;<span class="type">SecondaryThreadRunLoopSourceContext</span>&gt;()</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是<code>CFRunLoopSourceContext</code>的<code>init</code>方法中的第二个参数和<code>CFRunLoopSourceCreate</code>方法的第三个参数都是指针，那么在Swift中，将对象转换为指针的方法有两种：</p>
<ul>
<li>使用<code>unsafeBitCast</code>方法，该方法会将第一个参数的内容按照第二个参数的类型进行转换。一般当需要对象与指针来回转换时使用该方法。</li>
<li>在对象前面加<code>&amp;</code>符号，表示传入指针地址。</li>
</ul>
<p>当主线程的自定义事件源初始化完成之后，调用<code>addToCurrentRunLoop()</code>方法，将事件源添加至当前Run Loop中，即主线程的Run Loop：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cfrunloop = <span class="type">CFRunLoopGetCurrent</span>()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> rls = runloopSource &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="type">CFRunLoopAddSource</span>(cfrunloop, rls, kCFRunLoopDefaultMode)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来创建二级线程，并且让其执行二级线程的配置任务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> secondaryThread = <span class="type">NSThread</span>(target: <span class="keyword">self</span>, selector: <span class="string">"startThreadWithRunloop"</span>, object: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">secondaryThread.start()</span><br></pre></td></tr></table></figure>
<p>在二级线程中同样初始化自定义事件源，并将将其添加至二级线程的Run Loop中，然后启动Run Loop：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">startThreadWithRunloop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    autoreleasepool&#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">var</span> done = <span class="literal">false</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> secondaryThreadRunLoopSource = <span class="type">SecondaryThreadRunLoopSource</span>()</span><br><span class="line">            </span><br><span class="line">        secondaryThreadRunLoopSource.addToCurrentRunLoop()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">let</span> result = <span class="type">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">5</span>, <span class="literal">true</span>)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> ((result == <span class="type">CFRunLoopRunResult</span>.<span class="type">Stopped</span>) || (result == <span class="type">CFRunLoopRunResult</span>.<span class="type">Finished</span>)) &#123;</span><br><span class="line">                    </span><br><span class="line">                done = <span class="literal">true</span>;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125; <span class="keyword">while</span>(!done)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6267_u884C_u4E8B_u4EF6_u6E90_u7684schedule_u56DE_u8C03_u51FD_u6570"><a href="#u6267_u884C_u4E8B_u4EF6_u6E90_u7684schedule_u56DE_u8C03_u51FD_u6570" class="headerlink" title="执行事件源的schedule回调函数"></a>执行事件源的schedule回调函数</h4><p>前文中说过将事件源添加至Run Loop后会触发事件源的<code>schedule</code>回调函数，所以当执行完<code>mainThreadRunLoopSource.addToCurrentRunLoop()</code>这句代码后，便会触发主线程自定义事件源的<code>schedule</code>回调函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">runloopSourceScheduleRoutine</span><span class="params">()</span></span> -&gt; <span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123; (info, runloop, runloopMode) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> mainThreadRunloopSource = <span class="built_in">unsafeBitCast</span>(info, <span class="type">MainThreadRunLoopSource</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> mainThreadRunloopSourceContext = <span class="type">MainThreadRunLoopSourceContext</span>(runloop: runloop, runloopSource: mainThreadRunloopSource)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> appDelegate = <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br><span class="line">            </span><br><span class="line">        appDelegate.performSelector(<span class="string">"registerMainThreadRunLoopSource:"</span>, withObject: mainThreadRunloopSourceContext)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还需注意的是在Swift2.0中，如果一个作为回调函数方法的返回类型是指向函数的指针，这类指针可以转换为闭包，并且要在闭包前面加上<code>@convention(c)</code>标注。在<code>runloopSourceScheduleRoutine()</code>方法中，获取到主线程事件源对象并初始化事件源上下文对象，然后将该事件源上下文对象传给<code>AppDelegate</code>的对应方法注册该事件源上下文对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">registerMainThreadRunLoopSource</span><span class="params">(runloopSourceContext: MainThreadRunLoopSourceContext)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    mainThreadRunloopSourceContext = runloopSourceContext</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自然当在二级线程中执行完<code>secondaryThreadRunLoopSource.addToCurrentRunLoop()</code>这句代码后，也会触发二级线程自定义事件源的<code>schedule</code>回调函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">runloopSourceScheduleRoutine</span><span class="params">()</span></span> -&gt; <span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123; (info, runloop, runloopMode) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> secondaryThreadRunloopSource = <span class="built_in">unsafeBitCast</span>(info, <span class="type">SecondaryThreadRunLoopSource</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> secondaryThreadRunloopSourceContext = <span class="type">SecondaryThreadRunLoopSourceContext</span>(runloop: runloop, runloopSource: secondaryThreadRunloopSource)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> appDelegate = <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br><span class="line">            </span><br><span class="line">        appDelegate.performSelectorOnMainThread(<span class="string">"registerSecondaryThreadRunLoopSource:"</span>, withObject: secondaryThreadRunloopSourceContext, waitUntilDone: <span class="literal">true</span>)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，在该方法中同样是将二级线程事件源上下文对象传给了<code>AppDelegate</code>的对应方法，但是这里用了<code>performSelectorOnMainThread</code>方法，让其在主线程中执行，目的在于注册完上下文对象后就接着从主线程给二级线程发送事件消息了，其实我将这里作为了主线程触发二级线程执行任务的触发点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">registerSecondaryThreadRunLoopSource</span><span class="params">(runloopSourceContext: SecondaryThreadRunLoopSourceContext)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    secondaryThreadRunloopSourceContext = runloopSourceContext</span><br><span class="line">        </span><br><span class="line">    sendCommandToSecondaryThread()</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sendCommandToSecondaryThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    secondaryThreadRunloopSourceContext?.runloopSource?.commandBuffer?.append(mainThreadRunloopSourceContext!)</span><br><span class="line">        </span><br><span class="line">    secondaryThreadRunloopSourceContext?.runloopSource?.signalSourceAndWakeUpRunloop(secondaryThreadRunloopSourceContext!.runloop!)</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看到在<code>sendCommandToSecondaryThread()</code>方法中，将主线程的事件源上下文放入了二级线程事件源的指令池中，这里我设计的是只要指令池中有内容就代表事件源需要执行后续任务了。然后执行了二级线程事件源的<code>signalSourceAndWakeUpRunloop()</code>方法，给其标记为待执行，并唤醒二级线程的Run Loop：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">signalSourceAndWakeUpRunloop</span><span class="params">(runloop: CFRunLoopRef)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">CFRunLoopSourceSignal</span>(runloopSource)</span><br><span class="line">        </span><br><span class="line">    <span class="type">CFRunLoopWakeUp</span>(runloop)</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6267_u884C_u4E8B_u4EF6_u6E90_u7684perform_u56DE_u8C03_u51FD_u6570"><a href="#u6267_u884C_u4E8B_u4EF6_u6E90_u7684perform_u56DE_u8C03_u51FD_u6570" class="headerlink" title="执行事件源的perform回调函数"></a>执行事件源的perform回调函数</h4><p>当二级线程事件源被标记并且二级线程Run Loop被唤醒后，就会触发事件源的<code>perform</code>回调函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">runloopSourcePerformRoutine</span><span class="params">()</span></span> -&gt; <span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123; info -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> appDelegate = <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br><span class="line">            </span><br><span class="line">        appDelegate.performSelector(<span class="string">"performSecondaryThreadRunLoopSourceTask"</span>)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二级线程事件源的<code>perform</code>回调函数会在当前线程，也就是二级线程中执行<code>AppDelegate</code>中的对应方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSecondaryThreadRunLoopSourceTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> secondaryThreadRunloopSourceContext!.runloopSource!.commandBuffer!.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">        mainCollectionViewController!.generateRandomAlpha()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> mainThreadRunloopSourceContext = secondaryThreadRunloopSourceContext!.runloopSource!.commandBuffer![<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">        secondaryThreadRunloopSourceContext!.runloopSource!.commandBuffer!.removeAll()</span><br><span class="line">            </span><br><span class="line">        mainThreadRunloopSourceContext.runloopSource?.commandBuffer?.append(secondaryThreadRunloopSourceContext!)</span><br><span class="line">            </span><br><span class="line">        mainThreadRunloopSourceContext.runloopSource?.signalSourceAndWakeUpRunloop(mainThreadRunloopSourceContext.runloop!)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看到，先会判断二级线程事件源的指令池中有没有内容，如果有的话，那么执行计算<code>UICollectionViewCell</code>透明度的任务，然后从指令池中获取到主线程事件源上下文对象，将二级线程事件源上下文对象放入主线程事件源的指令池中，并将主线程事件源标记为待执行，然后唤醒主线程Run Loop。之后便会触发主线程事件源的<code>perform</code>回调函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">runloopSourcePerformRoutine</span><span class="params">()</span></span> -&gt; <span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123; info -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> appDelegate = <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br><span class="line">            </span><br><span class="line">        appDelegate.performSelector(<span class="string">"performMainThreadRunLoopSourceTask"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performMainThreadRunLoopSourceTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> mainThreadRunloopSourceContext!.runloopSource!.commandBuffer!.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        </span><br><span class="line">        mainThreadRunloopSourceContext!.runloopSource!.commandBuffer!.removeAll()</span><br><span class="line">            </span><br><span class="line">        mainCollectionViewController!.collectionView.reloadData()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> timer = <span class="type">NSTimer</span>(timeInterval: <span class="number">1</span>, target: <span class="keyword">self</span>, selector: <span class="string">"sendCommandToSecondaryThread"</span>, userInfo: <span class="literal">nil</span>, repeats: <span class="literal">false</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="type">NSRunLoop</span>.mainRunLoop().addTimer(timer, forMode: <span class="type">NSDefaultRunLoopMode</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>performMainThreadRunLoopSourceTask()</code>方法中同样会先判断主线程事件源的指令池是否有内容，然后执行<code>MainCollectionViewController</code>中的刷新UI的方法，最后再次给二级线程发送事件消息，以此循环。大家可以去Github下载该示例的<a href="https://github.com/DevTalking/CustomRunloopInputSourceSample.git" target="_blank" rel="external">源码</a>，编译环境是Xcode7.2，然后可以自己试着在界面中添加一个<strong>Stop</strong>按钮，让事件源执行<code>cancel</code>回调函数。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Swift/" rel="tag">#Swift</a>
          
            <a href="/tags/Thread/" rel="tag">#Thread</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/articles/read-threading-programming-guide-2/" rel="next" title="读 Threading Programming Guide 笔记（二）">
                <i class="fa fa-chevron-left"></i> 读 Threading Programming Guide 笔记（二）
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/articles/read-threading-programming-guide-4/" rel="prev" title="读 Threading Programming Guide 笔记（四）">
                读 Threading Programming Guide 笔记（四） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!--MOB SHARE BEGIN-->
<div class="-hoofoo-share-title">分享到：</div>
<div class="-hoofoo-share-buttons">
    <div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"><i class="fa fa-weibo" aria-hidden="true"></i></div>
    <div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"><i class="fa fa-weixin" aria-hidden="true"></i></div>
    <div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"><i class="fa fa-twitter" aria-hidden="true"></i></div>
    <div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"><i class="fa fa-ellipsis-h" aria-hidden="true"></i></div>
</div><div class="-mob-share-ui -mob-share-ui-theme -mob-share-ui-theme-slide-left" style="display: none">
    <ul class="-mob-share-list">
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-pocket"><p>Pocket</p></li>
        <li class="-mob-share-instapaper"><p>Instapaper</p></li>
        <li class="-mob-share-linkedin"><p>Linkedin</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-douban"><p>豆瓣</p></li>
        <li class="-mob-share-facebook"><p>Facebook</p></li>
        <li class="-mob-share-google"><p>Google+</p></li>
    </ul>
    <div class="-mob-share-close">取消</div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="http://f1.webshare.mob.com/code/mob-share.js?appkey=26252752de4d6"></script>
<!--MOB SHARE END--> 
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
              <div id="disqus_thread">
                <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
              </div>
            
          </div>
        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            本站概覽
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://www.devtalking.com/devtalking.png" alt="DevTalking" itemprop="image"/>
          <p class="site-author-name" itemprop="name">DevTalking</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">91</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

         <!-- <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分類</span>
              
          </div> -->

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">44</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://www.linkedin.com/in/宇轩-付-5aa406a6" target="_blank">
                  
                    <i class="fa fa-linkedin"></i> linkedin
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:jace.fu@icloud.com" target="_blank">
                  
                    <i class="fa fa-envelope"></i> Email
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#u4F55_u65F6_u4F7F_u7528Run_Loop"><span class="nav-number">1.</span> <span class="nav-text">何时使用Run Loop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Run_Loop_u5BF9_u8C61"><span class="nav-number">2.</span> <span class="nav-text">Run Loop对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u83B7_u53D6Run_Loop_u5BF9_u8C61"><span class="nav-number">2.1.</span> <span class="nav-text">获取Run Loop对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u914D_u7F6ERun_Loop_u89C2_u5BDF_u8005"><span class="nav-number">2.2.</span> <span class="nav-text">配置Run Loop观察者</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u542F_u52A8Run_Loop"><span class="nav-number">2.3.</span> <span class="nav-text">启动Run Loop</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#u65E0_u6761_u4EF6_u542F_u52A8"><span class="nav-number">2.3.1.</span> <span class="nav-text">无条件启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u8BBE_u7F6E_u65F6_u95F4_u9650_u5236_u542F_u52A8"><span class="nav-number">2.3.2.</span> <span class="nav-text">设置时间限制启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u6307_u5B9A_u7279_u5B9A_u6A21_u5F0F_u542F_u52A8"><span class="nav-number">2.3.3.</span> <span class="nav-text">指定特定模式启动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u9000_u51FARun_Loop"><span class="nav-number">2.4.</span> <span class="nav-text">退出Run Loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Run_Loop_u5BF9_u8C61_u7684_u7EBF_u7A0B_u5B89_u5168_u6027"><span class="nav-number">2.5.</span> <span class="nav-text">Run Loop对象的线程安全性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90"><span class="nav-number">3.</span> <span class="nav-text">自定义Run Loop事件源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u521B_u5EFARun_Loop_u4E8B_u4EF6_u6E90_u5BF9_u8C61"><span class="nav-number">3.1.</span> <span class="nav-text">创建Run Loop事件源对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u5C06_u4E8B_u4EF6_u6E90_u6DFB_u52A0_u81F3Run_Loop"><span class="nav-number">3.2.</span> <span class="nav-text">将事件源添加至Run Loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u6807_u8BB0_u4E8B_u4EF6_u6E90_u53CA_u5524_u9192Run_Loop"><span class="nav-number">3.3.</span> <span class="nav-text">标记事件源及唤醒Run Loop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u6267_u884CRun_Loop_u4E8B_u4EF6_u6E90_u7684_u4EFB_u52A1"><span class="nav-number">3.4.</span> <span class="nav-text">执行Run Loop事件源的任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u79FB_u9664Run_Loop_u4E8B_u4EF6_u6E90"><span class="nav-number">3.5.</span> <span class="nav-text">移除Run Loop事件源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90_u7684_u5B9E_u9645_u8FD0_u7528"><span class="nav-number">3.6.</span> <span class="nav-text">自定义Run Loop事件源的实际运用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#u7A0B_u5E8F_u5F00_u59CB_u8FD0_u884C"><span class="nav-number">3.6.1.</span> <span class="nav-text">程序开始运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u6267_u884C_u4E8B_u4EF6_u6E90_u7684schedule_u56DE_u8C03_u51FD_u6570"><span class="nav-number">3.6.2.</span> <span class="nav-text">执行事件源的schedule回调函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u6267_u884C_u4E8B_u4EF6_u6E90_u7684perform_u56DE_u8C03_u51FD_u6570"><span class="nav-number">3.6.3.</span> <span class="nav-text">执行事件源的perform回调函数</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DevTalking</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'jacefu';
      var disqus_identifier = '/articles/read-threading-programming-guide-3/';
      var disqus_title = '读 Threading Programming Guide 笔记（三）';
      var disqus_url = 'http://www.devtalking.com//articles/read-threading-programming-guide-3/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/lib/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
