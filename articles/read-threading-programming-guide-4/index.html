<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-121973094-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-121973094-1');
</script>


<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
 <script type="text/x-mathjax-config">
 MathJax.Hub.Config({tex2jax: {inlineMath:[['$','$']]}});
 </script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #272822; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #272822, 0 0 5px #272822; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #272822;    /*上边框颜色*/
        border-left-color: #272822;    /*左边框颜色*/
    }
</style>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>




  <meta name="keywords" content="Swift,Thread," />



  <link rel="alternate" href="/atom.xml" title="程序员说" type="application/atom+xml" />



  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description" content="&amp;lt;!-- DevTalking Banner1 --&amp;gt;


(adsbygoogle = window.adsbygoogle || []).push({});



本文首发CSDN，如需转载请与CSDN联系。

记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文">
<meta property="og:type" content="article">
<meta property="og:title" content="读 Threading Programming Guide 笔记（四）">
<meta property="og:url" content="http://www.devtalking.com/articles/read-threading-programming-guide-4/index.html">
<meta property="og:site_name" content="程序员说">
<meta property="og:description" content="&amp;lt;!-- DevTalking Banner1 --&amp;gt;


(adsbygoogle = window.adsbygoogle || []).push({});



本文首发CSDN，如需转载请与CSDN联系。

记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文">
<meta property="og:updated_time" content="2016-08-19T01:01:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读 Threading Programming Guide 笔记（四）">
<meta name="twitter:description" content="&amp;lt;!-- DevTalking Banner1 --&amp;gt;


(adsbygoogle = window.adsbygoogle || []).push({});



本文首发CSDN，如需转载请与CSDN联系。

记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> 读 Threading Programming Guide 笔记（四） | 程序员说 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?980738dc41a50d91861a17ad4b768a1f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>


  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">程序员说</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                读 Threading Programming Guide 笔记（四）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-02-22T00:00:00+08:00" content="2016-02-22">
              2016-02-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/read-threading-programming-guide-4/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/read-threading-programming-guide-4/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/56726" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文章中有对官方文档的翻译，也有自己的理解，官方文档中代码片段的示例在这篇文章中都进行了完整的重写，还有一些文档中没有的代码示例，并且都使用Swift完成，给大家一些Objc与Swift转换的参考。<br>官方文档地址：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></p>
</blockquote>
<h2 id="u914D_u7F6ETimer_u4E8B_u4EF6_u6E90"><a href="#u914D_u7F6ETimer_u4E8B_u4EF6_u6E90" class="headerlink" title="配置Timer事件源"></a>配置Timer事件源</h2><p>配置Timer事件源拢共分几步？很简单，大体只有两步，先创建Timer对象，然后将其添加至Run Loop中。在Cocoa框架和Core Foundation框架中都提供了相关的对象和接口，在Cocoa框架中，它为我们提供了<code>NSTimer</code>类，该类有两个类方法，可以让我们很方便的在当前线程的Run Loop中配置Timer事件源：</p>
<ul>
<li><code>scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</code>：该方法有五个参数分别是执行事件消息时间间隔、接收事件消息的目标对象、事件消息、发送给事件消息的参数、是否重复执行标识。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(<span class="number">0.5</span>, target: <span class="keyword">self</span>, selector: <span class="string">"fireTimer:"</span>, userInfo: <span class="string">"This is a arg"</span>, repeats: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">fireTimer</span><span class="params">(sender: NSTimer)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Fire timer...<span class="subst">\(sender.userInfo <span class="keyword">as</span>! String)</span>"</span>)</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>scheduledTimerWithTimeInterval:invocation:repeats:</code>：该方法有三个参数，分别是执行事件消息事件间隔、<code>NSInvocation</code>对象、是否重复执行标识。这里说一下<code>NSInvocation</code>类，该类的作用是静态渲染消息，说的简单粗暴一点，那就是该类表示某个对象中的某个方法，以及该方法的一个或多个参数和返回值,当我们需要发送有多个参数或者有返回值的消息时就可以用这个类。但是在Swift中无法使用这个类，这里就不做过多说明了。</li>
</ul>
<p>以上两个类方法所添加的Timer事件源都只能添加在当前线程的Run Loop中，并且是在默认的Run Loop模式下(<code>NSDefaultRunLoopMode</code>)，如果我们想将Timer事件源添加至其他线程Run Loop的其他模式下，那么就需要创建<code>NSTimer</code>对象，并使用<code>NSRunLoop</code>的<code>addTimer:forMode:</code>方法添加创建好的<code>NSTimer</code>对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomThread</span>: <span class="title">NSThread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> myTimer: <span class="type">NSTimer</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(myTimer: <span class="type">NSTimer</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.myTimer = myTimer</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        autoreleasepool&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> runloop = <span class="type">NSRunLoop</span>.currentRunLoop()</span><br><span class="line">            </span><br><span class="line">            runloop.addTimer(<span class="keyword">self</span>.myTimer, forMode: <span class="type">NSRunLoopCommonModes</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="type">NSThread</span>.isMultiThreaded())</span><br><span class="line">            </span><br><span class="line">            runloop.runUntilDate(<span class="type">NSDate</span>(timeIntervalSinceNow: <span class="number">5</span>))</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">testTimerSource</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> fireTimer = <span class="type">NSDate</span>(timeIntervalSinceNow: <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> myTimer = <span class="type">NSTimer</span>(fireDate: fireTimer, interval: <span class="number">0.5</span>, target: <span class="keyword">self</span>, selector: <span class="string">"timerTask"</span>, userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> customThread = <span class="type">CustomThread</span>(myTimer: myTimer)</span><br><span class="line">        </span><br><span class="line">        customThread.start()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">timerTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Fire timer..."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.testTimerSource()</span><br></pre></td></tr></table></figure>
<p>在Core Foundation框架中，也为我们提供了一系列相关的类和方法为Run Loop添加Timer事件源，我们一起来看看：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">testCFTimerSource</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> cfRunloop = <span class="type">CFRunLoopGetCurrent</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> cfRunloopTimerContext = <span class="type">CFRunLoopTimerContext</span>(version: <span class="number">0</span>, info: <span class="built_in">unsafeBitCast</span>(<span class="keyword">self</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>), retain: <span class="literal">nil</span>, release: <span class="literal">nil</span>, copyDescription: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> cfRunloopTimer = <span class="type">CFRunLoopTimerCreate</span>(kCFAllocatorDefault, <span class="number">1</span>, <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0</span>, cfRunloopTimerCallback(), &amp;cfRunloopTimerContext)</span><br><span class="line">        </span><br><span class="line">        <span class="type">CFRunLoopAddTimer</span>(cfRunloop, cfRunloopTimer, kCFRunLoopDefaultMode)</span><br><span class="line">        </span><br><span class="line">        <span class="type">CFRunLoopRun</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">cfRunloopTimerCallback</span><span class="params">()</span></span> -&gt; <span class="type">CFRunLoopTimerCallBack</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123; (cfRunloopTimer, info) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Fire timer..."</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.testCFTimerSource()</span><br></pre></td></tr></table></figure>
<h2 id="u914D_u7F6E_u57FA_u4E8E_u7AEF_u53E3_u7684_u4E8B_u4EF6_u6E90"><a href="#u914D_u7F6E_u57FA_u4E8E_u7AEF_u53E3_u7684_u4E8B_u4EF6_u6E90" class="headerlink" title="配置基于端口的事件源"></a>配置基于端口的事件源</h2><p>Cocoa框架和Core Foundation框架都提供了创建配置基于端口事件源的类和方法，下面我们来看看如何使用Cocoa框架创建基于端口的事件源以及配置使用该类事件源。</p>
<h3 id="u4F7F_u7528NSMachPort_u5BF9_u8C61"><a href="#u4F7F_u7528NSMachPort_u5BF9_u8C61" class="headerlink" title="使用NSMachPort对象"></a>使用NSMachPort对象</h3><p><code>NSMachPort</code>对象是什么呢？其实就是线程与线程之间通信的桥梁，我们创建一个<code>NSMachPort</code>对象，将其添加至主线程的Run Loop中，然后我们在二级线程执行的任务中就可以获取并使用该对象向主线程发送消息，也就是说这种方式是将<code>NSMachPort</code>对象在不同线程中相互传递从而进行消息传递的。</p>
<h4 id="u5728_u4E3B_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort"><a href="#u5728_u4E3B_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort" class="headerlink" title="在主线程中创建配置NSMachPort"></a>在主线程中创建配置NSMachPort</h4><p>因为<code>NSMachPort</code>只能在OS X系统中使用，所以我们需要创建一个OS X应用的工程我们先来看看代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Cocoa</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">NSViewController</span>, <span class="title">NSMachPortDelegate</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> printMessageId = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> mainThreadPort = <span class="type">NSMachPort</span>()</span><br><span class="line">        </span><br><span class="line">        mainThreadPort.setDelegate(<span class="keyword">self</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSRunLoop</span>.currentRunLoop().addPort(mainThreadPort, forMode: <span class="type">NSDefaultRunLoopMode</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> workerClass = <span class="type">WorkerClass</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"launchThreadWithPort:"</span>, toTarget: workerClass, withObject: mainThreadPort)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: NSPortDelegate Method</span></span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">handlePortMessage</span><span class="params">(message: NSPortMessage)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看到<code>ViewController</code>类遵循了<code>NSMachPortDelegate</code>协议，因为它要作为<code>NSMachPort</code>的代理类，通过<code>NSMachPortDelegate</code>的<code>handlePortMessage:</code>方法处理来自二级线程的消息。</p>
<p>在<code>viewDidLoad</code>方法中我们先是创建了<code>NSMachPort</code>对象的实例，接着设置它的代理，然后使用<code>NSRunLoop</code>的<code>addPort:forMode:</code>方法将创建好的端口对象添加至主线程的Run Loop中，最后通过<code>NSThread</code>的<code>detachNewThreadSelector:toTarget:withObject:</code>方法创建二级线程，并让该二级线程执行<code>WorkerClass</code>类中的<code>launchThreadWithPort:</code>方法，同时将刚才创建好的端口对象作为参数传给该方法，也就是将主线程中的端口对象传到了二级线程中。下面来看看<code>handlePortMessage:</code>中应该如何处理接收到的消息：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">handlePortMessage</span><span class="params">(message: NSPortMessage)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> messageId = message.msgid</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> messageId == <span class="type">UInt32</span>(printMessageId) &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Receive the message that id is 1000 and this is a print task."</span>)</span><br><span class="line">            </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// Handle other messages</span></span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过端口传递的消息可以根据消息编号判断该执行什么样的任务，所以该方法中通过<code>NSPortMessage</code>对象获取到消息id然后进行判断并执行相应的任务，消息id在二级线程通过端口向主线程发送消息时可以设置。</p>
<h4 id="u5728_u4E8C_u7EA7_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort"><a href="#u5728_u4E8C_u7EA7_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort" class="headerlink" title="在二级线程中创建配置NSMachPort"></a>在二级线程中创建配置NSMachPort</h4><p>首先二级线程中与主线程中一样，都需要创建端口对象、设置代理、将端口对象添加至当前线程的Run Loop中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Cocoa</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerClass</span>: <span class="title">NSObject</span>, <span class="title">NSMachPortDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launchThreadWithPort</span><span class="params">(port: NSMachPort)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        autoreleasepool&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> secondaryThreadPort = <span class="type">NSMachPort</span>()</span><br><span class="line">            </span><br><span class="line">            secondaryThreadPort.setDelegate(<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> runloop = <span class="type">NSRunLoop</span>.currentRunLoop()</span><br><span class="line">            </span><br><span class="line">            runloop.addPort(secondaryThreadPort, forMode: <span class="type">NSDefaultRunLoopMode</span>)</span><br><span class="line">            </span><br><span class="line">            sendPrintMessage(port, receivePort: secondaryThreadPort)</span><br><span class="line">            </span><br><span class="line">            runloop.runMode(<span class="type">NSDefaultRunLoopMode</span>, beforeDate: <span class="type">NSDate</span>(timeIntervalSinceNow: <span class="number">500</span>))</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">sendPrintMessage</span><span class="params">(sendPort: NSMachPort, receivePort: NSMachPort)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// MARK: NSPortDelegate Method</span></span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">handlePortMessage</span><span class="params">(message: NSPortMessage)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建并配置好端口后就需要向主线程发送消息了，下面我们来看看<code>sendPrintMessage:receivePort:</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sendPrintMessage</span><span class="params">(sendPort: NSMachPort, receivePort: NSMachPort)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">let</span> portMessage = <span class="type">NSPortMessage</span>(sendPort: sendPort, receivePort: receivePort, components: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">    portMessage.msgid = <span class="type">UInt32</span>(<span class="number">1000</span>)</span><br><span class="line">        </span><br><span class="line">    portMessage.sendBeforeDate(<span class="type">NSDate</span>(timeIntervalSinceNow: <span class="number">1</span>))</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先需要创建<code>NSPortMessage</code>对象，该对象就是端口之间相互传递的介质，初始化方法的第一个参数为主线程的端口对象，也就是发送消息的目标端口，第二个参数是二级线程的端口对象，第三个参数的作用是向主线程发送需要的数据，该参数的类型是<code>AnyObject</code>的数组。</p>
<p>创建完消息对象后，要给该消息设置消息id，以便主线程接收后进行判断，最后通过<code>sendBeforeDate:</code>方法发送消息。</p>
<h2 id="u7EBF_u7A0B_u5B89_u5168_u673A_u5236"><a href="#u7EBF_u7A0B_u5B89_u5168_u673A_u5236" class="headerlink" title="线程安全机制"></a>线程安全机制</h2><p>在前文中提到过，在应用中使用多线程势必会给增加我们编写代码的工作量，而且会带来一些潜在的问题，最大的问题就是资源竞争的问题，多个线程同时访问资源或者重复更改资源。如果我们足够幸运，这些问题会使应用产生比较明显的异常现象，那我们尚可发现并修复，但是如果这些问题产生的影响不那么明显，或者说只有在应用做一些特定操作才会发生异常，而我们又没测到时就会给我们带来大麻烦。</p>
<p>或许我们可以让每个线程之间都不进行交互，没个线程都有独有资源，从而避免资源竞争问题的发生，但是这并不是长远之计，很多情况下线程之间必须要进行交互，这时我们就需要更好的设计模式或者工具策略来避免这类问题的发生。所幸的是OS X和iOS系统已经提供了多种线程安全的方法，这一节让我们来看看如何使用它们。</p>
<h3 id="u539F_u5B50_u64CD_u4F5C_uFF08Atomic_Operations_uFF09"><a href="#u539F_u5B50_u64CD_u4F5C_uFF08Atomic_Operations_uFF09" class="headerlink" title="原子操作（Atomic Operations）"></a>原子操作（Atomic Operations）</h3><p>原子操作是最简单也是最基本的保证线程安全的方法，原子的本意是<strong>不能被分裂的最小粒子</strong>，故原子操作是<strong>不可被中断的一个或一系列操作</strong>。从处理器角度来说原子操作是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址，从应用层面来说就是当一个线程对共享变量进行操作时，其他线程不能对该变量进行操作，并且其他线程不会被阻塞。</p>
<p>举个简单的例子，有一个共享变量<code>i</code>，初始值是1，现在我们对它进行两次<code>i++</code>的操作，期望值是3，但是在多核CPU的情况下就有可能是CPU1对<code>i</code>进行了一次<code>i++</code>操作，CPU2对<code>i</code>进行了一次<code>i++</code>操作，所以结果就并不是我们期望的值3，而是2，因为CPU1和CPU2同时从各自的缓存中读取变量<code>i</code>，分别进行加一操作，然后分别写入系统内存当中。那么想要保证读改写共享变量的操作是原子的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存。在我们使用原子操作时首先应将变量申明为原子类型（<code>atomic_t</code>），然后根据内核提供的原子操作API对变量进行操作，比如给原子类型的变量<code>v</code>增加值<code>i</code>的函数<code>void atomic_add(int i, atomic_t *v);</code>等。OS X和iOS也提供了一些数学运算和逻辑运算的原子操作供我们使用，这里就不深入说明了，大家如果有兴趣可以去官方文档找找。</p>
<h3 id="u5185_u5B58_u5C4F_u969C_uFF08Memory_Barriers_uFF09_u548C_u53EF_u89C1_u53D8_u91CF_uFF08Volatile_Variables_uFF09"><a href="#u5185_u5B58_u5C4F_u969C_uFF08Memory_Barriers_uFF09_u548C_u53EF_u89C1_u53D8_u91CF_uFF08Volatile_Variables_uFF09" class="headerlink" title="内存屏障（Memory Barriers）和可见变量（Volatile Variables）"></a>内存屏障（Memory Barriers）和可见变量（Volatile Variables）</h3><p>CPU对内存的操作无非就是读和写，我们虽然知道CPU对内存进行了操作，但是我们无法决定在一系列CPU对内存的操作时单个操作指令的顺序，这些顺序完全由CPU随性而来。举个例子，在有两个CPU的情况下，现在有四个指令待操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">A</span> = <span class="number">1</span>; x = <span class="type">A</span>;</span><br><span class="line"><span class="type">B</span> = <span class="number">2</span>; y = <span class="type">B</span>;</span><br></pre></td></tr></table></figure>
<p>这四个指令的执行顺序就可能有24种不同的组合。所以内存屏障就是一个帮助CPU规定操作指令顺序的手段，它将内存操作隔开，给屏障两侧的内存操作强加一个顺序关系，比如所有该屏障之前的写操作和读操作必须在该屏障之后的写操作和读操作之前执行。</p>
<p>可见变量是另一个确保共享变量被多个线程操作后仍能保持正确结果的机制，CPU为了提高处理速度，通常情况下不会直接与主存打交道，而是先将系统主存中的数据读到缓存中，当从缓存中读取到共享变量，对其进行操作后又不会立即写回主存，所以如果其他CPU也要操作该共享变量，就很有可能读到它的旧值。但是当我们在申明共享变量时加上<code>volatile</code>关键字，将其申明为可见变量时就可以避免这种情况，因为CPU从缓存中读取并修改可见共享变量后会立即写回主存，而且其他CPU在操作之前会先判断缓存中的数据是否已过期，如果过期那么从主存中重新缓存，这样一来可见变量在每个CPU操作时都能保证是最新值。但需要注意的是内存屏障和可见变量都会降低编译器的性能，所以没有必须要使用的情况时不要滥用这两个机制。</p>
<h3 id="u9501_u673A_u5236"><a href="#u9501_u673A_u5236" class="headerlink" title="锁机制"></a>锁机制</h3><p>锁机制在大多数编程语言中都是很常用的线程安全机制，你可以在关键的代码前后，或者只希望同时只能被一个线程执行的任务前后加上线程锁来避免因为多线程给程序造成不可预知的问题。OS X和iOS提供了多种锁的类型，下面让我们来看一看：</p>
<ul>
<li>互斥锁（Mutex）：互斥锁扮演的角色就是代码或者说任务的栅栏，它将你希望保护的代码片段围起来，当其他线程也试图执行这段代码时会被互斥锁阻塞，直到互斥锁被释放，如果多个线程同时竞争一个互斥锁，有且只有一个线程可以获得互斥锁。</li>
<li>递归锁（Recursive lock）：递归锁是互斥锁的变种。它允许一个线程在已经拥有一个锁，并且没有释放的前提下再次获得锁。当该线程释放锁时也需要一个一个释放。</li>
<li>读写锁（Read-write lock）：读写锁一般用在有资源被多个线程频繁的进行读操作，而只偶尔会有专职线程对该资源进行写操作的情况下。读写锁可被多个进行读操作的线程获得，但只能被一个进行写操作的线程获得，当有读操作的线程等待时，写操作的线程就不能获得锁，反之亦然，当写操作的线程在等待时，读操作的线程就不能获得锁。</li>
<li>分配锁（Distributed lock）：这种锁作用在进程级别，将进程保护起来，但是该锁不会阻塞其他进程，而是当其他进程与被保护进程交互时分配锁会告知前来的访问进程被访问进程处于锁状态，让前来访问的进程自行决定下一个操作。</li>
<li>自旋锁（Spin lock）：自旋锁与互斥锁有点类似，但不同的是其他线程不会被自旋锁阻塞，而是而是在进程中空转，就是执行一个空的循环。一般用于自旋锁被持有时间较短的情况。</li>
<li>双检测锁（Double-checked lock）：这种锁的目的是为了最大限度推迟上锁的时间，因为在多线程中线程安全对开销还是挺大的，所以一般能不上锁就不上锁。所以这种锁在上锁之前会先检查一次是否需要上锁，在上锁之后再检查一次，最后才真正执行操作。</li>
</ul>
<h3 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h3><p>Conditions是一种多线程间协调通信的机制，它通常用于标明共享资源是否可被访问或者确保一系列任务能按照指定的执行顺序执行。如果一个线程试图访问一个共享资源，而正在访问该资源的线程将其条件设置为不可访问，那么该线程会被阻塞，直到正在访问该资源的线程将访问条件更改为可访问状态或者说给被阻塞的线程发送信号后，被阻塞的线程才能正常访问这个资源。后面会说明如何使用这种机制。</p>
<h2 id="u8BBE_u8BA1_u7EBF_u7A0B_u5B89_u5168_u9700_u8981_u6CE8_u610F_u7684_u4E8B_u9879"><a href="#u8BBE_u8BA1_u7EBF_u7A0B_u5B89_u5168_u9700_u8981_u6CE8_u610F_u7684_u4E8B_u9879" class="headerlink" title="设计线程安全需要注意的事项"></a>设计线程安全需要注意的事项</h2><p>诚然使用线程安全的各种机制可以是我们的程序更加健壮，不易出错，但是因为这些机制本身也会有较大的性能开销，如果滥用这些机制反而会严重影响到程序的性能。所以我们应该在线程安全和性能之间寻求到一个平衡点，这一节我们就来看看在设计线程安全时应该注意的事项。</p>
<h3 id="u907F_u514D_u6EE5_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236"><a href="#u907F_u514D_u6EE5_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236" class="headerlink" title="避免滥用线程安全机制"></a>避免滥用线程安全机制</h3><p>不论是新的项目还是已经有的项目，在设计逻辑代码或者属性时应该避免产生线程安全与不安全的问题。有效的避免措施就是减少逻辑代码之间的交互，或者说任务与任务之间的交互，线程与线程之间的交互，减少多线程中任务访问同一变量的情况，如果需要那么可以确保每个任务中都有该变量的拷贝，这样就可以有效避免对变量或者任务采取线程安全机制。虽然对变量进行拷贝也会消耗资源，但是我们应该要判断一下这与采用线程安全机制消耗的资源之间谁多谁少，从而做出正确的决定。</p>
<h3 id="u8BA4_u6E05_u4F7F_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236_u65F6_u7684_u9677_u9631"><a href="#u8BA4_u6E05_u4F7F_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236_u65F6_u7684_u9677_u9631" class="headerlink" title="认清使用线程安全机制时的陷阱"></a>认清使用线程安全机制时的陷阱</h3><p>在使用锁机制和内存屏障机制时我们往往需要考虑将它们设置在代码的哪个位置是最正确的，但是有些时候，你认为正确的位置不代表它真的正确，下面是一段伪代码片段，向我们揭示一个使用锁机制时容易发生的陷阱。假设有一个可变类型的数组<code>myArray</code>，但是该数组中的对象是不可变类型的对象<code>anObject</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSLock</span>* arrayLock = <span class="type">GetArrayLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">NSMutableArray</span>* myArray = <span class="type">GetSharedArray</span>(); </span><br><span class="line"></span><br><span class="line">id anObject;</span><br><span class="line"></span><br><span class="line">[arrayLock lock]; </span><br><span class="line"></span><br><span class="line">anObject = [myArray objectAtIndex:<span class="number">0</span>]; </span><br><span class="line"></span><br><span class="line">[arrayLock unlock];</span><br><span class="line"></span><br><span class="line">[anObject doSomething];</span><br></pre></td></tr></table></figure>
<p>上述代码片段中，对从<code>myArray</code>数组中获取第一个元素的操作加了锁，因为该数组是可变类型的，所以加锁防止其他线程同时操作该数组从而导致错误发生，又因为<code>anObject</code>是一个不可变类型对象，所以不需要担心其他线程会对其进行改变，所以调用<code>anObject</code>对象的<code>doSomething</code>方法时并没有加锁。</p>
<p>看起来这段代码的逻辑似乎没什么问题，但是凡事都架不住如果和万一，如果在<code>arrayLock</code>释放锁之后和<code>anObject</code>对象调用<code>doSomething</code>方法之前这区间里，另外一个线程清空了<code>myArray</code>里的元素，这时这段代码的结果会怎样呢？答案显然是因为当前类对<code>anObject</code>对象的引用被释放，<code>anObject</code>对象因为指向了错误的内存地址从而调用方法出错。所以为了避免这种小概率事件的发生，应该将<code>anObject</code>对象调用方法的操作也加上锁：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSLock</span>* arrayLock = <span class="type">GetArrayLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">NSMutableArray</span>* myArray = <span class="type">GetSharedArray</span>();</span><br><span class="line"></span><br><span class="line">id anObject;</span><br><span class="line"></span><br><span class="line">[arrayLock lock]; </span><br><span class="line"></span><br><span class="line">anObject = [myArray objectAtIndex:<span class="number">0</span>]; </span><br><span class="line"></span><br><span class="line">[anObject doSomething]; </span><br><span class="line"></span><br><span class="line">[arrayLock unlock];</span><br></pre></td></tr></table></figure>
<p>那么问题又来了，如果<code>doSomething</code>方法执行的时间很长，线程锁一直无法释放，那么又会对线程的性能产生很大影响。要想彻底解决问题，就要找到产生问题的关键点，在这个示例中产生问题的关键点就是<code>anObject</code>对象有可能被其他线程释放，所以解决问题的关键就是防止<code>anObject</code>对象被释放，我们来看看最终的解决方案：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">NSLock</span>* arrayLock = <span class="type">GetArrayLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">NSMutableArray</span>* myArray = <span class="type">GetSharedArray</span>(); </span><br><span class="line"></span><br><span class="line">id anObject;</span><br><span class="line"></span><br><span class="line">[arrayLock lock];</span><br><span class="line"></span><br><span class="line">anObject = [myArray objectAtIndex:<span class="number">0</span>]; </span><br><span class="line"></span><br><span class="line">[anObject retain]; </span><br><span class="line"></span><br><span class="line">[arrayLock unlock];</span><br><span class="line"></span><br><span class="line">[anObject doSomething]; </span><br><span class="line"></span><br><span class="line">[anObject release];</span><br></pre></td></tr></table></figure>
<h3 id="u9632_u6B62_u6B7B_u9501_u548C_u6D3B_u9501_u7684_u53D1_u751F"><a href="#u9632_u6B62_u6B7B_u9501_u548C_u6D3B_u9501_u7684_u53D1_u751F" class="headerlink" title="防止死锁和活锁的发生"></a>防止死锁和活锁的发生</h3><p>死锁的意思就是线程A和线程B各持有一把锁，现在线程A在等待线程B释放锁，而线程B又在等待线程A释放锁，所以这两个线程谁也拿不到锁，也不是释放自己持有的锁，就会永远被阻塞在进程中。</p>
<p>活锁的意思是线程A可以使用资源，但它很礼貌，让其他线程先使用资源，线程B也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源，导致活锁，活锁与死锁的区别在于前者的线程并没有被阻塞，而是在不停的做一些与任务无关的事。</p>
<p>产生死锁和活锁的根本原因是线程中持有多把锁，所以避免这两种情况发生的最好办法就是尽量让线程只持有一把锁，如果实在有需求要持有多把锁，那么也应该尽量避免其他线程来请求锁。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u6B63_u786E_u4F7F_u7528volatile_u5173_u952E_u5B57"><a href="#u6B63_u786E_u4F7F_u7528volatile_u5173_u952E_u5B57" class="headerlink" title="正确使用volatile关键字"></a>正确使用volatile关键字</h3><p>如果你已经使用的锁机制来保护一段代码逻辑，那么就不要使用<code>volatile</code>关键字来保护这段代码中使用的变量。上文中说过，可见变量机制会让代码每次从主存中加载读取变量而非缓存，本身就比较影响性能，如果再与锁机制结合，不但没有起到额外的保护作用，反而会严重影响程序的性能。所以如果使用了锁机制，那么可以完全省去使用可见变量机制，因为锁机制就已经可以很好的保护变量的线程安全性了，不需要多此一举。</p>
<h2 id="u4F7F_u7528_u539F_u5B50_u64CD_u4F5C"><a href="#u4F7F_u7528_u539F_u5B50_u64CD_u4F5C" class="headerlink" title="使用原子操作"></a>使用原子操作</h2><p>有些时候我们只希望一些数学运算或者简单的逻辑能够保证线程安全，如果使用锁机制或者条件机制虽然可以实现，但是会耗费较大的资源开销，并且锁机制还会使线程阻塞，造成性能损失，非常不划算，所以当遇到这种情况时，我们可以尝试使用原子操作来达到目的。</p>
<p>我们一般使用原子操作对32位和64位的值执行一些数学运算或简单的逻辑运算，主要依靠底层的硬件指令或者使用内存屏障确保正在执行的操作是线程安全的，下面我们来看看Apple给我们提供了哪些原子操作的方法：</p>
<h3 id="Add_u64CD_u4F5C"><a href="#Add_u64CD_u4F5C" class="headerlink" title="Add操作"></a>Add操作</h3><p>Add操作是将两个整数相加，并将结果存储在其中一个变量中：</p>
<ul>
<li><code>OSAtomicAdd32(__theAmount: Int32, _ __theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicAdd32Barrier(__theAmount: Int32, _ __theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicAdd64(__theAmount: Int64, _ __theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
<li><code>OSAtomicAdd64Barrier(__theAmount: Int64, _ __theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="type">Int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="type">OSAtomicAdd64</span>(<span class="number">20</span>, &amp;num)</span><br><span class="line">        </span><br><span class="line"><span class="type">OSAtomicAdd64Barrier</span>(<span class="number">20</span>, &amp;num)</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(num)</span>"</span>) <span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<h3 id="Increment_u64CD_u4F5C"><a href="#Increment_u64CD_u4F5C" class="headerlink" title="Increment操作"></a>Increment操作</h3><p>Increment操作将指定值加1：</p>
<ul>
<li><code>OSAtomicIncrement32(__theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicIncrement32Barrier(__theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicIncrement64(__theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
<li><code>OSAtomicIncrement64Barrier(__theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="type">Int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="type">OSAtomicIncrement64</span>(&amp;num)</span><br><span class="line">        </span><br><span class="line"><span class="type">OSAtomicIncrement64Barrier</span>(&amp;num)</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(num)</span>"</span>) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<h3 id="Decrement_u64CD_u4F5C"><a href="#Decrement_u64CD_u4F5C" class="headerlink" title="Decrement操作"></a>Decrement操作</h3><p>Decrement操作将指定值减1:</p>
<ul>
<li><code>OSAtomicDecrement32(__theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicDecrement32Barrier(__theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicDecrement64(__theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
<li><code>OSAtomicDecrement64Barrier(__theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Int64</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="type">Int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="type">OSAtomicDecrement64</span>(&amp;num)</span><br><span class="line">        </span><br><span class="line"><span class="type">OSAtomicDecrement64Barrier</span>(&amp;num)</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(num)</span>"</span>) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<h3 id="OR_u903B_u8F91_u8FD0_u7B97_u3001AND_u903B_u8F91_u8FD0_u7B97_u3001XOR_u903B_u8F91_u8FD0_u7B97"><a href="#OR_u903B_u8F91_u8FD0_u7B97_u3001AND_u903B_u8F91_u8FD0_u7B97_u3001XOR_u903B_u8F91_u8FD0_u7B97" class="headerlink" title="OR逻辑运算、AND逻辑运算、XOR逻辑运算"></a>OR逻辑运算、AND逻辑运算、XOR逻辑运算</h3><p>对两个32位数值中的位置相同的位执行按位比较：</p>
<ul>
<li><code>OSAtomicOr32(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicOr32Barrier(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicAnd32(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicAnd32Barrier(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicXor32(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
<li><code>OSAtomicXor32Barrier(__theMask: UInt32, _ __theValue: UnsafeMutablePointer&lt;UInt32&gt;) -&gt; Int32</code></li>
</ul>
<h3 id="CAS_u64CD_u4F5C"><a href="#CAS_u64CD_u4F5C" class="headerlink" title="CAS操作"></a>CAS操作</h3><p>CAS操作是比较与交换（Compare and Swap）操作，有三个参数分别是旧值、新值、想要比较的值的内存地址，整个过程是先将你期望的旧值与指定的内存地址中的值进行比较，如果相同，那么将该内存地址的值更新为指定的新值，并返回<code>true</code>，如果比较后发现不同，那么不再做任何操作，并返回<code>false</code>，Apple提供了不同类型的CAS原子操作：</p>
<ul>
<li><code>OSAtomicCompareAndSwap32(__oldValue: Int32, _ __newValue: Int32, _ __theValue: UnsafeMutablePointer&lt;Int32&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicCompareAndSwap64(__oldValue: Int64, _ __newValue: Int64, _ __theValue: UnsafeMutablePointer&lt;Int64&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicCompareAndSwapPtr(__oldValue: UnsafeMutablePointer&lt;Void&gt;, _ __newValue: UnsafeMutablePointer&lt;Void&gt;, _ __theValue: UnsafeMutablePointer&lt;UnsafeMutablePointer&lt;Void&gt;&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicCompareAndSwapLong(__oldValue: Int, _ __newValue: Int, _ __theValue: UnsafeMutablePointer&lt;Int&gt;) -&gt; Bool</code></li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num: <span class="type">Int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="type">OSAtomicCompareAndSwap64</span>(<span class="number">10</span>, <span class="number">20</span>, &amp;num)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(num)</span>"</span>) <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num: <span class="type">Int64</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="type">OSAtomicCompareAndSwap64</span>(<span class="number">11</span>, <span class="number">20</span>, &amp;num)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(num)</span>"</span>) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="u6BD4_u7279_u4F4D_u8BBE_u7F6E_u64CD_u4F5C"><a href="#u6BD4_u7279_u4F4D_u8BBE_u7F6E_u64CD_u4F5C" class="headerlink" title="比特位设置操作"></a>比特位设置操作</h3><p>将给定比特位的值设置位1或者0:</p>
<ul>
<li><code>OSAtomicTestAndSet(__n: UInt32, _ __theAddress: UnsafeMutablePointer&lt;Void&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicTestAndSetBarrier(__n: UInt32, _ __theAddress: UnsafeMutablePointer&lt;Void&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicTestAndClear(__n: UInt32, _ __theAddress: UnsafeMutablePointer&lt;Void&gt;) -&gt; Bool</code></li>
<li><code>OSAtomicTestAndClearBarrier(__n: UInt32, _ __theAddress: UnsafeMutablePointer&lt;Void&gt;) -&gt; Bool</code></li>
</ul>
<h2 id="u4F7F_u7528_u9501_u673A_u5236"><a href="#u4F7F_u7528_u9501_u673A_u5236" class="headerlink" title="使用锁机制"></a>使用锁机制</h2><p>锁机制是多线程编程中最常用的也是最基本的确保线程安全的机制，它能有效的保证多行逻辑代码的线程安全性。OS X和iOS系统为我们提供了基本的互斥锁和基于互斥锁变异的特殊锁以应对不同的情况。这一节我们来看看如何使用锁机制。</p>
<h3 id="POSIX_u4E92_u65A5_u9501"><a href="#POSIX_u4E92_u65A5_u9501" class="headerlink" title="POSIX互斥锁"></a>POSIX互斥锁</h3><p>前文中说过，POSIX是可移植操作系统接口（Portable Operating System Interface of UNIX），它定义了操作系统应该为应用程序提供的接口标准，在类Unix系统中都可以使用。使用POSIX互斥锁很简单，先申明互斥锁指针，类型为<code>UnsafeMutablePointer&lt;pthread_mutex_t&gt;</code>，然后通过<code>pthread_mutex_init</code>函数初始化互斥锁，最后通过<code>pthread_mutex_lock</code>函数和<code>pthread_mutex_unlock</code>函数上锁和释放锁：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> mutex: <span class="type">UnsafeMutablePointer</span>&lt;pthread_mutex_t&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        mutex = <span class="type">UnsafeMutablePointer</span>.alloc(<span class="built_in">sizeof</span>(pthread_mutex_t))</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">posixMutexLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_init(mutex, <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_lock(mutex)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Do work..."</span>)</span><br><span class="line">        </span><br><span class="line">        pthread_mutex_unlock(mutex)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textLock = <span class="type">TestLock</span>()</span><br><span class="line">textLock.posixMutexLock()</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528NSLock"><a href="#u4F7F_u7528NSLock" class="headerlink" title="使用NSLock"></a>使用NSLock</h3><p>在Cocoa框架中，我们可以使用<code>NSLock</code>来实现锁机制，该类遵循了<code>NSLocking</code>协议，并实现了加锁和释放锁的方法。</p>
<p>在<code>NSLock</code>中有两个加锁的方法：</p>
<ul>
<li><code>tryLock</code>：该方法使当前线程试图去获取锁，并返回布尔值表示是否成功，但是当获取锁失败后并不会使当前线程阻塞。</li>
<li><code>lockBeforeDate</code>：该方法与上面的方法类似，但是只有在设置的时间内获取锁失败线程才不会被阻塞，如果获取锁失败时已超出了设置的时间，那么当前线程会被阻塞。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> nslock: <span class="type">NSLock</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        nslock = <span class="type">NSLock</span>()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">acquireLock</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        nslock.tryLock()</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        nslock.lockBeforeDate(NSDate(timeIntervalSinceNow: 10))</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Do work..."</span>)</span><br><span class="line">        </span><br><span class="line">        nslock.unlock()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textLock = <span class="type">TestLock</span>()</span><br><span class="line">textLock.acquireLock()</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528NSRecursiveLock"><a href="#u4F7F_u7528NSRecursiveLock" class="headerlink" title="使用NSRecursiveLock"></a>使用NSRecursiveLock</h3><p>上文中介绍了几种锁的类型，其中一种叫递归锁，在Cocoa中对应的类是<code>NSRecursiveLock</code>，我们来看看如何使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> nsRecursiveLock: <span class="type">NSRecursiveLock</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        nsRecursiveLock = <span class="type">NSRecursiveLock</span>()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">recursiveFunction</span><span class="params">(<span class="keyword">var</span> value: Int)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        nsRecursiveLock.lock()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> value != <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">            --value</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"<span class="subst">\(value)</span>"</span>)</span><br><span class="line">            </span><br><span class="line">            recursiveFunction(value)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        nsRecursiveLock.unlock()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textLock = <span class="type">TestLock</span>()</span><br><span class="line">textLock.recursiveFunction(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528NSConditionLock"><a href="#u4F7F_u7528NSConditionLock" class="headerlink" title="使用NSConditionLock"></a>使用NSConditionLock</h3><p>条件锁也是互斥锁的一种变种，在Cocoa框架中对应的类是<code>NSConditionLock</code>，条件锁顾名思义可以设置加锁和释放锁的条件。假设我们有一个消息队列，并且有消息生产者和消息消费者，那么一般情况是当消息生产者产生消息，放入消息队列，然后消息消费者从消息队列中获取消息，并将其从消息队列移除进行后续操作。那么消费者在获取消息和移除消息时要确保两点先决条件，第一就是获取消息时队列中确实已有消息，第二就是此时生产者不能向队列中添加消息，否则会影响消息队列中消息的顺序或者影响获取到消息的结果，所以在这种情况下我们就可以使用条件锁来保证他们的线程安全：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> nsConditionLock: <span class="type">NSConditionLock</span></span><br><span class="line">    <span class="keyword">var</span> messageQueue = [<span class="type">AnyObject</span>]()</span><br><span class="line">    <span class="keyword">let</span> <span class="type">HAS_MESSAGES</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> <span class="type">NO_MESSAGES</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        nsConditionLock = <span class="type">NSConditionLock</span>(condition: <span class="type">NO_MESSAGES</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">produceMessage</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"consumeMessage"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">            </span><br><span class="line">            nsConditionLock.lock()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 生产消息并添加到消息队列中</span></span><br><span class="line">            </span><br><span class="line">            nsConditionLock.unlockWithCondition(<span class="type">HAS_MESSAGES</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">consumeMessage</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">            </span><br><span class="line">            nsConditionLock.lockWhenCondition(<span class="type">HAS_MESSAGES</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从消息队列中获取消息并从队列中移除消息</span></span><br><span class="line">            </span><br><span class="line">            nsConditionLock.unlockWithCondition(messageQueue.isEmpty ? <span class="type">NO_MESSAGES</span> : <span class="type">HAS_MESSAGES</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> textLock = <span class="type">TestLock</span>()</span><br><span class="line">textLock.produceMessage()</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528@synchronized_u5173_u952E_u5B57"><a href="#u4F7F_u7528@synchronized_u5173_u952E_u5B57" class="headerlink" title="使用@synchronized关键字"></a>使用@synchronized关键字</h3><p>在Objective-C中，我们会经常使用<code>@synchronized</code>关键字来修饰变量，确保变量的线程安全，它能自动为修饰的变量创建互斥锁或解锁：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">- (void)myMethod:(id)anObj &#123; </span><br><span class="line"></span><br><span class="line">    @synchronized(anObj) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在该作用域中，anObj不会被其他线程改变 </span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码片段中可以看到<code>myMethod:</code>方法的<code>anObj</code>参数在被<code>@synchronized</code>关键字修饰的作用域中是线程安全的。而且使用该关键字还有一个好处，那就是当有多个线程要同时执行一个带参数的方法，但不同线程中传递的参数不同，如果用<code>NSLock</code>将该方法中的逻辑代码上锁，那么就只能有一个线程获得锁，而其他线程就会被阻塞，如果使用<code>@synchronized</code>关键字就可以避免其他线程被阻塞的情况。</p>
<p>但在Swift中，Apple不知出于什么考虑，这个关键字已经不存在了，也就是我们不能在Swift中使用这个关键字对变量加锁了，但关键字都是语法糖，虽然不能使用语法糖，但还是可以使用其背后的机制的，我们来看看objc_sync的源码，看看这个关键字都干了些什么：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Begin synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Allocates recursive mutex associated with 'obj' if needed.</span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line">int objc_sync_enter(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = <span class="type">OBJC_SYNC_SUCCESS</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="type">SyncData</span>* data = id2data(obj, <span class="type">ACQUIRE</span>);</span><br><span class="line">        <span class="built_in">assert</span>(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">DebugNilSync</span>) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// End synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line">int objc_sync_exit(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    int result = <span class="type">OBJC_SYNC_SUCCESS</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="type">SyncData</span>* data = id2data(obj, <span class="type">RELEASE</span>); </span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = <span class="type">OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bool okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = <span class="type">OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见<code>@synchronized</code>关键字其实是调用了<code>objc_sync_enter</code>和<code>objc_sync_exit</code>这两个方法，所以在Swift中使用时可以这样给变量加锁：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">(anObj: AnyObject!)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    objc_sync_enter(anObj)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// anObj参数在这两个方法之间具有线程安全特性，不会被其他线程改变</span></span><br><span class="line"></span><br><span class="line">    objc_sync_exit(anObj)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u4F7F_u7528Condition_u673A_u5236"><a href="#u4F7F_u7528Condition_u673A_u5236" class="headerlink" title="使用Condition机制"></a>使用Condition机制</h2><p>Condition机制和锁机制很类似，区别也不大，同样都会使线程阻塞，这一节我们来看看如何使用该机制。</p>
<h3 id="u4F7F_u7528NSCondition_u7C7B"><a href="#u4F7F_u7528NSCondition_u7C7B" class="headerlink" title="使用NSCondition类"></a>使用NSCondition类</h3><p>这里举个生产者和消费者的例子，消费者从队列中获取产品进行消费，当队列中没有产品时消费者等待生产者生产，当生产者生产出产品放入队列后再通知消费者继续进行消费：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> products: [<span class="type">AnyObject</span>]</span><br><span class="line">    <span class="keyword">let</span> nscondition: <span class="type">NSCondition</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        </span><br><span class="line">        products = [<span class="type">AnyObject</span>]()</span><br><span class="line">        </span><br><span class="line">        nscondition = <span class="type">NSCondition</span>()</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"consumeProduct"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"generateProduct"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">consumeProduct</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        nscondition.lock()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> products.<span class="built_in">count</span> == <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            nscondition.wait()</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> product = products[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        products.removeAtIndex(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"消费产品"</span>)</span><br><span class="line">        </span><br><span class="line">        nscondition.unlock()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">generateProduct</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        nscondition.lock()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> product = <span class="type">NSObject</span>()</span><br><span class="line">        </span><br><span class="line">        products.append(product)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"生产产品"</span>)</span><br><span class="line">        </span><br><span class="line">        nscondition.signal()</span><br><span class="line">        </span><br><span class="line">        nscondition.unlock()</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码中可以看到，<code>NSCondition</code>类同样是用<code>lock</code>和<code>unlock</code>方法进行上锁和释放锁，然后通过<code>wait</code>方法阻塞线程，通过<code>signal</code>方法唤醒阻塞的线程，该方法唤醒的时最近一次使用<code>wait</code>方法等待的线程。如果想一次性唤醒所有在等待的线程，可以使用<code>broadcast</code>方法。<code>NSCondition</code>还有另外一个阻塞线程的方法<code>waitUntilDate(_ limit: NSDate)</code>，该方法设置一个线程阻塞时间并返回一个布尔值，如果在指定的时间内没有信号量的通知，那么就唤醒线程继续进行，此时该方法返回<code>false</code>，如果在指定时间内接收到信号量的通知，此时该方法返回<code>true</code>。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Swift/" rel="tag">#Swift</a>
          
            <a href="/tags/Thread/" rel="tag">#Thread</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/articles/read-threading-programming-guide-3/" rel="next" title="读 Threading Programming Guide 笔记（三）">
                <i class="fa fa-chevron-left"></i> 读 Threading Programming Guide 笔记（三）
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/articles/read-concurrency-programming-guide-1/" rel="prev" title="读 Concurrency Programming Guide 笔记（一）">
                读 Concurrency Programming Guide 笔记（一） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!--MOB SHARE BEGIN-->
<div class="-hoofoo-share-title">分享到：</div>
<div class="-hoofoo-share-buttons">
    <div class="-mob-share-weibo -hoofoo-share-weibo -hoofoo-share-ui-button"><i class="fa fa-weibo" aria-hidden="true"></i></div>
    <div class="-mob-share-weixin -hoofoo-share-weixin -hoofoo-share-ui-button"><i class="fa fa-weixin" aria-hidden="true"></i></div>
    <div class="-mob-share-twitter -hoofoo-share-twitter -hoofoo-share-ui-button"><i class="fa fa-twitter" aria-hidden="true"></i></div>
    <div class="-hoofoo-share-more -hoofoo-share-ui-button -mob-share-open"><i class="fa fa-ellipsis-h" aria-hidden="true"></i></div>
</div><div class="-mob-share-ui -mob-share-ui-theme -mob-share-ui-theme-slide-left" style="display: none">
    <ul class="-mob-share-list">
        <li class="-mob-share-weixin"><p>微信</p></li>
        <li class="-mob-share-pocket"><p>Pocket</p></li>
        <li class="-mob-share-instapaper"><p>Instapaper</p></li>
        <li class="-mob-share-linkedin"><p>Linkedin</p></li>
        <li class="-mob-share-twitter"><p>Twitter</p></li>
        <li class="-mob-share-weibo"><p>新浪微博</p></li>
        <li class="-mob-share-douban"><p>豆瓣</p></li>
        <li class="-mob-share-facebook"><p>Facebook</p></li>
        <li class="-mob-share-google"><p>Google+</p></li>
    </ul>
    <div class="-mob-share-close">取消</div>
</div>
<div class="-mob-share-ui-bg"></div>
<script id="-mob-share" src="http://f1.webshare.mob.com/code/mob-share.js?appkey=26252752de4d6"></script>
<!--MOB SHARE END--> 
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
              <div id="disqus_thread">
                <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
              </div>
            
          </div>
        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目錄
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            本站概覽
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://www.devtalking.com/devtalking.png" alt="DevTalking" itemprop="image"/>
          <p class="site-author-name" itemprop="name">DevTalking</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">94</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

         <!-- <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分類</span>
              
          </div> -->

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">44</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://www.linkedin.com/in/宇轩-付-5aa406a6" target="_blank">
                  
                    <i class="fa fa-linkedin"></i> linkedin
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:jace.fu@icloud.com" target="_blank">
                  
                    <i class="fa fa-envelope"></i> Email
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#u914D_u7F6ETimer_u4E8B_u4EF6_u6E90"><span class="nav-number">1.</span> <span class="nav-text">配置Timer事件源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u914D_u7F6E_u57FA_u4E8E_u7AEF_u53E3_u7684_u4E8B_u4EF6_u6E90"><span class="nav-number">2.</span> <span class="nav-text">配置基于端口的事件源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u4F7F_u7528NSMachPort_u5BF9_u8C61"><span class="nav-number">2.1.</span> <span class="nav-text">使用NSMachPort对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#u5728_u4E3B_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort"><span class="nav-number">2.1.1.</span> <span class="nav-text">在主线程中创建配置NSMachPort</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#u5728_u4E8C_u7EA7_u7EBF_u7A0B_u4E2D_u521B_u5EFA_u914D_u7F6ENSMachPort"><span class="nav-number">2.1.2.</span> <span class="nav-text">在二级线程中创建配置NSMachPort</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u7EBF_u7A0B_u5B89_u5168_u673A_u5236"><span class="nav-number">3.</span> <span class="nav-text">线程安全机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u539F_u5B50_u64CD_u4F5C_uFF08Atomic_Operations_uFF09"><span class="nav-number">3.1.</span> <span class="nav-text">原子操作（Atomic Operations）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u5185_u5B58_u5C4F_u969C_uFF08Memory_Barriers_uFF09_u548C_u53EF_u89C1_u53D8_u91CF_uFF08Volatile_Variables_uFF09"><span class="nav-number">3.2.</span> <span class="nav-text">内存屏障（Memory Barriers）和可见变量（Volatile Variables）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u9501_u673A_u5236"><span class="nav-number">3.3.</span> <span class="nav-text">锁机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Conditions"><span class="nav-number">3.4.</span> <span class="nav-text">Conditions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u8BBE_u8BA1_u7EBF_u7A0B_u5B89_u5168_u9700_u8981_u6CE8_u610F_u7684_u4E8B_u9879"><span class="nav-number">4.</span> <span class="nav-text">设计线程安全需要注意的事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u907F_u514D_u6EE5_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236"><span class="nav-number">4.1.</span> <span class="nav-text">避免滥用线程安全机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u8BA4_u6E05_u4F7F_u7528_u7EBF_u7A0B_u5B89_u5168_u673A_u5236_u65F6_u7684_u9677_u9631"><span class="nav-number">4.2.</span> <span class="nav-text">认清使用线程安全机制时的陷阱</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u9632_u6B62_u6B7B_u9501_u548C_u6D3B_u9501_u7684_u53D1_u751F"><span class="nav-number">4.3.</span> <span class="nav-text">防止死锁和活锁的发生</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u6B63_u786E_u4F7F_u7528volatile_u5173_u952E_u5B57"><span class="nav-number">4.4.</span> <span class="nav-text">正确使用volatile关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u4F7F_u7528_u539F_u5B50_u64CD_u4F5C"><span class="nav-number">5.</span> <span class="nav-text">使用原子操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Add_u64CD_u4F5C"><span class="nav-number">5.1.</span> <span class="nav-text">Add操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Increment_u64CD_u4F5C"><span class="nav-number">5.2.</span> <span class="nav-text">Increment操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Decrement_u64CD_u4F5C"><span class="nav-number">5.3.</span> <span class="nav-text">Decrement操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OR_u903B_u8F91_u8FD0_u7B97_u3001AND_u903B_u8F91_u8FD0_u7B97_u3001XOR_u903B_u8F91_u8FD0_u7B97"><span class="nav-number">5.4.</span> <span class="nav-text">OR逻辑运算、AND逻辑运算、XOR逻辑运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS_u64CD_u4F5C"><span class="nav-number">5.5.</span> <span class="nav-text">CAS操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u6BD4_u7279_u4F4D_u8BBE_u7F6E_u64CD_u4F5C"><span class="nav-number">5.6.</span> <span class="nav-text">比特位设置操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u4F7F_u7528_u9501_u673A_u5236"><span class="nav-number">6.</span> <span class="nav-text">使用锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#POSIX_u4E92_u65A5_u9501"><span class="nav-number">6.1.</span> <span class="nav-text">POSIX互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4F7F_u7528NSLock"><span class="nav-number">6.2.</span> <span class="nav-text">使用NSLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4F7F_u7528NSRecursiveLock"><span class="nav-number">6.3.</span> <span class="nav-text">使用NSRecursiveLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4F7F_u7528NSConditionLock"><span class="nav-number">6.4.</span> <span class="nav-text">使用NSConditionLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#u4F7F_u7528@synchronized_u5173_u952E_u5B57"><span class="nav-number">6.5.</span> <span class="nav-text">使用@synchronized关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#u4F7F_u7528Condition_u673A_u5236"><span class="nav-number">7.</span> <span class="nav-text">使用Condition机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#u4F7F_u7528NSCondition_u7C7B"><span class="nav-number">7.1.</span> <span class="nav-text">使用NSCondition类</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DevTalking</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'jacefu';
      var disqus_identifier = '/articles/read-threading-programming-guide-4/';
      var disqus_title = '读 Threading Programming Guide 笔记（四）';
      var disqus_url = 'http://www.devtalking.com//articles/read-threading-programming-guide-4/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/lib/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
