<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>




  <meta name="keywords" content="Hexo,next" />





  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="程序员说">
<meta property="og:url" content="http://www.devtalking.com/page/5/index.html">
<meta property="og:site_name" content="程序员说">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员说">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> 程序员说 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">程序员说</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/failable-initializers/" itemprop="url">
                  可失败构造器（Failable Initializers）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-21T00:00:00+08:00" content="2014-10-21">
              2014-10-21
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p><a href="https://developer.apple.com/xcode/downloads/" target="_blank" rel="external">Xcode6.1</a>中Swift的最新版本是1.1，在该版本中引入了一个新的特性：可失败构造器。通过构造器初始化实际上是给<code>class</code>或<code>struct</code>的每一个存储属性（参数）提供初始值，进行对象实例化的过程。在一些情况下，初始化的过程是有可能失败的。比如，实例化一个对象，在实例化的过程中需要访问资源文件，就像从文件中加载图片一样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">NSImage</span>(contentsOfFile: <span class="string">"swift.png"</span>)</span><br></pre></td></tr></table></figure>
<p>如果该文件不存在或者因为某种原因不允许访问，那么<code>NSImage</code>的初始化过程就会失败。在Swift 1.1版本中，像这种情况可以通过可失败构造器进行捕获。如果在构造一个对象时使用可失败构造器，那么当对象构造成功时返回该对象，当对象构造失败时则返回<code>nil</code>。因此可以直接用条件判断语句使用可失败构造器来实例化对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> image = <span class="type">NSImage</span>(contentsOfFile: <span class="string">"swift.png"</span>) &#123;</span><br><span class="line">	<span class="comment">// loaded the image successfully</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// could not load the image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>init</code>初始化方法可以通过在<code>init</code>关键字后面加上<code>?</code>或<code>!</code>将其变为可失败初始化方法，这样就表示某对象的初始化方法会产生两种结果。比如，将<code>Int</code>类型的<code>init</code>初始化方法变为可失败初始化方法，然后执行<code>String</code>类型转换：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">	<span class="keyword">init</span>?(fromString: <span class="type">String</span>) &#123; </span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">let</span> i = fromString.toInt() &#123;</span><br><span class="line">			<span class="comment">// Initialize</span></span><br><span class="line">			<span class="keyword">self</span> = i</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">			<span class="comment">// return nil, discarding self is implied</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在可失败构造器或可失败初始化方法中，一旦返回<code>nil</code>就代表构造失败或初始化失败，不会再返回其他的值。在上述的示例中，当<code>String</code>不能解析为<code>Integer</code>时会导致初始化失败，返回<code>nil</code>，否则返回解析成功后的值。</p>
<p>可失败构造器/初始化方法解决了以前在Swift中只能通过工厂方法捕获构造或初始化失败情况的问题。比如，一个枚举，通过<code>fromRaw</code>工厂方法通过一个原始值来寻找它所对应的枚举成员，返回类型为可选枚举类型。即如果该原始值对应的枚举成员存在，那么返回该枚举成员，如果不存在则返回<code>nil</code>。现在，Swift编译器结合可失败构造器，通过可失败的初始化方法用<code>switch</code>语句判断原始值对应的枚举成员，如果没有对应的则返回<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">Red</span> = <span class="number">0</span>, <span class="type">Green</span> = <span class="number">1</span>, <span class="type">Blue</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// implicitly synthesized</span></span><br><span class="line">	<span class="keyword">var</span> rawValue: <span class="type">Int</span> &#123; <span class="comment">/* returns raw value for current case */</span> &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// implicitly synthesized</span></span><br><span class="line">	<span class="keyword">init</span>?(rawValue: <span class="type">Int</span>) &#123;</span><br><span class="line">		<span class="keyword">switch</span> rawValue &#123; </span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">self</span> = .<span class="type">Red</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">self</span> = .<span class="type">Green</span></span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">self</span> = .<span class="type">Blue</span></span><br><span class="line">			<span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用可失败构造器可极大程度的统一Swift中的构造对象语法，消除了构造器与工厂方法之间混乱、重复的冗余语法，使Swift更加简洁。随着可失败构造器这一特性的加入，Swift将对大多数Cocoa中带<code>NSError</code>参数的工厂初始化方法进行调整，从而加强Swift中构造对象语法的统一性，给开发者带来更好的开发体验。</p>
<p>原文地址：<a href="https://developer.apple.com/swift/blog/?id=17" target="_blank" rel="external">Failable Initializers</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/adaptive-layout-for-iphone6-2/" itemprop="url">
                  为iPhone6设计自适应布局（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-17T00:00:00+08:00" content="2014-10-17">
              2014-10-17
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="Size_Classes"><a href="#Size_Classes" class="headerlink" title="Size Classes"></a>Size Classes</h2><p>自适应布局的布局约束自然是好东西，但也不是万能的，有时候我们也需要使用最基本的布局，所以使用size classes将它们两者结合起来才能碰撞出更有激情的火花。</p>
<blockquote>
<p>引用我上篇译文中的一段话：<br>Size Classes并不代表真正的尺寸，而是我们从感官上感觉尺寸的种类，通过这种种类的组合，表示出不同屏幕尺寸设备的横屏及竖屏。</p>
</blockquote>
<p>我们在给storyboard中的对象添加约束时可以选择给某一个size class添加约束，所以在你选择特定的size class时，只能看到你添加的只适用于该size class的约束。</p>
<p>这些特性能使我们有效的在不同的设备和屏幕方向中定义、设计不同的用户界面。</p>
<h3 id="Size_Classes_u4E2D_u7684_u9AD8_u548C_u5BBD"><a href="#Size_Classes_u4E2D_u7684_u9AD8_u548C_u5BBD" class="headerlink" title="Size Classes中的高和宽"></a>Size Classes中的高和宽</h3><p>Size Classes为高和宽分别提供了三种类型：紧凑型（compact）、普通型（regular）、任意型（any）。用这三种高和宽的类型就可以组合出9种size class，来表示不同的设备屏幕。</p>
<p>在实际运用中，我们发现并不是所有的尺寸都能在Size Classes中找到明确的组合（比如没有组合可以明确表示iPhone6 Plus的竖屏，iPad的横竖屏也不好区分），但是我们可以使用表示这个尺寸范围的组合。比如我们可以用Compact Width | Regular Height来表示iPhone6 Plus的竖屏。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-23.png" alt="图片"></p>
<p>接下来还是用一个活生生的示例来向大家介绍Size Classes。</p>
<h3 id="u6211_u4EEC_u7684_u76EE_u6807"><a href="#u6211_u4EEC_u7684_u76EE_u6807" class="headerlink" title="我们的目标"></a>我们的目标</h3><p>这个示例是实现Instagram的一个详细信息页面，并让它自适应更大的屏幕尺寸，在竖屏和横屏中都展现出最合适的布局。</p>
<p>我们的目标是让布局自适应iPhone6的屏幕（这里需要注意一下，我所说的自适应是指图片、文字信息的布局排版，对于个人信息的头像不会根据布局的变化而变化），在竖屏中各个信息按照堆栈方式从上到下布局，在横屏时各元素按照大小进行有序排列，而不再是堆栈的方式：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-24.png" alt="图片"></p>
<h3 id="u7ED9_u901A_u7528_u7684size_class_u6DFB_u52A0_u7EA6_u675F"><a href="#u7ED9_u901A_u7528_u7684size_class_u6DFB_u52A0_u7EA6_u675F" class="headerlink" title="给通用的size class添加约束"></a>给通用的size class添加约束</h3><p>在这个示例中，我们不会像上个示例那样使用模拟器的实际尺寸来设计布局，我们使用Size Classes提供的抽象的屏幕尺寸，这里我们先使用通用的尺寸来设计布局，也就是<strong>w Any | h Any</strong>尺寸。我们要注意的是，在这个尺寸下添加的view或者约束必须是一些公用的，也就是说在任何尺寸，任何屏幕方向的情况下都适用的。</p>
<p>这些约束包括：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-25.png" alt="图片"></p>
<p>除了之前介绍过的页边间距约束、水平间距约束、等高等宽约束、方向比例约束外还有顶部、底部间距约束。</p>
<p>添加完上述的view和约束后，storyboard里应该是这番景象：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-26.png" alt="图片"></p>
<p>这里要注意一下，目前这个界面的布局还有很多关键点需要考虑横屏和竖屏的布局，但是这些工作不会在<strong>w Any | h Any</strong>尺寸下进行。大伙接着往下看。</p>
<h3 id="u4E3AiPhone_u7684_u7AD6_u5C4F_u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F"><a href="#u4E3AiPhone_u7684_u7AD6_u5C4F_u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F" class="headerlink" title="为iPhone的竖屏添加布局约束"></a>为iPhone的竖屏添加布局约束</h3><p>现在在Size Classes选择器中选择<strong>w Compact | h Regular</strong>尺寸，这个size class适用于所有iPhone设备的竖屏界面，不论尺寸是多少。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-27.gif" alt="图片"></p>
<p>当你在Size Classes选择器中选择某一个size class后，storyboard<br>中的view controller会实时的反映出你改变后的尺寸大小。</p>
<p>现在你就可以为iPhone的竖屏状态重新设计view的位置和添加新的布局约束了。下图中说明了我在竖屏状态下添加的约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-28.png" alt="图片"></p>
<p>我的storyboard中看起来是这样的：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-29.png" alt="图片"></p>
<p>在这个阶段，你可以在3.5、4、4.7、5.5这几个尺寸的模拟器中编译运行应用，在竖屏状态下看看它们的运行情况，尽管在横屏状态表现的还很糟糕。</p>
<p>这里要注意的是我们并没有定义图片的宽度，我们只是给图片添加了相对父容器的左右边间距，并将其值设为了0。所以当屏幕尺寸增大的时候图片的宽度在布局约束的作用下也会增加，这时又因为我们给图片添加了高宽比例约束，所以图片的高度也会随之增加。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-30.png" alt="图片"></p>
<h3 id="u4E3AiPhone_u7684_u6A2A_u5C4F_u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F"><a href="#u4E3AiPhone_u7684_u6A2A_u5C4F_u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F" class="headerlink" title="为iPhone的横屏添加布局约束"></a>为iPhone的横屏添加布局约束</h3><p>打开Size Classes选择器，选择<strong>w Any | h Compact</strong>，这个size class适用于任何一个尺寸的横屏状态。我们将在这个size class下设计我们希望在iPhone横屏时显示的用户界面。</p>
<p>此时图片的顶部、左侧、底部都添加了相对于父容器的边界约束。在显示评论的label上添加了右侧边界约束。</p>
<p>当设备横屏时，图片在布局约束的作用下移到了左侧，个人信息label和评论label在约束的作用下被挤到了右侧，并且评论label的高度增加，宽度减少。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-31.png" alt="图片"></p>
<p>现在来看看我的storyboard中显示的内容。大家注意左侧的对象结构树中有很多个约束，但是有些是灰色的。那是因为这些灰色的约束在当前的size class下是禁用的，或者说不适用、不起作用。那些是竖屏时用到的约束。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-32.png" alt="图片"></p>
<p>现在在storyboard中切换size class时布局也会随之变化，更新非常及时和平滑。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-33.gif" alt="图片"></p>
<p>我们在模拟器中编译运行应用，切换横竖屏，可以看到布局切换的效果，过度非常自然平滑。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-1.gif" alt="图片"></p>
<blockquote>
<p>为了能让大家看清楚布局变化过度的细节，我放慢了这个git动画。大家注意，在布局变化时屏幕上的组件有一个层级关系，从该示例中我们可以看到图片view的层级高于个人信息label和评论label。所以我们在设计布局的时候就要考虑如何给view分层，包括在普通布局中不会被覆盖的view。这是一个细节问题。</p>
</blockquote>
<h3 id="u5C4F_u5E55_u9884_u89C8_u52A9_u624B_u7F16_u8F91_u5668"><a href="#u5C4F_u5E55_u9884_u89C8_u52A9_u624B_u7F16_u8F91_u5668" class="headerlink" title="屏幕预览助手编辑器"></a>屏幕预览助手编辑器</h3><p>Xcode6中另一个值得关注的功能是屏幕预览助手。它可以避免你一遍遍的在不同屏幕尺寸的模拟器中编译运行应用来检查布局的正确与否。你可以在屏幕预览编辑器中添加一个或多个你想查看的屏幕尺寸，并可以让他们呈现横屏或竖屏的状态。</p>
<p>当然它也不是非常完美（因为在预览时导航栏的颜色会丢失），但是切换<em>Double Length Pseudolanguage</em>选项很方便，便于你检查问题。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-34.gif" alt="图片"></p>
<p>从上图中大家可以看到我在屏幕预览编辑器中显示了3.5寸屏幕的横屏和4寸屏幕的竖屏，整体布局没有问题，但是当选择<em>Double Length Pseudolanguage</em>使label中的文字都增加一倍时，问题就出现了，个人信息和评论的label长度没有自适应。</p>
<h3 id="u4E3AiPad_u5E03_u5C40_u6DFB_u52A0_u7EA6_u675F"><a href="#u4E3AiPad_u5E03_u5C40_u6DFB_u52A0_u7EA6_u675F" class="headerlink" title="为iPad布局添加约束"></a>为iPad布局添加约束</h3><p>现在我们将Sizae Classes调整为<strong>w Regular | h Regular</strong>，这个size class表示了iPad的横屏和竖屏大小。</p>
<p>和往常一样，我们先调整图片和各个label的位置及大小，调整满意后，再添加相关的约束。在iPad布局中我打算将图片的尺寸设置为固定尺寸（不像iPhone中那样随着横屏和竖屏改变图片的尺寸），并将个人信息和评论label紧跟在图片下面。</p>
<p>我的storyboard现在看起来是这样的：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-35.png" alt="图片"></p>
<p>以往，我们都是在特定的size class中添加相关的约束，但在iPad布局中，我们不仅仅只添加一些约束。</p>
<p>因为在iPad布局中有很大的空余空间，所以我们不只是重新排列一下组件的位置和大小，我们还要添加一些其他的组件。在这个示例中，我们再添加两个图片view（分别表示当前显示图片的上一张图片和下一张图片）。</p>
<p>再来看看我的storyboard：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-36.png" alt="图片"></p>
<p>我们不需要对这两个图片手动的设置高宽，而是给它们设置对于主显示图片的相对高宽即可。</p>
<p>这样做的好处是当主显示图片的尺寸更改时，我们不需要自己手动计算和更改这两个图片的尺寸，相对高宽会自动针对主显示图片的尺寸调整这两个图片的尺寸。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-37.gif" alt="图片"></p>
<p>我没有制作在iPad上运行的gif动画，但这里有iPad横屏竖屏的运行图片，大家可以看看：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-38.png" alt="图片"></p>
<h2 id="u4F7F_u7528_u5E03_u5C40_u89C6_u56FE_u548C_u95F4_u8DDD_u89C6_u56FE"><a href="#u4F7F_u7528_u5E03_u5C40_u89C6_u56FE_u548C_u95F4_u8DDD_u89C6_u56FE" class="headerlink" title="使用布局视图和间距视图"></a>使用布局视图和间距视图</h2><p>目前Xcode提供的布局约束可以满足大部分的布局需求，但是有些场景下需要变通的使用约束才能达到我们想要的效果。</p>
<h3 id="u5E03_u5C40_u89C6_u56FE_u793A_u4F8B"><a href="#u5E03_u5C40_u89C6_u56FE_u793A_u4F8B" class="headerlink" title="布局视图示例"></a>布局视图示例</h3><p>通过Xcode提供的约束，我们可以很容易设置组件与view controller view的边缘的间距，也可以很容易的让组件在view controller view中水平居中显示和垂直居中显示。但是却不太容易设置组件与view controller view的水平中线或垂直中线的间距。像这样：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-39.png" alt="图片"></p>
<p>下面向大家介绍两种实现该需求的方法。首先我们先添加一个view，背景色设置为透明，让它在屏幕中垂直居中显示，它作为该需求中组件的父容器，因为父容器在屏幕中是垂直居中的，所以可以给组件添加相对于父容器的Center X约束，就可以达到我们的需求了：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-40.png" alt="图片"></p>
<p>但是通过上述的方式未免会使我们的布局的层级关系太过复杂，我更希望布局比较扁平一些，不需要太多的层级关系。因为上述方法中的容器view主要是用于布局使用，所以这种view我称之为布局视图。</p>
<p>我们来改进一下方法，首先也是在view controller view中添加一个布局视图，我习惯将高度设置为20（这个值随个人喜好或实际情况而定），然后将它和屏幕的顶部、左侧、右侧的间距设为0，这样的话这个布局视图就和状态栏重合了，我们将这个布局视图设置一个深一点的颜色，然后将它的<code>hidden</code>属性设置为<code>true</code>，这样布局视图的颜色就会变浅，也不太会影响我们的布局，而且在应用运行时是不会显示该视图的。现在我们的组件就可以设置相对于布局视图的Center X约束来实现我们的需求了。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-41.png" alt="图片"></p>
<h3 id="u95F4_u9694_u89C6_u56FE_u793A_u4F8B"><a href="#u95F4_u9694_u89C6_u56FE_u793A_u4F8B" class="headerlink" title="间隔视图示例"></a>间隔视图示例</h3><p>之前我们学习了如何使用约束设置视图和视图边缘的间距，并且当屏幕尺寸增加时视图也会相应的改变大小，但它们的间距不会改变。</p>
<p>但是如果我们希望当屏幕增加尺寸时，视图的大小保持不变，只是增加间距呢？</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-42.png" alt="图片"></p>
<p>从理论上讲，实现该需求可能可以使用类似等宽这样的约束，但是现实往往的是骨干感的。</p>
<p>这时我们就需要间距视图出场了，和布局视图一样，间距视图可以设置一个深一点的颜色，<code>hidden</code>属性要设置为<code>true</code>。</p>
<p>我们在每个视图与视图间距之间添加一个间距视图，设置每个视图与相邻间距视图的边缘间距约束，然后给所有的间距视图添加相对于view controller view的等宽约束，设置合适的比例即可。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-43.png" alt="图片"></p>
<p>原文地址：<a href="http://mathewsanders.com/designing-adaptive-layouts-for-iphone-6-plus" target="_blank" rel="external">ADAPTIVE LAYOUTS FOR iPHONE 6</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/adaptive-layout-for-iphone6-1/" itemprop="url">
                  为iPhone6设计自适应布局（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-16T00:00:00+08:00" content="2014-10-16">
              2014-10-16
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <blockquote>
<p>译者的话：<br>本文是自适应布局的巩固篇，所以对布局约束的添加操作步骤等没有详细的说明。如果看着吃力的话请先移步<a href="http://www.devtalking.com/articles/adaptive-layout-1/">Swift自适应布局（Adaptive Layout）教程</a>。</p>
</blockquote>
<p>Apple从iOS6加入了Auto Layout后开始就比较委婉的开始鼓励、建议开发者使用自适应布局，但是到目前为止，我感觉大多数开发者一直在回避这个问题，不管是不是由于历史原因造成的，至少他们在心底还坚守着固定布局的老传统思想。</p>
<p>随着iPhone6、iPhone6 Plus的到来，使用自适应布局更是迫在眉睫的事，固定布局的老传统思想脆弱的不堪一击。现在的iPhone有4种尺寸，如果算上iPad，现在Apple的iOS设备有5种尺寸。我们在准备使用自适应布局设计应用界面之前，可以把这5种尺寸划分为3种分辨率和屏幕方向，这样在设计时分类会更加清晰一些。</p>
<p>我们先来看一张自适应布局的效果图：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-1.gif" alt="图片"></p>
<p>当你们学习完这篇文章后，你们应该会比较自如的使用 <em>storyboard</em>、<em>constaints</em>、<em>size classes</em> 这三个Apple在Xcode里提供的工具，去探索和构建巧妙的自适应布局。</p>
<h2 id="Storyboards"><a href="#Storyboards" class="headerlink" title="Storyboards"></a>Storyboards</h2><p>在Xcode中，storyboard是一个可以让我们对应用界面进行可视化布局的工具，你首先可以在storyboard文件中看到一个或若干个iOS设备屏幕大小的布局区，然后你可以从组件库（Object Library）中拖拽组件到屏幕布局区中进行布局（比如按钮、图片、文本框、labels等），你还可以定义屏幕布局区之间的连接关系。</p>
<p>用Xcode的术语来说，人们可以看到、触碰到或以其他方式（按钮、图片、文本框、labels等）进行交互的用户界面被称为<em>views</em>。屏幕中包含和管理这些views的容器称为<em>view controller</em>。</p>
<p>当我们在storyboard中添加一个view controller后，我们所看到的并不是一个我们熟知的屏幕尺寸，而是一个600X600的正方形：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-2.png" alt="图片"></p>
<p>从上图我们可以很明显的看出，storyboard中显示的屏幕尺寸不是实际设备的尺寸。Apple这样做的目的是将屏幕尺寸进行了抽象化，也就是说你可以将这个正方形的屏幕看成iphone4的屏幕，也可以将它看成iphone6的屏幕。</p>
<h3 id="u6A21_u62DF_u5668_u7684_u5C3A_u5BF8"><a href="#u6A21_u62DF_u5668_u7684_u5C3A_u5BF8" class="headerlink" title="模拟器的尺寸"></a>模拟器的尺寸</h3><p>当你习惯了600X600的屏幕后，你可能会用着很爽，但是有些时候，我们也需要将它改成实际的屏幕尺寸来设计一些东西。</p>
<p>我们可以很方便的在Xcode中改变view controller的模拟屏幕尺寸和屏幕方向：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-3.gif" alt="图片"></p>
<h2 id="u5E03_u5C40_u7EA6_u675F"><a href="#u5E03_u5C40_u7EA6_u675F" class="headerlink" title="布局约束"></a>布局约束</h2><p>介绍布局约束的最好、最直观的方法就是向你们展示一个示例。</p>
<p>首先我们将storyboard中的屏幕布局区域的尺寸调整为iphone5s的尺寸，也就是4寸屏幕，然后添加两个正方形的view，并排放置在屏幕顶部，一个设置为蓝色，一个设置为粉色。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-4.png" alt="图片"></p>
<p>我们选择iPhone5s模拟器设备并编译运行应用，可以看到一蓝一粉这两个方块按照我们设定的那样杵在竖屏方向的屏幕上，没有问题。当我们把设备调整为横屏时，这两个方块像拥护党一样拥护着他们的坐标位置，所以在横屏的时候看着就不是那么完美：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-5.gif" alt="图片"></p>
<p>我们再将模拟器改为iPhone6，然后编译运行，此时在竖屏的时候就已经感觉无法再爱了。这两个方块并没有按照我们设置或设想的那样在屏幕顶部中间，而是偏向了左边，在右边有一块留白区域。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-6.png" alt="图片"></p>
<p>这是就是没有布局约束而导致的，蓝色粉色方块的大小、坐标位置都是固定的，都是在4寸屏幕的参照下设置的，不论在哪种尺寸的屏幕下，它们都在固定的那个坐标位置和固定的大小，所以就会出现上面的情况。</p>
<p>那么接下来让我们给这两个方块添加一些布局约束，再看看会有什么神奇的事情发生。</p>
<h3 id="u9875_u8FB9_u95F4_u8DDD_u7EA6_u675F_uFF08Leading_and_Trailing_space_uFF09"><a href="#u9875_u8FB9_u95F4_u8DDD_u7EA6_u675F_uFF08Leading_and_Trailing_space_uFF09" class="headerlink" title="页边间距约束（Leading and Trailing space）"></a>页边间距约束（Leading and Trailing space）</h3><p>页边间距约束分前部间距约束（Leading space constaint）和尾部间距约束（Trailing space constaint）。从屏幕上说就是左边距和右边距。我们给蓝色方块添加左边距约束，其值设置为10，给粉色方块设置右边距约束，其值也设置为10。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-7.png" alt="图片"></p>
<p>我们再次在iPhone5s模拟器中运行应用，当横屏时蓝色方块被左边距约束拉到了屏幕左边，粉色方块被右边距约束拉到了屏幕右边。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-8.gif" alt="图片"></p>
<h3 id="u6C34_u5E73_u95F4_u8DDD_u7EA6_u675F_uFF08Horizontal_space_constaint_uFF09"><a href="#u6C34_u5E73_u95F4_u8DDD_u7EA6_u675F_uFF08Horizontal_space_constaint_uFF09" class="headerlink" title="水平间距约束（Horizontal space constaint）"></a>水平间距约束（Horizontal space constaint）</h3><p>给蓝色方块和粉色方块添加水平间距约束，其值设置为10。这个约束会使这两个方块之间的距离永远约束为10。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-9.png" alt="图片"></p>
<p>我们再来运行应用，现在横屏时两个方块之间的间距、它们与屏幕边缘的间距都和竖屏时显示的一样了。但是其中粉色方块为了满足水平间距约束自行增加了方块的宽度，变成了长方形。简直是一只老鼠坏了一锅汤有木有。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-10.gif" alt="图片"></p>
<p>从上面这个效果我们可以得知，除非我们特别限制了view的尺寸，否则的话iOS会为满足布局约束而改变view的尺寸，也就是保持一个自然的尺寸。</p>
<h3 id="u7B49_u5BBD_u7EA6_u675F_uFF08Equal_widths_constaint_uFF09"><a href="#u7B49_u5BBD_u7EA6_u675F_uFF08Equal_widths_constaint_uFF09" class="headerlink" title="等宽约束（Equal widths constaint）"></a>等宽约束（Equal widths constaint）</h3><p>我们给这两个方块添加一个等宽约束来改善上面的情况。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-11.png" alt="图片"></p>
<p>再次运行应用，现在在横屏时由于等宽约束的作用，两个方块的宽度保持了一致。我们已经非常接近完美了。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-12.gif" alt="图片"></p>
<h3 id="u65B9_u5411_u6BD4_u4F8B_u7EA6_u675F_uFF08Aspect_ratio_constaint_uFF09"><a href="#u65B9_u5411_u6BD4_u4F8B_u7EA6_u675F_uFF08Aspect_ratio_constaint_uFF09" class="headerlink" title="方向比例约束（Aspect ratio constaint）"></a>方向比例约束（Aspect ratio constaint）</h3><p>从上面的运行情况来看各个约束都工作正常，但唯一不足的是本来在竖屏是两个正方形方块，在横屏时缺变成了长方形方块，由范爷变成了凤姐这是人类无法接受的。</p>
<p>我们给这两个方块添加方向比例约束来解决这个问题。这个约束使方块在满足其他约束的前提下始终保持高和宽的比例相同。所以在横屏时就会以方块的宽度为比例标准，将高度的比例改为宽度的比例。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-13.png" alt="图片"></p>
<p>用iPhone5s模拟器编译运行应用，现在在横屏状态下两个正方形方块完美的呈现在我们眼前。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-14.gif" alt="图片"></p>
<p>我们在iPhone6模拟器上再编译运行应用，从下面的图中我们可以很清晰的看到添加约束之前和之后的变化。布局约束根据多出的空间大小将方块放大到合适的尺寸以满足约束。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-15.png" alt="图片"></p>
<h3 id="u5B9E_u8DF5_u5E03_u5C40_u7EA6_u675F"><a href="#u5B9E_u8DF5_u5E03_u5C40_u7EA6_u675F" class="headerlink" title="实践布局约束"></a>实践布局约束</h3><p>到目前为止，你们已经看到布局约束神奇的作用和效果。是时候让你们在你们自己的storyboard文件中添加布局约束了。</p>
<p>熟练布局约束最好的方法就是多练习，从添加少量的布局约束开始，一步步达到自己想要的效果。</p>
<p>另外有一点，我始终不认为添加过多的布局约束会对应用的性能产生影响。但是我们也不能滥用约束布局，好钢要用在刀刃上，我们尽可能用最节俭的约束布局达到我们想要的效果。</p>
<h3 id="u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F_u7684_u65B9_u5F0F"><a href="#u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F_u7684_u65B9_u5F0F" class="headerlink" title="添加布局约束的方式"></a>添加布局约束的方式</h3><p>这里向大家介绍三种在storyboard中添加约束的方式：</p>
<h4 id="1-_u5E95_u90E8_u5E03_u5C40_u7EA6_u675F_u6309_u94AE"><a href="#1-_u5E95_u90E8_u5E03_u5C40_u7EA6_u675F_u6309_u94AE" class="headerlink" title="1.底部布局约束按钮"></a>1.底部布局约束按钮</h4><p>这种方式可能是最简单直观的一种方式，在屏幕上选择一个或多个对象，然后点击底部的布局约束按钮添加一个或多个需要的约束。它的好处是可以直观的看到当前选择的对象已经添加了该类中的那些约束。</p>
<p>如果你指选择了一个对象想要添加某个约束，但发现该约束是不可选的，那么就意味着这个约束是适用于两个以上对象的约束。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-16.gif" alt="图片"></p>
<h4 id="2-_u6309_u4F4FControl_u952E_u62D6_u62FD_u9F20_u6807"><a href="#2-_u6309_u4F4FControl_u952E_u62D6_u62FD_u9F20_u6807" class="headerlink" title="2.按住Control键拖拽鼠标"></a>2.按住Control键拖拽鼠标</h4><p>你也可以选择一个对象，然后按住Control键和鼠标左键，拖拽鼠标到另一个对象（容器对象，也就是父对象或者选中对象自己），松开鼠标后会弹出适用的约束菜单，你可以选择约束进行添加。</p>
<p>这是我偏爱的一种方式，因为它比上面那种方式来的快多了。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-17.gif" alt="图片"></p>
<h4 id="3-_u83DC_u5355/_u7ED1_u5B9A_u5FEB_u6377_u952E"><a href="#3-_u83DC_u5355/_u7ED1_u5B9A_u5FEB_u6377_u952E" class="headerlink" title="3.菜单/绑定快捷键"></a>3.菜单/绑定快捷键</h4><p>你也可以通过菜单选项<code>editor —&gt; pin</code>给一个或多个对象添加布局约束。这是效率最低的一种方式。如果你发现有些约束你会一遍遍的反复添加，那么你就可以给该约束绑定一个快捷键来提高效率。</p>
<h3 id="u68C0_u67E5_u548C_u7F16_u8F91_u5DF2_u6DFB_u52A0_u7684_u5E03_u5C40_u7EA6_u675F"><a href="#u68C0_u67E5_u548C_u7F16_u8F91_u5DF2_u6DFB_u52A0_u7684_u5E03_u5C40_u7EA6_u675F" class="headerlink" title="检查和编辑已添加的布局约束"></a>检查和编辑已添加的布局约束</h3><p>检查约束最简单的方式就是选中一个对象，然后打开右侧工具栏，选择Size Inspector面板。或者在storyboard界面左侧的结构树中查看约束。</p>
<p>通过这两种方式，你都可以选择某个约束，然后编辑它。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-18.gif" alt="图片"></p>
<h3 id="u79FB_u9664_u5E03_u5C40_u7EA6_u675F"><a href="#u79FB_u9664_u5E03_u5C40_u7EA6_u675F" class="headerlink" title="移除布局约束"></a>移除布局约束</h3><p>布局约束可以添加自然也就可以删除。选中某个约束使其高亮显示，然后按下Delete键移除该约束。</p>
<p>如果想移除某个对象上所有的约束，有一个快捷的方式。选择该对象，然后在底部点击Resolve Auto Layout Issues按钮，选择Clear Constaints。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-19.gif" alt="图片"></p>
<h3 id="u5E03_u5C40_u51FA_u73B0_u7684_u95EE_u9898_u548C_u51B2_u7A81"><a href="#u5E03_u5C40_u51FA_u73B0_u7684_u95EE_u9898_u548C_u51B2_u7A81" class="headerlink" title="布局出现的问题和冲突"></a>布局出现的问题和冲突</h3><p>我们在添加约束时，经常伴随有警告或者错误出现。虽然有些警告是因为我们还没有添加完约束出现的，当我们添加完我们设想的约束后警告就会自然消失。但大多数的警告还是指明我们的约束确实存在问题，需要我们修复。</p>
<p>查看警告或错误最方便的方式就是在storyboard左侧的结构树中，在view controller的右边会出现一个红色或黄色的小图标，向我们指明这里存在问题：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-20.gif" alt="图片"></p>
<h3 id="u9519_u8BEF_u6446_u653Eview_u7684_u8B66_u544A"><a href="#u9519_u8BEF_u6446_u653Eview_u7684_u8B66_u544A" class="headerlink" title="错误摆放view的警告"></a>错误摆放view的警告</h3><p>view位置的错误摆放是一个很常见的警告。当一个view没有摆放在约束规定的位置的时候，会出现该警告。</p>
<p>这些问题会在你切换不同设备的模拟器或鼠标不小心移动了某个对象时出现。</p>
<p>选中一个错误摆放的对象，在屏幕上会出现布局约束给你提示的正确的摆放位置。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-21.gif" alt="图片"></p>
<p>点击左侧出现的黄色警告图片，会弹出一个菜单，你可以选择让Xcode改变约束，以适应当前该对象的位置，但通常情况下我们都选择让Xcode将该对象移动到约束规定的位置。</p>
<h3 id="u7F3A_u5C11_u5E03_u5C40_u7EA6_u675F_u7684_u9519_u8BEF"><a href="#u7F3A_u5C11_u5E03_u5C40_u7EA6_u675F_u7684_u9519_u8BEF" class="headerlink" title="缺少布局约束的错误"></a>缺少布局约束的错误</h3><p>我们回到早些时候的示例中。这时候我们没有给方块添加Y坐标位置的约束。在运行时没有问题，因为iOS会假设方块的位置就是我们在storyboard中摆放的那个位置。但是Xcode会提示我们一个缺失约束的错误，为了避免意外发生（更换设备尺寸），我还是要根据Xcode的提示添加缺失的约束。</p>
<p>我们给这两个方块添加一个<em>top space to to layout guide</em>约束使方块的位置更加清晰，并消除Xcode的错误提示。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-22.gif" alt="图片"></p>
<p>未完待续……</p>
<p>原文地址：<a href="http://mathewsanders.com/designing-adaptive-layouts-for-iphone-6-plus" target="_blank" rel="external">ADAPTIVE LAYOUTS FOR iPHONE 6</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/adaptive-layout-2/" itemprop="url">
                  Swift自适应布局（Adaptive Layout）教程（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-13T00:00:00+08:00" content="2014-10-13">
              2014-10-13
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="u7ED9TextContainer_u4E2D_u6DFB_u52A0_u5185_u5BB9"><a href="#u7ED9TextContainer_u4E2D_u6DFB_u52A0_u5185_u5BB9" class="headerlink" title="给TextContainer中添加内容"></a>给TextContainer中添加内容</h2><p>打开 <strong>Main.storyboard</strong> ，从组件库（Object Library）中拖拽两个 <strong>Label</strong> 组件到TextContainer中，位置可以随意摆放：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-35.png" alt="图片"></p>
<p>先选择靠上的Label，然后点击底部的 <strong>Align</strong> 按钮，添加一个 <strong>Horizontal Center in Container</strong> 约束，再点击 <strong>Pin</strong> 按钮，添加一个 <strong>Top Spacing to nearest neighbor</strong> 约束，设置其值为10：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-36.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-37.png" alt="图片"></p>
<p>然后选择右侧工具栏中的 <strong>Attribute Inspector</strong> 页签，将该Label的 <strong>Text</strong> 属性设置为 <strong>Cupertino</strong> ，<strong>Color</strong> 属性设置为 <strong>White</strong> ，<strong>Font</strong> 属性设置为 <strong>Helvetica Neue, Thin</strong> ， <strong>Size</strong> 属性设置为 <strong>150</strong>。</p>
<p>这时同学们可能会发现基本看不到刚才设置的文字的全貌，这是因为Label大小的原因。别着急，我们很快就会解决这个问题。</p>
<p>现在选择另一个Label，按照上述的方法给它也添加一个 <strong>Horizontal Center in Container</strong> 约束以及一个 <strong>Bottom Spacing<br>to nearest neighbor</strong> 约束，将其值设置为10。打开右侧工具栏中的 <strong>Size Inspector</strong> 看看：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-38.png" alt="图片"></p>
<p>然后选择 <strong>Attribute Inspector</strong> 将该Label的 <strong>Text</strong> 属性设置为 <strong>28C</strong> ， <strong>Color</strong> 属性设置为 <strong>White</strong>， 将 <strong>Font</strong> 属性设置为 <strong>Helvetica Neue, Thin</strong>， 将 <strong>Size</strong> 属性设置为 <strong>250</strong>。</p>
<p>现在是时候解决Label大小的问题了。选中view controller的view，点击底部的 <strong>Resolve Auto Layout Issues</strong> 按钮，在弹出菜单中选择 <strong>All Views\Update Frames</strong> ，现在看看<code>storyboard</code>中发生了什么：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-39.png" alt="图片"></p>
<p>我们看到了刚才设置的城市和温度，但是他们有一点点重叠，这可不是我们想要的结果。在我们修改这个问题之前，先看看预览编辑区的显示情况。我们发现在iPad下显示貌似还挺完美：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-40.png" alt="图片"></p>
<p>但是在iPhone下不出所料的无法直视，字体太大了：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-41.png" alt="图片"></p>
<p>接下来让我们解决这个重叠和字体大小的问题。</p>
<h2 id="Size_Classes"><a href="#Size_Classes" class="headerlink" title="Size Classes"></a>Size Classes</h2><p>通用的<code>storyboard</code>文件固然很好，但是你想真正把它玩转还是得花功夫去研究它，这是一件很有挑战性的工作，当然我们也要懂得运用一些现有的工具来帮助我们。Xcode6就为我们提供了一些工具和技巧，帮助我们更好的实现自适应布局。</p>
<p>自适应布局有一个很重要的概念就是 <strong>Size Classes</strong>。它并不代表真正的尺寸，而是我们从感官上感觉尺寸的种类，通过这种种类的组合，表示出不同屏幕尺寸设备的横屏及竖屏。</p>
<p>Xcode6为我们提供了两个种类：普通（<strong>Regular</strong>）和紧凑（<strong>Compact</strong>）。虽然它们涉及到视图的物理尺寸，但一般它们只代表视图的语义尺寸，即不是真正的尺寸，而是我们从感官上分出的尺寸种类。</p>
<p>下面这个表格向同学们展示了size classes和各个尺寸设备竖屏、横屏之间的关系：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-42.png" alt="图片"></p>
<p>上表中的这些size classes组合都是我们在开发应用中经常碰到的。然而你也可以在视图的任何一个层级中覆盖这些size classes。当以后我们开发Apple Watch应用时显得尤其有用。</p>
<h2 id="Size_Classes_u4E0E_u5F00_u53D1_u8005"><a href="#Size_Classes_u4E0E_u5F00_u53D1_u8005" class="headerlink" title="Size Classes与开发者"></a>Size Classes与开发者</h2><p>何为设计应用的UI？虽然现在你们的应用已经知道要使用Size Classes，并且你们在<code>storyboard</code>文件中设计应用界面时已经抛开了具体尺寸大小的束缚。但是你们难道没有发现在所有尺寸的设备中，不管是竖屏还是横屏，应用的界面布局都是一致的吗？只是自适应了尺寸大小而已。这还远远不是设计。</p>
<p>当你们决心要设计自适应的界面并已经开始设计的时候，有一点很关键。那就是要知道界面在不同的Size Classes要有继承的关系。你们应该首先设计一个基础的界面，然后根据不同尺寸的横竖屏在基础的界面上进行自定义。千万不要把不同的Size Classes当做独立的屏幕尺寸去设计UI。应该在你们的脑海中建立起界面的一个继承关系的思想，也就是大多数的设备使用基础界面，然后特别的尺寸及横竖屏再根据情况基于基础界面修改。</p>
<p>在本文中，一直没有像大家介绍过如何设置特殊设备的布局，那是应为自适应布局的核心概念Size Classes本身就是由各种特殊设备的特点抽象而来的。也就是说一个Size Classes就意味着一种特殊设备的布局特点，其实普通情况也是特殊情况中的一种。所以说我们可以组合不同的Size Classes来满足各种特殊的布局情况，比如一个支持自适应的视图，它可以在应用的父视图控制器中自适应，也可以在某一个功能的视图控制器容器中自适应。但是两者自适应后的布局却不相同。</p>
<p>这种改进对Apple本身也是有益的，因为他们不断的改变移动设备的尺寸，但从来没有强迫开发者和设计者重新开发和设计他们的应用以适应新尺寸的设备。这就不会让开发者和设计者对Apple不断改变设备尺寸这件事有抗拒心理。</p>
<p>接下来，我们将自定义Size Classes以适应iPhone横屏的时候，因为现在的布局在横屏时用户体验很糟糕。</p>
<h2 id="u4F7F_u7528Size_Classes"><a href="#u4F7F_u7528Size_Classes" class="headerlink" title="使用Size Classes"></a>使用Size Classes</h2><p>回到 <strong>Main.storyboard</strong>，点击底部的 <strong>w Any h Any</strong>，你就可以看到Size Classes的选择器了：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-43.png" alt="图片"></p>
<p>在这个由9个方格组成的网格中，你就可以选择你想在<code>storyboard</code>中显示的Size Class。一共有9种组合方式：3种垂直的也就是竖屏的（任意尺寸（Any），普通（regular），紧凑（compact））选择和3种水平的也就是横屏（任意尺寸（Any），普通（regular），紧凑（compact））的选择。</p>
<blockquote>
<p>注意：这里有一点需要大家注意。在Size Classes中，有两个重要的概念叫做<em>水平（Horizontal）</em>和<em>垂直（Vertical）</em>。但是在IB中叫做 <em>宽（Width）</em>和<em>高（Height）</em>。但他们是等价的，所以大家记住这个概念有两种叫法就可以了。</p>
</blockquote>
<p>目前我们的布局在紧凑高度（Compact Height）时显示的很糟糕，也就是iPhone横屏时。我们来解决这个问题，在Size Classes选择器中选择 <strong>Any Width | Compact Height</strong> 的组合：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-44.png" alt="图片"></p>
<p>这时你会发现在<code>storyboard</code>中会立即出现2个变化：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-45.png" alt="图片"></p>
<ol>
<li><code>storyboard</code>中的view controller变成了我们刚才设置的size class。</li>
<li><code>storyboard</code>底部会出现蓝色的长条区域，并显示出当前我们正在使用的size class。</li>
</ol>
<p>为了在该size class下改变布局，我们要临时改变一些之前设置好的约束。在自动布局中这种操作有个术语叫做 <strong>装配（installing）</strong> 和 <strong>卸载（uninstalling）</strong> 约束。当一个约束在当前的size class中是适用的，我们就将该约束装配在当前的size class中，如果不适用，我们就卸载它。</p>
<p>选择image view，在右侧工具栏中选择 <strong>Size Inspector</strong>。你可以看到在image view上添加的所有约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-46.png" alt="图片"></p>
<p>单击鼠标左键选择 <strong>Align Center X to: Superview</strong> 约束，然后按下键盘上的 <strong>Delete</strong> 键来卸载该约束。这时我们可以看到在<code>storyboard</code>中这个约束就立即消失了，并且在<code>storyboard</code>的结构目中和 Size Inspector中该约束都变成了灰色：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-47.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-48.png" alt="图片"></p>
<blockquote>
<p>注意：你可以在Size Inspector中点击 <strong>All</strong> 来查看当前size class卸载掉的约束。</p>
</blockquote>
<p>鼠标双击刚才卸载的那条约束，我们可以看到在约束编辑界面的底部出现了额外的2个选项：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-49.png" alt="图片"></p>
<p>这两个选项的意思就是这条约束在基础布局中是可用的，但在当前的 <strong>Any Width | Compact Height</strong> 布局中是不可用的。  </p>
<p>按照上面的步骤卸载掉image view上的另外3个约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-50.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-51.png" alt="图片"></p>
<p>现在你就可以添加适合当前size class的约束了。我们添加一个 <strong>Align/Vertical Center in Container</strong> 约束，再添加一个 <strong>Pin/Left Spacing to nearest neighbor</strong> 约束，其值设置为10：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-52.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-53.png" alt="图片"></p>
<p>选择image view，按住 <strong>Ctrl</strong> 键从image view上拖拽至view controller的view上，在弹出的菜单中选择 <strong>Equal Widths</strong> 约束。</p>
<p>打开右侧工具栏中的 <strong>Size Inspector</strong> 页签，双击 <strong>Equal Width to: Superview</strong> 打开该约束的属性编辑界面。如果 <strong>First Item</strong> 属性的值不是 <strong>cloud.Width</strong> ，那么点击输入框，在下拉菜单中选择 <strong>Reverse First and Second Item</strong>。然后将 <strong>Multiplier</strong> 属性的值设置为 <strong>0.45</strong>。</p>
<p>现在image view在所有的size class中显示应该都没有什么问题了。但是text container view还有点问题。你需要给它添加一个约束，让它显示在该size class屏幕的右侧。</p>
<p><code>TextContainer</code> view现在有两种约束在身。一种是内部约束，它约束了两个Label的位置，这些约束在各size class中表现的还不错。另一种是外部的约束，它们限制了text container view的左、右、底部与它容器的左、右、底部的间距。这些约束在当前的size class中表现的就不尽如人意了。如果想使text container view在当前size class中位于容器的右下角位置，你得卸载掉左侧的约束。</p>
<p>选中 <strong>Left Spacing to nearest neighbor</strong> 约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-54.png" alt="图片"></p>
<p>按 <strong>Cmd-Delete</strong> 卸载该约束，和之前一样，被卸载的约束显示为灰色。</p>
<p>现在你需要再添加两个约束将TextContainer限制在正确的位置上。一个是让text container view的宽度为它容器（view controller的view）宽度的一半。另一个是将text container view固定在顶部。</p>
<p>按理来说，你现在需要选中text container view然后按住Ctrl键和鼠标左键拖动鼠标到view controller view上，然后选择约束。但是目前的情况由于image view和text container view占满了整个view controller，所以你很难选中view controller的view。同学们可以通过<code>storyboard</code>的结构树上进行该操作，会容易很多。</p>
<p>在结构树中选中TextContainer，按住 <strong>Ctrl</strong> 键和鼠标左键，拖动鼠标到结构树的View上：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-55.png" alt="图片"></p>
<p>弹出菜单中显示了可用的约束，按住 <strong>Shift</strong> 键点击 <strong>Top Space to Top Layout Guide</strong> 和 <strong>Equal Widths</strong> 约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-56.png" alt="图片"></p>
<p>然后选中TextContainer，在 <strong>Size Inspector</strong> 中设置刚刚添加的两个约束：</p>
<ul>
<li>将 <strong>Top Space to: Top Layout Guide </strong> 约束的值设置为0。</li>
<li>将 <strong>Equal Width</strong> 约束的 <strong>Multiplier</strong> 的值设置为0.5。这里要注意 <strong>First Item</strong> 和 <strong>Second Item</strong> 这两个属性的值。前者应为TextContainer view，后者为view controller view。如果不一致，那么点击任意一个输入框，选择 <strong>Reverse First and Second Item</strong>。</li>
</ul>
<p>现在点击<code>storyboard</code>界面底部的 <strong>Resolve Auto Layout Issues</strong> 按钮，然后选择 <strong>All Views\Update frames</strong> 。看看发生了什么变化呢：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-57.png" alt="图片"></p>
<p>到目前为止，我们的布局已经越来越接近完美了，唯一一点不足的就是字体大小的自适应，我们会在下一节解决它！</p>
<h2 id="u6587_u5B57_u5C5E_u6027_u7684_u81EA_u9002_u5E94"><a href="#u6587_u5B57_u5C5E_u6027_u7684_u81EA_u9002_u5E94" class="headerlink" title="文字属性的自适应"></a>文字属性的自适应</h2><p>目前TextContainer中的文字尺寸在iPad设备上，也就是使用普通（Regular）size class显示还比较正常。但是当使用紧凑（Compact）size class时文字尺寸就显得太大了，以至于都超出了视图。不过同学们不要怕，我们照样可以在不同的Size Classes中设置不同的文字尺寸来做到自适应。</p>
<blockquote>
<p>注意：与重写布局不同，在不同的size class中改变文字的属性始终会影响基础布局中的文字。它不能像布局一样，在不同的size class中设置不同的属性值。我们通过下面的方法来解决这一问题。</p>
</blockquote>
<p>回到<code>storyboard</code>文件中，将目前的size class改为最基础的 <strong>Any Width | Any Height</strong> 。</p>
<p>选择显示Cupertino的Label，打开 <strong>Attribute Inspector</strong> 。点击 <strong>Font</strong> 属性前面的 <strong>+</strong> 号：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-58.png" alt="图片"></p>
<p>弹出的菜单内容是让我们选择一种size class的组合来重写该组合下的文字属性。我们选择 <strong>Compact Width &gt; Any Height</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-59.png" alt="图片"></p>
<p>这时就会出现另外一个文字属性下拉框，针对于我们刚才选择的 <strong>Compact Width | Any Height</strong> size class，我们将字体大小改为90：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-60.png" alt="图片"></p>
<p>再选择显示温度的Label，重复刚才的操作，选择size class组合时选择 <strong>Compact Width &gt; Any Height</strong>。设置字体大小为150。</p>
<p>在预览区域会自动更新我们刚才的设置：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-61.png" alt="图片"></p>
<p>现在看起来稍微好一些了，但是显示 <strong>Cupertino</strong> 的Label被截掉了两头。同学们可能会继续调整字体大小使Cupertino显示完全，虽然目前看起来完美了，但是当换一个城市名称后或许又会出现刚才的问题。比如Washington, D.C这么长的名称，又比如Kleinfeltersville, PA这个更长的名称。那么我们应该如何设计呢？</p>
<p>我们的救世主 <strong>自动布局（Auto Layout）</strong> 再次出马。你只需要给显示城市名称和温度的这两个Label设置一个相对于TextContainer view的宽度约束即可。选中显示Cupertino的Label，按住 <strong>Ctrl</strong> 键和鼠标左键，拖动鼠标到TextContainer view，在弹出菜单中选择 <strong>Equal Widths</strong> 约束。对显示温度的Label做相同的操作。之后在预览界面看看发生了什么：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-62.png" alt="图片"></p>
<p>呃……貌似还是有问题，城市名显示不完全。Label中的文字长度超出了允许显示的空间。不过我们可以通过一个选项，让Label自动判断当前的空间可以显示多大的字体。</p>
<p>选择显示Cupertino的Label，然后打开 <strong>Attribute Inspector</strong>。将 <strong>AutoShrink</strong> 属性设置为 <strong>Minimum font scale</strong>，将其值设置为0.5。将 <strong>Alignment</strong> 属性设置为 <strong>Centered</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-63.png" alt="图片"></p>
<p>对显示温度的Label做相同的操作。</p>
<p>再来看看预览区域，是不是在不同尺寸的iPhone横屏、竖屏下显示都比较完美了：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-64.png" alt="图片"></p>
<p>是时候在不同的设备上编译运行我们的程序了。用设备来检验才是最保险的。iPhone下的横屏、竖屏是多么的完美：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-65.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-66.png" alt="图片"></p>
<p>同学们，至此你们已经学习到了自适应布局最基本的技能。恭喜你们！</p>
<p>原文地址：<a href="http://www.raywenderlich.com/83276/beginning-adaptive-layout-tutorial" target="_blank" rel="external">Beginning Adaptive Layout Tutorial</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/adaptive-layout-1/" itemprop="url">
                  Swift自适应布局（Adaptive Layout）教程（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-11T00:00:00+08:00" content="2014-10-11">
              2014-10-11
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="u901A_u7528_u7684Storyboard"><a href="#u901A_u7528_u7684Storyboard" class="headerlink" title="通用的Storyboard"></a>通用的Storyboard</h2><p>通用的<code>stroyboard</code>文件是通向自适应布局光明大道的第一步。在一个<code>storyboard</code>文件中适配iPad和iPhone的布局在iOS8中已不再是梦想。我们不必再为不同尺寸的Apple移动设备创建不同的<code>storyboard</code>文件，不用再苦逼的同步若干个<code>storyboard</code>文件中的内容。这真是一件美好的事情。</p>
<p>我们打开Xcode，新建一个项目： </p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-1.png" alt="图片"></p>
<p>选择<code>iOS\Application\Single View Application</code>创建一个单视图应用：  </p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-2.png" alt="图片"></p>
<p>设置项目名称<strong>AdaptiveWeather</strong>，语言选择<strong>Swift</strong>，设备选择<strong>Universal</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-3.png" alt="图片"></p>
<p>创建好项目后，我们在项目目录结构中可以看到只存在一个<code>storyboard</code>文件：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-4.png" alt="图片"></p>
<p><strong>Main.storyboard</strong>文件就是一个通用的<code>storyboard</code>文件，它可以适配目前所有屏幕尺寸的Apple移动设备。打开该文件，同学们会看到一个View Controller，以及一个我们不太熟悉的界面尺寸：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-5.png" alt="图片"></p>
<p>同学们不要吃惊，没错，你们看到的就是一个简单的、有点大的正方形！大伙都知道，在上一个版本的Xcode中，<code>storyboard</code>里的屏幕尺寸都对应着我们所选的目标设备的尺寸，但是这样无法让我们达到“用一个<code>storyboard</code>搞定所有设备”的宏伟目标。所以在iOS8中，Apple将<code>storyboard</code>中屏幕的尺寸进行了抽象处理，也就是说我们看到的这个正方形是一个抽象的屏幕尺寸。</p>
<p>我们接着往下走，选中<code>Main.storyboard</code>文件，然后在右侧工具栏中选择<strong>File Inspector</strong>页签，然后勾选<strong>Use Size Classes</strong>选项：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-6.png" alt="图片"></p>
<p>在新的iOS8项目中，该选项默认是勾选的。但当你使用老版本的项目创建新的<code>storyboard</code>文件时就需要你手动进行勾选了。</p>
<h3 id="u8BBE_u7F6E_u4F60_u7684Storyboard_u6587_u4EF6"><a href="#u8BBE_u7F6E_u4F60_u7684Storyboard_u6587_u4EF6" class="headerlink" title="设置你的Storyboard文件"></a>设置你的Storyboard文件</h3><p>首先，我们打开<code>Main.storyboard</code>文件，从组件库（Object Library）中选择<strong>Image View</strong>拖拽到View Controller中。选中刚刚拖入的Image View，在右侧工具栏选择<strong>Size Inspector</strong>页签，设置<strong>X</strong>坐标为150，<strong>Y</strong>坐标为20，<strong>宽</strong>为300，<strong>高</strong>为265。</p>
<p>然后再拖入一个<strong>View</strong>组件，设置<strong>X</strong>坐标为150，<strong>Y</strong>坐标为315，<strong>宽</strong>为300，<strong>高</strong>为265。</p>
<p>选择你刚才拖入的View，在右侧工具栏中选择<strong>Identity Inspector</strong>页签，在<strong>Document</strong>面板中的<strong>Label</strong>属性输入框中输入<strong>TextContainer</strong>。这个属性的作用就是给View起一个名字，方便我们辨认。这里要注意一下，<strong>Document</strong>面板有可能是隐藏的，我们需要点击它后面的 <strong>Show</strong>按钮来显示它。我们拖入的这个View最后是显示城市和温度Label的容器。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-7.png" alt="图片"></p>
<p>完成上面的设置后，同学们可能会发现刚才拖入的View貌似看不到，这是因为它的背景色和View Controller的背景色是相同的，都是白色，所以我们不太容易辨别。我们来解决这个问题，选中View Controller的View，然后在右侧工具栏中选择<strong>Attribute Inspector</strong>页签，设置背景色为 <strong>红：74，绿：171，蓝：247</strong>。然后再选择TextContainer，就是我们拖入的View，设置背景色为 <strong>红：55，绿：128，蓝：186</strong>。此时<code>Main.storyboard</code>文件中应该是这番景象：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-8.png" alt="图片"></p>
<p>到目前为止，我们在View Controller中添加了两个组件Image View和View，这也是仅有的两个组件，接下来我们就要给它们添加一些布局约束了。</p>
<h3 id="u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F"><a href="#u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F" class="headerlink" title="添加布局约束"></a>添加布局约束</h3><p>选择image view，点击底部自动布局工具栏中的<strong>Align</strong>按钮，勾选<strong>Horizontal Center in Container</strong>选项，将后面的值设置为0，点击 <strong>Add 1 Constraint</strong>按钮添加第一个约束。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-9.png" alt="图片"></p>
<p>这个约束的意思是让image view在它的容器（View Controller的View）中保持居中。</p>
<p>然后再点击底部自动布局工具栏中的<strong>Pin</strong>按钮，添加一个image view顶部与容器顶部间距的约束，我们设置为0：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-10.png" alt="图片"></p>
<p>上面这两个约束使image view处于容器居中的位置，并且它的顶部与容器顶部有一个固定的间距。现在我们需要添加image view和text container view之间的约束。同学们先选中image view，然后按住<strong>Ctrl</strong>键和鼠标左键，从image view往text container view移动鼠标：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-11.png" alt="图片"></p>
<p>松开鼠标左键后会弹出一个约束菜单，我们选择<strong>Vertical Spacing</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-12.png" alt="图片"></p>
<p>这个约束决定了image view底部和text container view顶部之间的距离。</p>
<p>现在选中image view然后点击右侧工具栏中的<strong>Size Inspector</strong>页签，同学们会发现这里在Xcode6中和之前的Xcode版本有所不同：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-13.png" alt="图片"></p>
<p>你会看到之前添加的三个布局约束，你可以在<strong>Size Inspector</strong>中很方便的修改这些布局约束。比如点击<strong>Bottom Space To: TextContainer</strong>约束后的 <strong>Edit</strong>按钮，会弹出约束属性编辑框，我们让<strong>Constant</strong>的值等于20：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-14.png" alt="图片"></p>
<p>然后点击该弹出框之外的任意地方关闭该弹出框。</p>
<p>你先已经将TextContainer view顶部与image view底部的间距调整到了20，我们还需要添加TextContainer view另外三个边的间距约束。</p>
<p>继续选择TextContainer view，点击底部的<strong>Pin</strong>按钮弹出 <strong>Add New Constraints</strong>窗口，在 <strong>Spacing to nearest neighbor</strong>面板中设置左、右、底部的约束，将值设置为0，然后点击<strong>Add 3 Constraints</strong>按钮添加约束。这里要注意的是，在设置约束时要将 <strong>Constrain to margins</strong>选项的勾去掉，这样可以避免TextContainer view产生内边距：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-15.png" alt="图片"></p>
<p>这三个约束会让TextContainer view的左、右、底部三个边与容器的左、右、底部的间距始终为0。</p>
<p>现在<strong>Main.storyboard</strong>中应该是这番景象：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-16.png" alt="图片"></p>
<p>此时同学们应该会注意到在view上有几个橘黄色的约束线，这意味着还有一些约束上的问题需要我们注意。不过在运行时<code>storyboard</code>会自动更新view的大小来满足它与容器的约束条件。我们也可以点击底部 <strong>Resolve Auto Layout Issues</strong> 按钮，在弹出框中选择 <strong>All Views in View Controller/Update Frames</strong> 来修复提示的约束问题，但是如果我们这样做，那么image view的尺寸就会压缩成零，也就是会看不到image view。</p>
<p>这是因为我们的image view还有没有任何内容，但是它有一个缺省的高和宽，并且值为0。进行自动布局的时候，如果被约束的view没有实际的高和宽，那么会依照缺省的高和宽来满足约束条件。</p>
<p>我们接着学习，在项目结构中打开 <strong>Images.xcassets</strong> ，然后点击左下角的 <strong>+</strong>号，在弹出菜单中选择 <strong>New Image Set</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-17.png" alt="图片"></p>
<p>双击左上角的 <strong>Image</strong> 标题将其改为 <strong>cloud</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-18.png" alt="图片"></p>
<p>我们刚才新建的这个image set其实就是若干图片文件的一个集合，其中的每一个图片都会对应一个特定的应用场景，也就是针对与不同分辨率的Apple移动设备。比如说，一个图片集合可能会包含针对非视网膜、视网膜、视网膜高清三种分辨率的图片。自从Xcode中的资源库与UIKit完美结合后，在代码中引入图片时我们只需要写图片的名称，程序在运行时会根据当前运行的设备自动选择对应分辨率的图片。</p>
<blockquote>
<p>注意：如果你以前使用过通过资源库管理图片，那么你可能会发现在Xcode6中会有所不同。那就是3x图片是怎么回事？</p>
<p>这个新的分片率是专为iPhone 6 Plus提供的。这意味着每一个点是由3个像素点组成，也就是说3x的图片比1x图片的像素多9倍。</p>
</blockquote>
<p>目前你的图片集合中还是空的，同学们可以在这里下载需要的图片<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/09/cloud_images.zip" target="_blank" rel="external">cloud_images.zip </a>，然后将图片拖入刚才创建的名为cloud的图片集合中，将 <strong>cloud_small.png</strong>图片拖到 <strong>1x</strong>图片区域：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-19.png" alt="图片"></p>
<p>由于我们的图片背景颜色是透明的，所以在图片集合中看到的都是白色的图片。你可以选中某一个图片，然后按下空格键来预览图片。比如选中 <strong>1x</strong> 图片，按下空格：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-20.png" alt="图片"></p>
<p>现在将 <strong>cloud_small@2x.png</strong> 图片拖至 <strong>2x</strong> 图片区域，将 <strong>cloud_small@3x.png</strong> 图片拖至 <strong>3x</strong> 图片区域。和之前情况一样，我们看到的只是白色的图片，但我们可以通过空格键来预览图片集合中的图片。</p>
<p>现在你就可以在image view中设置图片了。我们回到 <strong>Main.storyboard</strong> 中，选中image view，在右侧工具栏中选择 <strong>Attribute Inspector</strong> 页签，将 <strong>Image View</strong> 面板中的 <strong>Image</strong> 属性设置为 <strong>cloud</strong>，然后将 <strong>View</strong> 面板中的 <strong>Mode</strong> 属性设置为 <strong>Aspect Fit</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-21.png" alt="图片"></p>
<p>现在你的<strong>Main.storyboard</strong>中应该是这番景象：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-22.png" alt="图片"></p>
<p>我们看到<code>storyboard</code>中一直有橘黄色的约束提示，是时候让我们来修复它们了。首先选中view controller的view：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-23.png" alt="图片"></p>
<p>然后点击底部的 <strong>Resolve Auto Layout Issues</strong> 按钮，在弹出菜单的 <strong>All Views in View Controller</strong> 面板中选择 <strong>Update Frames</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-24.png" alt="图片"></p>
<p>这时，<code>storyboard</code>会自动根据约束条件重新计算view的大小以满足约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-25.png" alt="图片"></p>
<h3 id="u9884_u89C8_u52A9_u624B_u7F16_u8F91_u5668_uFF08Preview_Assistant_Editor_uFF09"><a href="#u9884_u89C8_u52A9_u624B_u7F16_u8F91_u5668_uFF08Preview_Assistant_Editor_uFF09" class="headerlink" title="预览助手编辑器（Preview Assistant Editor）"></a>预览助手编辑器（Preview Assistant Editor）</h3><p>一般情况下，在这个时候我们应该会在iPad、iPhone4s、iPhone5s、iPhone6、iPhone6 Plus这几个不同尺寸的设备上编译运行程序，以便测试通用的<code>storyboard</code>是否能在不同尺寸的设备上正确的自适应。但这确实是个体力活，一遍一遍的更改设备、编译、运行，多么苦逼。但上天总是会眷顾我们这些苦逼的程序员，Xcode6提供了Preview Assistant Editor，能在一个界面上显示出不同尺寸设备的程序运行情况，是否有问题一目了然。</p>
<p>我们打开 <strong>Main.storyboard</strong> ，然后选择 <strong>View\Assistant Editor\Show Assistant Editor</strong> ，这时编辑区会分隔为两部分。再点击顶部导航栏中的 <strong>Automatic</strong> ，在弹出菜单中选择 <strong>Preview</strong> ，最后选择 <strong>Main.storyboard (Preview)</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-26.png" alt="图片"></p>
<p>现在在 <strong>Assistant Editor</strong> 区域会显示一个4寸的界面：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-27.png" alt="图片"></p>
<p>我们还可以点击预览界面底部，名字（比如图中的iPhone 4-inch）旁边的地方让屏幕翻转为横屏：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-28.png" alt="图片"></p>
<p>这无疑是针对检查不同尺寸设备的自适应情况的一项重大改进，但还远远不止于此！点击预览界面左下角的 <strong>+</strong> 按钮，会弹出当前<code>storyboard</code>文件支持的各种尺寸的设备，可供我们预览：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-29.png" alt="图片"></p>
<p>分别选择iPhone 5.5-inch和iPad，此时我们在预览界面就可以同时显示三种尺寸的屏幕：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-30.png" alt="图片"></p>
<p>此时同学们是否注意到4寸的横屏显示有点别扭呢？没错，它的那朵元太大了，我们可以通过对image view添加其他的约束条件来改善这个问题。</p>
<p>回到 <strong>Main.storyboard</strong> ，选择image view，然后按住 <strong>Ctrl</strong>建和鼠标左键，拖动鼠标到View Controller的View上，松开鼠标后会弹出一个菜单，我们选择 <strong>Equal Heights</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-31.png" alt="图片"></p>
<p>这时会出现一些红色的约束提示，这是因为我们刚才加的这个约束条件与之前加过的约束条件有冲突。因为之前我们添加过image view和TextContainer view之间的垂直间距（Vertical Margins）约束，所以image view的高度不可能等于它容器（View Controller的View）的高度。</p>
<p>让我们来修复该问题，首先在<code>storyboard</code>的结构目录中选择我们刚才添加的 <strong>Equal Heights</strong> 约束，然后选择右侧工具栏中的 <strong>Attribute Inspect</strong> 页签，如果 <strong>First Item</strong> 属性不是 <strong>cloud.Height</strong> ，那么在下拉菜单中选择 <strong>Reverse First and Second Item</strong> 这一项让 <strong>First Item</strong> 的值成为 <strong>cloud.Height</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-32.png" alt="图片"></p>
<p>接下来将 <strong>Relation</strong> 属性的值设置为 <strong>Less Than or Equal</strong> ，将 <strong>Multiplier</strong> 的值设置为 <strong>0.4</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-33.png" alt="图片"></p>
<p>这一系列设置的作用是让cloud这张图片的高度要么等于它自身的高度，要么等于屏幕高度的40%，最后呈现的效果选择这两者中较小的一个高度。</p>
<p>现在你应该注意到了在预览面板中，4寸的横屏显示即时的对你刚才的约束改动做出了响应：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-34.png" alt="图片"></p>
<p>你看看其他尺寸的预览自动更新了么？答案那是必须的，所以说 <strong>Preview Assistant Editor</strong> 确实是一项重大改进，是程序员和设计人员的福音！</p>
<p>由于本文的示例是一个天气应用，所以光有天气图标不行，我们还得加上城市和温度才行。</p>
<p>未完待续……</p>
<p>原文地址：<a href="http://www.raywenderlich.com/83276/beginning-adaptive-layout-tutorial" target="_blank" rel="external">Beginning Adaptive Layout Tutorial</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://www.devtalking.com/devtalking.png" alt="DevTalking" itemprop="image"/>
          <p class="site-author-name" itemprop="name">DevTalking</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">65</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分類</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">31</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jacefu" target="_blank">
                  <i class="fa fa-微博"></i> 微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="jace.fu@icloud.com" target="_blank">
                  <i class="fa fa-邮箱"></i> 邮箱
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="jace.fu@icloud.com" target="_blank">
                  <i class="fa fa-email"></i> email
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DevTalking</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
