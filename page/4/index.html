<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-121973094-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-121973094-1');
</script>


<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
 <script type="text/x-mathjax-config">
 MathJax.Hub.Config({tex2jax: {inlineMath:[['$','$']]}});
 </script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #272822; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #272822, 0 0 5px #272822; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #272822;    /*上边框颜色*/
        border-left-color: #272822;    /*左边框颜色*/
    }
</style>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>




  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="程序员说" type="application/atom+xml" />



  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="程序员说">
<meta property="og:url" content="http://www.devtalking.com/page/4/index.html">
<meta property="og:site_name" content="程序员说">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员说">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> 程序员说 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?980738dc41a50d91861a17ad4b768a1f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>


  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">程序员说</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/read-threading-programming-guide-3/" itemprop="url">
                  读 Threading Programming Guide 笔记（三）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-02-18T00:00:00+08:00" content="2016-02-18">
              2016-02-18
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/read-threading-programming-guide-3/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/read-threading-programming-guide-3/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/56056" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文章中有对官方文档的翻译，也有自己的理解，官方文档中代码片段的示例在这篇文章中都进行了完整的重写，还有一些文档中没有的代码示例，并且都使用Swift完成，给大家一些Objc与Swift转换的参考。<br>官方文档地址：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></p>
</blockquote>
<h2 id="u4F55_u65F6_u4F7F_u7528Run_Loop"><a href="#u4F55_u65F6_u4F7F_u7528Run_Loop" class="headerlink" title="何时使用Run Loop"></a>何时使用Run Loop</h2><p>前文中多次提到过，在主线程中Run Loop是随着应用程序一起启动的，也就是说当我们打开一个应用时，主线程中的Run Loop就已经启动了，尤其现在我们都使用Xcode中的项目模版创建项目，更是不用考虑主线程中Run Loop的状体。所以只有在二级线程中，也就是我们自己创建的线程中才有机会手动的创建的Run Loop，并对其进行配置的操作。</p>
<p>在前文中还提到过，Run Loop在线程中的主要作用就是帮助线程常驻在进程中，并且不会过多消耗资源。所以说Run Loop在二级线程中也不是必须需要的，要根据该线程执行的任务类型以及在整个应用中担任何作用而决定是否需要使用Run Loop。比如说，如果你创建一个二级线程只是为了执行一个不会频繁执行的一次性任务，或者需要执行很长时间的任务，那么可能就不需要使用Run Loop了。如果你需要一个线程执行周期性的定时任务，或者需要较为频繁的与主线程之间进行交互，那么就需要使用Run Loop。归纳一下需要使用Run Loop的情况大概有以下四点：</p>
<ul>
<li>通过基于端口或自定义的数据源与其他线程进行交互。</li>
<li>在线程中执行定时事件源的任务。</li>
<li>使用Cocoa框架提供的<code>performSelector…</code>系列方法。</li>
<li>在线程中执行较为频繁的，具有周期性的任务。</li>
</ul>
<p>光说不练假把式，下面就让我们来看看如何具体创建、配置、操作Run Loop。</p>
<h2 id="Run_Loop_u5BF9_u8C61"><a href="#Run_Loop_u5BF9_u8C61" class="headerlink" title="Run Loop对象"></a>Run Loop对象</h2><p>要想操作配置Run Loop，那自然需要通过Run Loop对象来完成，它提供了一系列接口，可帮助我们便捷的添加Input sources、timers以及观察者。较高级别的Cocoa框架提供了<code>NSRunLoop</code>类，较底层级别的Core Foundation框架提供了指向<code>CFRunloopRef</code>的指针。</p>
<h3 id="u83B7_u53D6Run_Loop_u5BF9_u8C61"><a href="#u83B7_u53D6Run_Loop_u5BF9_u8C61" class="headerlink" title="获取Run Loop对象"></a>获取Run Loop对象</h3><p>前文中提到过，在Cocoa和Core Foundation框架中都没有提供创建Run Loop的方法，只有从当前线程获取Run Loop的方法：</p>
<ul>
<li>在Cocoa框架中，<code>NSRunLoop</code>类提供了类方法<code>currentRunLoop()</code>获取<code>NSRunLoop</code>对象。<br>> 该方法是获取当前线程中已存在的Run Loop，如果不存在，那其实还是会创建一个Run Loop对象返回，只是Cocoa框架没有向我们暴露该接口。</li>
<li>在Core Foundation框架中提供了<code>CFRunLoopGetCurrent()</code>函数获取<code>CFRunLoop</code>对象。</li>
</ul>
<p>虽然这两个Run Loop对象并不完全等价，它们之间还是可以转换的，我们可以通过<code>NSRunLoop</code>对象提供的<code>getCFRunLoop()</code>方法获取<code>CFRunLoop</code>对象。因为<code>NSRunLoop</code>和<code>CFRunLoop</code>指向的都是当前线程中同一个Run Loop，所以在使用时它们可以混用，比如说要给Run Loop添加观察者时就必须得用<code>CFRunLoop</code>了。</p>
<h3 id="u914D_u7F6ERun_Loop_u89C2_u5BDF_u8005"><a href="#u914D_u7F6ERun_Loop_u89C2_u5BDF_u8005" class="headerlink" title="配置Run Loop观察者"></a>配置Run Loop观察者</h3><p>前文中提到过，可以向Run Loop中添加各种事件源和观察者，这里事件源是必填项，也就是说Run Loop中至少要有一种事件源，不论是Input source还是timer，如果Run Loop中没有事件源的话，那么在启动Run Loop后就会立即退出。而观察者是可选项，如果没有监控Run Loop各运行状态的需求，可以不配置观察者，这一节先看看如何向Run Loop中添加观察者。</p>
<p>在Cocoa框架中，并没有提供创建配置Run Loop观察者的相关接口，所以我们只能通过Core Foundation框架中提供的对象和方法创建并配置Run Loop观察者，下面我们看看示例代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"createAndConfigObserverInSecondaryThread"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="type">NSThread</span>.isMultiThreaded())</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">createAndConfigObserverInSecondaryThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        autoreleasepool&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 1</span></span><br><span class="line">            <span class="keyword">let</span> runloop = <span class="type">NSRunLoop</span>.currentRunLoop()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2</span></span><br><span class="line">            <span class="keyword">var</span> _self = <span class="keyword">self</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">            <span class="keyword">var</span> observerContext = <span class="type">CFRunLoopObserverContext</span>(version: <span class="number">0</span>, info: &amp;_self, retain: <span class="literal">nil</span>, release: <span class="literal">nil</span>, copyDescription: <span class="literal">nil</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4</span></span><br><span class="line">            <span class="keyword">let</span> observer = <span class="type">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, <span class="type">CFRunLoopActivity</span>.<span class="type">AllActivities</span>.rawValue, <span class="literal">true</span>, <span class="number">0</span>, <span class="keyword">self</span>.observerCallbackFunc(), &amp;observerContext)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(observer != <span class="literal">nil</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 5</span></span><br><span class="line">                <span class="keyword">let</span> cfRunloop = runloop.getCFRunLoop()</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 6</span></span><br><span class="line">                <span class="type">CFRunLoopAddObserver</span>(cfRunloop, observer, kCFRunLoopDefaultMode)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 7</span></span><br><span class="line">            <span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(<span class="number">0.5</span>, target: <span class="keyword">self</span>, selector: <span class="string">"fireTimer"</span>, userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> loopCount = <span class="number">10</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">repeat</span> &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 8</span></span><br><span class="line">                runloop.runUntilDate(<span class="type">NSDate</span>(timeIntervalSinceNow: <span class="number">1</span>))</span><br><span class="line">                </span><br><span class="line">                loopCount--</span><br><span class="line">            </span><br><span class="line">            &#125; <span class="keyword">while</span>(loopCount &gt; <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">observerCallbackFunc</span><span class="params">()</span></span> -&gt; <span class="type">CFRunLoopObserverCallBack</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;(observer, activity, context) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">            <span class="keyword">switch</span>(activity) &#123;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">Entry</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop已经启动"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">BeforeTimers</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop分配定时任务前"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">BeforeSources</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop分配输入事件源前"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">BeforeWaiting</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop休眠前"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">AfterWaiting</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop休眠后"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">CFRunLoopActivity</span>.<span class="type">Exit</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Run Loop退出后"</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">fireTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>下面解读一下上述代码示例，<code>launch()</code>方法在主线程中，通过<code>NSThread</code>类的类方法<code>detachNewThreadSelector:toTarget:withObject:</code>创建并启动一个二级线程，将<code>createAndConfigObserverInSecondaryThread()</code>方法作为事件消息传入该二级线程，这个方法的主要作用就是在二级线程中创建配置Run Loop观察者并启动Run Loop，然后让主线程持续3秒，以便二级线程有足够的时间执行任务。</p>
<p>在<code>createAndConfigObserverInSecondaryThread()</code>中共有8个关键步骤，下面一一进行说明：</p>
<ul>
<li><strong>第一步</strong>：通过<code>NSRunLoop</code>类的类方法<code>currentRunLoop()</code>获取当前线程的Run Loop，这里获取到的Run Loop对象是<code>NSRunLoop</code>对象。</li>
<li><strong>第二步</strong>：申明当前对象的变量，至于为什么要这么做，在下一步中会有说明。</li>
<li><strong>第三步</strong>：通过Core Foundation框架的<code>CFRunLoopObserverContext</code>结构体构造Run Loop观察者上下文，大家需要注意前两个参数，我们先看看这个结构体：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">CFRunLoopObserverContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> version: <span class="type">CFIndex</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> info: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> retain: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;)!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> release: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> copyDescription: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!)!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>()</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(version: <span class="type">CFIndex</span>, info: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, retain: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;)!, release: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)!, copyDescription: (<span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!)!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>version</code>：结构体版本号，必须设置为0。</li>
<li><code>info</code>：上下文中<code>retain</code>、<code>release</code>、<code>copyDescription</code>三个回调函数以及Run Loop观察者的回调函数所有者对象的指针。在Swift中，<code>UnsafePointer</code>结构体代表C系语言中申明为常量的指针，<code>UnsafeMutablePoinger</code>结构体代表C系语言中申明为非常量的指针，比如说：</li>
</ol>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">C</span>:</span><br><span class="line">void functionWithConstArg(const int *constIntPointer);</span><br><span class="line"></span><br><span class="line"><span class="type">Swift</span>:</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">functionWithConstArg</span><span class="params">(constIntPointer: UnsafePointer&lt;Int32&gt;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">C</span>:</span><br><span class="line">void functionWithNotConstArg(unsigned int *unsignedIntPointer);</span><br><span class="line"></span><br><span class="line"><span class="type">Swift</span>:</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">functionWithNotConstArg</span><span class="params">(unsignedIntPointer: UnsafeMutablePointer&lt;UInt32&gt;)</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">C</span>:</span><br><span class="line">void functionWithNoReturnArg(void *voidPointer);</span><br><span class="line"></span><br><span class="line"><span class="type">Swift</span>:</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">functionWithNoReturnArg</span><span class="params">(voidPointer: UnsafeMutablePointer&lt;Void&gt;)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>第四步</strong>：通过Core Foundation框架的<code>CFRunLoopObserverCreate</code>函数创建<code>CFRunLoopObserver</code>对象：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopObserverCreate</span><span class="params">(allocator: CFAllocator!, <span class="number">_</span> activities: CFOptionFlags, <span class="number">_</span> repeats: Bool, <span class="number">_</span> order: CFIndex, <span class="number">_</span> callout: CFRunLoopObserverCallBack!, <span class="number">_</span> context: UnsafeMutablePointer&lt;CFRunLoopObserverContext&gt;)</span></span> -&gt; <span class="type">CFRunLoopObserver</span>!</span><br></pre></td></tr></table></figure>
<ol>
<li><code>allocator</code>：该参数为对象内存分配器，一般使用默认的分配器<code>kCFAllocatorDefault</code>。</li>
<li><code>activities</code>：该参数配置观察者监听Run Loop的哪种运行状态。在示例中，我们让观察者监听Run Loop的所有运行状态。</li>
<li><code>repeats</code>：该参数标识观察者只监听一次还是每次Run Loop运行时都监听。</li>
<li><code>order</code>：观察者优先级，当Run Loop中有多个观察者监听同一个运行状态时，那么就根据该优先级判断，0为最高优先级别。</li>
<li><code>callout</code>：观察者的回调函数，在Core Foundation框架中用<code>CFRunLoopObserverCallBack</code>重定义了回调函数的闭包。</li>
<li><code>context</code>：观察者的上下文。</li>
</ol>
<ul>
<li><strong>第五步</strong>：因为<code>NSRunLoop</code>没有提供操作观察者的接口，所以我们需要<code>getCFRunLoop()</code>方法获取到<code>CFRunLoop</code>对象。</li>
<li><strong>第六步</strong>：通过<code>CFRunLoopAddObserver</code>函数向当前线程的Run Loop中添加创建好的观察者：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopAddObserver</span><span class="params">(<span class="number">_</span> rl: CFRunLoop!, <span class="number">_</span> observer: CFRunLoopObserver!, <span class="number">_</span> mode: CFString!)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>rl</code>：当前线程的<code>CFRunLoop</code>对象。</li>
<li><code>observer</code>：创建好的观察者。</li>
<li><code>mode</code>：设置将观察者添加到哪个Run Loop模式中。</li>
</ol>
<blockquote>
<p>这里需要注意的是，一个观察者只能被添加到一个Run Loop中，但是可以被添加到Run Loop中的多个模式中。</p>
</blockquote>
<ul>
<li><strong>第七步</strong>：通过Timer事件源向当前线程发送重复执行的定时任务，时间间隔为0.5秒，因为只是为了测试观察者，所以<code>fireTimer()</code>是一个空任务。另外前文中提到过，如果Run Loop中没有任何数据源，那么Run Loop启动后会立即退出，所以大家可以把这行注释了运行看看会有什么效果。</li>
<li><strong>第八步</strong>：通过<code>NSRunLoop</code>对象的<code>runUntilDate(limitDate: NSDate)</code>方法启动Run Loop，设置Run Loop的运行时长为1秒。这里将其放在一个循环里，最大循环次数为10次，也就是说，如果不考虑主线程的运行时间，该二级线程的Run Loop可运行10次。</li>
</ul>
<p>再来看看观察者的回调方法<code>observerCallbackFunc()</code>，上面在介绍<code>CFRunLoopObserverCreate</code>函数时提到观察者的回调函数是<code>CFRunLoopObserverCallBack</code>重定义的一个闭包，我们来看看这个闭包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">CFRunLoopObserverCallBack</span> = (<span class="type">CFRunLoopObserver</span>!, <span class="type">CFRunLoopActivity</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span></span><br></pre></td></tr></table></figure>
<p>这个闭包没有返回值，第一个参数是触发监听的观察者，第二个参数是观察者监听的Run Loop运行状态，第三个参数是观察者的运行上下文环境。所以在回调方法中，我们只需要根据第二个参数的值即可判断观察者监听到的Run Loop状态。大家可以拷贝上面的代码，建一个Command Application运行看看结果。</p>
<h3 id="u542F_u52A8Run_Loop"><a href="#u542F_u52A8Run_Loop" class="headerlink" title="启动Run Loop"></a>启动Run Loop</h3><p>在启动Run Loop前务必要保证已添加一种类型的事件源，原因在前文中已提到多次。在Cocoa框架和Core Foundation框架中启动Run Loop大体有三种形式，分别是无条件启动、设置时间限制启动、指定特定模式启动。</p>
<h4 id="u65E0_u6761_u4EF6_u542F_u52A8"><a href="#u65E0_u6761_u4EF6_u542F_u52A8" class="headerlink" title="无条件启动"></a>无条件启动</h4><p><code>NSRunLoop</code>对象的<code>run()</code>方法和Core Foundation框架中的<code>CFRunLoopRun()</code>函数都是无条件启动Run Loop的方式。这种方式虽然是最简单的启动方式，但也是最不推荐使用的一个方式，因为这种方式将Run Loop置于一个永久运行并且不可控的状态，它使Run Loop只能在默认模式下运行，无法给Run Loop设置特定的或自定义的模式，而且以这种模式启动的Run Loop只能通过<code>CFRunLoopStop(_ rl: CFRunLoop!)</code>函数强制停止。</p>
<h4 id="u8BBE_u7F6E_u65F6_u95F4_u9650_u5236_u542F_u52A8"><a href="#u8BBE_u7F6E_u65F6_u95F4_u9650_u5236_u542F_u52A8" class="headerlink" title="设置时间限制启动"></a>设置时间限制启动</h4><p>该方式对应的方法是<code>NSRunLoop</code>对象的<code>runUntilDate(_ limitDate: NSDate)</code>方法，在启动Run Loop时设置超时时间，一旦超时那么Run Loop则自动退出。该方法的好处是可以在循环中反复启动Run Loop处理相关任务，而且可控制运行时长。</p>
<h4 id="u6307_u5B9A_u7279_u5B9A_u6A21_u5F0F_u542F_u52A8"><a href="#u6307_u5B9A_u7279_u5B9A_u6A21_u5F0F_u542F_u52A8" class="headerlink" title="指定特定模式启动"></a>指定特定模式启动</h4><p>该方式对应的方法是<code>NSRunLoop</code>对象的<code>runMode(_ mode: String, beforeDate limitDate: NSDate)</code>方法和Core Foundation框架的<code>CFRunLoopRunInMode(_ mode: CFString!, _ seconds: CFTimeInterval, _ returnAfterSourceHandled: Bool)</code>函数。前者有两个参数，第一个参数是Run Loop模式，第二个参数仍然是超时时间，该方法使Run Loop只处理指定模式中的事件源事件，当处理完事件或超时Run Loop会退出，该方法的返回值类型是<code>Bool</code>，如果返回<code>true</code>则表示Run Loop启动成功，并分派执行了任务或者达到超时时间，若返回<code>false</code>则表示Run Loop启动失败。后者有三个参数，前两个参数的作用一样，第三个参数的意思是Run Loop是否在执行完任务后就退出，如果设置为<code>false</code>，那么代表Run Loop在执行完任务后不退出，而是一直等到超时后才退出。该方法返回Run Loop的退出状态：</p>
<ul>
<li><code>CFRunLoopRunResult.Finished</code>：表示Run Loop已分派执行完任务，并且再无任务执行的情况下退出。</li>
<li><code>CFRunLoopRunResult.Stopped</code>：表示Run Loop通过<code>CFRunLoopStop(_ rl: CFRunLoop!)</code>函数强制退出。</li>
<li><code>CFRunLoopRunResult.TimedOut</code>：表示Run Loop因为超时时间到而退出。</li>
<li><code>CFRunLoopRunResult.HandledSource</code>：表示Run Loop已执行完任务而退出，改状态只有在<code>returnAfterSourceHandled</code>设置为<code>true</code>时才会出现。</li>
</ul>
<h3 id="u9000_u51FARun_Loop"><a href="#u9000_u51FARun_Loop" class="headerlink" title="退出Run Loop"></a>退出Run Loop</h3><p>退出Run Loop的方式总体来说有三种：</p>
<ul>
<li>启动Run Loop时设置超时时间。</li>
<li>强制退出Run Loop。</li>
<li>移除Run Loop中的事件源，从而使Run Loop退出。</li>
</ul>
<p>第一种方式是推荐使用的方式，因为可以给Run Loop设置可控的运行时间，让它执行完所有的任务以及给观察者发送通知。第二种强制退出Run Loop主要是应对无条件启动Run Loop的情况。第三种方式是最不推荐的方式，虽然在理论上说当Run Loop中没有任何数据源时会立即退出，但是在实际情况中我们创建的二级线程除了执行我们指定的任务外，有可能系统还会让其执行一些系统层面的任务，而且这些任务我们一般无法知晓，所以用这种方式退出Run Loop往往会存在延迟退出。</p>
<h3 id="Run_Loop_u5BF9_u8C61_u7684_u7EBF_u7A0B_u5B89_u5168_u6027"><a href="#Run_Loop_u5BF9_u8C61_u7684_u7EBF_u7A0B_u5B89_u5168_u6027" class="headerlink" title="Run Loop对象的线程安全性"></a>Run Loop对象的线程安全性</h3><p>Run Loop对象的线程安全性取决于我们使用哪种API去操作。Core Foundation框架中的<code>CFRunLoop</code>对象是线程安全的，我们可以在任何线程中使用。Cocoa框架的<code>NSRunLoop</code>对象是线程不安全的，我们必须在拥有Run Loop的当前线程中操作Run Loop，如果操作了不属于当前线程的Run loop，会导致异常和各种潜在的问题发生。</p>
<h2 id="u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90"><a href="#u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90" class="headerlink" title="自定义Run Loop事件源"></a>自定义Run Loop事件源</h2><p>Cocoa框架因为是较为高层的框架，所以没有提供操作较为底层的Run Loop事件源相关的接口和对象，所以我们只能使用Core Foundation框架中的对象和函数创建事件源并给Run Loop设置事件源。</p>
<h3 id="u521B_u5EFARun_Loop_u4E8B_u4EF6_u6E90_u5BF9_u8C61"><a href="#u521B_u5EFARun_Loop_u4E8B_u4EF6_u6E90_u5BF9_u8C61" class="headerlink" title="创建Run Loop事件源对象"></a>创建Run Loop事件源对象</h3><p>我们定义自己的Run Loop事件源首先就是需要创建事件源，我们来看看创建事件源的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopSourceCreate</span><span class="params">(<span class="number">_</span> allocator: CFAllocator!, <span class="number">_</span> order: CFIndex, <span class="number">_</span> context: UnsafeMutablePointer&lt;CFRunLoopSourceContext&gt;)</span></span> -&gt; <span class="type">CFRunLoopSource</span>!</span><br></pre></td></tr></table></figure>
<ol>
<li><code>allocator</code>：该参数为对象内存分配器，一般使用默认的分配器<code>kCFAllocatorDefault</code>。</li>
<li><code>order</code>：事件源优先级，当Run Loop中有多个接收相同事件的事件源被标记为待执行时，那么就根据该优先级判断，0为最高优先级别。</li>
<li><code>context</code>：事件源上下文。</li>
</ol>
<p>Run Loop事件源上下文很重要，我们来看看它的结构：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CFRunLoopSourceContext</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> version: <span class="type">CFIndex</span> </span><br><span class="line">    <span class="keyword">var</span> info: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt; </span><br><span class="line">    <span class="keyword">var</span> retain: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;)! </span><br><span class="line">    <span class="keyword">var</span> release: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)! </span><br><span class="line">    <span class="keyword">var</span> copyDescription: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!)! </span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">equal</span>: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">DarwinBoolean</span>)! </span><br><span class="line">    <span class="keyword">var</span> hash: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">CFHashCode</span>)! </span><br><span class="line">    <span class="keyword">var</span> schedule: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span>)! </span><br><span class="line">    <span class="keyword">var</span> cancel: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span>)! </span><br><span class="line">    <span class="keyword">var</span> perform: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)! </span><br><span class="line">    <span class="keyword">init</span>() </span><br><span class="line">    <span class="keyword">init</span>(version version: <span class="type">CFIndex</span>, info info: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, retain retain: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;)!, release release: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)!, copyDescription copyDescription: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">CFString</span>&gt;!)!, <span class="built_in">equal</span> <span class="built_in">equal</span>: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">DarwinBoolean</span>)!, hash hash: ((<span class="type">UnsafePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">CFHashCode</span>)!, schedule schedule: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span>)!, cancel cancel: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span>)!, perform perform: ((<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span>)!) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该结构体中我们需要关注的是前两个和后三个属性：</p>
<ol>
<li><code>version</code>：事件源上下文的版本，必须设置为0。</li>
<li><code>info</code>：上下文中<code>retain</code>、<code>release</code>、<code>copyDescription</code>、<code>equal</code>、<code>hash</code>、<code>schedule</code>、<code>cancel</code>、<code>perform</code>这八个回调函数所有者对象的指针。</li>
<li><code>schedule</code>：该回调函数的作用是将该事件源与给它发送事件消息的线程进行关联，也就是说如果主线程想要给该事件源发送事件消息，那么首先主线程得能获取到该事件源。</li>
<li><code>cancel</code>：该回调函数的作用是使该事件源失效。</li>
<li><code>perform</code>：该回调函数的作用是执行其他线程或当前线程给该事件源发来的事件消息。</li>
</ol>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u5C06_u4E8B_u4EF6_u6E90_u6DFB_u52A0_u81F3Run_Loop"><a href="#u5C06_u4E8B_u4EF6_u6E90_u6DFB_u52A0_u81F3Run_Loop" class="headerlink" title="将事件源添加至Run Loop"></a>将事件源添加至Run Loop</h3><p>事件源创建好之后，接下来就是将其添加到指定某个模式的Run Loop中，我们来看看这个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopAddSource</span><span class="params">(<span class="number">_</span> rl: CFRunLoop!, <span class="number">_</span> source: CFRunLoopSource!, <span class="number">_</span> mode: CFString!)</span></span></span><br></pre></td></tr></table></figure>
<ol>
<li><code>rl</code>：希望添加事件源的Run Loop对象，类型是<code>CFRunLoop</code>。</li>
<li><code>source</code>：我们创建好的事件源。</li>
<li><code>mode</code>：Run Loop的模式。（可以回顾之前文章）</li>
</ol>
<p>我们再来看看这个方法都干了些什么：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">void <span class="type">CFRunLoopAddSource</span>(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopSourceRef</span> rls, <span class="type">CFStringRef</span> modeName) &#123;</span><br><span class="line">  </span><br><span class="line">    .....</span><br><span class="line">  </span><br><span class="line">    __CFRunLoopSourceSchedule(rls, rl, rlm);</span><br><span class="line">  </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __CFRunLoopSourceSchedule(<span class="type">CFRunLoopSourceRef</span> rls, <span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm) &#123;  </span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="type">NULL</span> != rls-&gt;_context.version0.schedule) &#123;</span><br><span class="line">             rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, rlm-&gt;_name);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述的代码片段可以看出，在<code>CFRunLoopAddSource</code>中调用了<code>__CFRunLoopSourceSchedule</code>内部函数，而该函数中正是执行了Run Loop事件源上下文中的<code>schedule</code>回调函数。也就是说当把事件源添加到Run Loop中后就会将事件源与给它发送事件消息的线程进行关联。</p>
<h3 id="u6807_u8BB0_u4E8B_u4EF6_u6E90_u53CA_u5524_u9192Run_Loop"><a href="#u6807_u8BB0_u4E8B_u4EF6_u6E90_u53CA_u5524_u9192Run_Loop" class="headerlink" title="标记事件源及唤醒Run Loop"></a>标记事件源及唤醒Run Loop</h3><p>前面的文章中说过，srouce0类型，也就是非port类型的事件源都需要进行手动标记，标记完还需要手动唤醒Run Loop，下面我们来看看这两个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopSourceSignal</span><span class="params">(<span class="number">_</span> source: CFRunLoopSource!)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopWakeUp</span><span class="params">(<span class="number">_</span> rl: CFRunLoop!)</span></span></span><br></pre></td></tr></table></figure>
<p>这里需要注意的是唤醒Run Loop并不等价与启动Run Loop，因为启动Run Loop时需要对Run Loop进行模式、时限的设置，而唤醒Run Loop只是当已启动的Run Loop休眠时重新让其运行。</p>
<h3 id="u6267_u884CRun_Loop_u4E8B_u4EF6_u6E90_u7684_u4EFB_u52A1"><a href="#u6267_u884CRun_Loop_u4E8B_u4EF6_u6E90_u7684_u4EFB_u52A1" class="headerlink" title="执行Run Loop事件源的任务"></a>执行Run Loop事件源的任务</h3><p>唤醒Run Loop意味着让休眠的Run Loop重新运行，那么我们就从启动Run Loop，让其开始运行的方法看起：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSRunLoop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">runUntilDate</span><span class="params">(limitDate: NSDate)</span></span> &#123;</span><br><span class="line">        <span class="keyword">while</span> runMode(<span class="type">NSDefaultRunLoopMode</span>, beforeDate: limitDate) &amp;&amp; limitDate.timeIntervalSinceReferenceDate &gt; <span class="type">CFAbsoluteTimeGetCurrent</span>() &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">runMode</span><span class="params">(mode: String, beforeDate limitDate: NSDate)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        .....</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> limitTime = limitDate.timeIntervalSinceReferenceDate</span><br><span class="line">        <span class="keyword">let</span> ti = limitTime - <span class="type">CFAbsoluteTimeGetCurrent</span>()</span><br><span class="line">        <span class="type">CFRunLoopRunInMode</span>(modeArg, ti, <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">SInt32</span> <span class="type">CFRunLoopRunInMode</span>(<span class="type">CFStringRef</span> modeName, <span class="type">CFTimeInterval</span> seconds, <span class="type">Boolean</span> returnAfterSourceHandled) &#123;     </span><br><span class="line">    <span class="type">CHECK_FOR_FORK</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="type">CFRunLoopRunSpecific</span>(<span class="type">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">SInt32</span> <span class="type">CFRunLoopRunSpecific</span>(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFStringRef</span> modeName, <span class="type">CFTimeInterval</span> seconds, <span class="type">Boolean</span> returnAfterSourceHandled) &#123;     </span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> int32_t __CFRunLoopRun(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm, <span class="type">CFTimeInterval</span> seconds, <span class="type">Boolean</span> stopAfterHandle, <span class="type">Boolean</span> waitIfEmpty) &#123;</span><br><span class="line"></span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">Boolean</span> __CFRunLoopDoSources0(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm, <span class="type">Boolean</span> stopAfterHandle) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">CFTypeRef</span> sources = <span class="type">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopSourceIsSignaled(rls)) &#123;</span><br><span class="line">    </span><br><span class="line">        .....</span><br><span class="line">    </span><br><span class="line">        rls-&gt;_context.version0.perform(rls-&gt;_context.version0.info);</span><br><span class="line">        </span><br><span class="line">        .....</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码片段中可以看出，当Run Loop运行后会调用内部函数<code>__CFRunLoopDoSources0</code>执行自定义事件源的任务，在执行之前会通过内部函数<code>__CFRunLoopSourceIsSignaled(rls)</code>判断事件源是否已被标记为待执行，然后执行Run Loop事件上下文中的<code>perform</code>回调函数。</p>
<h3 id="u79FB_u9664Run_Loop_u4E8B_u4EF6_u6E90"><a href="#u79FB_u9664Run_Loop_u4E8B_u4EF6_u6E90" class="headerlink" title="移除Run Loop事件源"></a>移除Run Loop事件源</h3><p>当我们自定义的事件源完成使命后就可以将其从Run Loop中移除，我们来看看对应的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">CFRunLoopRemoveSource</span><span class="params">(<span class="number">_</span> rl: CFRunLoop!, <span class="number">_</span> source: CFRunLoopSource!, <span class="number">_</span> mode: CFString!)</span></span></span><br><span class="line"></span><br><span class="line">void <span class="type">CFRunLoopRemoveSource</span>(<span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopSourceRef</span> rls, <span class="type">CFStringRef</span> modeName) &#123;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">    __CFRunLoopSourceCancel(rls, rl, rlm);</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> void __CFRunLoopSourceCancel(<span class="type">CFRunLoopSourceRef</span> rls, <span class="type">CFRunLoopRef</span> rl, <span class="type">CFRunLoopModeRef</span> rlm) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == rls-&gt;_context.version0.version) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="type">NULL</span> != rls-&gt;_context.version0.cancel) &#123;</span><br><span class="line">              rls-&gt;_context.version0.cancel(rls-&gt;_context.version0.info, rl, rlm-&gt;_name);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码片段可以看出，当我们调用了<code>CFRunLoopRemoveSource</code>方法后，其实是执行了Run Loop事件源上下文中的<code>cancel</code>回调函数。</p>
<h3 id="u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90_u7684_u5B9E_u9645_u8FD0_u7528"><a href="#u81EA_u5B9A_u4E49Run_Loop_u4E8B_u4EF6_u6E90_u7684_u5B9E_u9645_u8FD0_u7528" class="headerlink" title="自定义Run Loop事件源的实际运用"></a>自定义Run Loop事件源的实际运用</h3><p>在讲解示例之前，我们先来看看示例Demo的效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-5.gif" alt="LearnThread-5"></p>
<p>在这个示例中，创建了两个自定义事件源，一个添加到主线程中，另一个添加到二级线程中。主线程给二级线程中的自定义事件源发送事件消息，目的是让其改变所有<code>UICollectionViewCell</code>的透明度，当二级线程收到事件消息后执行计算每个<code>UICollectionViewCell</code>透明度的任务，然后再给主线程的自定义事件源发送事件消息，让其更新<code>UICollectionViewCell</code>的透明度并显示。下面来看看类图：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-6-new.png" alt="LearnThread-6"></p>
<p>整个工程一共就这六个类：</p>
<ul>
<li><code>MainCollectionViewController</code>：程序主控制器，启动程序、展示UI及计算<code>UICollectionViewCell</code>透明度的相关方法。</li>
<li><code>MainThreadRunLoopSource</code>：主线程自定义事件源管理对象，负责初始化事件源，将事件源添加至指定线程，标记事件源并唤醒指定Run Loop以及包含上文中说过的事件源最主要的三个回调方法。</li>
<li><code>MainThreadRunLoopSourceContext</code>：主线程自定义事件源上下文，可获取到对应的事件源及添加了该事件源的Run Loop。</li>
<li><code>SecondaryThreadRunLoopSource</code>：二级线程自定义事件源管理对象，负责初始化事件源，将事件源添加至指定线程，标记事件源并唤醒指定Run Loop以及包含上文中说过的事件源最主要的三个回调方法。</li>
<li><code>SecondaryThreadRunLoopSourceContext</code>：二级线程自定义事件源上下文，可获取到对应的事件源及添加了该事件源的Run Loop。</li>
<li><code>AppDelegate</code>：应用程序代理类，这里零时充当为各自定义事件源回调方法执行内容的管理类。</li>
</ul>
<p>下面我按照程序的运行顺序一一对这些类及属性和方法进行简单说明。</p>
<h4 id="u7A0B_u5E8F_u5F00_u59CB_u8FD0_u884C"><a href="#u7A0B_u5E8F_u5F00_u59CB_u8FD0_u884C" class="headerlink" title="程序开始运行"></a>程序开始运行</h4><p><code>MainCollectionViewController</code>类中与UI展示相关的方法在这里就不再累赘了。点击<strong>Start</strong>按钮，调用<code>start()</code>方法，初始化<code>MainThreadRunLoopSource</code>对象，在这个过程中初始化了<code>CFRunLoopSourceContext</code>对象并且创建<code>CFRunLoopSource</code>对象以及初始化该事件源的指令池：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mainThreadRunLoopSource = <span class="type">MainThreadRunLoopSource</span>()</span><br><span class="line">        </span><br><span class="line">mainThreadRunLoopSource.addToCurrentRunLoop()</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> runloopSourceContext = <span class="type">CFRunLoopSourceContext</span>(version: <span class="number">0</span>, info: <span class="built_in">unsafeBitCast</span>(<span class="keyword">self</span>, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>), retain: <span class="literal">nil</span>, release: <span class="literal">nil</span>, copyDescription: <span class="literal">nil</span>, <span class="built_in">equal</span>: <span class="literal">nil</span>, hash: <span class="literal">nil</span>, schedule: runloopSourceScheduleRoutine(), cancel: runloopSourceCancelRoutine(), perform: runloopSourcePerformRoutine())</span><br><span class="line">        </span><br><span class="line">runloopSource = <span class="type">CFRunLoopSourceCreate</span>(kCFAllocatorDefault, <span class="number">0</span>, &amp;runloopSourceContext)</span><br><span class="line">        </span><br><span class="line">commandBuffer = <span class="type">Array</span>&lt;<span class="type">SecondaryThreadRunLoopSourceContext</span>&gt;()</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是<code>CFRunLoopSourceContext</code>的<code>init</code>方法中的第二个参数和<code>CFRunLoopSourceCreate</code>方法的第三个参数都是指针，那么在Swift中，将对象转换为指针的方法有两种：</p>
<ul>
<li>使用<code>unsafeBitCast</code>方法，该方法会将第一个参数的内容按照第二个参数的类型进行转换。一般当需要对象与指针来回转换时使用该方法。</li>
<li>在对象前面加<code>&amp;</code>符号，表示传入指针地址。</li>
</ul>
<p>当主线程的自定义事件源初始化完成之后，调用<code>addToCurrentRunLoop()</code>方法，将事件源添加至当前Run Loop中，即主线程的Run Loop：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cfrunloop = <span class="type">CFRunLoopGetCurrent</span>()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> rls = runloopSource &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="type">CFRunLoopAddSource</span>(cfrunloop, rls, kCFRunLoopDefaultMode)</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来创建二级线程，并且让其执行二级线程的配置任务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> secondaryThread = <span class="type">NSThread</span>(target: <span class="keyword">self</span>, selector: <span class="string">"startThreadWithRunloop"</span>, object: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">secondaryThread.start()</span><br></pre></td></tr></table></figure>
<p>在二级线程中同样初始化自定义事件源，并将将其添加至二级线程的Run Loop中，然后启动Run Loop：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">startThreadWithRunloop</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    autoreleasepool&#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">var</span> done = <span class="literal">false</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> secondaryThreadRunLoopSource = <span class="type">SecondaryThreadRunLoopSource</span>()</span><br><span class="line">            </span><br><span class="line">        secondaryThreadRunLoopSource.addToCurrentRunLoop()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">let</span> result = <span class="type">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">5</span>, <span class="literal">true</span>)</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> ((result == <span class="type">CFRunLoopRunResult</span>.<span class="type">Stopped</span>) || (result == <span class="type">CFRunLoopRunResult</span>.<span class="type">Finished</span>)) &#123;</span><br><span class="line">                    </span><br><span class="line">                done = <span class="literal">true</span>;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125; <span class="keyword">while</span>(!done)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6267_u884C_u4E8B_u4EF6_u6E90_u7684schedule_u56DE_u8C03_u51FD_u6570"><a href="#u6267_u884C_u4E8B_u4EF6_u6E90_u7684schedule_u56DE_u8C03_u51FD_u6570" class="headerlink" title="执行事件源的schedule回调函数"></a>执行事件源的schedule回调函数</h4><p>前文中说过将事件源添加至Run Loop后会触发事件源的<code>schedule</code>回调函数，所以当执行完<code>mainThreadRunLoopSource.addToCurrentRunLoop()</code>这句代码后，便会触发主线程自定义事件源的<code>schedule</code>回调函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">runloopSourceScheduleRoutine</span><span class="params">()</span></span> -&gt; <span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123; (info, runloop, runloopMode) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> mainThreadRunloopSource = <span class="built_in">unsafeBitCast</span>(info, <span class="type">MainThreadRunLoopSource</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> mainThreadRunloopSourceContext = <span class="type">MainThreadRunLoopSourceContext</span>(runloop: runloop, runloopSource: mainThreadRunloopSource)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> appDelegate = <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br><span class="line">            </span><br><span class="line">        appDelegate.performSelector(<span class="string">"registerMainThreadRunLoopSource:"</span>, withObject: mainThreadRunloopSourceContext)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里还需注意的是在Swift2.0中，如果一个作为回调函数方法的返回类型是指向函数的指针，这类指针可以转换为闭包，并且要在闭包前面加上<code>@convention(c)</code>标注。在<code>runloopSourceScheduleRoutine()</code>方法中，获取到主线程事件源对象并初始化事件源上下文对象，然后将该事件源上下文对象传给<code>AppDelegate</code>的对应方法注册该事件源上下文对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">registerMainThreadRunLoopSource</span><span class="params">(runloopSourceContext: MainThreadRunLoopSourceContext)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    mainThreadRunloopSourceContext = runloopSourceContext</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自然当在二级线程中执行完<code>secondaryThreadRunLoopSource.addToCurrentRunLoop()</code>这句代码后，也会触发二级线程自定义事件源的<code>schedule</code>回调函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">runloopSourceScheduleRoutine</span><span class="params">()</span></span> -&gt; <span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;, <span class="type">CFRunLoop</span>!, <span class="type">CFString</span>!) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123; (info, runloop, runloopMode) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> secondaryThreadRunloopSource = <span class="built_in">unsafeBitCast</span>(info, <span class="type">SecondaryThreadRunLoopSource</span>.<span class="keyword">self</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> secondaryThreadRunloopSourceContext = <span class="type">SecondaryThreadRunLoopSourceContext</span>(runloop: runloop, runloopSource: secondaryThreadRunloopSource)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> appDelegate = <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br><span class="line">            </span><br><span class="line">        appDelegate.performSelectorOnMainThread(<span class="string">"registerSecondaryThreadRunLoopSource:"</span>, withObject: secondaryThreadRunloopSourceContext, waitUntilDone: <span class="literal">true</span>)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的是，在该方法中同样是将二级线程事件源上下文对象传给了<code>AppDelegate</code>的对应方法，但是这里用了<code>performSelectorOnMainThread</code>方法，让其在主线程中执行，目的在于注册完上下文对象后就接着从主线程给二级线程发送事件消息了，其实我将这里作为了主线程触发二级线程执行任务的触发点：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">registerSecondaryThreadRunLoopSource</span><span class="params">(runloopSourceContext: SecondaryThreadRunLoopSourceContext)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    secondaryThreadRunloopSourceContext = runloopSourceContext</span><br><span class="line">        </span><br><span class="line">    sendCommandToSecondaryThread()</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sendCommandToSecondaryThread</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    secondaryThreadRunloopSourceContext?.runloopSource?.commandBuffer?.append(mainThreadRunloopSourceContext!)</span><br><span class="line">        </span><br><span class="line">    secondaryThreadRunloopSourceContext?.runloopSource?.signalSourceAndWakeUpRunloop(secondaryThreadRunloopSourceContext!.runloop!)</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看到在<code>sendCommandToSecondaryThread()</code>方法中，将主线程的事件源上下文放入了二级线程事件源的指令池中，这里我设计的是只要指令池中有内容就代表事件源需要执行后续任务了。然后执行了二级线程事件源的<code>signalSourceAndWakeUpRunloop()</code>方法，给其标记为待执行，并唤醒二级线程的Run Loop：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">signalSourceAndWakeUpRunloop</span><span class="params">(runloop: CFRunLoopRef)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">CFRunLoopSourceSignal</span>(runloopSource)</span><br><span class="line">        </span><br><span class="line">    <span class="type">CFRunLoopWakeUp</span>(runloop)</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="u6267_u884C_u4E8B_u4EF6_u6E90_u7684perform_u56DE_u8C03_u51FD_u6570"><a href="#u6267_u884C_u4E8B_u4EF6_u6E90_u7684perform_u56DE_u8C03_u51FD_u6570" class="headerlink" title="执行事件源的perform回调函数"></a>执行事件源的perform回调函数</h4><p>当二级线程事件源被标记并且二级线程Run Loop被唤醒后，就会触发事件源的<code>perform</code>回调函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">runloopSourcePerformRoutine</span><span class="params">()</span></span> -&gt; <span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123; info -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> appDelegate = <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br><span class="line">            </span><br><span class="line">        appDelegate.performSelector(<span class="string">"performSecondaryThreadRunLoopSourceTask"</span>)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二级线程事件源的<code>perform</code>回调函数会在当前线程，也就是二级线程中执行<code>AppDelegate</code>中的对应方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSecondaryThreadRunLoopSourceTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> secondaryThreadRunloopSourceContext!.runloopSource!.commandBuffer!.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">            </span><br><span class="line">        mainCollectionViewController!.generateRandomAlpha()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> mainThreadRunloopSourceContext = secondaryThreadRunloopSourceContext!.runloopSource!.commandBuffer![<span class="number">0</span>]</span><br><span class="line">            </span><br><span class="line">        secondaryThreadRunloopSourceContext!.runloopSource!.commandBuffer!.removeAll()</span><br><span class="line">            </span><br><span class="line">        mainThreadRunloopSourceContext.runloopSource?.commandBuffer?.append(secondaryThreadRunloopSourceContext!)</span><br><span class="line">            </span><br><span class="line">        mainThreadRunloopSourceContext.runloopSource?.signalSourceAndWakeUpRunloop(mainThreadRunloopSourceContext.runloop!)</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中可以看到，先会判断二级线程事件源的指令池中有没有内容，如果有的话，那么执行计算<code>UICollectionViewCell</code>透明度的任务，然后从指令池中获取到主线程事件源上下文对象，将二级线程事件源上下文对象放入主线程事件源的指令池中，并将主线程事件源标记为待执行，然后唤醒主线程Run Loop。之后便会触发主线程事件源的<code>perform</code>回调函数：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">runloopSourcePerformRoutine</span><span class="params">()</span></span> -&gt; <span class="preprocessor">@convention</span>(<span class="built_in">c</span>) (<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;) -&gt; <span class="type">Void</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &#123; info -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> appDelegate = <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>! <span class="type">AppDelegate</span></span><br><span class="line">            </span><br><span class="line">        appDelegate.performSelector(<span class="string">"performMainThreadRunLoopSourceTask"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performMainThreadRunLoopSourceTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> mainThreadRunloopSourceContext!.runloopSource!.commandBuffer!.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        </span><br><span class="line">        mainThreadRunloopSourceContext!.runloopSource!.commandBuffer!.removeAll()</span><br><span class="line">            </span><br><span class="line">        mainCollectionViewController!.collectionView.reloadData()</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">let</span> timer = <span class="type">NSTimer</span>(timeInterval: <span class="number">1</span>, target: <span class="keyword">self</span>, selector: <span class="string">"sendCommandToSecondaryThread"</span>, userInfo: <span class="literal">nil</span>, repeats: <span class="literal">false</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="type">NSRunLoop</span>.mainRunLoop().addTimer(timer, forMode: <span class="type">NSDefaultRunLoopMode</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>performMainThreadRunLoopSourceTask()</code>方法中同样会先判断主线程事件源的指令池是否有内容，然后执行<code>MainCollectionViewController</code>中的刷新UI的方法，最后再次给二级线程发送事件消息，以此循环。大家可以去Github下载该示例的<a href="https://github.com/DevTalking/CustomRunloopInputSourceSample.git" target="_blank" rel="external">源码</a>，编译环境是Xcode7.2，然后可以自己试着在界面中添加一个<strong>Stop</strong>按钮，让事件源执行<code>cancel</code>回调函数。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/read-threading-programming-guide-2/" itemprop="url">
                  读 Threading Programming Guide 笔记（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-02-10T00:00:00+08:00" content="2016-02-10">
              2016-02-10
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/read-threading-programming-guide-2/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/read-threading-programming-guide-2/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/55617" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文章中有对官方文档的翻译，也有自己的理解，官方文档中代码片段的示例在这篇文章中都进行了完整的重写，还有一些文档中没有的代码示例，并且都使用Swift完成，给大家一些Objc与Swift转换的参考。<br>官方文档地址：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></p>
</blockquote>
<h2 id="u7EBF_u7A0B_u5C5E_u6027_u914D_u7F6E"><a href="#u7EBF_u7A0B_u5C5E_u6027_u914D_u7F6E" class="headerlink" title="线程属性配置"></a>线程属性配置</h2><p>线程也是具有若干属性的，自然一些属性也是可配置的，在启动线程之前我们可以对其进行配置，比如线程占用的内存空间大小、线程持久层中的数据、设置线程类型、优先级等。</p>
<h3 id="u914D_u7F6E_u7EBF_u7A0B_u7684_u6808_u7A7A_u95F4_u5927_u5C0F"><a href="#u914D_u7F6E_u7EBF_u7A0B_u7684_u6808_u7A7A_u95F4_u5927_u5C0F" class="headerlink" title="配置线程的栈空间大小"></a>配置线程的栈空间大小</h3><p>在前文中提到过线程对内存空间的消耗，其中一部分就是线程栈，我们可以对线程栈的大小进行配置：</p>
<ul>
<li>Cocoa框架：在OS X v10.5之后的版本和iOS2.0之后的版本中，我们可以通过修改<code>NSThread</code>类的<code>stackSize</code>属性，改变二级线程的线程栈大小，不过这里要注意的是该属性的单位是字节，并且设置的大小必须得是4KB的倍数。</li>
<li>POSIX API：通过<code>pthread_attr_- setstacksize</code>函数给线程属性<code>pthread_attr_t</code>结构体设置线程栈大小，然后在使用<code>pthread_create</code>函数创建线程时将线程属性传入即可。</li>
</ul>
<blockquote>
<p>注意：在使用Cocoa框架的前提下修改线程栈时，不能使用<code>NSThread</code>的<code>detachNewThreadSelector: toTarget:withObject:</code>方法，因为上文中说过，该方法先创建线程，即刻便启动了线程，所以根本没有机会修改线程属性。</p>
</blockquote>
<h3 id="u914D_u7F6E_u7EBF_u7A0B_u5B58_u50A8_u5B57_u5178"><a href="#u914D_u7F6E_u7EBF_u7A0B_u5B58_u50A8_u5B57_u5178" class="headerlink" title="配置线程存储字典"></a>配置线程存储字典</h3><p>每一个线程，在整个生命周期里都会有一个字典，以<code>key-value</code>的形式存储着在线程执行过程中你希望保存下来的各种类型的数据，比如一个常驻线程的运行状态，线程可以在任何时候访问该字典里的数据。</p>
<p>在Cocoa框架中，可以通过<code>NSThread</code>类的<code>threadDictionary</code>属性，获取到<code>NSMutableDictionary</code>类型对象，然后自定义<code>key</code>值，存入任何里先储存的对象或数据。如果使用POSIX线程，可以使用<code>pthread_setspecific</code>和<code>pthread_getspecific</code>函数设置获取线程字典。</p>
<h3 id="u914D_u7F6E_u7EBF_u7A0B_u7C7B_u578B"><a href="#u914D_u7F6E_u7EBF_u7A0B_u7C7B_u578B" class="headerlink" title="配置线程类型"></a>配置线程类型</h3><p>在上文中提到过，线程有Joinable和Detached类型，大多数非底层的线程默认都是Detached类型的，相比Joinable类型的线程来说，Detached类型的线程不用与其他线程结合，并且在执行完任务后可自动被系统回收资源，而且主线程不会因此而阻塞，这着实要方便许多。</p>
<p>使用<code>NSThread</code>创建的线程默认都是Detached类型，而且似乎也不能将其设置为Joinable类型。而使用POSIX API创建的线程则默认为Joinable类型，而且这也是唯一创建Joinable类型线程的方式。通过POSIX API可以在创建线程前通过函数<code>pthread_attr_setdetachstate</code>更新线程属性，将其设置为不同的类型，如果线程已经创建，那么可以使用<code>pthread_detach</code>函数改变其类型。Joinable类型的线程还有一个特性，那就是在终止之前可以将数据传给与之相结合的线程，从而达到线程之间的交互。即将要终止的线程可以通过<code>pthread_exit</code>函数传递指针或者任务执行的结果，然后与之结合的线程可以通过<code>pthread_join</code>函数接受数据。</p>
<p>虽然通过POSIX API创建的线程使用和管理起来较为复杂和麻烦，但这也说明这种方式更为灵活，更能满足不同的使用场景和需求。比如当执行一些关键的任务，不能被打断的任务，像执行I/O操作之类。</p>
<h3 id="u8BBE_u7F6E_u7EBF_u7A0B_u4F18_u5148_u7EA7"><a href="#u8BBE_u7F6E_u7EBF_u7A0B_u4F18_u5148_u7EA7" class="headerlink" title="设置线程优先级"></a>设置线程优先级</h3><p>每一个新创建的二级线程都有它自己的默认优先级，内核会根据线程的各属性通过分配算法计算出线程的优先级。这里需要明确一个概念，高优先级的线程虽然会更早的运行，但这其中并没有执行时间效率的因素，也就是说高优先级的线程会更早的执行它的任务，但在执行任务的时间长短方面并没有特别之处。</p>
<p>不论是通过<code>NSThread</code>创建线程还是通过POSIX API创建线程，他们都提供了设置线程优先级的方法。我们可以通过<code>NSThread</code>的类方法<code>setThreadPriority:</code>设置优先级，因为线程的优先级由0.0～1.0表示，所以设置优先级时也一样。我们也可以通过<code>pthread_setschedparam</code>函数设置线程优先级。</p>
<blockquote>
<p>注意：设置线程的优先级时可以在线程运行时设置。</p>
</blockquote>
<p>虽然我们可以调节线程的优先级，但不到必要时还是不建议调节线程的优先级。因为一旦调高了某个线程的优先级，与低优先级线程的优先等级差距太大，就有可能导致低优先级线程永远得不到运行的机会，从而产生性能瓶颈。比如说有两个线程A和B，起初优先级相差无几，那么在执行任务的时候都会相继无序的运行，如果将线程A的优先级调高，并且当线程A不会因为执行的任务而阻塞时，线程B就可能一直不能运行，此时如果线程A中执行的任务需要与线程B中任务进行数据交互，而迟迟得不到线程B中的结果，此时线程A就会被阻塞，那么程序的性能自然就会产生瓶颈。</p>
<h2 id="u7EBF_u7A0B_u6267_u884C_u7684_u4EFB_u52A1"><a href="#u7EBF_u7A0B_u6267_u884C_u7684_u4EFB_u52A1" class="headerlink" title="线程执行的任务"></a>线程执行的任务</h2><p>在任何平台，线程存在的价值和意义都是一样的，那就是执行任务，不论是方法、函数或一段代码，除了依照语言语法正常编写外，还有一些额外需要大家注意的事项。</p>
<h3 id="Autorelease_Pool"><a href="#Autorelease_Pool" class="headerlink" title="Autorelease Pool"></a>Autorelease Pool</h3><p>在Xcode4.3之前，我们都处在手动管理引用计数的时代，代码里满是<code>retain</code>和<code>release</code>的方法，所以那个时候，被线程执行的任务中，为了能自动处理大量对象的<code>retain</code>和<code>release</code>操作，都会使用<code>NSAutoreleasePool</code>类创建自动释放池，它的作用是将线程中要执行的任务都放在自动释放池中，自动释放池会捕获所有任务中的对象，在任务结束或线程关闭之时自动释放这些对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myThreadMainRoutine</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init]; <span class="comment">// 顶层自动释放池</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程执行任务的逻辑代码</span></span><br><span class="line"></span><br><span class="line">    [pool release];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了自动引用计数（ARC）时代，就不能使用<code>NSAutoreleasePool</code>进行自动释放池管理了，而是新加了<code>@autoreleasepool</code>代码块语法来创建自动释放池：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myThreadMainRoutine</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 线程执行任务的逻辑代码</span></span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道每个应用程序都是运行在一个主线程里的，而线程都至少得有一个自动释放池，所以说整个应用其实是跑在一个自动释放池中的。大家都知道C系语言中，程序的入口函数都是<code>main</code>函数，当我们创建一个Objective－C的iOS应用后，Xcode会在<strong>Supporting Files</strong>目录下自动为我们创建一个<code>main.m</code>文件：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-2.png" alt="LearnThread-2"></p>
<p>在<code>main.m</code>这个文件中就能证实上面说的那点：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上都是在Objective－C中，但在Swift中，就有点不一样了，<code>NSAutoreleasePool</code>和<code>@autoreleasepool</code>都不能用了，取而代之的是Swift提供的一个方法<code>func autoreleasepool(code: () -&gt; ())</code>，接收的参数为一个闭包，我们可以这样使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performInBackground</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        autoreleasepool(&#123;</span><br><span class="line">        </span><br><span class="line">          <span class="comment">// 线程执行任务的逻辑代码</span></span><br><span class="line">          </span><br><span class="line">          <span class="built_in">print</span>(<span class="string">"I am a event, perform in Background Thread."</span>)  </span><br><span class="line">          </span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据尾随闭包的写法，还可以这样使用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performInBackground</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        autoreleasepool&#123;</span><br><span class="line">        </span><br><span class="line">          <span class="comment">// 线程执行任务的逻辑代码</span></span><br><span class="line">          </span><br><span class="line">          <span class="built_in">print</span>(<span class="string">"I am a event, perform in Background Thread."</span>)</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>有些人可能会问在ARC的时代下为什么还要用自动释放池呢？比如在SDWebImage中就大量使用了<code>@autoreleasepool</code>代码块，其原因就是为了避免内存峰值，大家都知道在MRC时代，除了<code>retain</code>和<code>release</code>方法外，还有一个常用的方法是<code>autorelease</code>，用来延迟释放对象，它释放对象的时机是当前runloop结束时。到了ARC时代，虽然不用我们手动管理内存了，但其自动管理的本质与MRC时是一样的，只不过由编译器帮我们在合适的地方加上了这三个方法，所以说如果在一个线程执行的任务中大量产生需要<code>autorelease</code>的对象时，因为不能及时释放对象，所以就很有可能产生内存峰值。那么在这种任务中在特定的时候使用<code>@autorelease</code>代码块，帮助释放对象，就可以有效的防止内存峰值的发生。</p>
<h3 id="u8BBE_u7F6E_u5F02_u5E38_u5904_u7406"><a href="#u8BBE_u7F6E_u5F02_u5E38_u5904_u7406" class="headerlink" title="设置异常处理"></a>设置异常处理</h3><p>在线程执行任务的时候，难免会出现异常，如果不能及时捕获异常任由其抛出，就会导致整个应用程序退出。在Swift2.0中，Apple提供了新的<a href="http://www.devtalking.com/articles/what-is-new-in-swift/">异常控制处理机制</a>，让我们能像Java中一样形如流水的捕获处理异常。所以在线程执行的任务中，我们尽量使用异常处理机制，提高健壮性。</p>
<h3 id="u521B_u5EFARunloop"><a href="#u521B_u5EFARunloop" class="headerlink" title="创建Runloop"></a>创建Runloop</h3><p>大家知道，一个线程只能执行一个任务，当任务结束后也就意味着这个线程也要结束，频繁的创建线程也是挺消耗资源的一件事，于是就有了常驻线程，前文介绍线程相关概念时也提到过：</p>
<blockquote>
<p>简单的来说，RunLoop用于管理和监听异步添加到线程中的事件，当有事件输入时，系统唤醒线程并将事件分派给RunLoop，当没有需要处理的事件时，RunLoop会让线程进入休眠状态。这样就能让线程常驻在进程中，而不会过多的消耗系统资源，达到有事做事，没事睡觉的效果。</p>
</blockquote>
<p>如果想要线程不结束，那就要被执行的任务不结束，让被执行的任务不结束显然不靠谱，那么就需要一个机制，能占着线程。该机制就是事件循环机制（Eventloop），体现在代码中就是一个<code>do-while</code>循环，不断的接收事件消息、处理事件、等待新事件消息，除非接收到一个让其退出的事件消息，否则它将一直这么循环着，线程自然就不会结束。Runloop就是管理消息和事件，并提供Eventloop函数的对象，线程执行的任务其实就是在Runloop对象的Eventloop函数里运行。关于Runloop更详细的知识及配置<br>操作在后文中会有讲述。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u7EC8_u6B62_u7EBF_u7A0B"><a href="#u7EC8_u6B62_u7EBF_u7A0B" class="headerlink" title="终止线程"></a>终止线程</h3><p>打个不恰当的比方，人终有一死，或正常生老病死，或非正常出事故意外而亡，前者尚合情合理后者悲痛欲绝。线程也一样，有正常终止结束，也有非正常的强制结束，不管是线程本身还是应用程序都希望线程能正常结束，因为正常结束也就意味着被执行的任务正常执行完成，从而让线程处理完后事随即结束，如果在任务执行途中强制终止线程，会导致线程没有机会处理后事，也就是正常释放资源对象等，这样会给应用程序带来例如内存溢出这类潜在的问题，所以强烈不推荐强制终止线程的做法。</p>
<p>如果确实有在任务执行途中终止线程的需求，那么可以使用Runloop，在任务执行过程中定期查看是否有收到终止任务的事件消息，这样一来可以在任务执行途中判断出终止任务的信号，然后进行终止任务的相关处理，比如保存数据等，二来可以让线程有充分的时间释放资源。</p>
<h2 id="Run_Loop"><a href="#Run_Loop" class="headerlink" title="Run Loop"></a>Run Loop</h2><p>Run Loops是线程中的基础结构，在上文中也提到过，Run Loops其实是一个事件循环机制，用来分配、分派线程接受到的事件任务，同时可以让线程成为一个常驻线程，即有任务时处理任务，没任务时休眠，且不消耗资源。在实际应用时，Run Loop的生命周期并不全是自动完成的，还是需要人工进行配置，不论是Cocoa框架还是Core Foundation框架都提供了Run Loop的相关对象对其进行配置和管理。</p>
<blockquote>
<p>注：Core Foundation框架是一组C语言接口，它们为iOS应用程序提供基本数据管理和服务功能，比如线程和Run Loop、端口、Socket、时间日期等。</p>
</blockquote>
<p>在所有的线程中，不论是主线程还是二级线程，都不需要显示的创建Run Loop对象，这里的显示指的是通过任何<em>create</em>打头的方法创建Run Loop。对于主线程来说，当应用程序通过<code>UIApplicationMain</code>启动时，主线程中的Run Loop就已经创建并启动了，而且也配置好了。那么如果是二级线程，则需要我们手动先获取Run Loop，然后再手动进行配置并启动。下面的章节会向大家详细介绍Run Loop的知识。</p>
<blockquote>
<p>注：在二级线程中获取Run Loop有两种方式，通过<code>NSRunloop</code>的类方法<code>currentRunLoop</code>获取Run Loop对象（<code>NSRunLoop</code>），或者通过Core Foundation框架中的<code>CFRunLoopGetCurrent()</code>函数获取当前线程的Run Loop对象（<code>CFRunLoop</code>）。<code>NSRunLoop</code>是<code>CFRunLoop</code>的上层封装。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nsrunloop = <span class="type">NSRunLoop</span>.currentRunLoop()</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> cfrunloop = <span class="type">CFRunLoopGetCurrent</span>()</span><br></pre></td></tr></table></figure>
<h3 id="Run_Loop_u7684_u4E8B_u4EF6_u6765_u6E90"><a href="#Run_Loop_u7684_u4E8B_u4EF6_u6765_u6E90" class="headerlink" title="Run Loop的事件来源"></a>Run Loop的事件来源</h3><p>Run Loop有两个事件来源，一个是<strong>Input source</strong>，接收来自其他线程或应用程序（进程）的异步事件消息，并将消息分派给对应的事件处理方法。另一个是<strong>Timer source</strong>，接收定期循环执行或定时执行的同步事件消息，同样会将消息分派给对应的事件处理方法。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-3.png" alt="LearnThread-3"></p>
<p>上图展示了Run Loop的两类事件来源，以及在Input source中的两种不同的子类型，它们分别对应着Run Loop中不同的处理器。当不同的事件源接收到消息后，通过<code>NSRunLoop</code>的<code>runUntilDate:</code>方法启动运行Run Loop，将事件消息分派给对应的处理器执行，一直到指定的时间时退出Run Loop。</p>
<h3 id="Run_Loop_u7684_u89C2_u5BDF_u8005"><a href="#Run_Loop_u7684_u89C2_u5BDF_u8005" class="headerlink" title="Run Loop的观察者"></a>Run Loop的观察者</h3><p>Run Loop的观察者可以理解为Run Loop自身运行状态的监听器，它可以监听Run Loop的下面这些运行状态：</p>
<ul>
<li>Run Loop准备开始运行时。</li>
<li>当Run Loop准备要执行一个Timer Source事件时。</li>
<li>当Run Loop准备要执行一个Input Source事件时。</li>
<li>当Run Loop准备休眠时。</li>
<li>当Run Loop被进入的事件消息唤醒并且还没有开始让处理器执行事件消息时。</li>
<li>退出Run Loop时。</li>
</ul>
<p>Run Loop的观察者在<code>NSRunloop</code>中没有提供相关接口，所以我们需要通过Core Foundation框架使用它，可以通过<code>CFRunLoopObserverCreate</code>方法创建Run Loop的观察者，类型为<code>CFRunLoopObserverRef</code>，它其实是<code>CFRunLoopObserver</code>的重定义名称。上述的那些可以被监听的运行状态被封装在了<code>CFRunLoopActivity</code>结构体中，对应关系如下：</p>
<ul>
<li><code>CFRunLoopActivity.Entry</code></li>
<li><code>CFRunLoopActivity.BeforeTimers</code></li>
<li><code>CFRunLoopActivity.BeforeSources</code></li>
<li><code>CFRunLoopActivity.BeforeWaiting</code></li>
<li><code>CFRunLoopActivity.AfterWaiting</code></li>
<li><code>CFRunLoopActivity.Exit</code></li>
</ul>
<p>Run Loop的观察者和Timer事件类似，可以只使用一次，也可以重复使用，在创建观察者时可以设置。如果只使用一次，那么当监听到对应的状态后会自行移除，如果是重复使用的，那么会留在Run Loop中多次监听Run Loop相同的运行状态。</p>
<h3 id="Run_Loop_Modes"><a href="#Run_Loop_Modes" class="headerlink" title="Run Loop Modes"></a>Run Loop Modes</h3><p>Run Loop Modes可以称之为Run Loop模式，这个模式可以理解为对Run Loop各种设置项的不同组合，举个例子，iPhone手机运行的iOS有很多系统设置项，假设白天我打开蜂窝数据，晚上我关闭蜂窝数据，而打开无线网络，到睡觉时我关闭蜂窝数据和无线网络，而打开飞行模式。假设在这三个时段中其他的所有设置项都相同，而只有这三个设置项不同，那么就可以说我的手机有三种不同的设置模式，对应着不同的时间段。那么Run Loop的设置项是什么呢？那自然就是前文中提到的不同的事件来源以及观察者了，比如说，Run Loop的模式A（Mode A），只包含接收Timer Source事件源的事件消息以及监听Run Loop运行时的观察者，而模式B（Mode B）只包含接收Input Source事件源的事件消息以及监听Run Loop准备休眠时和退出Run Loop时的观察者，如下图所示：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread%EF%BC%8D7.png" alt="LearnThread-4"></p>
<p>所以说，Run Loop的模式就是不同类型的数据源和不同观察者的集合，当Run Loop运行时要设置它的模式，也就是告知Run Loop只需要关心这个集合中的数据源类型和观察者，其他的一概不予理会。那么通过模式，就可以让Run Loop过滤掉它不关心的一些事件，以及避免被无关的观察者打扰。如果有不在当前模式中的数据源发来事件消息，那只能等Run Loop改为包含有该数据源类型的模式时，才能处理事件消息。</p>
<p>在Cocoa框架和Core Foundation框架中，已经为我们预定义了一些Run Loop模式：</p>
<ul>
<li>默认模式：在<code>NSRunloop</code>中的定义为<code>NSDefaultRunLoopMode</code>，在<code>CFRunloop</code>中的定义为<code>kCFRunLoopDefaultMode</code>。该模式包含的事件源囊括了除网络链接操作的大多数操作以及时间事件，用于当前Run Loop处于空闲状态等待事件时，以及Run Loop开始运行时。</li>
<li>NSConnectionReplyMode：该模式用于监听<code>NSConnection</code>相关对象的返回结果和状态，在系统内部使用，我们一般不会使用该模式。</li>
<li>NSModalPanelRunLoopMode：该模式用于过滤在模态面板中处理的事件（Mac App）。</li>
<li>NSEventTrackingRunLoopMode：该模式用于跟踪用户与界面交互的事件。</li>
<li>模式集合：或者叫模式组，顾名思义就是将多个模式组成一个组，然后将模式组认为是一个模式设置给Run Loop，在<code>NSRunloop</code>中的定义为<code>NSRunLoopCommonModes</code>，在<code>CFRunloop</code>中的定义为<code>kCFRunLoopCommonModes</code>。系统提供的模式组名为Common Modes，它默认包含NSDefaultRunLoopMode、NSModalPanelRunLoopMode、NSEventTrackingRunLoopMode这三个模式。</li>
</ul>
<p>以上五种系统预定的模式中，前四种属于只读模式，也就是我们无法修改它们包含的事件源类型和观察者类型。而模式组我们可以通过Core Foundation框架提供的<code>CFRunLoopAddCommonMode(_ rl: CFRunLoop!, _ mode: CFString!)</code>方法添加新的模式，甚至是我们自定义的模式。这里需要注意的是，既然在使用时，模式组是被当作一个模式使用的，那么自然可以给它设置不同类型的事件源或观察者，当给模式组设置事件源或观察者时，实际是给该模式组包含的所有模式设置。比如说给模式组设置了一个监听Run Loop准备休眠时的观察者，那么该模式组里的所有模式都会被设置该观察者。</p>
<h3 id="Input_Source"><a href="#Input_Source" class="headerlink" title="Input Source"></a>Input Source</h3><p>前文中说过，Input Sources接收到各种操作输入事件消息，然后异步的分派给对应事件处理方法。在Input Sources中又分两大类的事件源，一类是基于端口事件源（Port-based source），在<code>CFRunLoopSourceRef</code>的结构中为source1，主要通过监听应用程序的Mach端口接收事件消息并分派，该类型的事件源可以主动唤醒Run Loop。另一类是自定义事件源（Custom source），在<code>CFRunLoopSourceRef</code>的结构中为source0，一般是接收其他线程的事件消息并分派给当前线程的Run Loop，比如<code>performSwlwctor:onThread:...</code>系列方法，该类型的事件源无法自动唤醒Run Loop，而是需要手动将事件源设置为待执行的标记，然后再手动唤醒Run Loop。虽然这两种类型的事件源接收事件消息的方式不一样，但是当接收到消息后，对消息的分派机制是完全相同的。</p>
<h4 id="Port-Based_Source"><a href="#Port-Based_Source" class="headerlink" title="Port-Based Source"></a>Port-Based Source</h4><p>Cocoa框架和Core Foundation框架都提供了相关的对象和函数用于创建基于端口的事件源。在Cocoa框架中，实现基于端口的事件源主要是通过<code>NSPort</code>类实现的，它代表了交流通道，也就是说在不同的线程的Run Loop中都存在<code>NSPort</code>，那么它们之间就可以通过发送与接收消息（<code>NSPortMessage</code>）互相通信。所以我们只需要通过<code>NSPort</code>类的类方法<code>port</code>创建对象实例，然后通过<code>NSRunloop</code>的方法将其添加到Run Loop中，或者在创建二级线程时将创建好的<code>NSPort</code>对象传入即可，无需我们再做消息、消息上下文、事件源等其他配置，都由Run Loop自行配置好了。而在Core Foundation框架中就比较麻烦一些，大多数配置都需要我们手动配置，在后面会详细举例说明。</p>
<h4 id="Custom_Input_Source"><a href="#Custom_Input_Source" class="headerlink" title="Custom Input Source"></a>Custom Input Source</h4><p>Cocoa框架中没有提供创建自定义事件源的相关接口，我们只能通过Core Foundation框架中提供的对象和函数创建自定义事件源，手动配置事件源各个阶段要处理的逻辑，比如创建<code>CFRunLoopSourceRef</code>事件源对象，通过<code>CFRunLoopScheduleCallBack</code>回调函数配置事件源上下文并注册事件源，通过<code>CFRunLoopPerformCallBack</code>回调函数处理接收到事件消息后的逻辑，通过<code>CFRunLoopCancelCallBack</code>函数销毁事件源等等，在后文中会有详细举例说明。</p>
<p>虽然Cocoa框架没有提供创建自定义事件源的相关对象和接口，但是它为我们预定义好了一些事件源，能让我们在当前线程、其他二级线程、主线程中执行我们希望被执行的方法，让我们看看<code>NSObject</code>中的这些方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelectorOnMainThread</span><span class="params">(<span class="number">_</span> aSelector: Selector, withObject arg: AnyObject?, waitUntilDone wait: Bool)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelectorOnMainThread</span><span class="params">(<span class="number">_</span> aSelector: Selector, withObject arg: AnyObject?, waitUntilDone wait: Bool, modes array: [String]?)</span></span></span><br></pre></td></tr></table></figure>
<p>这两个方法允许我们将当前线程中对象的方法让主线程去执行，可以选择是否阻塞当前线程，以及希望被执行的方法作为事件消息被何种Run Loop模式监听。</p>
<blockquote>
<p>注：如果在主线程中使用该方法，当选择阻塞当前线程，那么发送的方法会立即被主线程执行，若选择不阻塞当前线程，那么被发送的方法将被排进主线程Run Loop的事件队列中，并等待执行。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(<span class="number">_</span> aSelector: Selector, withObject anArgument: AnyObject?, afterDelay delay: NSTimeInterval)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(<span class="number">_</span> aSelector: Selector, withObject anArgument: AnyObject?, afterDelay delay: NSTimeInterval, inModes modes: [String])</span></span></span><br></pre></td></tr></table></figure>
<p>这两个方法允许我们给当前线程发送事件消息，当前线程接收到消息后会依次加入Run Loop的事件消息队列中，等待Run Loop迭代执行。该方法还可以指定消息延迟发送时间及消息希望被何种Run Loop模式监听。</p>
<blockquote>
<p>注：该方法中的延迟时间并不是延迟Run Loop执行事件消息的事件，而是延迟向当前线程发送事件消息的时间。另外，即便不设置延迟时间，那么发送的事件消息也不一定立即被执行，因为在Run Loop的事件消息队列中可以已有若干等待执行的消息。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(<span class="number">_</span> aSelector: Selector, onThread thr: NSThread, withObject arg: AnyObject?, waitUntilDone wait: Bool)</span></span></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelector</span><span class="params">(<span class="number">_</span> aSelector: Selector, onThread thr: NSThread, withObject arg: AnyObject?, waitUntilDone wait: Bool, modes array: [String]?)</span></span></span><br></pre></td></tr></table></figure>
<p>这两个方法允许我们给其他二级线程发送事件消息，前提是要取得目标二级线程的<code>NSThread</code>对象实例，该方法同样提供了是否阻塞当前线程的选项和设置Run Loop模式的选项。</p>
<blockquote>
<p>注：使用该方法给二级线程发送事件消息时要确保目标线程正在运行，换句话说就是目标线程要有启动着的Run Loop。并且保证目标线程执行的任务要在应用程序代理执行<code>applicationDidFinishLaunching:</code>方法前完成，否则主线程就结束了，目标线程自然也就结束了。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">performSelectorInBackground</span><span class="params">(<span class="number">_</span> aSelector: Selector, withObject arg: AnyObject?)</span></span></span><br></pre></td></tr></table></figure>
<p>该方法允许我们在当前应用程序中创建一个二级线程，并将指定的事件消息发送给新创建的二级线程。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">cancelPreviousPerformRequestsWithTarget</span>(<span class="title">_</span> <span class="title">aTarget</span>: <span class="title">AnyObject</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">class</span> <span class="title">func</span> <span class="title">cancelPreviousPerformRequestsWithTarget</span>(<span class="title">_</span> <span class="title">aTarget</span>: <span class="title">AnyObject</span>, <span class="title">selector</span> <span class="title">aSelector</span>: <span class="title">Selector</span>, <span class="title">object</span> <span class="title">anArgument</span>: <span class="title">AnyObject</span>?)</span></span><br></pre></td></tr></table></figure>
<p>这两个方法是<code>NSObject</code>的类方法，第一个方法作用是在当前线程中取消Run Lop中某对象通过<code>performSelector:withObject:afterDelay:</code>方法发送的所有事件消息执行请求。第二个方法多了两个过滤参数，那就是方法名称和参数，取消指定方法名和参数的事件消息执行请求。</p>
<h3 id="Timer_Source"><a href="#Timer_Source" class="headerlink" title="Timer Source"></a>Timer Source</h3><p>Timer Source顾名思义就是向Run Loop发送在将来某一时间执行或周期性重复执行的同步事件消息。当某线程不需要其他线程通知而需要自己通知自己执行任务时就可以用这种事件源。举个应用场景，在iOS应用中，我们经常会用到搜索功能，而且一些搜索框具有自动搜索的能力，也就是说不用我们点击搜索按钮，只需要输入完我想要搜索的内容就会自动搜索，大家想一想如果每输入一个字就开始立即搜索，不但没有意义，性能开销也大，用户体验自然也很糟糕，我们希望当输入完这句话，或至少输入一部分之后再开始搜索，所以我们就可以在开始输入内容时向执行搜索功能的线程发送定时搜索的事件消息，让其在若干时间后再执行搜索任务，这样就有缓冲时间输入搜索内容了。</p>
<p>这里需要注意的是Timer Source发送给Run Loop的周期性执行任务的重复时间是相对时间。比如说给Run Loop发送了一个每隔5秒执行一次的任务，每次执行任务的正常时间为2秒，执行5次后终止，假设该任务被立即执行，那么当该任务终止时应该历时30秒，但当第一次执行时出现了问题，导致任务执行了20秒，那么该任务只能再执行一次就终止了，执行的这一次其实就是第5次，也就是说不论任务的执行时间延迟与否，Run Loop都会按照初始的时间间隔执行任务，并非按Finish-To-Finish去算的，所以一旦中间任务有延时，那么就会丢失任务执行次数。关于Timer Source的使用，在后文中会有详细举例说明。</p>
<h3 id="Run_Loop_u5185_u90E8_u8FD0_u884C_u903B_u8F91"><a href="#Run_Loop_u5185_u90E8_u8FD0_u884C_u903B_u8F91" class="headerlink" title="Run Loop内部运行逻辑"></a>Run Loop内部运行逻辑</h3><p>在Run Loop的运行生命周期中，无时无刻都伴随着执行等待执行的各种任务以及在不同的运行状态时通知不同的观察者，下面我们看看Run Loop中的运行逻辑到底是怎样的：</p>
<ol>
<li>通知对应观察者Run Loop准备开始运行。</li>
<li>通知对应观察者准备执行定时任务。</li>
<li>通知对应观察者准备执行自定义事件源的任务。</li>
<li>开始执行自定义事件源任务。</li>
<li>如果有基于端口事件源的任务准备待执行，那么立即执行该任务。然后跳到步骤9继续运转。</li>
<li>通知对应观察者线程进入休眠。</li>
<li>如果有下面的事件发生，则唤醒线程：<ol>
<li>接收到基于端口事件源的任务。</li>
<li>定时任务到了该执行的时间点。</li>
<li>Run Loop的超时时间到期。</li>
<li>Run Loop被手动唤醒。</li>
</ol>
</li>
<li>通知对应观察者线程被唤醒。</li>
<li>执行等待执行的任务。<ol>
<li>如果有定时任务已启动，执行定时任务并重启Run Loop。然后跳到步骤2继续运转。</li>
<li>如果有非定时器事件源的任务待执行，那么分派执行该任务。</li>
<li>如果Run Loop被手动唤醒，重启Run Loop。然后跳转到步骤2继续运转。</li>
</ol>
</li>
<li>通知对应观察者已退出Run Loop。</li>
</ol>
<p>以上这些Run Loop中的步骤也不是每一步都会触发，举一个例子：<br>1.对应观察者接收到通知Run Loop准备开始运行 -> 3.对应观察者接收到通知Run Loop准备执行自定义事件源任务 -> 4.开始执行自定义事件源任务 -> 任务执行完毕且没有其他任务待执行 -> 6.线程进入休眠状态，并通知对应观察者 -> 7.接收到定时任务并唤醒线程 -> 8.通知对应观察者线程被唤醒 -> 9.执行定时任务并重启Run Loop -> 2.通知对应观察者准备执行定时任务 －> Run Loop执行定时任务，并在等待下次执行任务的间隔中线程休眠 -> 6.线程进入休眠状态，并通知对应观察者…</p>
<p>这里需要注意的一点是从上面的运行逻辑中可以看出，当观察者接收到执行任务的通知时，Run Loop并没有真正开始执行任务，所以观察者接收到通知的时间与Run Loop真正执行任务的时间有时间差，一般情况下这点时间差影响不大，但如果你需要通过观察者知道Run Loop执行任务的确切时间，并根据这个时间要进行后续操作的话，那么就需要通过结合多个观察者接收到的通知共同确定了。一般通过监听准备执行任务的观察者、监听线程进入休眠的观察者、监听线程被唤醒的观察者共同确定执行任务的确切时间。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/read-threading-programming-guide-1/" itemprop="url">
                  读 Threading Programming Guide 笔记（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2016-02-01T00:00:00+08:00" content="2016-02-01">
              2016-02-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/read-threading-programming-guide-1/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/read-threading-programming-guide-1/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://geek.csdn.net/news/detail/54092" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<blockquote>
<p>记得第一次读这个文档还是3年前，那时也只是泛读。如今关于iOS多线程的文章层出不穷，但我觉得若想更好的领会各个实践者的文章，应该先仔细读读官方的相关文档，打好基础，定会有更好的效果。文章中有对官方文档的翻译，也有自己的理解，官方文档中代码片段的示例在这篇文章中都进行了完整的重写，还有一些文档中没有的代码示例，并且都使用Swift完成，给大家一些Objc与Swift转换的参考。<br>官方文档地址：<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html" target="_blank" rel="external">Threading Programming Guide</a></p>
</blockquote>
<h2 id="u4EC0_u4E48_u662F_u7EBF_u7A0B"><a href="#u4EC0_u4E48_u662F_u7EBF_u7A0B" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>我们设想在应用程序中，每行代码的执行都有一个执行路径并对应一个执行容器。线程，可以让应用程序中的代码通过多个执行路径执行，从而达到多个代码块同时在不同的执行路径下执行运算，即多任务同时执行。</p>
<p>在系统中，每个程序都是并行状态的，但是并不是一直持续着活跃状态，而是由系统根据程序的需要适时的分配执行时间和内存。在每个程序中，或许存在多个线程，执行着不同的任务，那么系统对程序执行的管理实际上就是对程序中线程的管理，比如适时的将某个线程安排到负载较小的内核中执行，或者阻止正在运行的优先级较低的线程，给优先级较高的线程让路等。所以说线程的运转需要内核级别和应用程序级别相互协调，即内核级别负责将事件分发给不同的线程，并将线程安排在合理的内核上执行以及管理线程的优先级，而应用程序级别是通过代码管理和操控线程的属性及状态。</p>
<h3 id="u4E3A_u4EC0_u4E48_u8981_u4F7F_u7528_u7EBF_u7A0B"><a href="#u4E3A_u4EC0_u4E48_u8981_u4F7F_u7528_u7EBF_u7A0B" class="headerlink" title="为什么要使用线程"></a>为什么要使用线程</h3><p>回到iOS，我们开发的App至少都有一个线程，称之为主线程，线程中执行方法或函数的原则是先进先出原则，一个接一个的执行。假设在我们的App中有从远程下载图片的功能，并且该功能放在主线程中执行，那么当下载一个1080p高清图片时，就会需要耗费较长的时间，如果主线程中下载功能后面还有其他待执行的方法，那么只能等待下载功能完成之后，才能继续执行。所以此时对于用户来说，得不到任何来自App的响应，那么很容易认为是你的App出问题了，如此糟糕的用户体验，足以让用户将你的App打入冷宫甚至删除。</p>
<p>如果我们使用另外一个线程专门处理下载功能，那么该线程和主线程同时执行，对于用户而言，此时可以由主线程对用户做出合适的响应，而下载在另一个线程中同时进行着。所以使用线程对提高程序的用户体验、性能无疑是最好的方法。</p>
<h3 id="u4F7F_u7528_u7EBF_u7A0B_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898"><a href="#u4F7F_u7528_u7EBF_u7A0B_u4F1A_u5BFC_u81F4_u7684_u95EE_u9898" class="headerlink" title="使用线程会导致的问题"></a>使用线程会导致的问题</h3><p>俗话说天下没有免费的午餐，诚然多线程能提高程序的性能、用户体验，但是在光鲜的背后还是要承担一定风险的。使用多线程势必会增加开发人员写代码花费的时间，因为代码的复杂度变高了，开发人员斟酌的频率就会变高，线程与线程之间有交互，容错率就会降低，开发人员调试的时间就会变多。由于多线程依然共享内存，所以会发生两个线程同时对某个数据进行操作，这样很容易使程序的执行结果发生错误。总而言之，多线程好，但使用时要知其根本，做到佩弦自急。</p>
<h2 id="u5B9E_u73B0_u591A_u4EFB_u52A1_u5E76_u53D1_u6267_u884C_u4EFB_u52A1_u7684_u89E3_u51B3_u65B9_u6848"><a href="#u5B9E_u73B0_u591A_u4EFB_u52A1_u5E76_u53D1_u6267_u884C_u4EFB_u52A1_u7684_u89E3_u51B3_u65B9_u6848" class="headerlink" title="实现多任务并发执行任务的解决方案"></a>实现多任务并发执行任务的解决方案</h2><p>因为线程本身相对比较低层，它实现程序中并发执行任务功能的方式也较为复杂，所以我们如果想使用好线程，那么就必须要真正理解线程，要明白在我们的程序中使用线程之后会带来哪些潜在的风险，所谓知己知彼方能百战不殆。同时，我们也不能滥用线程，该用的时候用，不该用的时候就不要画蛇添足。毕竟，使用线程会增加内存的消耗以及CPU得运算时间，要避免物极必反。在真正理解线程之前，我们先看看在OS X和iOS中提供的不那么底层的实现多任务并发执行的解决方案：</p>
<ul>
<li><p>Operation object：该技术出现在OS X 10.5中，通过将要执行的任务封装成操作对象的方式实现任务在多线程中执行。任务可以理解为你要想执行的一段代码。在这个操作对象中不光包含要执行的任务，还包含线程管理的内容，使用时通常与操作队列对象联合使用，操作队列对象会管理操作对象如何使用线程，所以我们只需要关心要执行的任务本身即可。</p>
</li>
<li><p>GCD：该技术出现在OS X 10.6中，它与Operation Object的初衷类似，就是让开发者只关注要执行的任务本身，而不需要去关注线程的管理。你只需要创建好任务，然后将任务添加到一个工作队列里即可，该工作队列会根据当前CPU性能及内核的负载情况，将任务安排到合适的线程中去执行。</p>
</li>
<li><p>Idle-time notification：该技术主要用于处理优先级相对比较低、执行时间比较短的任务，让应用程序在空闲的时候执行这类任务。Cocoa框架提供<code>NSNotificationQueue</code>对象处理空闲时间通知，通过使用<code>NSPostWhenIdle</code>选项，向队列发送空闲时间通知的请求。</p>
</li>
<li><p>Asynchronous functions：系统中有一些支持异步的函数，可以自动让你的代码并行执行。这些异步函数可能通过应用程序的守护进程或者自定义的线程执行你的代码，与主进程或主线程分离，达到并行执行任务的功能。</p>
</li>
<li><p>Timers：我们也可以在应用程序主线程中使用定时器去执行一些比较轻量级的、有一定周期性的任务。</p>
</li>
<li><p>Separate processes：虽然通过另起一个进程比线程更加重量级，但是在某些情况下要比使用线程更好一些，比如你需要的执行的任务和你的应用程序在展现数据和使用方面没有什么关系，但是可以优化你的应用程序的运行环境，或者提高应用程序获取数据的效率等。</p>
</li>
</ul>
<h2 id="u521D_u8BC6_u7EBF_u7A0B_u6982_u5FF5"><a href="#u521D_u8BC6_u7EBF_u7A0B_u6982_u5FF5" class="headerlink" title="初识线程概念"></a>初识线程概念</h2><h3 id="u7EBF_u7A0B_u6280_u672F"><a href="#u7EBF_u7A0B_u6280_u672F" class="headerlink" title="线程技术"></a>线程技术</h3><p>说到OS X和iOS中的线程技术，就不得不说GNU Mach。Apple操作系统中的线程技术是基于Mach线程技术实现的，所以本身就带有线程基本的特性，比如PEM。Mach线程我们几乎不会用到，一般编程中我们可能会使用POSIX API创建线程。</p>
<blockquote>
<p>GNU Mach：GNU是一个类UNIX操作系统，它采用GNU Hurd作为操作系统内核，而GNU Mach是基于GNU Hurd内核技术的微内核。<br>POSIX：可移植操作系统接口（Portable Operating System Interface of UNIX），它定义了操作系统应该为应用程序提供的接口标准， 是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称。<br>PEM：Preemptive Execution Model，以任务的优先级决定立即执行还是延后执行，或者安排至不同的内核执行。</p>
</blockquote>
<p>我们来看看OS X和iOS中主要的两种线程技术：</p>
<ul>
<li>Cocoa Threads：Cocoa框架中提供了<code>NSThread</code>和<code>NSObject</code>类供我们进行线程相关的操作。</li>
<li>POSIX Threads：POSIX的线程API实际是基于C语言的线程接口，这些接口在使用线程和配置线程方面更加容易和灵活。</li>
</ul>
<p>在应用程序层面，不管是什么平台，线程的运行方式都是大体相同的，在线程的运行过程中一般都会经历三种状态，即运行中、准备运行、阻塞。如果某个线程在当前处于不活跃状态，也即是非运行中状态，那么它有可能是处于阻塞状态并在等待执行任务的输入。也有可能已经有任务输入，处于准备运行状态，只是在等待被分派。当我们终止线程后，它会永久性的被系统回收，因为毕竟线程会占用一定的系统内存和CPU运算时间，所以一般情况下，我们放入二级线程（非主线程）中的任务都是比较重要和有意义的任务。</p>
<h3 id="RunLoops"><a href="#RunLoops" class="headerlink" title="RunLoops"></a>RunLoops</h3><p>上一节提到当线程终止后就会永久被系统收回，如果你还有任务需要另起线程执行，就要重新创建线程以及配置，但这也不是必须的，我们可以让线程在空闲的时候休眠，当有任务需要执行时唤醒，就像主线程一样，此时就要用到RunLoop。</p>
<p>简单的来说，RunLoop用于管理和监听异步添加到线程中的事件，当有事件输入时，系统唤醒线程并将事件分派给RunLoop，当没有需要处理的事件时，RunLoop会让线程进入休眠状态。这样就能让线程常驻在进程中，而不会过多的消耗系统资源，达到有事做事，没事睡觉的效果。</p>
<p>主线程中的RunLoop系统已经自动帮我们配置好了，但是我们自己创建的线程，还需要对RunLoop配置一番才可以使用，在后面的章节中都会有详细介绍。</p>
<h3 id="u540C_u6B65_u7B56_u7565"><a href="#u540C_u6B65_u7B56_u7565" class="headerlink" title="同步策略"></a>同步策略</h3><p>诚然，使用线程好处多多，但是之前也提到过，使用线程也是会存在一定问题的，那就是资源竞争，当两个线程在同一时间操作同一个变量时，就会产生问题。一种解决方案是让不同的线程拥有各自独有的变量，虽然可以解决问题，但不是最优方案。较为优雅一些的方案则是使用线程中的同步策略来解决该问题。</p>
<p>常用的同步策略有线程锁、状态位、原子操作。线程锁较为简单粗暴，简单的说当一个线程在操作变量时会挂上一把互斥锁，如果另一个线程先要操作该变量，它就得获得这把锁，但是锁只有一个，必须等第一个线程释放互斥锁后，才可以被其他线程获取，所以这样就解决了资源竞争的问题。状态位策略是通过线程或任务的执行情况生成一个状态，这个状态即像门卫又像协管员，一是阻止线程进行，二是以合适的执行顺序安排协调各个任务。第三个策略则是原子操作，相对前两个策略要更轻量级一些，它能通过硬件指令保证变量在更新完成之后才能被其他线程访问。</p>
<h3 id="u7EBF_u7A0B_u4E4B_u95F4_u7684_u4EA4_u4E92"><a href="#u7EBF_u7A0B_u4E4B_u95F4_u7684_u4EA4_u4E92" class="headerlink" title="线程之间的交互"></a>线程之间的交互</h3><p>虽然我们尽量让每个线程完成独立的任务，但是有些时候我们需要将二级线程中任务的执行结果发送到主线程中进一步进行操作，那么线程之间的交互就不可避免的发生，幸运的是进程中的线程是共享进程空间的，所以实现线程之间的交互也不是那么困难，比如通过发送messages、全局变量、同步策略等都可以实现，在后面的章节中都会有详细介绍。</p>
<h2 id="u4F7F_u7528_u7EBF_u7A0B_u65F6_u9700_u8981_u6CE8_u610F_u7684_u4E8B_u9879"><a href="#u4F7F_u7528_u7EBF_u7A0B_u65F6_u9700_u8981_u6CE8_u610F_u7684_u4E8B_u9879" class="headerlink" title="使用线程时需要注意的事项"></a>使用线程时需要注意的事项</h2><p>无规矩不成方圆，做任何事如果乱来，那必定会出现各种问题。因为线程相对比较底层，所以当我们对线程理解的不是特别透彻时直接创建线程，并手动管理线程，势必会出现正确性和性能上的各种问题，所以就有了这节对使用线程的一些建议。</p>
<h3 id="u907F_u514D_u76F4_u63A5_u521B_u5EFA_u7EBF_u7A0B"><a href="#u907F_u514D_u76F4_u63A5_u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="避免直接创建线程"></a>避免直接创建线程</h3><p>创建并管理线程在代码层面相对比较复杂和繁琐，一个不留神就会产生一些潜在的问题。OS X和iOS都提供了较为上层的创建使用线程的API，就是前面提到一些多任务并发执行的解决方案，比如GCD、Operation objects。使用它们可以帮我们规避在管理线程和处理线程性能方面可能出现的问题，提高多线程操作时的性能和健壮性。</p>
<h3 id="u8BA9_u7EBF_u7A0B_u6267_u884C_u6709_u4EF7_u503C_u7684_u4EFB_u52A1"><a href="#u8BA9_u7EBF_u7A0B_u6267_u884C_u6709_u4EF7_u503C_u7684_u4EFB_u52A1" class="headerlink" title="让线程执行有价值的任务"></a>让线程执行有价值的任务</h3><p>前文中提到过，线程消耗的系统资源不容小视，所以当我们手动创建和管理线程时，尤其要注意这一点。要保证另起线程执行的任务是有意义的、重要的任务，而且该终止的线程要终止，不要让线程有任何空闲时间，以保证系统资源的最优利用。</p>
<h3 id="u907F_u514D_u8D44_u6E90_u7ADE_u4E89"><a href="#u907F_u514D_u8D44_u6E90_u7ADE_u4E89" class="headerlink" title="避免资源竞争"></a>避免资源竞争</h3><p>进程中的线程是共享该进程空间的，所以很容易出现多个线程对同一个变量进行操作从而导致程序执行结果错误的情况。如果为每个线程都提供一份变量的拷贝，的确是可以解决这个问题，但是在开发中这样会造成更大的弊端，所以前文中提到了一些同步策略，能帮助我们达到线程交互及解决资源竞争的目的。但是在理论上还是会有出错的可能，比如让线程在指定的顺序下对某个变量依次进行操作。所以在程序设计阶段应该尽量避免线程之间的资源竞争及减少线程之间的交互。</p>
<h3 id="u7528_u6237_u754C_u9762_u4E0E_u7EBF_u7A0B"><a href="#u7528_u6237_u754C_u9762_u4E0E_u7EBF_u7A0B" class="headerlink" title="用户界面与线程"></a>用户界面与线程</h3><p>用户界面的更新、对用户事件的响应都应该放在主线程中，避免线程不安全的情况，以及能方便的管理UI界面。目前Cocoa框架默认对UI的操作都要在主线程中完成，即使不强制要求，我们也应该这样做。但是有一些情况比较特殊，比如对图片的处理，因为处理图片的过程并不是显性的，所以处理的过程可以放在二级线程中，当处理完成后，再在主线程中显示结果。这样可以有效的提升应用的性能。</p>
<h3 id="u6E05_u695A_u5F53_u7EBF_u7A0B_u7ED3_u675F_u65F6_u5E94_u8BE5_u505A_u4EC0_u4E48"><a href="#u6E05_u695A_u5F53_u7EBF_u7A0B_u7ED3_u675F_u65F6_u5E94_u8BE5_u505A_u4EC0_u4E48" class="headerlink" title="清楚当线程结束时应该做什么"></a>清楚当线程结束时应该做什么</h3><p>当用户退出应用后，理论上该应用进程中的所有线程都会立即被结束。但是如果此时正好有一个二级线程在后台处理其他任务，比如说下载或者正在存储一些数据。那么此时就要判断正在处理的这些任务是否要保留，如果要丢弃，那么直接结束所有线程即可，但是如果要保留，那么就需要主线程等待正在处理任务的二级线程，从而延迟应用退出。</p>
<p>这里处理时有两种情况，如果自行创建的线程并手动管理，那么要使用POSIX API创建具有<strong>joinable</strong>特性的二级线程，使主线程与之相关联。如果是使用Cocoa框架，那么可以使用<code>applicationShouldTerminate:</code>代理方法延迟应用关闭，当二级线程处理完任务后回调<code>replyToApplicationShouldTerminate:</code>通知到主线程，然后关闭应用。</p>
<h3 id="u5F02_u5E38_u5904_u7406"><a href="#u5F02_u5E38_u5904_u7406" class="headerlink" title="异常处理"></a>异常处理</h3><p>每个线程都有捕获当前任务在执行时产生的异常的责任，不论是主线程还是二级线程。如果二级线程产生的异常需要交由主线程处理是也不能任由其抛出，而是先将其捕获，然后向主线程发送消息，告知主线程当前的情况。当消息发出后二级线程可根据需求选择继续处理其他的任务还是终止线程。</p>
<h3 id="u5C3D_u53EF_u80FD_u5C11_u7684_u4F7F_u7528_u5E38_u9A7B_u7EBF_u7A0B"><a href="#u5C3D_u53EF_u80FD_u5C11_u7684_u4F7F_u7528_u5E38_u9A7B_u7EBF_u7A0B" class="headerlink" title="尽可能少的使用常驻线程"></a>尽可能少的使用常驻线程</h3><p>前文中提到过，可以为一些经常需要执行的、具有周期性的、量级较小的任务创建常驻线程，以减少创建关闭线程的资源消耗，但是不能滥用常驻线程。理论上，一个线程执行完任务后就应该关闭，并且关闭线程的最佳时机是执行完任务的后一秒。目的是为了避免空闲线程占用过多的资源从而导致一些潜在的问题。</p>
<h3 id="u786E_u4FDD_u7C7B_u5E93_u7684_u7EBF_u7A0B_u5B89_u5168"><a href="#u786E_u4FDD_u7C7B_u5E93_u7684_u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="确保类库的线程安全"></a>确保类库的线程安全</h3><p>如果我们在开发应用的相关功能，我们完全可以控制这块功能是否需要多线程去完成，但是当我们在开发一个供别人使用的类库时，就没法灵活的控制了。所以只能假设使用我们的类库必定会在多线程的环境中使用，这样我们可以通过锁机制确保线程安全。但是如果我们的类库没有在多线程环境中使用呢？那就会白白浪费掉对锁进行操作的相关资源，只能说使用锁机制可以保证类库线程安全的万无一失，但性能方面会大打折扣。</p>
<p>另一种方式是让使用我们类库的应用要对类库进行明确地初始化，不管是主线程还是二级线程，换句话说也就是让每个线程都有一份我们类库的内容，这样也可以有效的保证类库线程安全。在Cocoa框架中，还有一种可选的方式，就是可以为<code>NSWillBecomeMultiThreadedNotification</code>注册一个观察者，目的是当应用变为多线程环境时可以通知到我们的类库，从而采取相关措施，但这种方式不保险，有可能当类库已经被多线程环境中的代码使用后才收到通知。总而言之，如果开发类库，那么务必要确保其线程安全。</p>
<h2 id="u7EBF_u7A0B_u7684_u8D44_u6E90_u6D88_u8017"><a href="#u7EBF_u7A0B_u7684_u8D44_u6E90_u6D88_u8017" class="headerlink" title="线程的资源消耗"></a>线程的资源消耗</h2><p>在OS X和iOS中，每个应用其实就是一个进程，一个进程中由一个或多个线程组成，每个线程代表了所属应用中代码的执行路径。通常情况下应用始于主线程中的主函数，当需要有其他功能在二级线程中与主线程并行执行时，便可以创建其他二级线程。</p>
<p>一旦二级线程被创建，那么它就是一个独立的实体，线程与线程之间是没有任何关联的，它们有各自的执行堆栈，由内核单独为每个线程分派运行时的执行任务。虽然每个线程是独立实体，但是它们之间是可以相互交互的，在实际的应用中，这类需求是很常见的，因为它们共享所属进程的内存空间，并且拥有相同的读写权，所以也很容易实现线程之间的交互。既然一个应用中可能会有多个线程协作完成功能，所以管理线程就是重中之重了，这一章节会从线程的资源消耗、创建、配置、使用、关闭这几个关键点梳理实际运用中的线程管理。</p>
<p>线程的资源消耗主要分为三类，一类是内存空间的消耗、一类是创建线程消耗的时间、另一类是对开发人员开发成本的消耗。</p>
<p>内存空间的消耗又分为两部分，一部分是内核内存空间，另一部分是应用程序使用的内存空间，每个线程在创建时就会申请这两部分的内存空间。申请内核内存空间是用来存储管理和协调线程的核心数据结构的，而申请应用程序的内存空间是用来存储线程栈和一些初始化数据的。对于用户级别的二级线程来说，对应用程序内存空间的消耗是可以配置的，比如线程栈的空间大小等。下面是两种内存空间通常的消耗情况：</p>
<ul>
<li>内核内存空间：主要存储线程的核心数据结构，每个线程大约会占用1KB的空间。</li>
<li>应用程序内存空间：主要存储线程栈和初始化数据，主线程在OS X中大约占8MB空间，在iOS中大约占1MB。二级线程在两种系统中通常占大约512KB，但是上面提到二级线程在这块是可以配置的，所以可配置的最小空间为16KB，而且配置的空间大小必须是4KB的倍数。</li>
</ul>
<blockquote>
<p>注意：二级线程在创建时只是申请了内存程序空间，但还并没有真正分配给二级线程，只有当二级线程执行代码需要空间时才会真正分配。</p>
</blockquote>
<p>线程的创建时间取决于机器硬件的性能，但通常大约在90毫秒，虽然在我们看来90毫秒很短，但当频繁的创建线程时就会影响到CPU处理其他任务的时间。所以现在往往都会使用线程池，避免频繁的创建全新的线程。</p>
<p>前文中提到过设计和开发多线程的应用较单线程要复杂的多，要注意的事项在上文中就提出了八条，针对每条注意事项，都要花费不少时间去设计代码和测试。所以总体来说如果涉及到多线程，务必会增加开发人员的开发测试时间，但是换来的是应用程序具有更好的健壮性和高性能，所谓慢工出细活。</p>
<h2 id="u521B_u5EFA_u7EBF_u7A0B"><a href="#u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="创建线程"></a>创建线程</h2><p>说到创建线程，就得说说线程的两种类型，<strong>Joinable</strong>和<strong>Detach</strong>。Joinable类型的线程可以被其他线程回收其资源和终止。举个例子，如果一个Joinable的线程与主线程结合，那么当主线程准备结束而该二级线程还没有结束的时候，主线程会被阻塞等待该二级线程，当二级线程结束后由主线程回收其占用资源并将其关闭。如果在主线程还没有结束时，该二级线程结束了，那么它不但不会关闭，而且资源也不会被系统收回，只是等待主线程处理。而Detach的线程则相反，会自行结束关闭线程并且有系统回收其资源。</p>
<p>在OS X和iOS系统中有多种创建线程的方法，不同方法创建出的线程可能会有不同的线程属性，但就线程本身来说并没有什么差异。下面来看看创建线程的不同方法。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u4F7F_u7528NSThread_u521B_u5EFA_u7EBF_u7A0B"><a href="#u4F7F_u7528NSThread_u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="使用NSThread创建线程"></a>使用NSThread创建线程</h3><p>使用<code>NSThread</code>创建线程有两种方式：</p>
<ul>
<li><code>detachNewThreadSelector:toTarget:withObject:</code>：该方法是一个类方法，适用于OS X所有的版本和iOS2.0之后的版本。该方法其实完成了两个动作，先是创建线程，然后启动线程。通过方法名称就可以得知，该方法创建的线程为Detach类型的线程。</li>
<li>创建<code>NSThread</code>对象：这种方法适用于OS X 10.5之后的版本和iOS2.0之后的版本。该方法通过创建<code>NSThread</code>对象，使用它的<code>start()</code>方法启动线程，该方法的好处是可以在启动前通过<code>NSThread</code>对象的各个属性进行配置，待配置妥当后再调用<code>start()</code>方法启动线程。该方法创建的线程也是Detach类型的线程。</li>
</ul>
<h4 id="detachNewThreadSelector_3AtoTarget_3AwithObject_3A"><a href="#detachNewThreadSelector_3AtoTarget_3AwithObject_3A" class="headerlink" title="detachNewThreadSelector:toTarget:withObject:"></a>detachNewThreadSelector:toTarget:withObject:</h4><p>该方法有三个参数：</p>
<ul>
<li>selector：发送给线程的消息，或者说是让线程执行的任务。这里需要注意的是该任务最多只能有一个参数，并且不能有返回值。</li>
<li>target：在新的线程中接收消息的对象。</li>
<li>object：传给target对象的参数，也就是传入selector中的参数。</li>
</ul>
<p>下面来看一个简单示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"methodInSecondaryThread:"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="string">"I am a argument"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">methodInSecondaryThread</span><span class="params">(arg: String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(arg)</span> of event in Secondary Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>上述代码定义了一个类<code>TestThread</code>，包含两个方法<code>launch()</code>和<code>methodInSecondaryThread()</code>，<code>lanch()</code>方法中用<code>print()</code>函数模拟事件，在两个事件中创建一个二级线程，用于执行<code>methodInSecondaryThread()</code>方法，在该方法中执行其他事件。执行看看结果如何：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Terminating</span> app due to uncaught exception '<span class="type">NSInvalidArgumentException'</span>, reason: '*** -[<span class="type">NSThread</span> initWithTarget:selector:object:]: target does not implement selector (*** -[<span class="type">LearnThread</span>.<span class="type">TestThread</span> methodInSecondaryThread])'</span><br></pre></td></tr></table></figure>
<p>结果很不幸，报错了，原因很简单，因为我们的代码是Swift，而<code>NSThread</code>继承了<code>NSObject</code>是Objective-C世界的东西，所以需要对代码进行修改，有两种方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 让NSTread继承NSObject</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 在methodInSecondaryThread()方法前添加@objc</span></span><br><span class="line"><span class="preprocessor">@objc</span> <span class="func"><span class="keyword">func</span> <span class="title">methodInSecondaryThread</span><span class="params">(arg: String)</span></span> &#123;</span><br></pre></td></tr></table></figure>
<p>我习惯让类继承<code>NSObject</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"methodInSecondaryThread:"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="string">"I am a argument"</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">methodInSecondaryThread</span><span class="params">(arg: String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(arg)</span> of event in Secondary Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>继续运行看看效果：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">First</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">Second</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br></pre></td></tr></table></figure>
<p>运行成功了，但似乎少点什么东西，<code>methodInSecondaryThread()</code>方法中的内容并没有打印出来，难道线程没有执行吗？我们通过Instruments可以看到，在运行过程中二级线程是创建过的：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/LearnThread-1.png" alt="LearnThread-1"></p>
<p>导致这个问题的原因和上文介绍的线程类型有关系。因为主线程运行很快，快到当主线程结束时我们创建的二级线程还没来得及执行<code>methodInSecondaryThread()</code>方法，而通过<code>detachNewThreadSelector:toTarget:withObject:</code>创建的二级线程是Detach类型的，没有与主线程结合，所以主线程也不会等待，当主线程结束，进程结束，二级线程自然也结束了。解决这个问题的办法就是让二级线程有执行任务的时间，所以我们可以让主线程停顿几秒，让二级线程完成它的任务：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="type">NSThread</span>.detachNewThreadSelector(<span class="string">"methodInSecondaryThread:"</span>, toTarget: <span class="keyword">self</span>, withObject: <span class="string">"I am a argument"</span>)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">methodInSecondaryThread</span><span class="params">(arg: String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(arg)</span> of event in Secondary Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>再运行就可以看到正确地结果了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">First</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">I</span> am a argument of event <span class="keyword">in</span> <span class="type">Secondary</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">Second</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br></pre></td></tr></table></figure>
<h4 id="u521B_u5EFANSThread_u5BF9_u8C61"><a href="#u521B_u5EFANSThread_u5BF9_u8C61" class="headerlink" title="创建NSThread对象"></a>创建NSThread对象</h4><p>我们可以通过<code>initWithTarget:selector:object:</code>方法实例化一个<code>NSThread</code>对象，该方法的三个参数其实与<code>detachNewThreadSelector:toTarget:withObject:</code>方法的参数一样，只是顺序不一样而已：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> secondaryThread = <span class="type">NSThread</span>(target: <span class="keyword">self</span>, selector: <span class="string">"methodInSecondaryThread:"</span>, object: <span class="string">"I am a argument"</span>)</span><br><span class="line">        </span><br><span class="line">        secondaryThread.start()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">methodInSecondaryThread</span><span class="params">(arg: String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(arg)</span> of event in Secondary Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>上述的代码的运行结果自然也是一样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">First</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">I</span> am a argument of event <span class="keyword">in</span> <span class="type">Secondary</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">Second</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br></pre></td></tr></table></figure>
<p>这种方法依然只能在二级线程中执行最多只有一个参数的函数或方法，如果想要执行多参数的任务，可以将参数放入集合中传递，当然被执行的任务得能正确接收到参数集合。或者可以通过另外一种方法，那就是通过创建继承<code>NSThread</code>的类，然后重写<code>main()</code>方法来实现：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomThread</span>: <span class="title">NSThread</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> arg1: <span class="type">String</span>!</span><br><span class="line">    <span class="keyword">var</span> arg2: <span class="type">String</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(arg1: <span class="type">String</span>, arg2: <span class="type">String</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.arg1 = arg1</span><br><span class="line">        <span class="keyword">self</span>.arg2 = arg2</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(<span class="keyword">self</span>.arg1)</span>, <span class="subst">\(<span class="keyword">self</span>.arg2)</span>, we are the arguments in Secondary Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> customThread = <span class="type">CustomThread</span>(arg1: <span class="string">"I am arg1"</span>, arg2: <span class="string">"I am arg2"</span>)</span><br><span class="line">        </span><br><span class="line">        customThread.start()</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">methodInSecondaryThread</span><span class="params">(arg: String)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(arg)</span> of event in Secondary Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，我们创建了<code>CustomThread</code>类，并继承了<code>NSThread</code>，然后通过初始化方法传参，再重写<code>main()</code>方法处理相关任务。执行结果如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">First</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">I</span> am arg1, <span class="type">I</span> am arg2, we are the arguments <span class="keyword">in</span> <span class="type">Secondary</span> <span class="type">Thread</span>.</span><br><span class="line"><span class="type">Second</span> event <span class="keyword">in</span> <span class="type">Main</span> <span class="type">Thread</span>.</span><br></pre></td></tr></table></figure>
<h3 id="u4F7F_u7528NSObject_u521B_u5EFA_u7EBF_u7A0B"><a href="#u4F7F_u7528NSObject_u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="使用NSObject创建线程"></a>使用NSObject创建线程</h3><p>在OS X和iOS中，<code>NSObject</code>对象本身就具有创建线程的能力，所以只要是继承了<code>NSObject</code>的类自然也具备这个能力：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestThread</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"First event in Main Thread."</span>)</span><br><span class="line"></span><br><span class="line">        performSelectorInBackground(<span class="string">"performInBackground"</span>, withObject: <span class="literal">nil</span>)</span><br><span class="line">        </span><br><span class="line">        sleep(<span class="number">3</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Second event in Main Thread."</span>)</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">performInBackground</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"I am a event, perform in Background Thread."</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testThread = <span class="type">TestThread</span>()</span><br><span class="line">testThread.launch()</span><br></pre></td></tr></table></figure>
<p>上述代码中的<code>TestThread</code>类继承了<code>NSObject</code>类，那么就可以通过<code>performSelectorInBackground:withObject:</code>方法创建二级线程，该方法只有两个参数：</p>
<ul>
<li>selector：发送给线程的消息，或者说是让线程执行的任务。这里需要注意的是该任务最多只能有一个参数，并且不能有返回值。</li>
<li>object：传给target对象的参数，也就是传入selector中的参数。</li>
</ul>
<p>该方法创建的线程也是Detach类型的。以上这几种方式都是基于Cocoa框架实现的，大家可以使用<code>NSThread</code>的类方法<code>isMultiThreaded</code>去检验，在合适的地方插入这行代码<code>print(NSThread.isMultiThreaded())</code>，看看程序的线程状态。</p>
<h3 id="u4F7F_u7528POSIX_API_u521B_u5EFA_u7EBF_u7A0B"><a href="#u4F7F_u7528POSIX_API_u521B_u5EFA_u7EBF_u7A0B" class="headerlink" title="使用POSIX API创建线程"></a>使用POSIX API创建线程</h3><p>在OS X和iOS中，可以通过POSIX API创建线程，上文中提到过，POSIX的线程API实际是基于C语言的线程接口，这些接口在使用线程和配置线程方面更加容易和灵活，移植性也比较强，但由于相对较为底层，如果不熟悉C语言，上手成本会比较高,<code>NSThread</code>就是基于POSIX线程API封装而成的。</p>
<p>POSIX API通过<code>int pthread_create(pthread_t *restrict thread, const pthread_attr_t *restrict attr, void *(*start_routine)(void *), void *restrict arg);</code>函数创建线程：</p>
<ul>
<li>thread：线程标识符。</li>
<li>attr：线程属性设置。</li>
<li>start_routine：线程函数的起始地址。</li>
<li>arg：传递给start_routine的参数。</li>
<li>返回值：成功返回0，出错返回-1。</li>
</ul>
<p>大体的参数其实和使用<code>NSThread</code>创建线程基本一致，不过需要注意的是通过<code>pthread_create()</code>创建的线程是Joinable类型的，如果要将新线程设置为Detach类型，需要在创建前使用<code>pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</code>函数设置其线程属性。</p>
<p>在Cocoa框架中，上文提到的那些同步机制，比如线程锁，当二级线程创建后才就会自动生成。如果在程序中使用POSIX API创建线程，那么Cocoa框架是无法得知当前程序已处于多线程状态的，所以就不会自动开启相关的同步机制，而当我们又没有通过POSIX API手动控制的话，就有可能导致应用程序崩溃的情况。另外要注意的一点是Cocoa框架中的线程锁是不能操作通过POSIX API创建的线程的，反之亦然。所以当Cocoa框架与POSIX API混用的时候，在同步机制方面一定要配套使用。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/develop-tvos-app-with-tvml/" itemprop="url">
                  用TVML开发tvOS应用教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2015-12-31T00:00:00+08:00" content="2015-12-31">
              2015-12-31
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/develop-tvos-app-with-tvml/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/develop-tvos-app-with-tvml/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>作者：<a href="http://www.raywenderlich.com/u/Kelvin%20Lau" target="_blank" rel="external">Kelvin Lau</a> 原文地址：<a href="http://www.raywenderlich.com/114886/beginning-tvos-development-with-tvml-tutorial" target="_blank" rel="external">Beginning tvOS Development with TVML Tutorial</a></p>
<p>在2015年9月9日的产品发布会中，Apple宣布了新一代的Apple TV以及tvOS，并且在tvOS中集成了App Store。这使得我们多年以来想在Apple TV上开发专属应用的梦想成真了。</p>
<p>我和其他教程团队的成员已经开始深入研究tvOS SDK，并且正在努力为你们准备一些有价值的tvOS教程。在你开这篇文章之前，Chris Wagner已经写了一篇关于tvOS初步印象的<a href="http://www.raywenderlich.com/114313/tvos-initial-impressions" target="_blank" rel="external">文章</a>，我也基于这篇文章，设计了第一个tvOS的教程。</p>
<blockquote>
<p>译者注：可参阅Chris Wagner文章的中译版<a href="http://www.devtalking.com/articles/tvOS-initial-impression/">一个iOS开发者对tvOS SDK的初探</a>。</p>
</blockquote>
<p>在这篇教程中，你将会使用TVML开发你的第一款tvOS应用。信不信由你，你将会使用JavaScript管理你应用的逻辑以及创建TVML模板来展现你应用的UI。</p>
<p>当教程结束后，你应该可以基本理解如果通过TVML和TVJS管理、控制tvOS应用。现在就我们开始吧。</p>
<blockquote>
<p>注意：该教程需要Xcode7.1或更高的版本，你们可以在这里<a href="https://developer.apple.com/xcode/download/" target="_blank" rel="external">下载</a>。虽然你们可以跟着该教程一步一步的进行操作，但我还是建议你们能储备一些基本的JavaScript知识。</p>
</blockquote>
<h2 id="u9009_u62E9_u5F00_u53D1_u65B9_u5F0F"><a href="#u9009_u62E9_u5F00_u53D1_u65B9_u5F0F" class="headerlink" title="选择开发方式"></a>选择开发方式</h2><p>Apple为开发tvOS应用提供了两种方式：</p>
<ol>
<li><strong>TVML Apps</strong>：这类应用是使用完整的新开发技术开发的，比如TVML、TVJS、TVMLKit。在稍后我会解释这些简称的含义以及如何使用它们。</li>
<li><strong>Custom Apps</strong>：这类应用是使用我们已经比较熟悉的开发技术进行开发的，比如大家熟知的一些iOS框架和特性，像Storyboard、UIKit、Auto Layout等。</li>
</ol>
<p>这两种方式没有孰优孰劣之分，都是Apple推荐的方法，只是按需所取，以及你更想尝试哪种方式。</p>
<p>在这篇教程中，你们的目标是开发以个能播放<a href="http://www.rwdevcon.com/" target="_blank" rel="external">RWDevCon</a>讨论视频的tvOS应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-1.gif" alt="tvOS-1"></p>
<p>虽然用上述两种方式都可以开发这个应用，但是使用TVML会更加容易一些。所以这就是你在这篇教程中要学和要做的东西。</p>
<h2 id="u4EC0_u4E48_u662FTVML_uFF1F"><a href="#u4EC0_u4E48_u662FTVML_uFF1F" class="headerlink" title="什么是TVML？"></a>什么是TVML？</h2><p>正如我刚才提到的，第一种开发tvOS应用的方式是通过TVML、TVJS和TVMLKit这些新的技术实现的。如果你们对这些简称比较陌生，不要惊慌，因为他们本就是新鲜玩意。这里我简单解释一下：</p>
<ul>
<li><strong>TVML</strong>是一种XML格式，基于“Television Markup Language”。</li>
<li><strong>TVJS</strong>是基于JavaScript APIs的脚本语言，它可以根据TVML中定义的内容展示应用。</li>
<li><strong>TVMLKit</strong>是连接TVML、TVJS和原生tvOS应用的工具包。</li>
</ul>
<p>如果你是一名经常使用原生API开发原生iOS应用的开发者，那么看到这些类似前端的技术可能会有点退缩。但希望你能保持一颗学习的心，学习了解这些新的强大的特性。</p>
<p>我在这列举一个非常典型的Apple TV的应用场景。大家可以想象一下：你们想把一些内容或信息展现给用户，这些内容和信息储存在你们的服务器上，并且这些内容的格式、查询方式都服务于iPhone或iPad中的应用，那么你肯定会希望你的tvOS中的应用也能方便的使用这些内容，并做到与iOS中应用有相似的展现、查询、导航方式。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-2.jpg" alt="tvOS-2"></p>
<p>上述的这个场景恰恰是我们这片教程中的场景。我们已经有<a href="http://www.rwdevcon.com/" target="_blank" rel="external">RWDevCon</a>网站，上面有许多技术讨论视频，所以运用TVML模板应该很容易实现。并且我们也没有很严格的用户界面的需求，所以我们可以简单方便的使用Apple提供的UI<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">模板</a>。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-3.jpg" alt="tvOS-3"></p>
<p>简而言之：</p>
<ul>
<li><strong>开发TVML App</strong>：如果你主要是通过tvOS应用展现一些内容，不论是音频、视频、文本、图片，并且你已经有服务器存储这些资源。那么使用TVML开发是不错的选择。</li>
<li><strong>开发Custom App</strong>：如果你希望用户不只是被动的通过你的tvOS应用观看或收听内容，而是希望用户与应用有更多的交互，给用户高质量的用户体验。那么你应该选择使用iOS的相关技术开发自定义的应用。</li>
</ul>
<p>现在你们已经大概了解了TVML是如何工作的，以及我们为什么要在这篇教程中使用TVML开发tvOS应用。想要更深入的了解，最好的办法就是由你们在实践中去学习、理解了。让我们开始动手吧！</p>
<h2 id="u51C6_u5907_u5DE5_u4F5C"><a href="#u51C6_u5907_u5DE5_u4F5C" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先你们要确保已经下载并安装了Xcode7.1或更高版本。</p>
<p>然后通过 <strong>File\New\Project</strong> 创建新工程，在侧边栏选择 <strong>tvOS\Application\Single View Application</strong> 模板，然后点击 <strong>Next</strong>：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-4.png" alt="tvOS-4"></p>
<p>项目名称输入 <strong>RWDevCon</strong> ,语言选择 <strong>Swift</strong> ，确保下面的两个复选框为未选中状态，也就是不使用Core Data和单元测试，然后点击 <strong>Next</strong>：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-5.png" alt="tvOS-5"></p>
<p>选择一个目录，点击 <strong>Save</strong> 保存你的项目。Xcode会为你创建一个带有Storyboard的空工程（如果你开发自定义UI的tvOS应用，那么你需要使用Storyboard）。</p>
<p>然而在该教程中你不需要使用Storybard，因为我们会使用TVML来展示应用的UI，而不是用Storybard去设计UI。所以将 <strong>Main.storyboard</strong> 和 <strong>ViewController.swift</strong> 删去，在提示框中选择 <strong>Move To Trash</strong> 彻底删除。</p>
<p>接着打开 <strong>Info.plist</strong> 文件，删掉<code>Main storybaord file base name</code>属性。最后添加新的属性<code>App Transport Security Settings</code>（区分大小写），以及它的子属性<code>Allow Arbitrary Loads</code>，并将其值设为<code>YES</code>。</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-6.png" alt="tvOS-6"></p>
<blockquote>
<p>注意：在iOS9中，Apple不允许应用链接非HHTPS协议的服务，所以刚才的操作是很有必要的，因为在该教程中，你们将会以HTTP协议访问本地的服务器，所以你需要在Info.plist中添加上述属性以便允许应用通过HTTP协议访问服务器。</p>
</blockquote>
<h2 id="u52A0_u8F7D_u4F60_u7684TVML"><a href="#u52A0_u8F7D_u4F60_u7684TVML" class="headerlink" title="加载你的TVML"></a>加载你的TVML</h2><p>tvOS应用的生命周期开始于AppDelegate。在这里，你将创建<code>TVApplicationController</code>以及应用上下文，并将它们传给主要的JavaScript文件。</p>
<p>打开<strong>AppDelegate.swift</strong>并做下面这些事：</p>
<ul>
<li>删除所有的方法。</li>
<li>导入<code>TVMLKit</code>。</li>
<li>使AppDelegate遵循<code>TVApplicationControllerDelegate</code>协议。</li>
</ul>
<p>当完成这些事后，你的<strong>AppDelegate.swift</strong>看起来应该像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> TVMLKit</span><br><span class="line"> </span><br><span class="line"><span class="preprocessor">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span>, <span class="title">TVApplicationControllerDelegate</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> window: <span class="type">UIWindow</span>?</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着添加下面这些属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> appController: <span class="type">TVApplicationController</span>?</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> <span class="type">TVBaseURL</span> = <span class="string">"http://localhost:9001/"</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">let</span> <span class="type">TVBootURL</span> = <span class="string">"<span class="subst">\(AppDelegate.TVBaseURL)</span>js/application.js"</span></span><br></pre></td></tr></table></figure>
<p><code>TVApplicationController</code>是<code>TVMLKit</code>中的一个类，它负责与你的服务器的交互。<code>TVBaseURL</code>和<code>TVBootURL</code>包含了你的服务器的地址和JavaScript文件的地址，该JavaScript文件稍后会运行在你的服务器中。</p>
<p>接在在AppDelegate中添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  window = <span class="type">UIWindow</span>(frame: <span class="type">UIScreen</span>.mainScreen().bounds)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">let</span> appControllerContext = <span class="type">TVApplicationControllerContext</span>()</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> javaScriptURL = <span class="type">NSURL</span>(string: <span class="type">AppDelegate</span>.<span class="type">TVBootURL</span>) <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">"unable to create NSURL"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  appControllerContext.javaScriptApplicationURL = javaScriptURL</span><br><span class="line">  appControllerContext.launchOptions[<span class="string">"BASEURL"</span>] = <span class="type">AppDelegate</span>.<span class="type">TVBaseURL</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  appController = <span class="type">TVApplicationController</span>(context: appControllerContext, window: window, delegate: <span class="keyword">self</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码相对还是比较容易理解的：</p>
<ol>
<li>这里你首先创建了一个应用上下文<code>TVApplicationControllerContext</code>的实例，用于稍后初始化你的<code>TVApplicationController</code>。你可以理解为给一个简单的对象设置了一些属性，比如服务器的URL，然后该对象又作为属性设置给了另一个对象。</li>
<li>给应用上下文这个对象实例设置了两个简单的属性：主JavaScript文件的路径和服务器的地址。</li>
<li>通过你刚才设置好的应用上下文初始化<code>TVApplicationController</code>。此时就完全由Apple代码来接管了，他会加载到你的主JavaScript文件，并开始执行其内容。</li>
</ol>
<p>所以到目前为止，是时候让Xcode休息一会了，因为接下来你们将要编写JavaScript了。</p>
<h2 id="The_JavaScript"><a href="#The_JavaScript" class="headerlink" title="The JavaScript"></a>The JavaScript</h2><p>在客户端-服务端这类的tvOS应用中，你的JavaScript文件通常在应用连接的服务器中。在该教程中，你们将会在Mac上搭建一个简单的服务器。</p>
<h3 id="u5BA2_u6237_u7AEF_u4EE3_u7801"><a href="#u5BA2_u6237_u7AEF_u4EE3_u7801" class="headerlink" title="客户端代码"></a>客户端代码</h3><p>为了方便起见，我们把JavaScript文件放在桌面，在你们的 <strong>桌面</strong> 文件夹中新建一个文件夹名为 <strong>client</strong> 。在client文件夹中再新建一个文件夹名为 <strong>js</strong> 。该文件夹将作为你的JavaScript文件的容器。</p>
<p>通过你使用的编辑JavaScript的IDE，新建一个JavaScript文件，名为 <strong>application.js</strong> ，将它保存在你刚才新建的 <strong>js</strong> 文件夹中。然后在 <strong>application.js</strong> 中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">App</span>.onLaunch = function(options) &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> alert = createAlert(<span class="string">"Hello World"</span>, <span class="string">""</span>); <span class="comment">//第二个参数传入空字符串</span></span><br><span class="line">  navigationDocument.presentModal(alert);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> createAlert = function(title, description) &#123;</span><br><span class="line">  <span class="keyword">var</span> alertString = `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">    &lt;document&gt;</span><br><span class="line">      &lt;alertTemplate&gt;</span><br><span class="line">        &lt;title&gt;$&#123;title&#125;&lt;/title&gt;</span><br><span class="line">        &lt;description&gt;$&#123;description&#125;&lt;/description&gt;</span><br><span class="line">      &lt;/alertTemplate&gt;</span><br><span class="line">    &lt;/document&gt;`</span><br><span class="line">    <span class="keyword">var</span> parser = new <span class="type">DOMParser</span>();</span><br><span class="line">    <span class="keyword">var</span> alertDoc = parser.parseFromString(alertString, <span class="string">"application/xml"</span>);</span><br><span class="line">    <span class="keyword">return</span> alertDoc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>App.onLaunch</code>是处理JavaScript文件的入口方法。之前在 <strong>AppDelegate.swift</strong> 中已经初始化好的<code>TVApplicationController</code>会将<code>TVApplicationControllerContext</code>传到这。之后你会使用到上下文中的内容，但是现在，我们只创建一个简单的提示界面并显示在屏幕上。</p>
<ol>
<li>通过下面定义的<code>createAlert</code>函数，我们获得到了为我们展现界面的TVML文件。<code>navigationDocument</code>类似于iOS中的<code>UINavigationController</code>，它提供像栈一样的方式，可以推出或压进展现界面的TVML文件。</li>
<li><code>createAlert</code>是一个返回TVML文件的函数，你可以将它看作类似iOS中的<code>UIAlertController</code>。</li>
</ol>
<p>写到这顺便提一下，Apple已经提供了18种TVML模板供我们使用，你们可以在该<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">Apple TV Markup Language Reference</a>中查阅完成的模板列表。</p>
<p>上述代码中的 <strong>alertTemplate</strong> 就是这18个模板中的其中一个，它的主要用于展示重要信息，比如通过一段消息提示用户在继续操作之前需要执行其他的操作等。此时，距离你们编译运行你们的第一个tvOS应用已为时不远了。</p>
<h3 id="u914D_u7F6E_u670D_u52A1_u5668"><a href="#u914D_u7F6E_u670D_u52A1_u5668" class="headerlink" title="配置服务器"></a>配置服务器</h3><p>打开 <strong>Terminal</strong> 输入如下命令：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cd ~/<span class="type">Desktop</span>/client</span><br><span class="line">python -m <span class="type">SimpleHTTPServer</span> <span class="number">9001</span></span><br></pre></td></tr></table></figure>
<p>这两行命令的作用是在先前创建的client目录中开启一个基于Python的web服务器。现在，你们可以准备起飞了！</p>
<p>回到你的Xcode项目中编译运行程序。你应该可以看到你的第一个tvOS TVML应用了！</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-7.png" alt="tvOS-7"></p>
<p>我不知道你们的感觉如何，但是当我第一次运行成功后，我的感受就像下面这个家伙一样：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-8.png" alt="tvOS-8"></p>
<p>在继续进行教程之前，我想花点时间对你们目前已经完成的工作作以总结：</p>
<ol>
<li>你们创建了<code>TVApplicationController</code>实例。它用于管理JavaScript代码。</li>
<li>你们创建了<code>TVApplicationControllerContext</code>实例，并在创建<code>TVApplicationController</code>时将其与之关联。应用上下文有一个<code>launchOption</code>属性，用来构建我们的<code>BASEURL</code>，也就是服务器的地址。该应用上下文也用于配置tvOS应用与哪个服务器连接。</li>
<li>控制器被传到了JavaScript代码中。<code>App.onLaunch</code>作为整个JavaScript文件的入口方法，你们定义了<code>createAlert</code>函数，返回TVML提示信息模板文件，并由<code>navigationDocument</code>管理并展现界面。最后将“Hello World”显示在屏幕上。</li>
</ol>
<p>即使现在你们使用的服务器是运行在本机的，但是你们仍然可以连接一个真实的远程的服务器，可能是一个连着数据库的服务器。你们感受并想象一下应用场景，应该会很酷，对吧？</p>
<h2 id="u5B8C_u5584TVML_u6A21_u677F"><a href="#u5B8C_u5584TVML_u6A21_u677F" class="headerlink" title="完善TVML模板"></a>完善TVML模板</h2><p>我之前提到过，<code>createAlert</code>是一个返回TVML模板文件的函数。有很多属性可由我们在TVML文件中编辑修改，作为一个实验性质的小例子，你们将会在当前的 <strong>alertTemplate</strong> 中添加一个按钮。回到你们的JavaScript代码中，将目光聚焦在<code>createAlert</code>函数上，在模板中添加一个按钮：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> alertString = `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;alertTemplate&gt;</span><br><span class="line">      &lt;title&gt;$&#123;title&#125;&lt;/title&gt;</span><br><span class="line">      &lt;description&gt;$&#123;description&#125;&lt;/description&gt;</span><br><span class="line">      &lt;button&gt;</span><br><span class="line">        &lt;text&gt;<span class="type">OK</span>&lt;/text&gt;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/alertTemplate&gt;</span><br><span class="line">  &lt;/document&gt;`</span><br></pre></td></tr></table></figure>
<p>这里解释一下上述代码：</p>
<ol>
<li>一个TVML文件的第一级标签是<code>&lt;document&gt;</code>，也就是整个模板内容是由<code>&lt;document&gt;</code>和<code>&lt;/document&gt;</code>包起来的。</li>
<li>接着你们开始定义模板。使用Apple提供的 <strong>alertTemplate</strong> 模板，通过<code>createAlert</code>函数将其返回。</li>
<li>在该模板里，根据Apple的<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/TextboxTemplate.html#//apple_ref/doc/uid/TP40015064-CH2-SW8" target="_blank" rel="external">Apple TV Markup Language Reference</a>文档规范，添加了按钮、标题、描述三个标签。</li>
</ol>
<p>保存你们刚才编辑的JavaScript文件，再次编译运行。你们看到在提示信息下面出现了一个按钮。瞧，TVML是不是将构建tvOS UI变得很简单！</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-9.png" alt="tvOS-9"></p>
<blockquote>
<p>注意：在一个模板中，你能添加的元素数量和类型基于这个的模板的类型。比如，一个 <strong>loading Template</strong> 就不允许有任何按钮出现。此外，你可以自定义字体、颜色和其他一些属性。但是这些知识已经超越了该教程的范畴。你们可以查阅<a href="https://developer.apple.com/library/prerelease/tvos/documentation/LanguagesUtilities/Conceptual/ATV_Template_Guide/index.html#//apple_ref/doc/uid/TP40015064-CH41-SW1" target="_blank" rel="external">Apple TV Markup Language Reference</a>文档去了解更多TVML模板的信息。</p>
</blockquote>
<h2 id="u4E30_u5BCCJavaScript_u5BA2_u6237_u7AEF"><a href="#u4E30_u5BCCJavaScript_u5BA2_u6237_u7AEF" class="headerlink" title="丰富JavaScript客户端"></a>丰富JavaScript客户端</h2><p>到目前为止，你们已经完成了一些工作，并且正按照我们的指引一步一步达成目标。在这一节中，你们将要花一点时间在不同的JavaScript文件中将一些逻辑抽象出来，便于能更好的重用。</p>
<p>在 <strong>client/js</strong> 文件夹中新建一个JavaScript文件，名为 <strong>Presenter.js</strong> 。在该文件中，你们将定义<code>Presenter</code>类用于处理导航各个界面，或者说各个TVML模板文件，并且处理事件响应。在 <strong>Presenter.js</strong> 中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Presenter</span> = &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  makeDocument: function(resource) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="type">Presenter</span>.parser) &#123;</span><br><span class="line">      <span class="type">Presenter</span>.parser = new <span class="type">DOMParser</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> doc = <span class="type">Presenter</span>.parser.parseFromString(resource, <span class="string">"application/xml"</span>);</span><br><span class="line">    <span class="keyword">return</span> doc;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  modalDialogPresenter: function(xml) &#123;</span><br><span class="line">    navigationDocument.presentModal(xml);</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  pushDocument: function(xml) &#123;</span><br><span class="line">    navigationDocument.pushDocument(xml);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们解释一下上述代码：</p>
<ol>
<li>还记得你们在之前<code>createAlert</code>函数中用过的<code>DOMParser</code>类么，它可以将TVML字符串转换为可用于展示的TVML模板对象。因为该类不需要多次创建实例，所以采用单例模式创建它。然后通过<code>DOMParser</code>的<code>parseFormString()</code>方法将TVML字符串转为模板对象。</li>
<li><code>modalDialogPresenter</code>方法通过传入的TVML模板文件，将其模态的展现在屏幕上。</li>
<li><code>pushDocument</code>方法是在导航栈中推送一个TVML模板文件，相当于在iOS中push出一个界面。</li>
</ol>
<p>在之后，你们还会用到<code>Presenter</code>类管理选中处理操作。现在，让我们使用<code>Presenter</code>类对之前的JavaScript代码进行重构。将<code>App.onLaunch</code>中的代码替换为如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">App</span>.onLaunch = function(options) &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> javascriptFiles = [</span><br><span class="line">    `$&#123;options.<span class="type">BASEURL</span>&#125;js/<span class="type">Presenter</span>.js`</span><br><span class="line">  ];</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  evaluateScripts(javascriptFiles, function(success) &#123;</span><br><span class="line">    <span class="keyword">if</span>(success) &#123;</span><br><span class="line">      <span class="keyword">var</span> alert = createAlert(<span class="string">"Hello World!"</span>, <span class="string">""</span>);</span><br><span class="line">      <span class="type">Presenter</span>.modalDialogPresenter(alert);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 3 Handle the error CHALLENGE!//inside else statement of evaluateScripts. </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些代码相对还是比较容易理解的，我们来看一下：</p>
<ol>
<li>首先创建一个新的JavaScript文件的数组。然后通过<code>options</code>参数获取到<code>BASEURL</code>属性，并组装<code>Presenter.js</code>的路径。这里的<code>options</code>就是之前我们在<code>AppDelegate</code>类中创建的<code>TVApplicationControllerContext</code>，<code>BASEURL</code>自然也是那时我们设置的。</li>
<li><code>evaluateScripts</code>将加载JavaScript文件。</li>
<li>这里，你应该处理异常信息，稍后我们完善这里。</li>
</ol>
<p>在继续进行之前，编译运行程序，确保JavaScript文件修改过之后程序仍能正常运行。此时，我们通过<code>Presenter</code>类对JavaScript代码的重构有了一个良好的开端：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-10.png" alt="tvOS-10"></p>
<p>现在，看看上面代码中被注释的那行，你们能否自行完成对异常处理的挑战呢。如果<code>evaluateScripts</code>处理失败，可能是因为JavaScript文件的路径写错了，那么你可能会希望在此时显示一个提示消息给用户。<strong>提示：</strong> 之所以在这里出现了异常，是因为<code>Presenter</code>类加载失败导致，所以在这里你不能使用<code>Presenter</code>类显示提示信息的界面。</p>
<p>你应该通过之前所学到的知识来解决该问题。如果你们觉得有困难，那么可以参照下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//将这两行代码插入evaluateScripts的else代码块中. </span></span><br><span class="line"><span class="keyword">var</span> errorDoc = createAlert(<span class="string">"Evaluate Scripts Error"</span>, <span class="string">"Error attempting to evaluate external JavaScript files."</span>);</span><br><span class="line">navigationDocument.presentModal(errorDoc);</span><br></pre></td></tr></table></figure>
<p>想要测试错误信息，你们可以修改一下JavaScript文件的路径，比如把<code>Presenter.js</code>改为<code>Presentr.js</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$&#123;options.<span class="type">BASEURL</span>&#125;js/<span class="type">Presentr</span>.js</span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u4F7F_u7528CatalogTemplate"><a href="#u4F7F_u7528CatalogTemplate" class="headerlink" title="使用CatalogTemplate"></a>使用CatalogTemplate</h2><p><strong>catalogTemplate</strong>模板同样也是Apple提供的18个模板中的一个。它的作用是以分组的形式展现内容，用它来展示你们最喜欢的RWDevCon视频最好不过了！ <strong>catalogTemplate</strong>有许多有意思的元素：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-11.jpg" alt="tvOS-11"></p>
<h3 id="u590D_u5408_u5143_u7D20_u548C_u7B80_u5355_u5143_u7D20"><a href="#u590D_u5408_u5143_u7D20_u548C_u7B80_u5355_u5143_u7D20" class="headerlink" title="复合元素和简单元素"></a>复合元素和简单元素</h3><p>该模板中的<code>banner</code>元素在应用顶部，用于展示应用基本信息，比如名称、标题等。它本身是一个 <strong>复合元素</strong> ，也就是说它是由多个 <strong>简单元素</strong> 组合而成。比如，在<code>banner</code>中很显然有标题，那么该标题就是一个简单的<code>title</code>元素，并且在<code>title</code>背后还有背景图片，这又是另外一个简单元素<code>background</code>。所以<code>banner</code>是由两个简单元素组合而成。</p>
<p>让我们来试试这个模板吧。打开 <strong>client</strong> 文件夹，在 <strong>js</strong> 文件夹的同级目录新建两个文件夹，分别命名为 <strong>images</strong> 和 <strong>templates</strong> 。此时你的 <strong>client</strong> 文件夹里的内容应该是这样的：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-12.png" alt="tvOS-12"></p>
<p>你们会需要图片构建模板中的Cells，在我们这个场景中就是一个一个的视频，图片自然就是视频的封面了。我已经为你们准备好了封面图片，你们可以从<a href="/cdn3.raywenderlich.com/wp-content/uploads/2015/09/images.zip">这里下载</a>。下载成功后，将他们解压放在刚才你们创建的 <strong>images</strong> 文件夹中。</p>
<p>现在，你们即将要做的工作是在屏幕中显示图片!新建一个JavaScript文件，命名为 <strong>RWDevConTemplate.xml.js</strong> ，将其存在 <strong>templates</strong> 文件夹中。</p>
<p>打开 <strong>RWDevConTemplate.xml.js</strong> ，添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Template</span> = function() &#123; <span class="keyword">return</span> `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;catalogTemplate&gt;</span><br><span class="line">      &lt;banner&gt;</span><br><span class="line">        &lt;title&gt;<span class="type">RWDevConHighlights</span>&lt;/title&gt;</span><br><span class="line">      &lt;/banner&gt;</span><br><span class="line">    &lt;/catalogTemplate&gt;</span><br><span class="line">  &lt;/document&gt;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们试图通过<code>catalogTemplate</code>模板显示一个Banner条。但在使用只包含模板信息的JavaScript文件之前，我们需要通过某种方法让其他的JavaScript文件知道该文件的存在并能加载其模板信息，因为当前它没有通过任何方式向其他JavaScript文件暴露过。所以我们要创建的最后一个JavaScript文件： <strong>ResourceLoader.js</strong> 就是用来解决该问题的！</p>
<h3 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h3><p>新建一个JavaScript文件，命名为 <strong>ResourceLoader.js</strong> ，保存在 <strong>js</strong> 文件夹中，和 <strong>application.js</strong> 、 <strong>Presenter.js</strong> 一起。打开 <strong>ResourceLoader.js</strong> 添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function <span class="type">ResourceLoader</span>(baseurl) &#123;</span><br><span class="line">  this.<span class="type">BASEURL</span> = baseurl;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">ResourceLoader</span>.prototype.loadResource = function(resource, callback) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">self</span> = this;</span><br><span class="line">  evaluateScripts([resource], function(success) &#123;</span><br><span class="line">    <span class="keyword">if</span>(success) &#123;</span><br><span class="line">      <span class="keyword">var</span> resource = <span class="type">Template</span>.call(<span class="keyword">self</span>);</span><br><span class="line">      callback.call(<span class="keyword">self</span>, resource);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> title = <span class="string">"Resource Loader Error"</span>,</span><br><span class="line">          description = `<span class="type">Error</span> loading resource '$&#123;resource&#125;'. \n\n <span class="type">Try</span> again later.`,</span><br><span class="line">          alert = createAlert(title, description);</span><br><span class="line">      navigationDocument.presentModal(alert);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不用过于担心看不懂这些代码逐行的含义，你们只要清楚这些代码的作用是加载其他模板文件就可以了。</p>
<p>之前我们的主屏显示的是“Hello World”的提示信息模板，现在试着将它换成我们创建的<code>RWDevConTemplate</code>。打开 <strong>application.js</strong> 文件，根据如下代码修改之前的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> resourceLoader;</span><br><span class="line"> </span><br><span class="line"><span class="type">App</span>.onLaunch = function(options) &#123;</span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">var</span> javascriptFiles = [</span><br><span class="line">    `$&#123;options.<span class="type">BASEURL</span>&#125;js/<span class="type">ResourceLoader</span>.js`, </span><br><span class="line">    `$&#123;options.<span class="type">BASEURL</span>&#125;js/<span class="type">Presenter</span>.js`</span><br><span class="line">  ];</span><br><span class="line"> </span><br><span class="line">  evaluateScripts(javascriptFiles, function(success) &#123;</span><br><span class="line">    <span class="keyword">if</span>(success) &#123;</span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      resourceLoader = new <span class="type">ResourceLoader</span>(options.<span class="type">BASEURL</span>);</span><br><span class="line">      resourceLoader.loadResource(`$&#123;options.<span class="type">BASEURL</span>&#125;templates/<span class="type">RWDevConTemplate</span>.xml.js`, function(resource) &#123;</span><br><span class="line">        <span class="keyword">var</span> doc = <span class="type">Presenter</span>.makeDocument(resource);</span><br><span class="line">        <span class="type">Presenter</span>.pushDocument(doc);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> errorDoc = createAlert(<span class="string">"Evaluate Scripts Error"</span>, <span class="string">"Error attempting to evaluate external JavaScript files."</span>);</span><br><span class="line">      navigationDocument.presentModal(errorDoc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 先不管createAlert函数</span></span><br></pre></td></tr></table></figure>
<p>此时你们已经对之前的代码进行了三处的修改：</p>
<ol>
<li>申明了一个<code>resourceLoader</code>变量。</li>
<li>将 <strong>ResourceLoader.js</strong> 文件添加到JavaScript文件数组中。</li>
<li>使用<code>resourceLoader</code>加载TVML模板，然后使用<code>Presenter</code>展现在屏幕上。</li>
</ol>
<p>编译运行程序，你们应该会看到如下界面：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-13.png" alt="tvOS-13"></p>
<p>恭喜你们，现在你们已经可以通过更好的方式从JavaScript文件中加载TVML模板信息了，而不再使用硬编码写死在代码里！</p>
<h3 id="u5B8C_u5584catalogTemplate"><a href="#u5B8C_u5584catalogTemplate" class="headerlink" title="完善catalogTemplate"></a>完善catalogTemplate</h3><p>你管你们信不信，我们要做的tvOS应用马上要接近尾声了。通过TVML开发tvOS应用最优雅的一件事就是添加界面元素非常之简单。</p>
<p>打开 <strong>RWDevConTemplate.xml.js</strong> 文件，按照如下代码更新之前代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Template</span> = function() &#123; <span class="keyword">return</span> `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;catalogTemplate&gt; </span><br><span class="line">      &lt;banner&gt; </span><br><span class="line">        &lt;title&gt;<span class="type">RWDevConHighlights</span>&lt;/title&gt;</span><br><span class="line">      &lt;/banner&gt;</span><br><span class="line">      <span class="comment">//add stuff here</span></span><br><span class="line">      <span class="comment">//1.</span></span><br><span class="line">      &lt;list&gt; </span><br><span class="line">        &lt;section&gt; </span><br><span class="line">          <span class="comment">//2.</span></span><br><span class="line">      &lt;listItemLockup&gt; </span><br><span class="line">        &lt;title&gt;<span class="type">Inspiration</span> <span class="type">Videos</span>&lt;/title&gt;</span><br><span class="line">        &lt;decorationLabel&gt;<span class="number">13</span>&lt;/decorationLabel&gt;</span><br><span class="line">      &lt;/listItemLockup&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">      &lt;/list&gt;</span><br><span class="line">    &lt;/catalogTemplate&gt;</span><br><span class="line">  &lt;/document&gt;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在上面的代码中，新定义了一个list标签，该标签中的内容就是显示在屏幕上除了Banner以外的全部内容。</li>
<li><code>listItemLockup</code>代表一个组，它以<code>listItemLockup</code>标签开头。在该标签中，通过<code>title</code>标签定义了它的名称“Inspiration Videos”，然后通过<code>decorationLabel</code>标签定义了该组中包含内容的数量。</li>
</ol>
<p>编译运行程序，在模拟器中你们会看到如下界面：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-14.png" alt="tvOS-14"></p>
<p>看着还不赖吧！</p>
<h3 id="u5B8C_u6210catalogTemplate"><a href="#u5B8C_u6210catalogTemplate" class="headerlink" title="完成catalogTemplate"></a>完成catalogTemplate</h3><p>最后，我们准备在模板中添加cell，用于展示每一个视频。打开 <strong>RWDevConTemplate.xml.js</strong> 添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Template</span> = function() &#123; <span class="keyword">return</span> `&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;catalogTemplate&gt; </span><br><span class="line">      &lt;banner&gt; </span><br><span class="line">        &lt;title&gt;<span class="type">RWDevConHighlights</span>&lt;/title&gt;</span><br><span class="line">      &lt;/banner&gt;</span><br><span class="line">      &lt;list&gt; </span><br><span class="line">        &lt;section&gt; </span><br><span class="line">      &lt;listItemLockup&gt; </span><br><span class="line">        &lt;title&gt;<span class="type">Inspiration</span> <span class="type">Videos</span>&lt;/title&gt;</span><br><span class="line">        &lt;decorationLabel&gt;<span class="number">13</span>&lt;/decorationLabel&gt;</span><br><span class="line">            <span class="comment">//1. add from here</span></span><br><span class="line">        &lt;relatedContent&gt; </span><br><span class="line">          &lt;grid&gt;</span><br><span class="line">            &lt;section&gt; </span><br><span class="line">                  <span class="comment">//2</span></span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Ray-Wenderlich-Teamwork.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/ray.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;</span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Ryan-Nystrom-Contributing.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/ryan.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">              &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Matthijs-Hollemans-Math-Isnt-Scary.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/matthijs.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Vicki-Wenderlich-Identity.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/vicki.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">              &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Alexis-Gallagher-Identity.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/alexis.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">              &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Marin-Todorov-RW-Folklore.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/marin.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Chris-Wagner-Craftsmanship.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/chris.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">              &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Cesare-Rocchi-Cognition.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/cesare.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Ellen-Shapiro-Starting-Over.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/ellen.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Jake-Gundersen-Opportunity.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/jake.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Kim-Pedersen-Finishing.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/kim.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">              &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Tammy-Coron-Possible.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/tammy.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;                                 </span><br><span class="line">          &lt;lockup videoURL=<span class="string">"http://www.rwdevcon.com/videos/Saul-Mora-NSBrief.mp4"</span>&gt;</span><br><span class="line">            &lt;img src=<span class="string">"$&#123;this.BASEURL&#125;images/saul.png"</span> width=<span class="string">"500"</span> height=<span class="string">"308"</span> /&gt;</span><br><span class="line">          &lt;/lockup&gt;     </span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">          &lt;/grid&gt;</span><br><span class="line">        &lt;/relatedContent&gt;</span><br><span class="line">      &lt;/listItemLockup&gt;</span><br><span class="line">        &lt;/section&gt;</span><br><span class="line">      &lt;/list&gt;</span><br><span class="line">    &lt;/catalogTemplate&gt;</span><br><span class="line">  &lt;/document&gt;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>从上述代码中可以看到，在<code>listItemLockup</code>标签中添加了<code>relatedContent</code>，该标签是的作用是显示图中红色圆圈区域的：</li>
</ol>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-15.png" alt="tvOS-15"></p>
<ol>
<li>每个<code>lockup</code>代表一个视频，每个该标签中都有<code>videoURL</code>的属性，它的值就是 <strong>RWDevCon</strong> 网站上视频的地址。对于之后播放视频至关重要。</li>
</ol>
<p>编译运行程序，会看到被你赋予新生命力的应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-16.png" alt="tvOS-16"></p>
<p>现在，我们已经在“Inspiration Videos”这个组里添加了若干视频。让我们打开遥控器的模拟器，选中模拟器，在菜单栏中选择 <strong>Hardware\Show Apple TV Remote</strong> 。你可以通过遥控器中的 <strong>option</strong> 键选择不同的视频。</p>
<h2 id="u64AD_u653E_u89C6_u9891"><a href="#u64AD_u653E_u89C6_u9891" class="headerlink" title="播放视频"></a>播放视频</h2><p>到目前为止，我们已经构建好了应用的页面，看起来还是不错的。此时，你们可以再想想如果用iOS框架完成你们现在已经完成的布局，应该如何做。Apple把一些UI的细节全都抽象了出来，通过一个个模板提供给我们使用，可以让我们简单方便的通过模板创建出完美的界面，不得不说Apple做的太棒了。</p>
<p>接下来让我们完成最后两个遗留的功能：选择视频和播放视频。</p>
<h3 id="u9009_u62E9_u4E8B_u4EF6"><a href="#u9009_u62E9_u4E8B_u4EF6" class="headerlink" title="选择事件"></a>选择事件</h3><p>你们可能已经注意到了，当按下 <strong>enter</strong> 键或者在 <strong>Apple TV Remote</strong> 选择视频时并没有什么反应，所以是时候来实现选择视频的功能了。</p>
<p>打开<code>Presenter</code>，添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">load: function(event) &#123;</span><br><span class="line">  <span class="comment">//1</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">self</span> = this,</span><br><span class="line">  ele = event.target,</span><br><span class="line">  videoURL = ele.getAttribute(<span class="string">"videoURL"</span>)</span><br><span class="line">  <span class="keyword">if</span>(videoURL) &#123;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    <span class="keyword">var</span> player = new <span class="type">Player</span>();</span><br><span class="line">    <span class="keyword">var</span> playlist = new <span class="type">Playlist</span>();</span><br><span class="line">    <span class="keyword">var</span> mediaItem = new <span class="type">MediaItem</span>(<span class="string">"video"</span>, videoURL);</span><br><span class="line"> </span><br><span class="line">    player.playlist = playlist;</span><br><span class="line">    player.playlist.push(mediaItem);</span><br><span class="line">    player.present();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ol>
<li><code>load</code>函数用来处理视频选择事件。它相当于iOS中的<code>@IBAction</code>，该函数的<code>event</code>参数相当于<code>sender</code>参数。每个<code>event</code>都有一个<code>target</code>，每个<code>target</code>关联着模板中的<code>lockup</code>元素。一个<code>lockup</code>代表应用中的一个视频，它里面有视频封面的属性，以及视频地址<code>videoURL</code>属性。</li>
<li>播放视频非常简单。<code>Player</code>是 <strong>TVJS</strong> 框架提供的一个类，负责所有视频播放的相关功能。你们所要做的只是添加一个播放列表<code>playlist</code>，然后将要播放的项目<code>mediaItem</code>添加到播放列表里。最后通过<code>player.present()</code>方法就可以播放视频了。</li>
</ol>
<p>现在你们已经实现了选择视频后的响应事件。是时候将选择事件与每个视频关联在一起了。打开 <strong>application.js</strong> 文件，在<code>App.onLaunch</code>方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">App</span>.onLaunch = function(options) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//在resourceLoader.loadResource中...</span></span><br><span class="line">  <span class="keyword">var</span> doc = <span class="type">Presenter</span>.makeDocument(resource);</span><br><span class="line">  doc.addEventListener(<span class="string">"select"</span>, <span class="type">Presenter</span>.load.bind(<span class="type">Presenter</span>)); <span class="comment">//add this line</span></span><br><span class="line">  <span class="type">Presenter</span>.pushDocument(doc);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的<code>addEventListener</code>方法相当于iOS中按钮的<code>@IBAction</code>。编译运行程序，选择一个视频播放，你会看到一个完美的视频播放应用：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/tvOS-app-development-17.gif" alt="tvOS-17"></p>
<p>大家可以在这里下载教程中的完整项目：<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/client.zip" target="_blank" rel="external">client</a>和<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2015/09/RWDevCon.zip" target="_blank" rel="external">RWDevCon</a>。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/calayer-animation-gradient-animation/" itemprop="url">
                  CALayer Animation - Gradient Animation
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2015-09-22T00:00:00+08:00" content="2015-09-22">
              2015-09-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/calayer-animation-gradient-animation/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/calayer-animation-gradient-animation/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>本文首发<a href="http://www.csdn.net/article/2015-09-22/2825765" target="_blank" rel="external">CSDN</a>，如需转载请与CSDN联系。</p>
<p>在很多人的心目中iPhone的经典机型应该是iPhone4，精湛的工艺、完美的屏幕配上暗色的锁屏壁纸，看着屏幕底部闪烁的<strong>slide to unlock</strong>字样，高逼格彰显无遗。时至今日无论iPhone机身样式如何改变，屏幕尺寸如何改变，iOS系统如何改变，唯有锁屏底部闪烁的<strong>滑动来解锁</strong>不变。它的动画效果是如何实现的呢，这篇文章会告诉你们答案。</p>
<h2 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h2><p>新建一个应用名为<strong>GradientAnimation</strong>，打开<code>Main.storyboard</code>，将ViewController的View背景色设置为灰黑色，拖一个UIView到ViewController中，将其颜色设置为无色并设置好布局约束：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-1.png" alt="GradientAnimation - 1"></p>
<p>接着我们拖一个UILabel到刚才拖入的UIView中，设置高宽等同于它的父视图：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-2.png" alt="GradientAnimation - 2"></p>
<p>我对该UILabel的属性设置如下：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-4.png" alt="GradientAnimation - 4"></p>
<p>之后，我们在<code>ViewController</code>中添加UIView和UILabel的Outlet：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-5.png" alt="GradientAnimation - 5"></p>
<p>接下来回到<code>ViewController.swift</code>，我们添加一个常量属性<code>gradientLayer</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> gradientLayer = <span class="type">CAGradientLayer</span>()</span><br></pre></td></tr></table></figure>
<p>这里出现了CALayer的另一个子类CAGradientLayer，这个类的作用就是能在Layer上绘制出渐变颜色的效果，然后在<code>viewDidLoad()</code>中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gradientLayer.bounds = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: backgroundView.frame.size.width, height: backgroundView.frame.size.height)</span><br><span class="line">gradientLayer.position = <span class="type">CGPoint</span>(x: backgroundView.frame.size.width/<span class="number">2</span>, y: backgroundView.frame.size.height/<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>上述两行的代码是设置Layer的大小及位置，这在上两篇文章中已经讲过，这里就不再累赘了。接着我们继续添加两行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gradientLayer.startPoint = <span class="type">CGPoint</span>(x: <span class="number">0</span>, y: <span class="number">0.5</span>)</span><br><span class="line">gradientLayer.endPoint = <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>既然CAGradientLayer可以绘制出渐变颜色的效果，那自然有颜色渐变的方向，所以这两行代码的作用就是设置颜色渐变的起始点和结束点，这两个属性共同决定了颜色渐变的方向：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-3.png" alt="GradientAnimation - 3"></p>
<p>从上面的示意图中可以看出，CAGradientLayer是通过起始点和结束点的坐标位置来决定颜色渐变的方向的，起始点的默认值是(0.5, 0)，结束点的默认值是(0.5, 1)，也就是说默认的颜色渐变方向是沿垂直中线从上往下渐变的，我们在这里将它改成了沿水平中线从左往右渐变。</p>
<p>接下来我们设置CAGradientLayer的渐变颜色，接着添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gradientLayer.colors = [</span><br><span class="line">    <span class="type">UIColor</span>.blackColor().<span class="type">CGColor</span>,</span><br><span class="line">    <span class="type">UIColor</span>.whiteColor().<span class="type">CGColor</span>,</span><br><span class="line">    <span class="type">UIColor</span>.blackColor().<span class="type">CGColor</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>CAGradientLayer的<code>colors</code>属性类型是一个数组<code>[AnyObject]</code>，这就意味着我们可以实现多个颜色的渐变效果，并且可以规定各个颜色的顺序。不过在我们这个示例中我们只需要两种颜色，不过需要注意的是虽然颜色只有两种，但是整个颜色渐变的过程中有三个原色点，那就是黑、白、黑，所以我们在这个数组中也需要按照原色点的数量和顺序添加相应的颜色，哪怕颜色都是一样的。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>我们既然设置了渐变的三个原色，那么就要对这原色出现的位置进行设置，接着添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gradientLayer.locations = [<span class="number">0.2</span>, <span class="number">0.5</span>, <span class="number">0.8</span>]</span><br></pre></td></tr></table></figure>
<p>从上述代码中不难看出，我们将第一个黑色原色出现的位置设置在了整个Layer长度的十分之二的位置，第二个白色原色在中间，第三个黑色原色在十分之八的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-6.png" alt="GradientAnimation - 6"></p>
<p>设置完CAGradientLayer的相关属性后，我们将<code>gradientLayer</code>添加到<code>backgroundView</code>的Layer中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">backgroundView.layer.addSublayer(gradientLayer)</span><br></pre></td></tr></table></figure>
<p>现在我们编译运行一下代码看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-7.png" alt="GradientAnimation - 7"></p>
<p>接下来我们需要让颜色渐变动起来，先创建一个方法<code>gradinetAnimate()</code>，在方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> gradient = <span class="type">CABasicAnimation</span>(keyPath: <span class="string">"locations"</span>)</span><br><span class="line">gradient.fromValue = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.25</span>]</span><br><span class="line">gradient.toValue = [<span class="number">0.75</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">gradient.duration = <span class="number">2.5</span></span><br><span class="line">gradient.repeatCount = <span class="type">HUGE</span></span><br><span class="line">gradientLayer.addAnimation(gradient, forKey: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>首先，创建了一个<code>locations</code>类型的动画实例<code>gradient</code>，将<code>fromValue</code>属性，也就是起始位置的属性设置为<code>[0, 0, 0.25]</code>，它的意思是动画开始前，黑色、白色这两个原色的位置在整个Layer的最前端，第二个黑色原色在0.25的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-8.png" alt="GradientAnimation - 8"></p>
<p>而结束位置<code>toValue</code>，将白色和第二个黑色原色位置设置在整个Layer的末端，第一个黑色原色在0.75的位置：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-9.png" alt="GradientAnimation - 9"></p>
<p>从图中可以看出，此时整个Layer都变成了黑色。也就是说，在整个动画中，第一个黑色原色从0移动到0.75的位置，白色原色从0移动到1的位置，第二个黑色原色从0.25移动到1的位置。然后设置动画时间为2.5秒，无线重复次数，最后将<code>gradient</code>动画添加到<code>gradientLayer</code>中。我们在<code>viewDidAppear()</code>方法中调用该动画方法<code>gradientAnimate()</code>，编译运行看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-10.gif" alt="GradientAnimation - 10"></p>
<p>动画效果还不赖，但是如何将颜色渐变的动画作用在UILabel的文字上呢？其实非常简单，就是让UILabel上的文字称为CAGradientLayer的遮罩即可，我们先在<code>ViewController</code>中定义一个常量：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">"DevTalking"</span></span><br></pre></td></tr></table></figure>
<p>然后在<code>viewDidAppear()</code>中的<code>gradientAnimate()</code>方法之前添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">textLabel.text = text</span><br><span class="line">gradientLayer.mask = textLabel.layer</span><br></pre></td></tr></table></figure>
<p>我们再编译运行代码看看效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-11.gif" alt="GradientAnimation - 11"></p>
<p>到目前为止，锁屏中<strong>滑动来解锁</strong>的动画效果就完成了，这个动画效果在Facebook的Paper应用中也有使用。下一节，我们在该动画的基础上对文字再加点小动画。</p>
<h2 id="Text_Animation"><a href="#Text_Animation" class="headerlink" title="Text Animation"></a>Text Animation</h2><p>首先我们打开<code>AppDelegate.swift</code>，在<code>import UIKit</code>下面添加一个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">delay</span><span class="params">(seconds seconds: Double, completion:<span class="params">()</span></span></span>-&gt;()) &#123;</span><br><span class="line">    <span class="keyword">let</span> intervalTime = dispatch_time(<span class="type">DISPATCH_TIME_NOW</span>, <span class="type">Int64</span>( <span class="type">Double</span>(<span class="type">NSEC_PER_SEC</span>) * seconds ))</span><br><span class="line">    </span><br><span class="line">    dispatch_after(intervalTime, dispatch_get_main_queue(), &#123;</span><br><span class="line">        completion()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的作用如其名称一样，是一个延迟方法，该方法的第一个参数是想要延迟的时间，第二个参数是一个闭包，也就是延迟的主体。这个方法用到了GCD的知识，<code>dispatch_time</code>主要是用于创建一个类型为<code>dispatch_time_t</code>的相对时间，它的第一个参数指的是起始时间，一般都是用预定义的<code>DISPATCH_TIME_NOW</code>作为第一个参数的值，代表当前的时间。第二个参数代表时间间隔，注意这个参数需要的时间单位是纳秒，所以我们使用预定义的<code>NSEC_PER_SEC</code>纳秒单位乘以希望间隔的秒数。</p>
<p><code>dispatch_after</code>用于在队列中定时执行任务，当你想在一段时间后执行一个任务，那么就可以用这个函数。该函数的第一个参数指定延迟的时间，第二个参数指定一个队列，用于添加任务，第三个参数是一个闭包，也就是要执行的任务。</p>
<p>然后回到<code>ViewController.swift</code>，添加如下方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">textAnimate</span><span class="params">(text: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> text.characters.<span class="built_in">count</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        textLabel.text = <span class="string">"<span class="subst">\(textLabel.text!)</span><span class="subst">\(text.substringToIndex(text.startIndex.successor()</span>))"</span></span><br><span class="line">        delay(seconds: <span class="number">0.4</span>, completion: &#123;</span><br><span class="line">            <span class="keyword">self</span>.textAnimate(text.substringFromIndex(text.startIndex.successor()))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的参数<code>text</code>就是UILabel中要显示的文字内容。<code>substringToIndex(_ to: Int)</code>方法的作用是从字符串的开头一直截取到指定的位置，但不包括该指定位置的字符。<code>text.startIndex.successor()</code>这句意思是从<code>text</code>的起始位置开始取后面的一个字符。<code>substringFromIndex(_ from: Int)</code>方法的作用是以指定位置并包括指定位置的字符开始，一直截取之后的全部字符。所以整个方法的作用是每隔0.4秒显示一个字符，直到将整个字符串显示完。最后在<code>viewDidAppear()</code>中注释掉<code>textLabel.text = text</code>这行代码，并在方法最后调用<code>textAnimate(text)</code>方法。编译运行代码看看最终效果：</p>
<p><img src="http://7xpp8a.com1.z0.glb.clouddn.com/GradientAnimation-12.gif" alt="GradientAnimation - 12"></p>
<p>参考文献来自：<a href="http://www.raywenderlich.com/store/ios-animations-by-tutorials" target="_blank" rel="external">iOS Animations by Tutorials</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://www.devtalking.com/devtalking.png" alt="DevTalking" itemprop="image"/>
          <p class="site-author-name" itemprop="name">DevTalking</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">83</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

         <!-- <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分類</span>
              
          </div> -->

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">44</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://www.linkedin.com/in/宇轩-付-5aa406a6" target="_blank">
                  
                    <i class="fa fa-linkedin"></i> linkedin
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:jace.fu@icloud.com" target="_blank">
                  
                    <i class="fa fa-envelope"></i> Email
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DevTalking</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'jacefu';
      var disqus_identifier = 'page/4/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/lib/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
