<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-121973094-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-121973094-1');
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-4115205380866695",
          enable_page_level_ads: true
     });
</script>

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
 <script type="text/x-mathjax-config">
 MathJax.Hub.Config({tex2jax: {inlineMath:[['$','$']]}});
 </script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<style>
    .pace .pace-progress {
        background: #272822; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #272822, 0 0 5px #272822; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #272822;    /*上边框颜色*/
        border-left-color: #272822;    /*左边框颜色*/
    }
</style>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>




  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="程序员说" type="application/atom+xml" />



  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="程序员说">
<meta property="og:url" content="http://www.devtalking.com/page/16/index.html">
<meta property="og:site_name" content="程序员说">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员说">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> 程序员说 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?980738dc41a50d91861a17ad4b768a1f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>


  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">程序员说</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th"></i> <br />
            
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/adaptive-layout-2/" itemprop="url">
                  Swift自适应布局（Adaptive Layout）教程（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-13T00:00:00+08:00" content="2014-10-13">
              2014-10-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/adaptive-layout-2/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/adaptive-layout-2/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h2 id="u7ED9TextContainer_u4E2D_u6DFB_u52A0_u5185_u5BB9"><a href="#u7ED9TextContainer_u4E2D_u6DFB_u52A0_u5185_u5BB9" class="headerlink" title="给TextContainer中添加内容"></a>给TextContainer中添加内容</h2><p>打开 <strong>Main.storyboard</strong> ，从组件库（Object Library）中拖拽两个 <strong>Label</strong> 组件到TextContainer中，位置可以随意摆放：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-35.png" alt="图片"></p>
<p>先选择靠上的Label，然后点击底部的 <strong>Align</strong> 按钮，添加一个 <strong>Horizontal Center in Container</strong> 约束，再点击 <strong>Pin</strong> 按钮，添加一个 <strong>Top Spacing to nearest neighbor</strong> 约束，设置其值为10：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-36.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-37.png" alt="图片"></p>
<p>然后选择右侧工具栏中的 <strong>Attribute Inspector</strong> 页签，将该Label的 <strong>Text</strong> 属性设置为 <strong>Cupertino</strong> ，<strong>Color</strong> 属性设置为 <strong>White</strong> ，<strong>Font</strong> 属性设置为 <strong>Helvetica Neue, Thin</strong> ， <strong>Size</strong> 属性设置为 <strong>150</strong>。</p>
<p>这时同学们可能会发现基本看不到刚才设置的文字的全貌，这是因为Label大小的原因。别着急，我们很快就会解决这个问题。</p>
<p>现在选择另一个Label，按照上述的方法给它也添加一个 <strong>Horizontal Center in Container</strong> 约束以及一个 **Bottom Spacing<br>to nearest neighbor** 约束，将其值设置为10。打开右侧工具栏中的 <strong>Size Inspector</strong> 看看：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-38.png" alt="图片"></p>
<p>然后选择 <strong>Attribute Inspector</strong> 将该Label的 <strong>Text</strong> 属性设置为 <strong>28C</strong> ， <strong>Color</strong> 属性设置为 <strong>White</strong>， 将 <strong>Font</strong> 属性设置为 <strong>Helvetica Neue, Thin</strong>， 将 <strong>Size</strong> 属性设置为 <strong>250</strong>。</p>
<p>现在是时候解决Label大小的问题了。选中view controller的view，点击底部的 <strong>Resolve Auto Layout Issues</strong> 按钮，在弹出菜单中选择 <strong>All Views\Update Frames</strong> ，现在看看<code>storyboard</code>中发生了什么：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-39.png" alt="图片"></p>
<p>我们看到了刚才设置的城市和温度，但是他们有一点点重叠，这可不是我们想要的结果。在我们修改这个问题之前，先看看预览编辑区的显示情况。我们发现在iPad下显示貌似还挺完美：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-40.png" alt="图片"></p>
<p>但是在iPhone下不出所料的无法直视，字体太大了：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-41.png" alt="图片"></p>
<p>接下来让我们解决这个重叠和字体大小的问题。</p>
<h2 id="Size_Classes"><a href="#Size_Classes" class="headerlink" title="Size Classes"></a>Size Classes</h2><p>通用的<code>storyboard</code>文件固然很好，但是你想真正把它玩转还是得花功夫去研究它，这是一件很有挑战性的工作，当然我们也要懂得运用一些现有的工具来帮助我们。Xcode6就为我们提供了一些工具和技巧，帮助我们更好的实现自适应布局。</p>
<p>自适应布局有一个很重要的概念就是 <strong>Size Classes</strong>。它并不代表真正的尺寸，而是我们从感官上感觉尺寸的种类，通过这种种类的组合，表示出不同屏幕尺寸设备的横屏及竖屏。</p>
<p>Xcode6为我们提供了两个种类：普通（<strong>Regular</strong>）和紧凑（<strong>Compact</strong>）。虽然它们涉及到视图的物理尺寸，但一般它们只代表视图的语义尺寸，即不是真正的尺寸，而是我们从感官上分出的尺寸种类。</p>
<p>下面这个表格向同学们展示了size classes和各个尺寸设备竖屏、横屏之间的关系：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-42.png" alt="图片"></p>
<p>上表中的这些size classes组合都是我们在开发应用中经常碰到的。然而你也可以在视图的任何一个层级中覆盖这些size classes。当以后我们开发Apple Watch应用时显得尤其有用。</p>
<h2 id="Size_Classes_u4E0E_u5F00_u53D1_u8005"><a href="#Size_Classes_u4E0E_u5F00_u53D1_u8005" class="headerlink" title="Size Classes与开发者"></a>Size Classes与开发者</h2><p>何为设计应用的UI？虽然现在你们的应用已经知道要使用Size Classes，并且你们在<code>storyboard</code>文件中设计应用界面时已经抛开了具体尺寸大小的束缚。但是你们难道没有发现在所有尺寸的设备中，不管是竖屏还是横屏，应用的界面布局都是一致的吗？只是自适应了尺寸大小而已。这还远远不是设计。</p>
<p>当你们决心要设计自适应的界面并已经开始设计的时候，有一点很关键。那就是要知道界面在不同的Size Classes要有继承的关系。你们应该首先设计一个基础的界面，然后根据不同尺寸的横竖屏在基础的界面上进行自定义。千万不要把不同的Size Classes当做独立的屏幕尺寸去设计UI。应该在你们的脑海中建立起界面的一个继承关系的思想，也就是大多数的设备使用基础界面，然后特别的尺寸及横竖屏再根据情况基于基础界面修改。</p>
<p>在本文中，一直没有像大家介绍过如何设置特殊设备的布局，那是应为自适应布局的核心概念Size Classes本身就是由各种特殊设备的特点抽象而来的。也就是说一个Size Classes就意味着一种特殊设备的布局特点，其实普通情况也是特殊情况中的一种。所以说我们可以组合不同的Size Classes来满足各种特殊的布局情况，比如一个支持自适应的视图，它可以在应用的父视图控制器中自适应，也可以在某一个功能的视图控制器容器中自适应。但是两者自适应后的布局却不相同。</p>
<p>这种改进对Apple本身也是有益的，因为他们不断的改变移动设备的尺寸，但从来没有强迫开发者和设计者重新开发和设计他们的应用以适应新尺寸的设备。这就不会让开发者和设计者对Apple不断改变设备尺寸这件事有抗拒心理。</p>
<p>接下来，我们将自定义Size Classes以适应iPhone横屏的时候，因为现在的布局在横屏时用户体验很糟糕。</p>
<h2 id="u4F7F_u7528Size_Classes"><a href="#u4F7F_u7528Size_Classes" class="headerlink" title="使用Size Classes"></a>使用Size Classes</h2><p>回到 <strong>Main.storyboard</strong>，点击底部的 <strong>w Any h Any</strong>，你就可以看到Size Classes的选择器了：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-43.png" alt="图片"></p>
<p>在这个由9个方格组成的网格中，你就可以选择你想在<code>storyboard</code>中显示的Size Class。一共有9种组合方式：3种垂直的也就是竖屏的（任意尺寸（Any），普通（regular），紧凑（compact））选择和3种水平的也就是横屏（任意尺寸（Any），普通（regular），紧凑（compact））的选择。</p>
<blockquote>
<p>注意：这里有一点需要大家注意。在Size Classes中，有两个重要的概念叫做<em>水平（Horizontal）</em>和<em>垂直（Vertical）</em>。但是在IB中叫做 <em>宽（Width）</em>和<em>高（Height）</em>。但他们是等价的，所以大家记住这个概念有两种叫法就可以了。</p>
</blockquote>
<p>目前我们的布局在紧凑高度（Compact Height）时显示的很糟糕，也就是iPhone横屏时。我们来解决这个问题，在Size Classes选择器中选择 <strong>Any Width | Compact Height</strong> 的组合：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-44.png" alt="图片"></p>
<p>这时你会发现在<code>storyboard</code>中会立即出现2个变化：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-45.png" alt="图片"></p>
<ol>
<li><code>storyboard</code>中的view controller变成了我们刚才设置的size class。</li>
<li><code>storyboard</code>底部会出现蓝色的长条区域，并显示出当前我们正在使用的size class。</li>
</ol>
<p>为了在该size class下改变布局，我们要临时改变一些之前设置好的约束。在自动布局中这种操作有个术语叫做 <strong>装配（installing）</strong> 和 <strong>卸载（uninstalling）</strong> 约束。当一个约束在当前的size class中是适用的，我们就将该约束装配在当前的size class中，如果不适用，我们就卸载它。</p>
<p>选择image view，在右侧工具栏中选择 <strong>Size Inspector</strong>。你可以看到在image view上添加的所有约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-46.png" alt="图片"></p>
<p>单击鼠标左键选择 <strong>Align Center X to: Superview</strong> 约束，然后按下键盘上的 <strong>Delete</strong> 键来卸载该约束。这时我们可以看到在<code>storyboard</code>中这个约束就立即消失了，并且在<code>storyboard</code>的结构目中和 Size Inspector中该约束都变成了灰色：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-47.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-48.png" alt="图片"></p>
<blockquote>
<p>注意：你可以在Size Inspector中点击 <strong>All</strong> 来查看当前size class卸载掉的约束。</p>
</blockquote>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>鼠标双击刚才卸载的那条约束，我们可以看到在约束编辑界面的底部出现了额外的2个选项：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-49.png" alt="图片"></p>
<p>这两个选项的意思就是这条约束在基础布局中是可用的，但在当前的 <strong>Any Width | Compact Height</strong> 布局中是不可用的。  </p>
<p>按照上面的步骤卸载掉image view上的另外3个约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-50.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-51.png" alt="图片"></p>
<p>现在你就可以添加适合当前size class的约束了。我们添加一个 <strong>Align/Vertical Center in Container</strong> 约束，再添加一个 <strong>Pin/Left Spacing to nearest neighbor</strong> 约束，其值设置为10：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-52.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-53.png" alt="图片"></p>
<p>选择image view，按住 <strong>Ctrl</strong> 键从image view上拖拽至view controller的view上，在弹出的菜单中选择 <strong>Equal Widths</strong> 约束。</p>
<p>打开右侧工具栏中的 <strong>Size Inspector</strong> 页签，双击 <strong>Equal Width to: Superview</strong> 打开该约束的属性编辑界面。如果 <strong>First Item</strong> 属性的值不是 <strong>cloud.Width</strong> ，那么点击输入框，在下拉菜单中选择 <strong>Reverse First and Second Item</strong>。然后将 <strong>Multiplier</strong> 属性的值设置为 <strong>0.45</strong>。</p>
<p>现在image view在所有的size class中显示应该都没有什么问题了。但是text container view还有点问题。你需要给它添加一个约束，让它显示在该size class屏幕的右侧。</p>
<p><code>TextContainer</code> view现在有两种约束在身。一种是内部约束，它约束了两个Label的位置，这些约束在各size class中表现的还不错。另一种是外部的约束，它们限制了text container view的左、右、底部与它容器的左、右、底部的间距。这些约束在当前的size class中表现的就不尽如人意了。如果想使text container view在当前size class中位于容器的右下角位置，你得卸载掉左侧的约束。</p>
<p>选中 <strong>Left Spacing to nearest neighbor</strong> 约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-54.png" alt="图片"></p>
<p>按 <strong>Cmd-Delete</strong> 卸载该约束，和之前一样，被卸载的约束显示为灰色。</p>
<p>现在你需要再添加两个约束将TextContainer限制在正确的位置上。一个是让text container view的宽度为它容器（view controller的view）宽度的一半。另一个是将text container view固定在顶部。</p>
<p>按理来说，你现在需要选中text container view然后按住Ctrl键和鼠标左键拖动鼠标到view controller view上，然后选择约束。但是目前的情况由于image view和text container view占满了整个view controller，所以你很难选中view controller的view。同学们可以通过<code>storyboard</code>的结构树上进行该操作，会容易很多。</p>
<p>在结构树中选中TextContainer，按住 <strong>Ctrl</strong> 键和鼠标左键，拖动鼠标到结构树的View上：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-55.png" alt="图片"></p>
<p>弹出菜单中显示了可用的约束，按住 <strong>Shift</strong> 键点击 <strong>Top Space to Top Layout Guide</strong> 和 <strong>Equal Widths</strong> 约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-56.png" alt="图片"></p>
<p>然后选中TextContainer，在 <strong>Size Inspector</strong> 中设置刚刚添加的两个约束：</p>
<ul>
<li>将 **Top Space to: Top Layout Guide ** 约束的值设置为0。</li>
<li>将 <strong>Equal Width</strong> 约束的 <strong>Multiplier</strong> 的值设置为0.5。这里要注意 <strong>First Item</strong> 和 <strong>Second Item</strong> 这两个属性的值。前者应为TextContainer view，后者为view controller view。如果不一致，那么点击任意一个输入框，选择 <strong>Reverse First and Second Item</strong>。</li>
</ul>
<p>现在点击<code>storyboard</code>界面底部的 <strong>Resolve Auto Layout Issues</strong> 按钮，然后选择 <strong>All Views\Update frames</strong> 。看看发生了什么变化呢：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-57.png" alt="图片"></p>
<p>到目前为止，我们的布局已经越来越接近完美了，唯一一点不足的就是字体大小的自适应，我们会在下一节解决它！</p>
<h2 id="u6587_u5B57_u5C5E_u6027_u7684_u81EA_u9002_u5E94"><a href="#u6587_u5B57_u5C5E_u6027_u7684_u81EA_u9002_u5E94" class="headerlink" title="文字属性的自适应"></a>文字属性的自适应</h2><p>目前TextContainer中的文字尺寸在iPad设备上，也就是使用普通（Regular）size class显示还比较正常。但是当使用紧凑（Compact）size class时文字尺寸就显得太大了，以至于都超出了视图。不过同学们不要怕，我们照样可以在不同的Size Classes中设置不同的文字尺寸来做到自适应。</p>
<blockquote>
<p>注意：与重写布局不同，在不同的size class中改变文字的属性始终会影响基础布局中的文字。它不能像布局一样，在不同的size class中设置不同的属性值。我们通过下面的方法来解决这一问题。</p>
</blockquote>
<p>回到<code>storyboard</code>文件中，将目前的size class改为最基础的 <strong>Any Width | Any Height</strong> 。</p>
<p>选择显示Cupertino的Label，打开 <strong>Attribute Inspector</strong> 。点击 <strong>Font</strong> 属性前面的 <strong>+</strong> 号：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-58.png" alt="图片"></p>
<p>弹出的菜单内容是让我们选择一种size class的组合来重写该组合下的文字属性。我们选择 <strong>Compact Width > Any Height</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-59.png" alt="图片"></p>
<p>这时就会出现另外一个文字属性下拉框，针对于我们刚才选择的 <strong>Compact Width | Any Height</strong> size class，我们将字体大小改为90：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-60.png" alt="图片"></p>
<p>再选择显示温度的Label，重复刚才的操作，选择size class组合时选择 <strong>Compact Width > Any Height</strong>。设置字体大小为150。</p>
<p>在预览区域会自动更新我们刚才的设置：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-61.png" alt="图片"></p>
<p>现在看起来稍微好一些了，但是显示 <strong>Cupertino</strong> 的Label被截掉了两头。同学们可能会继续调整字体大小使Cupertino显示完全，虽然目前看起来完美了，但是当换一个城市名称后或许又会出现刚才的问题。比如Washington, D.C这么长的名称，又比如Kleinfeltersville, PA这个更长的名称。那么我们应该如何设计呢？</p>
<p>我们的救世主 <strong>自动布局（Auto Layout）</strong> 再次出马。你只需要给显示城市名称和温度的这两个Label设置一个相对于TextContainer view的宽度约束即可。选中显示Cupertino的Label，按住 <strong>Ctrl</strong> 键和鼠标左键，拖动鼠标到TextContainer view，在弹出菜单中选择 <strong>Equal Widths</strong> 约束。对显示温度的Label做相同的操作。之后在预览界面看看发生了什么：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-62.png" alt="图片"></p>
<p>呃……貌似还是有问题，城市名显示不完全。Label中的文字长度超出了允许显示的空间。不过我们可以通过一个选项，让Label自动判断当前的空间可以显示多大的字体。</p>
<p>选择显示Cupertino的Label，然后打开 <strong>Attribute Inspector</strong>。将 <strong>AutoShrink</strong> 属性设置为 <strong>Minimum font scale</strong>，将其值设置为0.5。将 <strong>Alignment</strong> 属性设置为 <strong>Centered</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-63.png" alt="图片"></p>
<p>对显示温度的Label做相同的操作。</p>
<p>再来看看预览区域，是不是在不同尺寸的iPhone横屏、竖屏下显示都比较完美了：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-64.png" alt="图片"></p>
<p>是时候在不同的设备上编译运行我们的程序了。用设备来检验才是最保险的。iPhone下的横屏、竖屏是多么的完美：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-65.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-66.png" alt="图片"></p>
<p>同学们，至此你们已经学习到了自适应布局最基本的技能。恭喜你们！</p>
<p>原文地址：<a href="http://www.raywenderlich.com/83276/beginning-adaptive-layout-tutorial" target="_blank" rel="external">Beginning Adaptive Layout Tutorial</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/adaptive-layout-1/" itemprop="url">
                  Swift自适应布局（Adaptive Layout）教程（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-11T00:00:00+08:00" content="2014-10-11">
              2014-10-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/adaptive-layout-1/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/adaptive-layout-1/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h2 id="u901A_u7528_u7684Storyboard"><a href="#u901A_u7528_u7684Storyboard" class="headerlink" title="通用的Storyboard"></a>通用的Storyboard</h2><p>通用的<code>stroyboard</code>文件是通向自适应布局光明大道的第一步。在一个<code>storyboard</code>文件中适配iPad和iPhone的布局在iOS8中已不再是梦想。我们不必再为不同尺寸的Apple移动设备创建不同的<code>storyboard</code>文件，不用再苦逼的同步若干个<code>storyboard</code>文件中的内容。这真是一件美好的事情。</p>
<p>我们打开Xcode，新建一个项目： </p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-1.png" alt="图片"></p>
<p>选择<code>iOS\Application\Single View Application</code>创建一个单视图应用：  </p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-2.png" alt="图片"></p>
<p>设置项目名称<strong>AdaptiveWeather</strong>，语言选择<strong>Swift</strong>，设备选择<strong>Universal</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-3.png" alt="图片"></p>
<p>创建好项目后，我们在项目目录结构中可以看到只存在一个<code>storyboard</code>文件：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-4.png" alt="图片"></p>
<p><strong>Main.storyboard</strong>文件就是一个通用的<code>storyboard</code>文件，它可以适配目前所有屏幕尺寸的Apple移动设备。打开该文件，同学们会看到一个View Controller，以及一个我们不太熟悉的界面尺寸：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-5.png" alt="图片"></p>
<p>同学们不要吃惊，没错，你们看到的就是一个简单的、有点大的正方形！大伙都知道，在上一个版本的Xcode中，<code>storyboard</code>里的屏幕尺寸都对应着我们所选的目标设备的尺寸，但是这样无法让我们达到“用一个<code>storyboard</code>搞定所有设备”的宏伟目标。所以在iOS8中，Apple将<code>storyboard</code>中屏幕的尺寸进行了抽象处理，也就是说我们看到的这个正方形是一个抽象的屏幕尺寸。</p>
<p>我们接着往下走，选中<code>Main.storyboard</code>文件，然后在右侧工具栏中选择<strong>File Inspector</strong>页签，然后勾选<strong>Use Size Classes</strong>选项：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-6.png" alt="图片"></p>
<p>在新的iOS8项目中，该选项默认是勾选的。但当你使用老版本的项目创建新的<code>storyboard</code>文件时就需要你手动进行勾选了。</p>
<h3 id="u8BBE_u7F6E_u4F60_u7684Storyboard_u6587_u4EF6"><a href="#u8BBE_u7F6E_u4F60_u7684Storyboard_u6587_u4EF6" class="headerlink" title="设置你的Storyboard文件"></a>设置你的Storyboard文件</h3><p>首先，我们打开<code>Main.storyboard</code>文件，从组件库（Object Library）中选择<strong>Image View</strong>拖拽到View Controller中。选中刚刚拖入的Image View，在右侧工具栏选择<strong>Size Inspector</strong>页签，设置<strong>X</strong>坐标为150，<strong>Y</strong>坐标为20，<strong>宽</strong>为300，<strong>高</strong>为265。</p>
<p>然后再拖入一个<strong>View</strong>组件，设置<strong>X</strong>坐标为150，<strong>Y</strong>坐标为315，<strong>宽</strong>为300，<strong>高</strong>为265。</p>
<p>选择你刚才拖入的View，在右侧工具栏中选择<strong>Identity Inspector</strong>页签，在<strong>Document</strong>面板中的<strong>Label</strong>属性输入框中输入<strong>TextContainer</strong>。这个属性的作用就是给View起一个名字，方便我们辨认。这里要注意一下，<strong>Document</strong>面板有可能是隐藏的，我们需要点击它后面的 <strong>Show</strong>按钮来显示它。我们拖入的这个View最后是显示城市和温度Label的容器。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-7.png" alt="图片"></p>
<p>完成上面的设置后，同学们可能会发现刚才拖入的View貌似看不到，这是因为它的背景色和View Controller的背景色是相同的，都是白色，所以我们不太容易辨别。我们来解决这个问题，选中View Controller的View，然后在右侧工具栏中选择<strong>Attribute Inspector</strong>页签，设置背景色为 <strong>红：74，绿：171，蓝：247</strong>。然后再选择TextContainer，就是我们拖入的View，设置背景色为 <strong>红：55，绿：128，蓝：186</strong>。此时<code>Main.storyboard</code>文件中应该是这番景象：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-8.png" alt="图片"></p>
<p>到目前为止，我们在View Controller中添加了两个组件Image View和View，这也是仅有的两个组件，接下来我们就要给它们添加一些布局约束了。</p>
<h3 id="u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F"><a href="#u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F" class="headerlink" title="添加布局约束"></a>添加布局约束</h3><p>选择image view，点击底部自动布局工具栏中的<strong>Align</strong>按钮，勾选<strong>Horizontal Center in Container</strong>选项，将后面的值设置为0，点击 <strong>Add 1 Constraint</strong>按钮添加第一个约束。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-9.png" alt="图片"></p>
<p>这个约束的意思是让image view在它的容器（View Controller的View）中保持居中。</p>
<p>然后再点击底部自动布局工具栏中的<strong>Pin</strong>按钮，添加一个image view顶部与容器顶部间距的约束，我们设置为0：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-10.png" alt="图片"></p>
<p>上面这两个约束使image view处于容器居中的位置，并且它的顶部与容器顶部有一个固定的间距。现在我们需要添加image view和text container view之间的约束。同学们先选中image view，然后按住<strong>Ctrl</strong>键和鼠标左键，从image view往text container view移动鼠标：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-11.png" alt="图片"></p>
<p>松开鼠标左键后会弹出一个约束菜单，我们选择<strong>Vertical Spacing</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-12.png" alt="图片"></p>
<p>这个约束决定了image view底部和text container view顶部之间的距离。</p>
<p>现在选中image view然后点击右侧工具栏中的<strong>Size Inspector</strong>页签，同学们会发现这里在Xcode6中和之前的Xcode版本有所不同：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-13.png" alt="图片"></p>
<p>你会看到之前添加的三个布局约束，你可以在<strong>Size Inspector</strong>中很方便的修改这些布局约束。比如点击<strong>Bottom Space To: TextContainer</strong>约束后的 <strong>Edit</strong>按钮，会弹出约束属性编辑框，我们让<strong>Constant</strong>的值等于20：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-14.png" alt="图片"></p>
<p>然后点击该弹出框之外的任意地方关闭该弹出框。</p>
<p>你先已经将TextContainer view顶部与image view底部的间距调整到了20，我们还需要添加TextContainer view另外三个边的间距约束。</p>
<p>继续选择TextContainer view，点击底部的<strong>Pin</strong>按钮弹出 <strong>Add New Constraints</strong>窗口，在 <strong>Spacing to nearest neighbor</strong>面板中设置左、右、底部的约束，将值设置为0，然后点击<strong>Add 3 Constraints</strong>按钮添加约束。这里要注意的是，在设置约束时要将 <strong>Constrain to margins</strong>选项的勾去掉，这样可以避免TextContainer view产生内边距：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-15.png" alt="图片"></p>
<p>这三个约束会让TextContainer view的左、右、底部三个边与容器的左、右、底部的间距始终为0。</p>
<p>现在<strong>Main.storyboard</strong>中应该是这番景象：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-16.png" alt="图片"></p>
<p>此时同学们应该会注意到在view上有几个橘黄色的约束线，这意味着还有一些约束上的问题需要我们注意。不过在运行时<code>storyboard</code>会自动更新view的大小来满足它与容器的约束条件。我们也可以点击底部 <strong>Resolve Auto Layout Issues</strong> 按钮，在弹出框中选择 <strong>All Views in View Controller/Update Frames</strong> 来修复提示的约束问题，但是如果我们这样做，那么image view的尺寸就会压缩成零，也就是会看不到image view。</p>
<p>这是因为我们的image view还有没有任何内容，但是它有一个缺省的高和宽，并且值为0。进行自动布局的时候，如果被约束的view没有实际的高和宽，那么会依照缺省的高和宽来满足约束条件。</p>
<p>我们接着学习，在项目结构中打开 <strong>Images.xcassets</strong> ，然后点击左下角的 <strong>+</strong>号，在弹出菜单中选择 <strong>New Image Set</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-17.png" alt="图片"></p>
<p>双击左上角的 <strong>Image</strong> 标题将其改为 <strong>cloud</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-18.png" alt="图片"></p>
<p>我们刚才新建的这个image set其实就是若干图片文件的一个集合，其中的每一个图片都会对应一个特定的应用场景，也就是针对与不同分辨率的Apple移动设备。比如说，一个图片集合可能会包含针对非视网膜、视网膜、视网膜高清三种分辨率的图片。自从Xcode中的资源库与UIKit完美结合后，在代码中引入图片时我们只需要写图片的名称，程序在运行时会根据当前运行的设备自动选择对应分辨率的图片。</p>
<blockquote>
<p>注意：如果你以前使用过通过资源库管理图片，那么你可能会发现在Xcode6中会有所不同。那就是3x图片是怎么回事？</p>
<p>这个新的分片率是专为iPhone 6 Plus提供的。这意味着每一个点是由3个像素点组成，也就是说3x的图片比1x图片的像素多9倍。</p>
</blockquote>
<p>目前你的图片集合中还是空的，同学们可以在这里下载需要的图片<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/09/cloud_images.zip" target="_blank" rel="external">cloud_images.zip </a>，然后将图片拖入刚才创建的名为cloud的图片集合中，将 <strong>cloud_small.png</strong>图片拖到 <strong>1x</strong>图片区域：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-19.png" alt="图片"></p>
<p>由于我们的图片背景颜色是透明的，所以在图片集合中看到的都是白色的图片。你可以选中某一个图片，然后按下空格键来预览图片。比如选中 <strong>1x</strong> 图片，按下空格：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-20.png" alt="图片"></p>
<p>现在将 <strong>cloud_small@2x.png</strong> 图片拖至 <strong>2x</strong> 图片区域，将 <strong>cloud_small@3x.png</strong> 图片拖至 <strong>3x</strong> 图片区域。和之前情况一样，我们看到的只是白色的图片，但我们可以通过空格键来预览图片集合中的图片。</p>
<p>现在你就可以在image view中设置图片了。我们回到 <strong>Main.storyboard</strong> 中，选中image view，在右侧工具栏中选择 <strong>Attribute Inspector</strong> 页签，将 <strong>Image View</strong> 面板中的 <strong>Image</strong> 属性设置为 <strong>cloud</strong>，然后将 <strong>View</strong> 面板中的 <strong>Mode</strong> 属性设置为 <strong>Aspect Fit</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-21.png" alt="图片"></p>
<p>现在你的<strong>Main.storyboard</strong>中应该是这番景象：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-22.png" alt="图片"></p>
<p>我们看到<code>storyboard</code>中一直有橘黄色的约束提示，是时候让我们来修复它们了。首先选中view controller的view：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-23.png" alt="图片"></p>
<p>然后点击底部的 <strong>Resolve Auto Layout Issues</strong> 按钮，在弹出菜单的 <strong>All Views in View Controller</strong> 面板中选择 <strong>Update Frames</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-24.png" alt="图片"></p>
<p>这时，<code>storyboard</code>会自动根据约束条件重新计算view的大小以满足约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-25.png" alt="图片"></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h3 id="u9884_u89C8_u52A9_u624B_u7F16_u8F91_u5668_uFF08Preview_Assistant_Editor_uFF09"><a href="#u9884_u89C8_u52A9_u624B_u7F16_u8F91_u5668_uFF08Preview_Assistant_Editor_uFF09" class="headerlink" title="预览助手编辑器（Preview Assistant Editor）"></a>预览助手编辑器（Preview Assistant Editor）</h3><p>一般情况下，在这个时候我们应该会在iPad、iPhone4s、iPhone5s、iPhone6、iPhone6 Plus这几个不同尺寸的设备上编译运行程序，以便测试通用的<code>storyboard</code>是否能在不同尺寸的设备上正确的自适应。但这确实是个体力活，一遍一遍的更改设备、编译、运行，多么苦逼。但上天总是会眷顾我们这些苦逼的程序员，Xcode6提供了Preview Assistant Editor，能在一个界面上显示出不同尺寸设备的程序运行情况，是否有问题一目了然。</p>
<p>我们打开 <strong>Main.storyboard</strong> ，然后选择 <strong>View\Assistant Editor\Show Assistant Editor</strong> ，这时编辑区会分隔为两部分。再点击顶部导航栏中的 <strong>Automatic</strong> ，在弹出菜单中选择 <strong>Preview</strong> ，最后选择 <strong>Main.storyboard (Preview)</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-26.png" alt="图片"></p>
<p>现在在 <strong>Assistant Editor</strong> 区域会显示一个4寸的界面：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-27.png" alt="图片"></p>
<p>我们还可以点击预览界面底部，名字（比如图中的iPhone 4-inch）旁边的地方让屏幕翻转为横屏：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-28.png" alt="图片"></p>
<p>这无疑是针对检查不同尺寸设备的自适应情况的一项重大改进，但还远远不止于此！点击预览界面左下角的 <strong>+</strong> 按钮，会弹出当前<code>storyboard</code>文件支持的各种尺寸的设备，可供我们预览：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-29.png" alt="图片"></p>
<p>分别选择iPhone 5.5-inch和iPad，此时我们在预览界面就可以同时显示三种尺寸的屏幕：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-30.png" alt="图片"></p>
<p>此时同学们是否注意到4寸的横屏显示有点别扭呢？没错，它的那朵元太大了，我们可以通过对image view添加其他的约束条件来改善这个问题。</p>
<p>回到 <strong>Main.storyboard</strong> ，选择image view，然后按住 <strong>Ctrl</strong>建和鼠标左键，拖动鼠标到View Controller的View上，松开鼠标后会弹出一个菜单，我们选择 <strong>Equal Heights</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-31.png" alt="图片"></p>
<p>这时会出现一些红色的约束提示，这是因为我们刚才加的这个约束条件与之前加过的约束条件有冲突。因为之前我们添加过image view和TextContainer view之间的垂直间距（Vertical Margins）约束，所以image view的高度不可能等于它容器（View Controller的View）的高度。</p>
<p>让我们来修复该问题，首先在<code>storyboard</code>的结构目录中选择我们刚才添加的 <strong>Equal Heights</strong> 约束，然后选择右侧工具栏中的 <strong>Attribute Inspect</strong> 页签，如果 <strong>First Item</strong> 属性不是 <strong>cloud.Height</strong> ，那么在下拉菜单中选择 <strong>Reverse First and Second Item</strong> 这一项让 <strong>First Item</strong> 的值成为 <strong>cloud.Height</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-32.png" alt="图片"></p>
<p>接下来将 <strong>Relation</strong> 属性的值设置为 <strong>Less Than or Equal</strong> ，将 <strong>Multiplier</strong> 的值设置为 <strong>0.4</strong> ：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-33.png" alt="图片"></p>
<p>这一系列设置的作用是让cloud这张图片的高度要么等于它自身的高度，要么等于屏幕高度的40%，最后呈现的效果选择这两者中较小的一个高度。</p>
<p>现在你应该注意到了在预览面板中，4寸的横屏显示即时的对你刚才的约束改动做出了响应：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-34.png" alt="图片"></p>
<p>你看看其他尺寸的预览自动更新了么？答案那是必须的，所以说 <strong>Preview Assistant Editor</strong> 确实是一项重大改进，是程序员和设计人员的福音！</p>
<p>由于本文的示例是一个天气应用，所以光有天气图标不行，我们还得加上城市和温度才行。</p>
<p>未完待续……</p>
<p>原文地址：<a href="http://www.raywenderlich.com/83276/beginning-adaptive-layout-tutorial" target="_blank" rel="external">Beginning Adaptive Layout Tutorial</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/tuple-in-swift/" itemprop="url">
                  Swift中的元组（Tuples）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-08T00:00:00+08:00" content="2014-10-08">
              2014-10-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/tuple-in-swift/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/tuple-in-swift/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u521B_u5EFA_u5143_u7EC4"><a href="#u521B_u5EFA_u5143_u7EC4" class="headerlink" title="创建元组"></a>创建元组</h2><p>在Swift中创建元组的方式很简单，它的语法有点类似数组，但是需要把方括号替换为圆括号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstHighScore = (<span class="string">"Mary"</span>, <span class="number">9001</span>)</span><br></pre></td></tr></table></figure>
<p>与数组不同的是，元组中的元素可以是任意类型。上面代码中<code>firstHighScore</code>元组就包含一个<code>String</code>类型的元素和一个<code>Int</code>类型的元素。</p>
<p>另外，在创建元组时你还可以给元组中的元素命名：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> secondHighScore = (name: <span class="string">"James"</span>, score: <span class="number">4096</span>)</span><br></pre></td></tr></table></figure>
<p>这样可以让我们在使用元组的时候明确的指定某个元素，非常有用。在后面的文章中大家可以看到给元素命名的好处。</p>
<p>以上就是创建元组的两种方式，非常简单和简洁。你不需要像创建<code>struct</code>一样写出它的结构和内部属性，也不需要像创建<code>class</code>一样要写初始化方法。你只需要把你想用的、任何类型的值放在圆括号内，用逗号隔开即可。如果你愿意你还可以给每个元素命名，提高元组使用效率。</p>
<h2 id="u4ECE_u5143_u7EC4_u4E2D_u8BFB_u5143_u7D20"><a href="#u4ECE_u5143_u7EC4_u4E2D_u8BFB_u5143_u7D20" class="headerlink" title="从元组中读元素"></a>从元组中读元素</h2><p>从元组中读取元素有几种方式，但一般我们会选择最适合当前应用场景的方式，并且确保选择的方式是在当前情况下最简单的一种。</p>
<h3 id="u5143_u7EC4_u5143_u7D20_u6CA1_u6709_u547D_u540D"><a href="#u5143_u7EC4_u5143_u7D20_u6CA1_u6709_u547D_u540D" class="headerlink" title="元组元素没有命名"></a>元组元素没有命名</h3><p>如果我们没有给元组的元素命名，我们可以用点语法，通过定义好的元组变量或常量获取它的第1个到第n个元素：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstHighScore = (<span class="string">"Mary"</span>, <span class="number">9001</span>)</span><br><span class="line">firstHighScore.<span class="number">0</span>            <span class="comment">// Mary</span></span><br><span class="line">firstHighScore.<span class="number">1</span>        <span class="comment">// 9001</span></span><br></pre></td></tr></table></figure>
<p>如果你觉得上述这种方法会造成语义的不明确，那么我们还可以将元组赋值给一个带有元素名称的元组（元素名称个数要对应）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> (firstName, firstScore) = firstHighScore</span><br><span class="line">firstName       <span class="comment">// Mary</span></span><br><span class="line">firstScore      <span class="comment">// 9001</span></span><br></pre></td></tr></table></figure>
<p>如果你只想读取<code>firstHighScore</code>元组中的分数，那么你可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> (<span class="number">_</span>, firstScore) = firstHighScore</span><br><span class="line">firstScore      <span class="comment">// 9001</span></span><br></pre></td></tr></table></figure>
<h3 id="u5143_u7EC4_u5143_u7D20_u6709_u547D_u540D"><a href="#u5143_u7EC4_u5143_u7D20_u6709_u547D_u540D" class="headerlink" title="元组元素有命名"></a>元组元素有命名</h3><p>如果我们已经给元组中的元素命名了名称，那么我们可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> secondName = secondHighScore.name</span><br><span class="line"><span class="keyword">let</span> secondScore = secondHighScore.score</span><br><span class="line">secondName      <span class="comment">// James</span></span><br><span class="line">secondScore     <span class="comment">// 4096</span></span><br></pre></td></tr></table></figure>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u5C06_u5143_u7EC4_u4F5C_u4E3A_u51FD_u6570_u8FD4_u56DE_u503C"><a href="#u5C06_u5143_u7EC4_u4F5C_u4E3A_u51FD_u6570_u8FD4_u56DE_u503C" class="headerlink" title="将元组作为函数返回值"></a>将元组作为函数返回值</h2><p>我们可以将元组作为函数的返回值，下面这个函数的返回值就是我们之前定义过的<code>secondHighScore</code>元组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getAHighScore</span><span class="params">()</span></span> -&gt; (name: <span class="type">String</span>, score: <span class="type">Int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> theName = <span class="string">"Patricia"</span></span><br><span class="line">    <span class="keyword">let</span> theScore = <span class="number">3894</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (theName, theScore)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么说上述函数的返回值是<code>secondHighScore</code>元组呢？因为<code>getAHighScore</code>函数返回的元组元素个数、元素名称、元素类型均和<code>secondHighScore</code>相同。</p>
<p>其实将元组作为函数的返回值时也可以不必对元素进行命名，只要你明白每个元素代表的含义即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getAHighScore</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>, <span class="type">Int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> theName = <span class="string">"Patricia"</span></span><br><span class="line">    <span class="keyword">let</span> theScore = <span class="number">3894</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (theName, theScore)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不确定返回的元组一定不为<code>nil</code>，那么你可以返回一个可选的元组类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">maybeGetHighScore</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>, <span class="type">Int</span>)?</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是可选的元组类型，所以当返回的元组不为<code>nil</code>时，你需要对元组进行解包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> possibleScore = maybeGetHighScore()</span><br><span class="line">&#123;</span><br><span class="line">    possibleScore.<span class="number">0</span></span><br><span class="line">    possibleScore.<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"Nothing Here"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：当你定义了一个没有返回值的函数时，其实该函数是返回一个空的元组<code>()</code>。</p>
</blockquote>
<h2 id="u5143_u7EC4_u7684_u8BBF_u95EE_u7EA7_u522B"><a href="#u5143_u7EC4_u7684_u8BBF_u95EE_u7EA7_u522B" class="headerlink" title="元组的访问级别"></a>元组的访问级别</h2><p>元组的访问级别取决于它包含的元素。比如元组里的元素都是<code>private</code>级别的，那么该元组也是<code>private</code>级别的。但这里有一个遵循最小的原则，也就是说如果一个元组中有两个元素，一个为<code>private</code>级别，另一个为<code>public</code>级别，那么该元组遵循最小原则，它的访问级别为<code>private</code>。</p>
<h2 id="u5143_u7EC4_u662F_u503C_u7C7B_u578B"><a href="#u5143_u7EC4_u662F_u503C_u7C7B_u578B" class="headerlink" title="元组是值类型"></a>元组是值类型</h2><p>关于值类型和引用类型的知识这里不再累赘，我们通过一个代码示例来看看元组是哪种类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> someScore = (<span class="string">"John"</span>, <span class="number">55</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> anotherScore = someScore</span><br><span class="line">anotherScore.<span class="number">0</span> = <span class="string">"Robert"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">println</span>(anotherScore.<span class="number">0</span>)  <span class="comment">//Outputs:  "Robert"</span></span><br><span class="line"><span class="built_in">println</span>(someScore.<span class="number">0</span>)     <span class="comment">//Outputs:  "John"</span></span><br></pre></td></tr></table></figure>
<p>通过上述的代码示例可以看出，我把<code>someScore</code>元组赋值给了<code>anotherScore</code>，然后修改了<code>anotherScore</code>的第1个元素的值，最后分别打印了<code>someScore</code>和<code>anotherScore</code>第1个元素的值。<code>someScore</code>元组第一个元素的值为<code>Robert</code>，而<code>anotherScore</code>元组第一个元素的值仍然为<code>John</code>。由此可见元组是值类型。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/how-to-create-action-extension/" itemprop="url">
                  如何在Swift中创建Action扩展
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-09-22T00:00:00+08:00" content="2014-09-22">
              2014-09-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/how-to-create-action-extension/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/how-to-create-action-extension/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>我们先想象一下，我们已经有一个很牛逼的应用了，我们姑且叫做重要信息记事本。它的功能就是将我们认为是重要的信息记录下，便于我们随时查看。那么何为重要信息呢？重要信息可以是很多类型的信息，比如武功秘籍、食谱、生日、一段牛逼的代码等等。当我们已经有了这样一个应用后，接下来应该考虑的事情就是如何记录重要信息了。通常思维下，你们可能认为应该是先打开这个应用，然后将重要信息敲进去。是这样么？你当用户是傻子么，什么年代了还手敲，简直弱爆了。下面我向你们介绍一个很酷的方法，那就是通过Action扩展，将信息记录到我们的应用中。下面例子的主要功能是将Safari浏览的网页中的信息保存在我们应用中。</p>
<h2 id="u89C1_u8BC1_u5947_u8FF9_u7684_u65F6_u523B"><a href="#u89C1_u8BC1_u5947_u8FF9_u7684_u65F6_u523B" class="headerlink" title="见证奇迹的时刻"></a>见证奇迹的时刻</h2><p>先通过<em>File > New > Project</em>菜单创建一个新的工程，选择<strong>Single View Application</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension1.png" alt="图片"></p>
<p>然后通过<em>File > New > Target</em>菜单给给工程添加一个<strong>Target</strong>，选择<strong>Action Extension</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension2.png" alt="图片"></p>
<p>在创建Action扩展时需要指定一个Aciton类型，Apple提供了两种Action扩展的类型模板。一种是有用户界面的类型，包含一个<code>UIViewController</code>和一个<code>Storeboard</code>文件，可以自定义显示界面和行为。另一种是不带用户界面的类型，这种类型只允许我们处理来自Host应用的请求。</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension3.png" alt="图片"></p>
<p>现在我们在工程中就可以看到刚才创建的Action扩展<strong>NoteAppExtension</strong>，它包含两个主要的文件，一个是<code>Action.js</code>，另一个是<code>ActionRequestHandler.swift</code>：</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension4.png" alt="图片"></p>
<p>我们来看看这两个文件的作用。<code>Action.js</code>文件用来实现和处理浏览器中请求的逻辑，在本文的例子中，它主要实现用户在浏览器中选中文本并发送到我们的应用中。<code>ActionRequestHandler.swift</code>用来处理Host应用发送的请求和参数。</p>
<p>在实现逻辑之前我们需要设置一下扩展的属性，打开<code>Info.plist</code>文件将<code>NSExtensionActivationSupportsWebURLWithMaxCount</code>属性设置为1，该设置让扩展知道我们需要请求一个URL。</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension5.png" alt="图片"></p>
<p>我们<code>Action.js</code>文件中有如下内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Action</span> = function() &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">Action</span>.prototype = &#123;</span><br><span class="line">    </span><br><span class="line">    run: function(arguments) &#123;</span><br><span class="line">        <span class="comment">// 在这个方法里，你可以通过document操作HTML中的元素，或者可以将HTML中的内容传给ActionRequestHandler文件的代码。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在本文的例子中，我们不做任何更新，只是将HTML中选中的内容穿给ActionRequestHandler文件的代码。</span></span><br><span class="line">        <span class="keyword">var</span> selected = <span class="string">"No Text Selected"</span>;</span><br><span class="line">        <span class="keyword">if</span> (window.getSelection) &#123;</span><br><span class="line">            selected = window.getSelection().getRangeAt(<span class="number">0</span>).<span class="built_in">toString</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            selected = document.getSelection().getRangeAt(<span class="number">0</span>).<span class="built_in">toString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        arguments.completionFunction(&#123;<span class="string">"args"</span> : selected&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    finalize: function(arguments) &#123;</span><br><span class="line">        <span class="comment">// 当ActionRequestHandler文件中的itemLoadCompletedWithPreprocessingResults方法执行完之后会调用该方法。</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果ActionRequestHandler文件向HTML返回了信息，我们可以通过arguments["message"]来查看，并且可以根据该信息操作HTML中的元素。</span></span><br><span class="line">        alert(arguments[<span class="string">"message"</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> <span class="type">ExtensionPreprocessingJS</span> = new <span class="type">Action</span></span><br></pre></td></tr></table></figure>
<p>Safari与Action扩展的交互就是通过<code>Action.js</code>文件中的<code>run</code>和<code>finalize</code>这两个方法实现的。当我们在Safari中使用Action扩展时就会调用<code>run</code>方法，它能让我们在该方法中操作当前Safari显示页面的DOM元素。当Action扩展处理完逻辑向Safari返回信息时会调用<code>finalize</code>方法，在我们的例子中，我们通过<code>self.extensionContext!.completeRequestReturningItems(nil, completionHandler: nil)</code>这段代码向Safari返回信息。该方法的第一个参数就是要返回的信息，它会将信息传给<code>Action.js</code>文件，然后通过js代码操作HTML。如果第一个参数传入<code>nil</code>，那就意味着不会调用<code>Action.js</code>文件中的<code>finalize</code>方法。<code>run</code>和<code>finalize</code>这两个方法的参数<code>arguments</code>都包含着一些信息，只不过一个是来自与HTML，一个来自<code>ActionRequestHandler</code>文件。</p>
<p><strong>一定要记住：</strong>我们必须要实例化<code>ExtensionPreprocessingJS</code>这个全局变量，因为它是Safari和Action扩展之间的桥梁。</p>
<p>我们的<code>ActionRequestHandler</code>文件内容如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionRequestHandler</span>: <span class="title">NSObject</span>, <span class="title">NSExtensionRequestHandling</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> extensionContext: <span class="type">NSExtensionContext</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">beginRequestWithExtensionContext</span><span class="params">(context: NSExtensionContext!)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.extensionContext = context</span><br><span class="line">        <span class="keyword">let</span> identifierType = <span class="type">NSString</span>(format: kUTTypePropertyList, <span class="type">NSUTF8StringEncoding</span>)</span><br><span class="line">        <span class="keyword">for</span> (item: <span class="type">NSExtensionItem</span>) <span class="keyword">in</span> context.inputItems <span class="keyword">as</span> [<span class="type">NSExtensionItem</span>] &#123;</span><br><span class="line">            <span class="keyword">for</span> (itemProvider: <span class="type">NSItemProvider</span>) <span class="keyword">in</span> item.attachments <span class="keyword">as</span> [<span class="type">NSItemProvider</span>] &#123;</span><br><span class="line">                <span class="keyword">if</span> itemProvider.hasItemConformingToTypeIdentifier(identifierType) &#123;</span><br><span class="line">                    itemProvider.loadItemForTypeIdentifier(identifierType, options: <span class="literal">nil</span>, completionHandler: &#123;(item, error) <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">let</span> dictionary = item <span class="keyword">as</span> <span class="type">NSDictionary</span></span><br><span class="line">                        dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">                            <span class="keyword">self</span>.itemLoadCompletedWithPreprocessingResults(dictionary[<span class="type">NSExtensionJavaScriptPreprocessingResultsKey</span>] <span class="keyword">as</span> <span class="type">NSDictionary</span>)</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">itemLoadCompletedWithPreprocessingResults</span><span class="params">(javaScriptPreprocessingResults: NSDictionary)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text = javaScriptPreprocessingResults[<span class="string">"args"</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> userDefaults = <span class="type">NSUserDefaults</span>(suiteName: <span class="string">"group.name"</span>)</span><br><span class="line">            userDefaults.setValue(text, forKey: <span class="string">"note"</span>)</span><br><span class="line">            userDefaults.synchronize()</span><br><span class="line">            <span class="keyword">self</span>.doneWithResults([<span class="string">"message"</span>: <span class="string">"Successfully added to the note app"</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">doneWithResults</span><span class="params">(resultsForJavaScriptFinalizeArg: NSDictionary?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> resultsForJavaScriptFinalize = resultsForJavaScriptFinalizeArg &#123;</span><br><span class="line">            <span class="keyword">let</span> identifierType = <span class="type">NSString</span>(format: kUTTypePropertyList, <span class="type">NSUTF8StringEncoding</span>)</span><br><span class="line">            <span class="comment">// 创建合适返回类型的标示符。            </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里创建的resultsItem将作为Action.js文件中finalize方法的参数。</span></span><br><span class="line">            <span class="keyword">var</span> resultsDictionary = [<span class="type">NSExtensionJavaScriptFinalizeArgumentKey</span>: resultsForJavaScriptFinalize]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> resultsProvider = <span class="type">NSItemProvider</span>(item: resultsDictionary, typeIdentifier: identifierType)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> resultsItem = <span class="type">NSExtensionItem</span>()</span><br><span class="line">            resultsItem.attachments = [resultsProvider]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这段代码意味着Action扩展已经处理完了逻辑，现在将信息返回给Action.js文件。</span></span><br><span class="line">            <span class="keyword">self</span>.extensionContext!.completeRequestReturningItems([resultsItem], completionHandler: <span class="literal">nil</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 就算我们没有任何要返回的信息，也要执行这段代码，用于告知我们的Action扩展已经完成了逻辑处理。</span></span><br><span class="line">            <span class="keyword">self</span>.extensionContext!.completeRequestReturningItems(<span class="literal">nil</span>, completionHandler: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.extensionContext = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以运行一下我们的应用，然后打开Safari，在Action选项中开启我们的Action扩展：</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension6.png" alt="图片"></p>
<p>然后我们就可以在Action栏中看到我们的扩展了：</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension7.png" alt="图片"></p>
<p>我们使用Safari随便打开一个含有文字的页面，选中一段文字，然后打开Action栏，点击<strong>NoteApp</strong>扩展，此时我们的扩展就会将选中的这段文字发送给我们的应用，形成一条新的重要信息。</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension8.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension9.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension10.png" alt="图片"></p>
<p>以上只是一个简单的Aciton扩展的例子，但我们可以由此延伸出更多有用、有创意的功能，让我们的生活更加美好。</p>
<p>本文例子的代码可以在这里下载：<a href="https://github.com/jorjuela33/NoteApp" target="_blank" rel="external">NoteApp</a></p>
<p>原文地址：<a href="http://nsnerd.co/action-extension-in-swift/" target="_blank" rel="external">Action Extension in Swift</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/ios8-day-by-day-day2-sharing-extension/" itemprop="url">
                  iOS8 Day-by-Day-- Day2 -- 分享应用扩展
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-09-17T00:00:00+08:00" content="2014-09-17">
              2014-09-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分類於
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/ios8-day-by-day-day2-sharing-extension/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/ios8-day-by-day-day2-sharing-extension/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u5F00_u573A_u767D"><a href="#u5F00_u573A_u767D" class="headerlink" title="开场白"></a>开场白</h2><p>在iOS8中，有一个重量级的特性，那就是应用扩展。不论是第三方的应用还是Apple自家的应用，开发者们都可以根据这些应用自身的特点通过应用扩展提升应用与系统之间的交互性、应用的用户体验等等。目前在iOS中提供6种应用场景的扩展：</p>
<ul>
<li>通知界面widget</li>
<li>分享扩展</li>
<li>Action</li>
<li>照片编辑扩展</li>
<li>资源存储扩展</li>
<li>自定义键盘</li>
</ul>
<p>我们在今后的文章中都会介绍以上这些场景的应用扩展，但今天我们的主角是分享扩展。</p>
<p>关于分享其实我们都不陌生，比如我们打开一个应用，在某个内容页会有系统提供的分享按钮，点击该按钮后会出现一个应用图标列表（比如Twitter，Flickr，新浪微博等），意在让我们选择一个希望分享内容的应用。分享扩展就是能让我们可以增加这个列表，让我们自己的应用图标能出现在分享列表里。</p>
<p>这里需要注意的是，这篇文章的内容有一定的难度，Apple提供的应用扩展特性还是比较复杂的。本文会列举最常用的使用场景作为示例来讲解分享扩展，当然你也可以在我们提供的示例基础上设计属于你自己的应用界面风格。Apple在应用扩展方面提供了非常详尽的文档，如果你在学习这篇文章的过程中有不懂的地方，你可以参阅Apple官方文档。</p>
<p>本文的示例应用名为“ShareAlike”，我们会通过该示例应用向大家展示如何实现图片、文本信息的分享。该示例的代码可以在<a href="https://github.com/ShinobiControls/iOS8-day-by-day" target="_blank" rel="external">Github</a>中下载。</p>
<h2 id="u521B_u5EFA_u4E00_u4E2A_u5206_u4EAB_u6269_u5C55"><a href="#u521B_u5EFA_u4E00_u4E2A_u5206_u4EAB_u6269_u5C55" class="headerlink" title="创建一个分享扩展"></a>创建一个分享扩展</h2><p>首先我们要清楚，应用扩展不能单独存在，它必须要依附一个应用程序，我们称之为应用扩展的载体应用。应用扩展以二进制文件形式存在于载体应用中。Xcode为每一种应用扩展都提供了一个模板，但是我们必须通过给一个应用程序添加Target的方式创建应用扩展的模板，创建好模板后，会在工程中增加一个应用扩展模块以及必要的属性文件。</p>
<p>我们执行一个分享操作主要是通过一系列界面来完成，所以分享扩展的主要部分就是UI展现。因此我们可以看到分享扩展模板为我们提供了一个继承了<code>SLComposeServiceViewController</code>的类以及一个<code>storyboard</code>文件。<code>SLComposeServiceViewController</code>为我们提供了一些常规的行为（包括字数、图片展示、文本输入、发送和取消按钮），并且这些行为对应的界面都符合iOS UI的标准。在本文的示例中我们基本都会用到这些默认的行为。</p>
<p>除了<code>UIViewController</code>的标准方法外，<code>SLComposeServiceViewController</code>还提供了一些与分享功能生命周期相关的属性和方法：</p>
<ul>
<li><code>presentationAnimationDidFinish()</code>方法可以让我们执行大数据量的分享任务，我们在分享图片时会用到它。</li>
<li><code>contentText</code>是一个<code>String</code>类型的属性，它存储分享者编辑的一些文字描述。</li>
<li><code>didSelectPost()</code>函数在点击<strong>Post</strong>按钮时调用。它是上传分享数据的入口。</li>
<li><code>didSelectCancel()</code>函数在点击<strong>Cancel</strong>按钮时调用。</li>
<li><code>isContentValid()</code>函数在分享者编辑的文字有变化时调用。</li>
<li><code>charactersRemaining</code>是一个<code>Int</code>类型的属性，当描述内容有字数限制时，它表示当前还能编写的字数，如果超出字数，该属性展示的字数会变红，并用负数表示已经超出了多少字数。</li>
</ul>
<p>只要你的应用工程里添加了分享扩展，那么用户就能很轻松的将选中的内容分享到你的应用中。我们会一步一步展示如何实现这些有用的功能，但首先我们要学习如何编译、运行和调试。</p>
<h2 id="u7F16_u8BD1_uFF0C_u8FD0_u884C_u548C_u8C03_u8BD5"><a href="#u7F16_u8BD1_uFF0C_u8FD0_u884C_u548C_u8C03_u8BD5" class="headerlink" title="编译，运行和调试"></a>编译，运行和调试</h2><p>在添加一个扩展Target时，Xcode会让你激活扩展的Scheme。在运行工程之前，如果我们选择app的Scheme，那么会直接运行app，如果选择扩展的Scheme，那么会出现让你选择在哪个应用程序中运行该扩展，也就是选择一个扩展的Host应用，然后就可以针对扩展进行调试了。通常情况下运行分享扩展最好的Host应用是照片应用（Photos），所以我们一般都选择照片应用，然后调试分享扩展。</p>
<p>下面有几个步骤能帮助我们熟悉这个过程：</p>
<ul>
<li>不管是选择一个扩展的Host应用还是使用扩展的载体应用充当Host应用，它们都应该有比较容易能分享的内容。在示例项目中，<strong>ShareAlike</strong>扩展使用它的载体应用充当Host应用，载体应用包含一张图片和一个分享按钮，点击分享按钮时会弹出标准的分享内容界面：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">handleShareSampleTapped</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">  shareContent(sharingText: <span class="string">"Highland Cow"</span>,</span><br><span class="line">                       sharingImage: sharingContentImageView.image)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Utility methods</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">shareContent</span><span class="params">(#sharingText: String?, sharingImage: UIImage?)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> itemsToShare = [<span class="type">AnyObject</span>]()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> text = sharingText &#123;</span><br><span class="line">    itemsToShare.append(text)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> image = sharingImage &#123;</span><br><span class="line">    itemsToShare.append(image)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> activityViewController = <span class="type">UIActivityViewController</span>(activityItems: itemsToShare, applicationActivities: <span class="literal">nil</span>)</span><br><span class="line">  presentViewController(activityViewController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension1.png" alt="图片">  </p>
<ul>
<li>在扩展中编写相关代码。</li>
<li>调试或测试时，选择载体应用的Scheme编译并运行，当点击Share Sample时，调试器会自动关联到扩展的进程上，简言之也就是可以捕获到你在分享扩展代码中设置的断点。</li>
<li>你也可以选择模拟器中的其他应用作为Host应用来使用分享扩展。但是调试器不会捕获到你设置的断点，也就是无法进行调试。你可以使用这种方式来测试扩展的运行情况，通常分享扩展最佳的Host应用是Photos。</li>
</ul>
<h2 id="u5206_u4EAB_u6269_u5C55_u7684_u5206_u4EAB_u5185_u5BB9_u5C5E_u6027_u8BBE_u7F6E"><a href="#u5206_u4EAB_u6269_u5C55_u7684_u5206_u4EAB_u5185_u5BB9_u5C5E_u6027_u8BBE_u7F6E" class="headerlink" title="分享扩展的分享内容属性设置"></a>分享扩展的分享内容属性设置</h2><p>与在<strong>Info.plist</strong>文件中设置应用一样，在扩展中也有这个文件。在该文件中有一个属性代表在分享应用列表中，我们扩展的显示名称（分享应用列表中图标下的文字）。</p>
<p>这个属性是<strong>Bundle display name</strong>（<code>CFBundleDisplayName</code>）：</p>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension2.png" alt="图片"></p>
<p>你还可以在<strong>Info.plist</strong>文件中定义你的分享扩展可以处理什么样的分享任务，比如说是否可以处理分享视频？</p>
<p>在该文件中有一个名为<code>NSExtension</code>字典类型属性，展开该属性后，可以看到<code>NSExtensionAttributes</code>属性，同样是字典类型，再展开该属性我们可以看到<code>NSExtenionActivationRule</code>属性，依然是字典类型的属性。可以看到<code>NSExtension</code>中有<code>Boolean</code>类型的、<code>String</code>类型的、<code>Number</code>类型的或者字典类型的各种属性。在<code>NSExtenionActivationRule</code>属性中就有设置分享图片数量，分享视频、文件、URL数量的属性：</p>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension3.png" alt="图片"></p>
<p>每一个属性表示的意思从字面上就可以理解，比如<code>NSExtensionActivationSupportsImageWithMaxCount</code>，类型为<code>Number</code>，值为1。意思就是我们的分享扩展支持的最大分享图片数为1，我们可以测试一下看看：</p>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension4.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension5.png" alt="图片"></p>
<p>从上图中可以看到，当我们选择了一张照片时，在分享应用列表中有我们的ShareAlike，如果选择了两张照片，分享应用列表中就没有我们的扩展了。</p>
<h2 id="u9A8C_u8BC1_u7528_u6237_u8F93_u5165_u7684_u5185_u5BB9"><a href="#u9A8C_u8BC1_u7528_u6237_u8F93_u5165_u7684_u5185_u5BB9" class="headerlink" title="验证用户输入的内容"></a>验证用户输入的内容</h2><p>到目前为止，你大概已经知道如何创建一个扩展并设置它的相关属性了，现在让我们看看如何实现一些自定义的扩展行为。首先，我们要知道如何验证用户的输入内容。比如我们通常情况下都需要的一个验证，就是限制用户输入的文字数量，我们可以通过<code>SLComposeServiceViewController</code>来实现它。</p>
<p>在之前我们提到过<code>SLComposeServiceViewController</code>类的一些属性方法，其中有一个方法叫<code>isContentValid() -&gt; Bool</code>。该方法的作用时随时监听着分享界面文本域的变化，也就是说一旦用户输入或删除文字，都会触发该方法。该方法如果返回<code>true</code>，那说明用户输入的内容合法，并可以使用<strong>Post</strong>按钮完成分享，如果返回<code>false</code>，那说明输入内容不合法，并且不能使用<strong>Post</strong>按钮。下面的代码片段展示了如何实现文字数量限制功能：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> sc_maxCharactersAllowed = <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">isContentValid</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> currentMessage = contentText &#123;</span><br><span class="line">    <span class="keyword">let</span> currentMessageLength = <span class="built_in">countElements</span>(currentMessage)</span><br><span class="line">    charactersRemaining = sc_maxCharactersAllowed - currentMessageLength</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="type">Int</span>(charactersRemaining) &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>contentText</code>是<code>SLComposeServiceViewController</code>中的属性，类型为<code>String!</code>，它存储着分享界面中<code>TextView</code>中的文本信息。<code>charactersRemaining</code>也是<code>SLComposeServiceViewController</code>中的属性，类型为<code>NSNumber</code>，他表示还有多少合法的字数以及超出的字数，并显示在分享界面的左下角。你可以用<code>countElements()</code>方法获取输入文本的字数，用于计算<code>charactersRemaining</code>的值并判断是否超出了限定的最大字数。至于<strong>Post</strong>按钮的可用和禁用由<code>charactersRemaining</code>决定，不需要我们额外设置。</p>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension6.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension7.png" alt="图片"></p>
<h2 id="u4E0A_u4F20_u5206_u4EAB_u5185_u5BB9"><a href="#u4E0A_u4F20_u5206_u4EAB_u5185_u5BB9" class="headerlink" title="上传分享内容"></a>上传分享内容</h2><p>到目前为止，我们已经知道了如何创建一个应用扩展、如何对应用扩展进行配置、如何控制用户的操作行为等。但是作为分享扩展，它的遵旨应该是将文本、图片、视频等资源上传至某个网络客户端（比如FaceBook、Twitter、新浪微博等）。下面就让我们看看应该如何做吧。</p>
<p>应用扩展相比载体应用或者Host应用来说，它是一个轻量级的、处理单一功能任务的组件，所以用户一般不会因为使用扩展而停止当前使用的应用或关闭正在看的内容。你可以试想一下，如果一个Host应用使用某个应用扩展让它处理一个简单的任务时，该扩展因为同时占用了Host应用的运行内存从而使Host应用不可用、退出以至于崩溃，这是多么令人发指的事情。因此，所有的上传操作都应该在后台执行（iOS7中<code>NSURLSession</code>类对实现该功能很有帮助）。你可能会认为跟着去年<a href="https://leanpub.com/ios7daybyday" target="_blank" rel="external">iOS7 Day-by-Day</a>系列文章就能很容易的实现该功能，但事实并非如此。</p>
<p>事情往往不是你想象的那么简单。首先提取分享的内容就不是一件容易的事（比如图片），而且你还要将它们分享出去，其次应用扩展没有任何写硬盘的权限。关于第二点，有人可能会有疑问：为什么应用扩展需要写硬盘的权限呢？因为所有后台上传的网络程序，在上传时都会先将上传内容缓存在硬盘中，然后从硬盘获取缓存的内容开始上传。为了能模拟硬盘缓存，我们需要在Host应用中创建一个存放分享内容的容器，并且要允许应用扩展使用该容器缓存分享内容。我们会在下面的内容中讲解如何实现该功能，但首先，我们先来看看如何提出分享内容中的图片。</p>
<h2 id="u63D0_u53D6_u8981_u5206_u4EAB_u7684_u56FE_u7247"><a href="#u63D0_u53D6_u8981_u5206_u4EAB_u7684_u56FE_u7247" class="headerlink" title="提取要分享的图片"></a>提取要分享的图片</h2><p>在<code>SLComposeServiceViewController</code>类中有一个属性叫<code>extensionContext</code>，它存储着与当前应用扩展有关联的所有数据，其中包含一个<code>NSInputItem</code>类型的数组，名叫<code>inputItems</code>。每个<code>NSInputItem</code>都含有一个<code>attachments</code>集合，它们的类型都为<code>NSItemProvider</code>。这些<code>attachments</code>存储的就是分享内容中的媒体资源，比如图片、视频、文件或链接。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">imageFromExtensionItem</span><span class="params">(extensionItem: NSExtensionItem, callback: <span class="params">(image: UIImage?)</span></span></span>-&gt;<span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> attachment <span class="keyword">in</span> extensionItem.attachments <span class="keyword">as</span> [<span class="type">NSItemProvider</span>] &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法的作用是从分享内容中提取图片（<code>UIImage</code>），注意这个方法没有返回值，而是用一个闭包回调函数来替代。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>为了确定<code>attachments</code>中是否包含了图片类型的资源，我们需要用到<code>hasItemConformingToTypeIdentifier()</code>方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(attachment.hasItemConformingToTypeIdentifier(kUTTypeImage <span class="keyword">as</span> <span class="type">NSString</span>)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的参数类型是<code>NSString</code>，并且类型标示符<code>kUTTypeImage</code>属于<strong>MobileCoreServices</strong>框架中的属性，所以我们要引入<strong>MobileCoreServices</strong>框架：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> MobileCoreServices</span><br></pre></td></tr></table></figure>
<p>该框架中还包含几种类型标示符：</p>
<ul>
<li><code>kUTTypeImage</code></li>
<li><code>kUTTypeMovie</code></li>
<li><code>kUTTypeAudio</code></li>
<li><code>kUTTypeSpreadsheet</code></li>
</ul>
<p>现在你可以确定<code>attachments</code>中至少包含了一个图片资源，并且需要将该图片资源提取出来。因为执行该任务会消耗很高的内存资源，所以为了确保在执行时UI界面不会出现无响应的情况，它应该在后台队列中执行。我们可以使用<code>loadItemForTypeIdentifier()</code>方法，与刚才的方法类似，该方法也有类型标示符参数，并且用闭包实现对图片的操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Marshal on to a background thread</span></span><br><span class="line">dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="type">UInt</span>(<span class="number">0</span>))) &#123;</span><br><span class="line">  attachment.loadItemForTypeIdentifier(kUTTypeImage <span class="keyword">as</span> <span class="type">NSString</span>, options: <span class="literal">nil</span>) &#123;</span><br><span class="line">      (imageProvider, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用Objective-C，那么你可以用block将返回结果强制转换为你期望的类型（比如<code>UIImage</code>），然后实现回调。但是在Swift中就行不通了，所以上面代码中的<code>imageProvider</code>变量的类型应该是<code>NSSecureCoding</code>，然后你可以将它强转为<code>UIImage</code>类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> image: <span class="type">UIImage</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> e = error &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"Item loading error: <span class="subst">\(e.localizedDescription)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">image = imageProvider <span class="keyword">as</span>? <span class="type">UIImage</span></span><br><span class="line">dispatch_async(dispatch_get_main_queue()) &#123;</span><br><span class="line">  callback(image: image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家注意，在<code>dispatch_async</code>中我使用了<code>callback()</code>函数，也就是<code>imageFromExtensionItem</code>方法的第二个参数，并将刚才强转为<code>UIImage</code>类型的<code>image</code>对象作为其参数。</p>
<p>这段代码可以让用户在输入分享文本信息的同时将<code>attachments</code>中的图片提取出来。看起来非常完美：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> attachedImage: <span class="type">UIImage</span>?</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">presentationAnimationDidFinish</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Only interested in the first item</span></span><br><span class="line">  <span class="keyword">let</span> extensionItem = extensionContext.inputItems[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSExtensionItem</span></span><br><span class="line">  <span class="comment">// Extract an image (if one exists)</span></span><br><span class="line">  imageFromExtensionItem(extensionItem) &#123;</span><br><span class="line">    image <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> image &#123;</span><br><span class="line">      dispatch_async(dispatch_get_main_queue()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.attachedImage = image</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的作用就是提取出图片，并将提取出的图片赋值给我们定义的<code>attachedImage</code>变量。</p>
<h2 id="u6267_u884C_u540E_u53F0_u4E0A_u4F20_u7684_u4EFB_u52A1"><a href="#u6267_u884C_u540E_u53F0_u4E0A_u4F20_u7684_u4EFB_u52A1" class="headerlink" title="执行后台上传的任务"></a>执行后台上传的任务</h2><p>一旦用户输入完要分享的文本信息，按下<strong>Post</strong>按钮后，分享扩展就应该将所有内容通过Web服务上传到某个地方。本文的示例为了达到这个目的，我们在视图控制器中定义了一个常量属性<code>sc_uploadURL</code>，值为一个URL，也就是一个服务地址：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> sc_uploadURL = <span class="string">"http://requestb.in/oha28noh"</span></span><br></pre></td></tr></table></figure>
<p>这个URL是Request Bin的服务，Request Bin可以给你提供一个临时的URL，用于测试一些网络操作。上面代码中的这个URL对你们来说没有什么用，因为这是我申请的，你们可以去<a href="http://requestb.in/" target="_blank" rel="external">requestb.in</a>申请一个自己的URL用于测试。</p>
<p>在前面我们提到过，应用扩展不应该和Host应用抢占内存资源，它应该在后台执行相关任务。因此，当<strong>Post</strong>按钮被按下时，在当前的Host应用中我们不会看到任何有关应用扩展的执行痕迹，像同步、网络操作等。此时，我们就需要使用<code>NSURLSession</code>给我们提供的API来实现后台的网络操作。</p>
<p>当用户点击<strong>Post</strong>按钮后会调用<code>didSelectPost()</code>方法，它的代码片段应该是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">didSelectPost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Perform upload</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Inform the host that we're done, so it un-blocks its UI.</span></span><br><span class="line">  extensionContext.completeRequestReturningItems(<span class="literal">nil</span>, completionHandler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置<code>NSURLSession</code>很简单，有规范的设置流程：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> configName = <span class="string">"com.shinobicontrols.ShareAlike.BackgroundSessionConfig"</span></span><br><span class="line"><span class="keyword">let</span> sessionConfig = <span class="type">NSURLSessionConfiguration</span>.backgroundSessionConfigurationWithIdentifier(configName)</span><br><span class="line"><span class="comment">// Extensions aren't allowed their own cache disk space. Need to share with application</span></span><br><span class="line">sessionConfig.sharedContainerIdentifier = <span class="string">"group.ShareAlike"</span></span><br><span class="line"><span class="keyword">let</span> session = <span class="type">NSURLSession</span>(configuration: sessionConfig)</span><br></pre></td></tr></table></figure>
<p>我们要特别注意上面代码片段中<code>sharedContainerIdentifier</code>的设置，它给<code>NSURLSession</code>使用的共享容器（用于缓存分享内容）指定了一个名称，这个容器也是扩展载体应用的一部分（在这个例子中，载体应用就是ShareAlike），所以我们要通过Xcode对载体应用进行设置：</p>
<ol>
<li>在工程设置面板中选择<strong>Capabilities</strong>页签，然后在左侧<strong>Targets</strong>栏中选中载体应用。</li>
<li>开启载体应用的<strong>App Groups</strong>。</li>
<li>创建一个App Group，起一个合适的名称，但是必须要以<code>group.</code>开头。在我们的示例中，我们刚才设置的名称为<code>group.ShareAlike</code>。</li>
<li>Xcode会进行一系列检查，然后创建App Group。</li>
</ol>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension8.png" alt="图片"></p>
<p>然后选中应用扩展，开启<strong>App Groups</strong>，然后选择刚才创建好的App Group。</p>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension9.png" alt="图片"></p>
<p>这些App Group都是登记在你的开发者账号下的，这样才能确保只有你的应用可以使用这些共享容器。</p>
<p>Xcode会为每个工程创建一个<code>.entitlements</code>授权文件，里面就包含有共享容器的访问名称。</p>
<p>现在<code>NSURLSession</code>就已经设置成功了，你还需要创建一个URL request对象来发送请求：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Prepare the URL Request</span></span><br><span class="line"><span class="keyword">let</span> request = urlRequestWithImage(attachedImage, text: contentText)</span><br></pre></td></tr></table></figure>
<p><code>urlRequestWithImage</code>函数的作用是构造一个URL请求结构，通过HTTP Post方式发送一些JSON格式的数据。这其中就包含了文本内容和图片的元数据信息：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">urlRequestWithImage</span><span class="params">(image: UIImage?, text: String)</span></span> -&gt; <span class="type">NSURLRequest</span>? &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="type">NSURL</span>.<span class="type">URLWithString</span>(sc_uploadURL)</span><br><span class="line">  <span class="keyword">let</span> request = <span class="type">NSMutableURLRequest</span>(<span class="type">URL</span>: url)</span><br><span class="line">  request.addValue(<span class="string">"application/json"</span>, forHTTPHeaderField: <span class="string">"Content-Type"</span>)</span><br><span class="line">  request.addValue(<span class="string">"application/json"</span>, forHTTPHeaderField: <span class="string">"Accept"</span>)</span><br><span class="line">  request.<span class="type">HTTPMethod</span> = <span class="string">"POST"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> jsonObject = <span class="type">NSMutableDictionary</span>()</span><br><span class="line">  jsonObject[<span class="string">"text"</span>] = text</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> image = image &#123;</span><br><span class="line">    jsonObject[<span class="string">"image_details"</span>] = extractDetailsFromImage(image)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the JSON payload</span></span><br><span class="line">  <span class="keyword">var</span> jsonError: <span class="type">NSError</span>?</span><br><span class="line">  <span class="keyword">let</span> jsonData = <span class="type">NSJSONSerialization</span>.dataWithJSONObject(jsonObject, options: <span class="literal">nil</span>, error: &amp;jsonError)</span><br><span class="line">  <span class="keyword">if</span> jsonData &#123;</span><br><span class="line">    request.<span class="type">HTTPBody</span> = jsonData</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = jsonError &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">"JSON Error: <span class="subst">\(error.localizedDescription)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法实际上并不是创建一个上传图片的请求，虽然也可以这样做，但这里我们将图片的详细信息（元数据）提取出来进行上传，下面代码是提取图片详细信息的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">extractDetailsFromImage</span><span class="params">(image: UIImage)</span></span> -&gt; <span class="type">NSDictionary</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> resultDict = <span class="type">NSMutableDictionary</span>()</span><br><span class="line">  resultDict[<span class="string">"height"</span>] = image.size.height</span><br><span class="line">  resultDict[<span class="string">"width"</span>] = image.size.width</span><br><span class="line">  resultDict[<span class="string">"orientation"</span>] = image.imageOrientation.toRaw()</span><br><span class="line">  resultDict[<span class="string">"scale"</span>] = image.scale</span><br><span class="line">  resultDict[<span class="string">"description"</span>] = image.description</span><br><span class="line">  <span class="keyword">return</span> resultDict.copy() <span class="keyword">as</span> <span class="type">NSDictionary</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后你就可以通过<code>resume()</code>在后台发起上传请求了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Create the task, and kick it off</span></span><br><span class="line"><span class="keyword">let</span> task = session.dataTaskWithRequest(request)</span><br><span class="line">task.resume()</span><br></pre></td></tr></table></figure>
<p>如果你按下<strong>Post</strong>按钮完成分享后，在requestb.in中，你应该可以看到如下的结果：</p>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension10.png" alt="图片"></p>
<p>原文地址：<a href="http://www.shinobicontrols.com/blog/posts/2014/07/21/ios8-day-by-day-day-2-sharing-extension" target="_blank" rel="external">iOS8 Day-by-Day :: Day 2 :: Sharing Extension</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://www.devtalking.com/devtalking.png" alt="DevTalking" itemprop="image"/>
          <p class="site-author-name" itemprop="name">DevTalking</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">117</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

         <!-- <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">分類</span>
              </a>
          </div> -->

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">93</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://www.linkedin.com/in/宇轩-付-5aa406a6" target="_blank">
                  
                    <i class="fa fa-linkedin"></i> linkedin
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:jace.fu@icloud.com" target="_blank">
                  
                    <i class="fa fa-envelope"></i> Email
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DevTalking</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'jacefu';
      var disqus_identifier = 'page/16/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/lib/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
