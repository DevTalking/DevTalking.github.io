<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>




  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="程序员说" type="application/atom+xml" />



  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="程序员说">
<meta property="og:url" content="http://www.devtalking.com/page/13/index.html">
<meta property="og:site_name" content="程序员说">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员说">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> 程序员说 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?980738dc41a50d91861a17ad4b768a1f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">程序员说</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/files-and-initialization/" itemprop="url">
                  Swift中的文件和初始化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-08-02T00:00:00+08:00" content="2014-08-02">
              2014-08-02
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/files-and-initialization/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/files-and-initialization/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h1 id="u6587_u4EF6_u548C_u521D_u59CB_u5316"><a href="#u6587_u4EF6_u548C_u521D_u59CB_u5316" class="headerlink" title="文件和初始化"></a>文件和初始化</h1><p>到目前为止，大多数开发者已经可以写出简单的Swift应用或者在<code>Playground</code>实验Swift语言的新特性。也许你也经历过这种情况，当你将<code>Playground</code>中运行正常的代码拷贝到Swift源文件中却发生了编译错误，“这到底是怎么回事？<code>Playground</code>文件和Swift源文件之间到底有什么不同？” 这篇文将告诉你们如何处理Swift项目中的各种文件，以及如何初始化全局数据。</p>
<h2 id="u5E94_u7528_u4E2D_u7684_u6587_u4EF6"><a href="#u5E94_u7528_u4E2D_u7684_u6587_u4EF6" class="headerlink" title="应用中的文件"></a>应用中的文件</h2><p>一个Swift应用必定会包含很多个源文件，基本上每个源文件中都有构成该应用的函数、类和其他一些申明等。Swift应用中的大多数源文件都是不需要按顺序访问的，都是<strong>无顺序</strong>的，你甚至可以在某个模块的最底部导入需要的源文件（虽然Swift不推荐这种编码风格）。  </p>
<p>不管怎样，在大多数Swift的源文件中是不允许有最顶层级别的代码的。这里解释一下顶层代码，任何写在函数体、类之外，或被封装供他人调用的可执行语句我们称为顶层代码。我们之所以不允许出现顶层代码，是因为它会影响我们判断程序是从哪里开始运行的。</p>
<h2 id="Playground_uFF0CREPL_uFF0C_u9876_u5C42_u4EE3_u7801"><a href="#Playground_uFF0CREPL_uFF0C_u9876_u5C42_u4EE3_u7801" class="headerlink" title="Playground，REPL，顶层代码"></a>Playground，REPL，顶层代码</h2><p>你可能会奇怪，为什么下面的代码在<code>Playground</code>中可以完美执行。由于它并没有包含任何其他东西，所以它必然是顶层代码：</p>
<pre><code>println(&quot;Hello world&quot;)
</code></pre><p>上面的单行程序在没有任何其他代码的情况就可以正常运行，是因为<code>Playground</code>支持执行顶层代码。并且在<code>Playground</code>中引入的文件或者代码是按自上而下的顺序执行的。比如说，你不能在定义某个类型之前去使用它。当然，在Swift的<code>Playground</code>中也可以定义函数、类和其他在Swift中合法的任何类型，但并没有必要这么做。<code>Playground</code>的目的在于让开发者们能更简单、更快速的学习Swift语言和实验新的API，而不用创建大量Swift源文件去做这些事。</p>
<p>除了<code>Playground</code>，顶层代码也可以在<code>REPL</code>（Read-Eval-Print-Loop）中运行或作为脚本在Swift文件启动时运行。通过脚本使用Swift时，你可以在终端中用<code>#!/usr/bin/xcrun swift</code>或者<code>xcrun swift myFile.swift</code>的方式使用Swift文件。</p>
<h2 id="u5E94_u7528_u7A0B_u5E8F_u7684_u5165_u53E3_u4E0E_u201Cmain-swift_u201D"><a href="#u5E94_u7528_u7A0B_u5E8F_u7684_u5165_u53E3_u4E0E_u201Cmain-swift_u201D" class="headerlink" title="应用程序的入口与“main.swift”"></a>应用程序的入口与“main.swift”</h2><p>你可能也注意到了，在上面的文章中，我们提到在大多数的源文件中是不允许使用顶层代码的。但对一个文件除外，那就是<code>main.swift</code>文件，该文件的作用类似于<code>Playground</code>，但是它是随着你应用的其他源文件一起编译的。<code>main.swift</code>文件中允许顶层代码并且执行顺序是自上而下的。实际上，<code>main.swift</code>文件中的第一行代码就默认为是程序的入口。正因为如此，所以我们才能看到在Swift最小的程序只有一行代码，但它必须要在<code>main.swift</code>文件中。  </p>
<p>在Xcode中，Mac程序模板文件中就包含一个<code>main.swift</code>文件，但在iOS程序的项目模板中是通过在Swift文件中添加<code>@UIApplicationMain</code>标签注明项目入口的。这样做会让编译器忽略<code>main.swift</code>入口文件，而将标注有<code>@UIApplicationMain</code>标签的文件当做入口文件。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u5168_u5C40_u53D8_u91CF"><a href="#u5168_u5C40_u53D8_u91CF" class="headerlink" title="全局变量"></a>全局变量</h2><p>我们已经知道了Swift是如何判断程序的执行入口，那么全局变量是如何工作的呢？下面的这行代码，在运行时需要初始化吗？</p>
<pre><code>var someGlobal = foo()
</code></pre><p>在单文件的程序中，代码是自上而下执行的，这类似于函数中变量的执行方式。这虽然看起来很简单，但是在复杂的程序中我们就不是很好回答这个问题了。我们从下面三个方面来考虑：</p>
<ol>
<li>限制初始化，像简单的常量表达式，比如C语言。</li>
<li>任意初始化，在应用程序加载执行静态构造函数时初始化，比如C++语言。</li>
<li>延迟初始化，当全局变量第一次被使用的时候初始化，比如Java语言。</li>
</ol>
<p>我们基本排除第一种情况，因为在Swift中不需要像C语言中的常量表达式。在Swift中，常量通常是在函数调用的时候执行的（内联）。而且也有更好的理由使用复杂的初始化方法，比如设置一个单例或者实例化一个字典。</p>
<p>第二种情况我们也基本排除，因为它在大型、复杂的程序中的效率很差。因为所有的初始化都要在应用程序启动之前，但是我们无法预测初始化的顺序，所以会有问题。</p>
<p>Swift采用第三种情况，这是最好的方法：允许自定义初始化，在程序启动时不会因为要进行大量初始化而降低效率，并且我们也可以预知每次初始化完成的顺序。</p>
<p>延迟初始化的全局变量（也包括结构体和枚举中的静态成员）是在第一次访问他们的时候才初始化的，并且以<code>dispatch_once</code>运行，确保了线程安全。你可以更酷的使用<code>dispatch_once</code>：只需要申明一个全局变量并初始化，再将其访问级别申明为<code>private</code>。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>Swift语言的设计使得它可以很方便的在<code>Playground</code>中进行试验或快捷的编写脚本。一个完整的程序可以只有一行代码。当然，你也可以使用Swift编写出各种复杂的应用程序。你可以通过<code>main.swift</code>掌控各种初始化的完成时机，或者通过<code>@UIApplicationMain</code>标签指定你的iOS应用的程序入口。</p>
<p>本文翻译自Swift官方博客，原文地址：<a href="https://developer.apple.com/swift/blog/?id=7" target="_blank" rel="external">Files and Initialization</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/swift-c-pointer/" itemprop="url">
                  在Swift中使用C语言的指针
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-08-01T00:00:00+08:00" content="2014-08-01">
              2014-08-01
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/swift-c-pointer/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/swift-c-pointer/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>Objective-C和C语言经常需要使用到指针。Swift中的数据类型由于良好的设计，使其可以和基于指针的C语言API无缝混用。同时Swift也可以自动处理大多数将指针作为参数的情况。在这篇文章里，我们可以看到在Swift语言中如何将变量、数组、字符串当做C语言中的指针参数来使用。</p>
<h2 id="u5C06_u8F93_u5165_u8F93_u51FA_u53C2_u6570_u4F5C_u4E3A_u6307_u9488_u53C2_u6570"><a href="#u5C06_u8F93_u5165_u8F93_u51FA_u53C2_u6570_u4F5C_u4E3A_u6307_u9488_u53C2_u6570" class="headerlink" title="将输入输出参数作为指针参数"></a>将输入输出参数作为指针参数</h2><p>C和Objective-C不支持多类型的返回值。所以Cocoa API就使用指针作为函数的输入输出参数，以用来传递多类型的数据。Swift允许使用指针参数进行类似<code>inout</code>参数的处理，所以你可以使用<code>&amp;</code>语法将一个<code>var</code>变量的引用作为指针参数进行传递。比如说，<code>UIColor</code>的<code>getRed(_:green:blue:alpha:)</code>方法，使用4个<code>CGFloat*</code>指针用来接收颜色的组成元素。我们可以使用<code>&amp;</code>将这几个颜色组成部分装配在本地变量中。</p>
<pre><code>var r: CGFloat = 0, g: CGFloat = 0, b: CGFloat = 0, a: CGFloat = 0
color.getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a)
</code></pre><p>另外一个常见的情况出现在Cocoa <code>NSError</code>类的使用中。很多方法都使用一个<code>NSError**</code>参数来保存异常信息。比如说，我们可以通过<code>NSFileManager</code>类的<code>contentsOfDirectoryAtPath(_:error:)</code>方法，挪列出指定目录中的信息，一旦出现疑似异常信息，就将其保存在<code>NSError?</code>类型的变量中。</p>
<pre><code>var maybeError: NSError?
if let contents = NSFileManager.defaultManager()
    .contentsOfDirectoryAtPath(&quot;/usr/bin&quot;, error: &amp;maybeError) {
    // Work with the directory contents
} else if let error = maybeError {
    // Handle the error
}
</code></pre><p>为安全起见，Swift要求在使用<code>&amp;</code>传值时，变量必须是已经被初始化的。这是因为Swift无法知道也无法判断在操作指针之前，该指针是否确实在内存有指向的地址。</p>
<h2 id="u5C06_u6570_u7EC4_u4F5C_u4E3A_u6307_u9488_u53C2_u6570"><a href="#u5C06_u6570_u7EC4_u4F5C_u4E3A_u6307_u9488_u53C2_u6570" class="headerlink" title="将数组作为指针参数"></a>将数组作为指针参数</h2><p>在C语言中，指针与数组是水乳交融，纠缠不清的。那么为了在Swift中能无缝的使用C语言中基于数组的一些API，Swift允许将<code>Array</code>作为指针参数。一个不可变数组的值可以作为一个<code>const</code>指针参数直接传递，可变数组可以使用<code>&amp;</code>作为一个非<code>const</code>指针参数进行传递，就<code>inout</code>参数一样。比如，我们使用<code>Accelerate</code>框架中的<code>vDSP_vadd</code>函数对数组<code>a</code>和数组<code>b</code>进行相加，将结果写入<code>result</code>数组：</p>
<pre><code>import Accelerate

let a: [Float] = [1, 2, 3, 4]
let b: [Float] = [0.5, 0.25, 0.125, 0.0625]
var result: [Float] = [0, 0, 0, 0]

vDSP_vadd(a, 1, b, 1, &amp;result, 1, 4)

// result now contains [1.5, 2.25, 3.125, 4.0625]
</code></pre><h2 id="u5C06_u5B57_u7B26_u4E32_u4F5C_u4E3A_u6307_u9488_u53C2_u6570"><a href="#u5C06_u5B57_u7B26_u4E32_u4F5C_u4E3A_u6307_u9488_u53C2_u6570" class="headerlink" title="将字符串作为指针参数"></a>将字符串作为指针参数</h2><p>C语言中，传递字符串的主要方式是通过<code>const char*</code>指针。在Swift中，<code>String</code>也可以被用作<code>const char*</code>指针，用它可以向函数传递空字符串或UTF-8编码的字符串。比如，我们可以在标准的C语言和POSIX的库函数中直接使用字符串作为参数传递：</p>
<pre><code>puts(&quot;Hello from libc&quot;)
let fd = open(&quot;/tmp/scratch.txt&quot;, O_WRONLY|O_CREAT, 0o666)

if fd &lt; 0 {
    perror(&quot;could not open /tmp/scratch.txt&quot;)
} else {
    let text = &quot;Hello World&quot;
    write(fd, text, strlen(text))
    close(fd)
}
</code></pre><h2 id="u6307_u9488_u53C2_u6570_u8F6C_u6362_u7684_u5B89_u5168_u6027"><a href="#u6307_u9488_u53C2_u6570_u8F6C_u6362_u7684_u5B89_u5168_u6027" class="headerlink" title="指针参数转换的安全性"></a>指针参数转换的安全性</h2><p>Swift一直在努力让我们可以方便的、无缝的使用C语言中的指针，因为在Cocoa中已经使用的非常普遍了。虽然Swift是一个类型安全的语言，对指针参数的转换的安全性也有保障，但是相比Swift原生的其他代码来说，还是存在着一定的不安全性。所以我们在使用时要格外小心。比如说：</p>
<ul>
<li>如果调用者在指针返回之后保存了指针指向的对象，那么再去使用这个对象时是不安全的。这些被转换的指针参数只能在调用过程中或者发送消息过程中保证其有效性。即时你使用相同的变量、数组或者字符串作为多指针参数进行传递，你每次接收到的指针都是不同的。除非是全局或者静态变量。你可以安全的使用全局或静态变量的指针的参数，比如KVO上下文参数。</li>
<li>当将数组或字符串作为指针参数传递时，Swift不会检查其边界值。在C语言中，数组和字符串的大小是不能增长的，所以当你将数组或字符串作为指针参数传递时，要确保它们有足够的大小，或者适合当前场景的大小。</li>
</ul>
<p>如果你使用的基于指针的API不在这篇指导内，或者你需要重写接收指针参数的Cocoa方法，那么你可以直接使用Swift原始内存中的不安全的指针。我们会在以后的文章中介绍更多Swift的特性。</p>
<p>本文翻译自Swift官方博客，原文地址：<a href="https://developer.apple.com/swift/blog/?id=6" target="_blank" rel="external">Interacting with C Pointers</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/swift-access-control/" itemprop="url">
                  Swift新特性 -- 访问控制（Access Control）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-07-26T00:00:00+08:00" content="2014-07-26">
              2014-07-26
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/swift-access-control/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/swift-access-control/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>苹果在发布了Xcode 6 Bate 4后为Swift添加了新的特性–访问控制（Access Control），并且更新了<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-XID_29" target="_blank" rel="external">The Swift Programming Language</a>文档，我抽空把这篇文档翻译了一下，下面让我们来详细了解一下Access Control。</p>
<h1 id="u8BBF_u95EE_u63A7_u5236"><a href="#u8BBF_u95EE_u63A7_u5236" class="headerlink" title="访问控制"></a>访问控制</h1><p>访问控制可以限定你在源文件或模块中访问代码的级别，也就是说可以控制哪些代码你可以访问，哪些代码你不能访问。这个特性可以让我们隐藏功能实现的一些细节，并且可以明确的指定我们提供给其他人的接口中哪些部分是他们可以使用的，哪些是他们看不到的。  </p>
<p>你可以明确的给类、结构体、枚举、设置访问级别，也可以给属性、函数、初始化方法、基本类型、下标索引等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。  </p>
<p>在提供了不同访问级别的同时，Swift并没有规定我们要在任何时候都要在代码中明确指定访问级别。其实，如果我们作为独立开发者在开发我们自己的app，而不是在开发一些<code>Framework</code>的时候，我们完全可以不用明确的指定代码的访问级别。</p>
<blockquote>
<p>注意：为方便起见，在代码中可以设置访问级别的它们（属性、基本类型、函数等）在下面的章节中我们称之为“实体”。</p>
</blockquote>
<h2 id="u6A21_u5757_u548C_u6E90_u6587_u4EF6"><a href="#u6A21_u5757_u548C_u6E90_u6587_u4EF6" class="headerlink" title="模块和源文件"></a>模块和源文件</h2><p>Swift中的访问控制模型基于模块和源文件这两个概念。  </p>
<p>模块指的是<code>Framework</code>或<code>App bundle</code>。在Swift中，可以用<code>import</code>关键字引入自己的工程。  </p>
<p>在Swift中，<code>Framewordk</code>或<code>App bundle</code>被作为模块处理。如果你是为了实现某个通用的功能，或者是为了封装一些常用方法而将代码打包成<code>Framework</code>，这个<code>Framework</code>在Swift中就被称为模块。不论它被引入到某个App工程或者其他的<code>Framework</code>，它里面的一切（属性、函数等）都属于这个模块。  </p>
<p>源文件指的是Swift中的<code>Swift File</code>，就是编写Swift代码的文件，它通常属于一个模块。通常一个源文件包含一个<code>类</code>，在<code>类</code>中又包含<code>函数</code>、<code>属性</code>等类型。</p>
<h2 id="u8BBF_u95EE_u7EA7_u522B"><a href="#u8BBF_u95EE_u7EA7_u522B" class="headerlink" title="访问级别"></a>访问级别</h2><p>Swift提供了三种不同的访问级别。这些访问级别相对于源文件中定义的实体，同时也相对于这些源文件所属的模块。</p>
<ul>
<li><code>Public</code>：可以访问自己模块或应用中源文件里的任何实体，别人也可以访问引入该模块中源文件里的所有实体。通常情况下，某个接口或<code>Framework</code>是可以被任何人使用时，你可以将其设置为<code>public</code>级别。</li>
<li><code>Internal</code>：可以访问自己模块或应用中源文件里的任何实体，但是别人不能访问该模块中源文件里的实体。通常情况下，某个接口或<code>Framework</code>作为内部结构使用时，你可以将其设置为<code>internal</code>级别。</li>
<li><code>Private</code>：只能在当前源文件中使用的实体，称为私有实体。使用<code>private</code>级别，可以用作隐藏某些功能的实现细节。</li>
</ul>
<p><code>Public</code>为最高级访问级别，<code>Private</code>为最低级访问级别。</p>
<h2 id="u8BBF_u95EE_u7EA7_u522B_u7684_u4F7F_u7528_u539F_u5219"><a href="#u8BBF_u95EE_u7EA7_u522B_u7684_u4F7F_u7528_u539F_u5219" class="headerlink" title="访问级别的使用原则"></a>访问级别的使用原则</h2><p>在Swift中，访问级别有如下使用原则：访问级别统一性。<br>比如说：</p>
<ul>
<li>一个<code>public</code>访问级别的变量，不能将它的类型定义为<code>internal</code>和<code>private</code>的类型。因为变量可以被任何人访问，但是定义它的类型不可以，所以这样就会出现错误。</li>
<li>函数的访问级别不能高于它的参数、返回类型的访问级别。因为如果函数定义为<code>public</code>而参数或者返回类型定义为<code>internal</code>或<code>private</code>，就会出现函数可以被任何人访问，但是它的参数和返回类型不可以，同样会出现错误。</li>
</ul>
<h2 id="u9ED8_u8BA4_u8BBF_u95EE_u7EA7_u522B"><a href="#u9ED8_u8BA4_u8BBF_u95EE_u7EA7_u522B" class="headerlink" title="默认访问级别"></a>默认访问级别</h2><p>代码中的所有实体，如果你不明确的定义其访问级别，那么它们默认为<code>internal</code>级别。在大多数情况下，我们不需要明确的设置实体的访问级别，因为我们大多数时候都是在开发一个App bundle。</p>
<h2 id="u5355_u76EE_u6807_u5E94_u7528_u7A0B_u5E8F_u7684_u8BBF_u95EE_u7EA7_u522B"><a href="#u5355_u76EE_u6807_u5E94_u7528_u7A0B_u5E8F_u7684_u8BBF_u95EE_u7EA7_u522B" class="headerlink" title="单目标应用程序的访问级别"></a>单目标应用程序的访问级别</h2><p>当你编写一个单目标应用程序时，该应用的所有功能都是为该应用服务，不需要提供给其他应用或者模块使用，所以我们不需要明确设置访问级别，使用默认的访问级别<code>internal</code>即可。但是如果你愿意，你也可以使用<code>private</code>级别，用于隐藏一些功能的实现细节。</p>
<h2 id="Framework_u7684_u8BBF_u95EE_u7EA7_u522B"><a href="#Framework_u7684_u8BBF_u95EE_u7EA7_u522B" class="headerlink" title="Framework的访问级别"></a>Framework的访问级别</h2><p>当你开发<code>Framework</code>时，就需要把一些实体定义为<code>public</code>级别，以便其他人导入该<code>Framework</code>后可以正常使用其功能。这些被你定义为<code>public</code>的实体，就是这个<code>Framework</code>的API。  </p>
<blockquote>
<p>注意：<code>Framework</code>的内部实现细节依然可以使用默认的<code>internal</code>级别，或者也可以定义为<code>private</code>级别。只有你想将它作为API的实体，才将其定义为<code>public</code>级别。</p>
</blockquote>
<h2 id="u8BBF_u95EE_u63A7_u5236_u8BED_u6CD5"><a href="#u8BBF_u95EE_u63A7_u5236_u8BED_u6CD5" class="headerlink" title="访问控制语法"></a>访问控制语法</h2><p>通过修饰符<code>public</code>、<code>internal</code>、<code>private</code>来声明实体的访问级别：</p>
<pre><code>public class SomePublicClass {}
internal class SomeInternalClass {}
private class SomePrivateClass {}

public var somePublicVariable = 0
internal let someInternalConstant = 0
private func somePrivateFunction() {}
</code></pre><p>除非有特殊的说明，否则实体都使用默认的访问级别<code>internal</code>，可以查阅<strong>默认访问级别</strong>这一节。这意味着<code>SomeInternalClass</code>和<code>someInternalConstant</code>不用明确的使用修饰符声明访问级别，但是他们任然拥有隐式的访问级别<code>internal</code>：</p>
<pre><code>class SomeInternalClass {}              // 隐式访问级别internal
var someInternalConstant = 0            // 隐式访问级别 internal
</code></pre><h2 id="u81EA_u5B9A_u4E49_u7C7B_u578B"><a href="#u81EA_u5B9A_u4E49_u7C7B_u578B" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>如果你想为一个自定义类型指定一个明确的访问级别，那么你要明确一点。那就是你要确保新类型的访问级别和它实际的作用域相匹配。比如说，如果某个类里的属性、函数、返回值它们的作用域仅在当前的源文件中，那么你就可以将这个类申明为<code>private</code>类，而不需要申明为<code>public</code>或者<code>internal</code>类。  </p>
<p>类的访问级别也可以影响到类成员（属性、函数、初始化方法等）的默认访问级别。如果你将类申明为<code>private</code>类，那么该类的所有成员的默认访问级别也会成为<code>private</code>。如果你将类申明为<code>public</code>或者<code>internal</code>类（或者不明确的指定访问级别，而使用默认的<code>internal</code>访问级别），那么该类的所有成员的访问级别是<code>internal</code>。  </p>
<blockquote>
<p>注意：上面提到，一个<code>public</code>类的所有成员的访问级别默认为<code>internal</code>级别，而不是<code>public</code>级别。如果你想将某个成员申明为<code>public</code>级别，那么你必须使用修饰符明确的申明该成员。这样做的好处是，在你定义公共接口API的时候，可以明确的选择哪些属性或方法是需要公开的，哪些是内部使用的，可以避免将内部使用的属性方法公开成公共API的错误。</p>
</blockquote>
<pre><code>public class SomePublicClass {          // 显示的 public 类
    public var somePublicProperty = 0    // 显示的 public 类成员 
    var someInternalProperty = 0         // 隐式的 internal 类成员 
    private func somePrivateMethod() {}  // 显示的 private 类成员 
}

class SomeInternalClass {               // 隐式的 internal 类
    var someInternalProperty = 0         // 隐式的 internal 类成员 
    private func somePrivateMethod() {}  // 显示的 private 类成员 
}

private class SomePrivateClass {        // 显示的 private 类
    var somePrivateProperty = 0          // 隐式的 private 类成员 
    func somePrivateMethod() {}          // 隐式的 private 类成员 
}
</code></pre><h2 id="u5143_u7EC4_u7C7B_u578B"><a href="#u5143_u7EC4_u7C7B_u578B" class="headerlink" title="元组类型"></a>元组类型</h2><p>元组的访问级别使用是所有类型的访问级别使用中最为严谨的。比如说，如果你构建一个包含两种不同类型元素的元组，其中一个元素类型的访问级别为<code>internal</code>，另一个为<code>private</code>级别，那么这个元组的访问级别为<code>private</code>。也就是说元组的访问级别遵循它里面元组中最低级的访问级别。  </p>
<blockquote>
<p>注意：元组不同于类、结构体、枚举、函数那样有单独的定义。元组的访问级别是在它被使用时自动推导出的，而不是明确的申明。</p>
</blockquote>
<h2 id="u51FD_u6570_u7C7B_u578B"><a href="#u51FD_u6570_u7C7B_u578B" class="headerlink" title="函数类型"></a>函数类型</h2><p>函数的访问级别需要根据该函数的参数类型访问级别、返回类型访问级别得出。如果根据参数类型和返回类型得出的函数访问级别不符合上下文，那么就需要明确的申明该函数的访问级别。  </p>
<p>下面的例子中定义了一个全局函数名为<code>someFunction</code>，并且没有明确的申明其访问级别。你也许会认为该函数应该拥有默认的访问级别<code>internal</code>，但事实并非如此。事实上，如果按下面这种写法，编译器是无法编译通过的：</p>
<pre><code>func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
    // function implementation goes here
}
</code></pre><p>我们可以看到，这个函数的返回类型是一个元组，该元组中包含两个自定义的类（可查阅<strong>自定义类型</strong>）。其中一个类的访问级别是<code>internal</code>，另一个的访问级别是<code>private</code>，所以根据元组访问级别的原则，该元组的访问级别是<code>private</code>（元组的访问级别遵循它里面元组中最低级的访问级别）。  </p>
<p>因为该函数返回类型的访问级别是<code>private</code>，所以你必须使用<code>private</code>修饰符，明确的申请该函数：</p>
<pre><code>private func someFunction() -&gt; (SomeInternalClass, SomePrivateClass) {
    // function implementation goes here
}
</code></pre><p>将该函数申明为<code>public</code>或<code>internal</code>，或者使用默认的访问级别<code>internal</code>都是错误的，因为如果把该函数当做<code>public</code>或<code>internal</code>级别来使用的话，是无法得到<code>private</code>级别的返回值的。</p>
<h2 id="u679A_u4E3E_u7C7B_u578B"><a href="#u679A_u4E3E_u7C7B_u578B" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举中成员的访问级别继承自该枚举，你不能为枚举中的成员指定访问级别。<br>比如下面的例子，枚举<code>CompassPoint</code>被明确的申明为<code>public</code>级别，那么它的成员<code>North</code>，<code>South</code>，<code>East</code>，<code>West</code>的访问级别同样也是<code>public</code>：</p>
<pre><code>public enum CompassPoint {
    case North
    case South
    case East
    case West
}
</code></pre><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h3 id="u539F_u59CB_u503C_u548C_u5173_u8054_u503C"><a href="#u539F_u59CB_u503C_u548C_u5173_u8054_u503C" class="headerlink" title="原始值和关联值"></a>原始值和关联值</h3><p>用于枚举定义中的任何原始值，或关联的值类型必须有一个访问级别，至少要高于枚举的访问级别。比如说，你不能在一个<code>internal</code>访问级别的枚举中定义<code>private</code>级别的原始值类型。</p>
<h2 id="u5D4C_u5957_u7C7B_u578B"><a href="#u5D4C_u5957_u7C7B_u578B" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>如果在<code>private</code>级别的类型中定义嵌套类型，那么该嵌套类型就自动拥有<code>private</code>访问级别。如果在<code>public</code>或者<code>internal</code>级别的类型中定义嵌套类型，那么该嵌套类型自动拥有<code>internal</code>访问级别。如果想让嵌套类型拥有<code>public</code>访问级别，那么需要对该嵌套类型进行明确的访问级别申明。</p>
<h3 id="u5B50_u7C7B"><a href="#u5B50_u7C7B" class="headerlink" title="子类"></a>子类</h3><p>子类的访问级别不得高于父类的访问级别。比如说，父类的访问级别是<code>internal</code>，子类的访问级别就不能申明为<code>public</code>。<br>此外，在满足子类不高于父类访问级别以及遵循各访问级别作用域（即模块或源文件）的前提下，你可以重写任意类成员（方法、属性、初始化方法、下标索引等）。  </p>
<p>如果我们无法直接访问某个类中的属性或函数等，那么可以继承该类，从而可以更容易的访问到该类的类成员。下面的例子中，类<code>A</code>的访问级别是<code>public</code>，它包含一个函数<code>someMethod</code>，访问级别为<code>private</code>。类<code>B</code>继承类<code>A</code>，并且访问级别申明为<code>internal</code>，但是在类<code>B</code>中重写了类<code>A</code>中访问级别为<code>private</code>的方法<code>someMethod</code>，并重新申明为<code>internal</code>级别。通过这种方式，我们就可以访问到某类中<code>private</code>级别的类成员，并且可以重新申明其访问级别，以便其他人使用：</p>
<pre><code>public class A {
    private func someMethod() {}
}

internal class B: A {
    override internal func someMethod() {}
}
</code></pre><p>只要满足子类不高于父类访问级别以及遵循各访问级别作用域的前提下（即<code>private</code>的作用域在同一个源文件中，<code>internal</code>的作用域在同一个模块下），我们甚至可以在子类中，用子类成员访问父类成员，哪怕父类成员的访问级别比子类成员的要低：</p>
<pre><code>public class A {
    private func someMethod() {}
}

internal class B: A {
    override internal func someMethod() {
        super.someMethod()
    }
}
</code></pre><p>因为父类<code>A</code>和子类<code>B</code>定义在同一个源文件中，所以在类<code>B</code>中可以在重写的<code>someMethod</code>方法中调用<code>super.someMethod()</code>。</p>
<h3 id="u5E38_u91CF_u3001_u53D8_u91CF_u3001_u5C5E_u6027_u3001_u4E0B_u6807"><a href="#u5E38_u91CF_u3001_u53D8_u91CF_u3001_u5C5E_u6027_u3001_u4E0B_u6807" class="headerlink" title="常量、变量、属性、下标"></a>常量、变量、属性、下标</h3><p>常量、变量、属性不能拥有比它们的类型更高的访问级别。比如说，你定义一个<code>public</code>级别的属性，但是它的类型是<code>private</code>级别的，这是编译器不允许的。同样，下标也不能拥有比索引类型或返回类型更高的访问级别。  </p>
<p>如果常量、变量、属性、下标索引的定义类型是<code>private</code>级别的，那么它们必须要明确的申明访问级别为<code>private</code>：</p>
<pre><code>private var privateInstance = SomePrivateClass()
</code></pre><h2 id="Getter_u548CSetter"><a href="#Getter_u548CSetter" class="headerlink" title="Getter和Setter"></a>Getter和Setter</h2><p>常量、变量、属性、下标索引的<code>Getters</code>和<code>Setters</code>的访问级别继承自它们所属成员的访问级别。</p>
<p><code>Setter</code>的访问级别可以低于对应的<code>Getter</code>的访问级别，这样就可以控制变量、属性或下标索引的读写权限。在<code>var</code>或<code>subscript</code>定义作用域之前，你可以通过<code>private(set)</code>或<code>internal(set)</code>先为它门的写权限申明一个较低的访问级别。</p>
<blockquote>
<p>注意：这个规定适用于用作存储的属性或用作计算的属性。即使你不明确的申明存储属性的<code>Getter</code>、<code>Setter</code>，Swift也会隐式的为其创建<code>Getter</code>和<code>Setter</code>，用于对该属性进行读取操作。使用<code>private(set)</code>和<code>internal(set)</code>可以改变Swift隐式创建的<code>Setter</code>的访问级别。在计算属性中也是同样的。  </p>
</blockquote>
<p>下面的例子中定义了一个结构体名为<code>TrackedString</code>，它记录了<code>value</code>属性被修改的次数：</p>
<pre><code>struct TrackedString {
    private(set) var numberOfEdits = 0
    var value: String = &quot;&quot; {
    didSet {
        numberOfEdits++
    }
    }
}
</code></pre><p><code>TrackedString</code>结构体定义了一个用于存储的属性名为<code>value</code>，类型为<code>String</code>，并将初始化值设为<code>&quot;&quot;</code>（即一个空字符串）。该结构体同时也定义了另一个用于存储的属性名为<code>numberOfEdits</code>，类型为<code>Int</code>，它用于记录属性<code>value</code>被修改的次数。这个功能的实现通过属性<code>value</code>的<code>didSet</code>方法实现，每当给<code>value</code>赋新值时就会调用<code>didSet</code>方法，给<code>numberOfEdits</code>加一。  </p>
<p>结构体<code>TrackedString</code>和它的属性<code>value</code>均没有明确的申明访问级别，所以它们都拥有默认的访问级别<code>internal</code>。但是该结构体的<code>numberOfEdits</code>属性使用<code>private(set)</code>修饰符进行申明，这意味着<code>numberOfEdits</code>属性只能在定义该结构体的源文件中赋值。<code>numberOfEdits</code>属性的<code>Getter</code>依然是默认的访问级别<code>internal</code>，但是<code>Setter</code>的访问级别是<code>private</code>，这表示该属性只有在当前的源文件中是可读可写的，在当前源文件所属的模块中它只是一个可读的属性。  </p>
<p>如果你实例化<code>TrackedString</code>结构体，并且多次对<code>value</code>属性的值进行修改，你就会看到<code>numberOfEdits</code>的值会随着修改次数更改：</p>
<pre><code>var stringToEdit = TrackedString()
stringToEdit.value = &quot;This string will be tracked.&quot;
stringToEdit.value += &quot; This edit will increment numberOfEdits.&quot;
stringToEdit.value += &quot; So will this one.&quot;
println(&quot;The number of edits is \(stringToEdit.numberOfEdits)&quot;)
// prints &quot;The number of edits is 3&quot;
</code></pre><p>虽然你可以在其他的源文件中实例化该结构体并且获取到<code>numberOfEdits</code>属性的值，但是你不能对其进行赋值。这样就能很好的告诉使用者，你只管使用，而不需要知道其实现细节。</p>
<h2 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h2><p>我们可以给自定义的初始化方法指定访问级别，但是必须要低于或等于它所属类的访问级别。但如果该初始化方法是必须要使用的话，那它的访问级别就必须和所属类的访问级别相同。  </p>
<p>如同函数或方法参数，初始化方法参数的访问级别也不能低于初始化方法的访问级别。</p>
<h2 id="u9ED8_u8BA4_u521D_u59CB_u5316_u65B9_u6CD5"><a href="#u9ED8_u8BA4_u521D_u59CB_u5316_u65B9_u6CD5" class="headerlink" title="默认初始化方法"></a>默认初始化方法</h2><p>Swift为结构体、类都提供了一个默认的无参初始化方法，用于给它们的所有属性提供赋值操作，但不会给出具体值。默认初始化方法可以参阅<a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-XID_336" target="_blank" rel="external">Default Initializers</a>。默认初始化方法的访问级别与所属类型的访问级别相同。  </p>
<blockquote>
<p>注意：如果一个类型被申明为<code>public</code>级别，那么默认的初始化方法的访问级别为<code>internal</code>。如果你想让无参的初始化方法在其他模块中可以被使用，那么你必须提供一个具有<code>public</code>访问级别的无参初始化方法。  </p>
</blockquote>
<h2 id="u7ED3_u6784_u4F53_u7684_u9ED8_u8BA4_u6210_u5458_u521D_u59CB_u5316_u65B9_u6CD5"><a href="#u7ED3_u6784_u4F53_u7684_u9ED8_u8BA4_u6210_u5458_u521D_u59CB_u5316_u65B9_u6CD5" class="headerlink" title="结构体的默认成员初始化方法"></a>结构体的默认成员初始化方法</h2><p>如果结构体中的任一存储属性的访问级别为<code>private</code>，那么它的默认成员初始化方法访问级别就是<code>private</code>。尽管如此，结构体的初始化方法的访问级别依然是<code>internal</code>。  </p>
<p>如果你想在其他模块中使用该结构体的默认成员初始化方法，那么你需要提供一个访问级别为<code>public</code>的默认成员初始化方法。</p>
<h2 id="u534F_u8BAE"><a href="#u534F_u8BAE" class="headerlink" title="协议"></a>协议</h2><p>如果你想为一个协议明确的申明访问级别，那么有一点需要注意，就是你要确保该协议只在你申明的访问级别作用域中使用。  </p>
<p>协议中的每一个必须要实现的函数都具有和该协议相同的访问级别。这样才能确保该协议的使用者可以实现它所提供的函数。</p>
<blockquote>
<p>注意：如果你定义了一个<code>public</code>访问级别的协议，那么实现该协议提供的必要函数也会是<code>public</code>的访问级别。这一点不同于其他类型，比如，<code>public</code>访问级别的其他类型，他们成员的访问级别为<code>internal</code>。</p>
</blockquote>
<h3 id="u534F_u8BAE_u7EE7_u627F"><a href="#u534F_u8BAE_u7EE7_u627F" class="headerlink" title="协议继承"></a>协议继承</h3><p>如果定义了一个新的协议，并且该协议继承了一个已知的协议，那么新协议拥有的访问级别最高也只和被继承协议的访问级别相同。比如说，你不能定义一个<code>public</code>的协议而去继承一个<code>internal</code>的协议。</p>
<h3 id="u534F_u8BAE_u4E00_u81F4_u6027"><a href="#u534F_u8BAE_u4E00_u81F4_u6027" class="headerlink" title="协议一致性"></a>协议一致性</h3><p>类可以采用比自身访问级别低的协议。比如说，你可以定义一个<code>public</code>级别的类，可以让它在其他模块中使用，同时它也可以采用一个<code>internal</code>级别的协议，并且只能在定义了该协议的模块中使用。</p>
<p>采用了协议的类的访问级别遵循它本身和采用协议中最低的访问级别。也就是说如果一个类是<code>public</code>级别，采用的协议是<code>internal</code>级别，那个采用了这个协议后，该类的访问级别也是<code>internal</code>。</p>
<p>如果你采用了协议，那么实现了协议必须的方法后，该方法的访问级别遵循协议的访问级别。比如说，一个<code>public</code>级别的类，采用了<code>internal</code>级别的协议，那么该类实现协议的方法至少也得是<code>internal</code>。</p>
<blockquote>
<p>注意：在Swift中和Objective-C中一样，协议的一致性保证了一个类不可能在同一个程序中用不同的方法采用同一个协议。</p>
</blockquote>
<h2 id="u6269_u5C55"><a href="#u6269_u5C55" class="headerlink" title="扩展"></a>扩展</h2><p>你可以在条件允许的情况下对类、结构体、枚举进行扩展。扩展成员应该具有和原始类成员一致的访问级别。比如你扩展了一个公共类型，那么你新加的成员应该具有和原始成员一样的默认的<code>internal</code>访问级别。  </p>
<p>或者，你可以明确申明扩展的访问级别（比如使用<code>private extension</code>）给该扩展内所有成员指定一个新的默认访问级别。这个新的默认访问级别仍然可以被单独成员所指定的访问级别所覆盖。</p>
<h3 id="u534F_u8BAE_u7684_u6269_u5C55"><a href="#u534F_u8BAE_u7684_u6269_u5C55" class="headerlink" title="协议的扩展"></a>协议的扩展</h3><p>如果一个扩展采用了某个协议，那么你就不能对该扩展使用访问级别修饰符来申明了。该扩展中实现协议的方法都会遵循该协议的访问级别。</p>
<h2 id="u6CDB_u578B"><a href="#u6CDB_u578B" class="headerlink" title="泛型"></a>泛型</h2><p>泛型类型或泛型函数的访问级别遵循泛型类型、函数本身、泛型类型参数三者中访问级别最低的级别。</p>
<h2 id="u7C7B_u578B_u522B_u540D"><a href="#u7C7B_u578B_u522B_u540D" class="headerlink" title="类型别名"></a>类型别名</h2><p>任何被你定义的类型别名都会认为是不同的类型进行访问控制。一个类型别名的访问级别低于或等于这个类型的访问级别。比如说，一个<code>private</code>级别的类型别名可以设定给一个<code>public</code>、<code>internal</code>、<code>private</code>的类型，但是一个<code>public</code>级别的类型别名只能设定给一个<code>public</code>级别的类型，不能设定给<code>internal</code>或<code>private</code>的类类型。  </p>
<blockquote>
<p>注意：这条规则也适用于为满足协议一致性而给相关类型命名别名。</p>
</blockquote>
<h2 id="u76F8_u5173_u94FE_u63A5"><a href="#u76F8_u5173_u94FE_u63A5" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html#//apple_ref/doc/uid/TP40014097" target="_blank" rel="external">The Swift Programming Language</a></li>
<li><a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216" target="_blank" rel="external">Using Swift with Cocoa and Objective-C</a></li>
<li><a href="https://github.com/JaceFu/Welcome-to-Swift/blob/master/TheSwiftProgrammingLanguage%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C.md" target="_blank" rel="external">The Swift Programming Language中文手册</a></li>
<li><a href="https://github.com/JaceFu/Welcome-to-Swift/blob/master/UsingSwiftwithCocoaandObjective-C%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C.md" target="_blank" rel="external">Using Swift with Cocoa and Objective-C中文手册</a></li>
</ul>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/gojs-nodes/" itemprop="url">
                  GOJS教程 -- 如何使用Nodes
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-07-23T00:00:00+08:00" content="2014-07-23">
              2014-07-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/gojs-nodes/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/gojs-nodes/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>你可以自定义节点的样式和行为。</p>
<h2 id="u5E38_u89C4_u8282_u70B9"><a href="#u5E38_u89C4_u8282_u70B9" class="headerlink" title="常规节点"></a>常规节点</h2><h3 id="u7B80_u5355_u7684_u6846_u56FE_u8282_u70B9"><a href="#u7B80_u5355_u7684_u6846_u56FE_u8282_u70B9" class="headerlink" title="简单的框图节点"></a>简单的框图节点</h3><p>大多数情况下，我们的节点都是一个框包含着文本信息（<code>TextBlock</code>），并且将排列属性设置为<code>Panel.Auto</code>。</p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Auto&quot;,
  $(go.Shape, &quot;Rectangle&quot;,
    new go.Binding(&quot;fill&quot;, &quot;color&quot;)),
  $(go.TextBlock,
    { margin: 5 },
    new go.Binding(&quot;text&quot;, &quot;key&quot;))
);

diagram.model.nodeDataArray = [
    { key: &quot;Alpha&quot;, color: &quot;lightblue&quot; }
];
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/node1.jpg" alt="node"></p>
<h3 id="u5176_u4ED6_u5F62_u72B6_u7684_u6846_u56FE_u8282_u70B9"><a href="#u5176_u4ED6_u5F62_u72B6_u7684_u6846_u56FE_u8282_u70B9" class="headerlink" title="其他形状的框图节点"></a>其他形状的框图节点</h3><p>下面的例子中展示其他几种形状的框图：</p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Auto&quot;,
  $(go.Shape,
    new go.Binding(&quot;figure&quot;, &quot;fig&quot;),
    new go.Binding(&quot;fill&quot;, &quot;color&quot;)),
  $(go.TextBlock,
    { margin: 5 },
    new go.Binding(&quot;text&quot;, &quot;key&quot;))
);

diagram.model.nodeDataArray = [
    { key: &quot;Alpha&quot;, color: &quot;lightblue&quot;, fig: &quot;RoundedRectangle&quot; },
    { key: &quot;Beta&quot;, color: &quot;lightblue&quot;, fig: &quot;Ellipse&quot; },
    { key: &quot;Gamma&quot;, color: &quot;lightblue&quot;, fig: &quot;Hexagon&quot; },
    { key: &quot;Delta&quot;, color: &quot;lightblue&quot;, fig: &quot;FramedRectangle&quot; },
    { key: &quot;Epsilon&quot;, color: &quot;lightblue&quot;, fig: &quot;Cloud&quot; },
    { key: &quot;Zeta&quot;, color: &quot;lightblue&quot;, fig: &quot;Procedure&quot; }
];
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/node2.jpg" alt="node"></p>
<h3 id="u8F83_u590D_u6742_u7684_u6846_u56FE_u8282_u70B9"><a href="#u8F83_u590D_u6742_u7684_u6846_u56FE_u8282_u70B9" class="headerlink" title="较复杂的框图节点"></a>较复杂的框图节点</h3><p>一个排列参数设置为<code>Panel.Auto</code>的节点中，你不必将<code>TextBlock</code>局限为一个，你可以根据情况自行组合<code>Panel</code>对象。下面的例子中就使用<code>TablePanel</code>包含了多个<code>TextBlock</code>。</p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Auto&quot;,
  $(go.Shape,
    { fill: $(go.Brush, go.Brush.Linear, { 0: &quot;white&quot;, 1: &quot;lightblue&quot; }),
      stroke: &quot;darkblue&quot;, strokeWidth: 2 }),
  $(go.Panel, &quot;Table&quot;,
    { defaultAlignment: go.Spot.Left, margin: 4 },
    $(go.RowColumnDefinition, { column: 1, width: 4 }),
    $(go.TextBlock,
      { row: 0, column: 0, columnSpan: 3, alignment: go.Spot.Center },
      { font: &quot;bold 12pt sans-serif&quot; },
      new go.Binding(&quot;text&quot;, &quot;key&quot;)),
    $(go.TextBlock, &quot;First: &quot;,
      { row: 1, column: 0 }),
    $(go.TextBlock,
      { row: 1, column: 2 },
      new go.Binding(&quot;text&quot;, &quot;prop1&quot;)),
    $(go.TextBlock, &quot;Second: &quot;,
      { row: 2, column: 0 }),
    $(go.TextBlock,
      { row: 2, column: 2 },
      new go.Binding(&quot;text&quot;, &quot;prop2&quot;))
  )
);

diagram.model.nodeDataArray = [
    { key: &quot;Alpha&quot;, prop1: &quot;value of &apos;prop1&apos;&quot;, prop2: &quot;the other property&quot; }
];
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/node3.jpg" alt="node"></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u7B80_u5355_u7EC4_u5408_u8282_u70B9"><a href="#u7B80_u5355_u7EC4_u5408_u8282_u70B9" class="headerlink" title="简单组合节点"></a>简单组合节点</h2><h3 id="u56FE_u6807_u8282_u70B9"><a href="#u56FE_u6807_u8282_u70B9" class="headerlink" title="图标节点"></a>图标节点</h3><p>像下面例子这种的节点，一般元素的排列属性都设置为<code>Panel.Vertical</code>，也就是说上面是图，下面是文字信息。</p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Vertical&quot;,
  $(go.Picture,
    { maxSize: new go.Size(50, 50) },
    new go.Binding(&quot;source&quot;, &quot;img&quot;)),
  $(go.TextBlock,
    { margin: new go.Margin(3, 0, 0, 0),
      maxSize: new go.Size(100, 30),
      editable: true, isMultiline: false },
    new go.Binding(&quot;text&quot;, &quot;text&quot;))
);

diagram.model.nodeDataArray = [
    { text: &quot;kitten&quot;, img: &quot;images/50x40.png&quot; }
];
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/node4.jpg" alt="node"></p>
<h3 id="u5C0F_u56FE_u6807_u8282_u70B9"><a href="#u5C0F_u56FE_u6807_u8282_u70B9" class="headerlink" title="小图标节点"></a>小图标节点</h3><p>一般这种节点元素的排列属性为<code>Panel.Horizontal</code>，水平排列，就是左边是图，右边是文字信息。</p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Horizontal&quot;,
  $(go.Picture,
    { maxSize: new go.Size(16, 16) },
    new go.Binding(&quot;source&quot;, &quot;img&quot;)),
  $(go.TextBlock,
    { margin: new go.Margin(0, 0, 0, 2) },
    new go.Binding(&quot;text&quot;, &quot;text&quot;))
);

diagram.model.nodeDataArray = [
    { text: &quot;kitten&quot;, img: &quot;images/50x40.png&quot; }
];
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/node5.jpg" alt="node"></p>
<h2 id="u590D_u6742_u7EC4_u5408_u8282_u70B9"><a href="#u590D_u6742_u7EC4_u5408_u8282_u70B9" class="headerlink" title="复杂组合节点"></a>复杂组合节点</h2><p>有时候，你需要在节点中展示更多的信息。那么我们就需要将元素排列属性设置为<code>Panel.Spot</code>，这个属性的意思就是<code>Node</code>里的元素都排列在这个<code>Node</code>中的各个锚点上。</p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Spot&quot;,
  // the main content:
  $(go.Panel, &quot;Vertical&quot;,
    $(go.Picture,
      { maxSize: new go.Size(50, 50) },
      new go.Binding(&quot;source&quot;, &quot;img&quot;)),
    $(go.TextBlock,
      { margin: new go.Margin(3, 0, 0, 0) },
      new go.Binding(&quot;text&quot;, &quot;text&quot;),
      new go.Binding(&quot;stroke&quot;, &quot;error&quot;, function(err) { return err ? &quot;red&quot; : &quot;black&quot; }))
  ),
  // decorations:
  $(go.Shape, &quot;TriangleUp&quot;,
    { alignment: go.Spot.TopLeft,
      fill: &quot;yellow&quot;, width: 14, height: 14,
      visible: false },
    new go.Binding(&quot;visible&quot;, &quot;info&quot;, function(i) { return i ? true : false; })),
  $(go.Shape, &quot;StopSign&quot;,
    { alignment: go.Spot.TopRight,
      fill: &quot;red&quot;, width: 14, height: 14,
      visible: false },
    new go.Binding(&quot;visible&quot;, &quot;error&quot;)),
  {
    toolTip:
      $(go.Adornment, &quot;Auto&quot;,
        $(go.Shape, { fill: &quot;#FFFFCC&quot; },
          new go.Binding(&quot;visible&quot;, &quot;info&quot;, function(i) { return i ? true : false; })),
        $(go.TextBlock, { margin: 4 },
          new go.Binding(&quot;text&quot;, &quot;info&quot;))
      )
  }
);

diagram.model.nodeDataArray = [
    { text: &quot;kitten&quot;, img: &quot;images/50x40.png&quot;, info: &quot;&quot; },
    { text: &quot;kitten&quot;, img: &quot;images/50x40.png&quot;, error: true, info: &quot;shredded curtains&quot; }
];
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/node6.jpg" alt="node"></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/gojs-links/" itemprop="url">
                  GOJS教程 -- 如何使用Links
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-07-22T00:00:00+08:00" content="2014-07-22">
              2014-07-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/gojs-links/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/gojs-links/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p><code>Link</code>对象顾名思义就是连线，它可以通过连线的方式表达<code>Node</code>之间的关系。</p>
<h2 id="u65E0_u65B9_u5411_u8FDE_u7EBF"><a href="#u65E0_u65B9_u5411_u8FDE_u7EBF" class="headerlink" title="无方向连线"></a>无方向连线</h2><p>最简单的<code>Link</code>就是没有箭头的，无方向的连线。当Diagram中的<code>Node</code>之间的关系没有方向性或者它们之间存在隐性关系的时候，我们使用这种连线。  </p>
<p>我们在构建<code>Link</code>时，先设置创建模板（<code>linkTemplate</code>），该模板指定了连线的样式。然后创建一个指定连线关系的数组<code>linkDataArray</code>，我们通过该数组指定<code>Node</code>之间的连线关系，最后通过<code>GraphLinksModel</code>方法构建连线。 </p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Auto&quot;,
  new go.Binding(&quot;location&quot;, &quot;loc&quot;, go.Point.parse),
  $(go.Shape, &quot;RoundedRectangle&quot;, { fill: &quot;lightgray&quot; }),
  $(go.TextBlock, { margin: 5 },
    new go.Binding(&quot;text&quot;, &quot;key&quot;))
);

diagram.linkTemplate =
$(go.Link,       // the whole link panel
  $(go.Shape));  // the link shape, default black stroke

var nodeDataArray = [
{ key: &quot;Alpha&quot;, loc: &quot;0 0&quot; },
{ key: &quot;Beta&quot;, loc: &quot;100 50&quot; }
];
var linkDataArray = [
{ from: &quot;Alpha&quot;, to: &quot;Beta&quot; }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/link1.jpg" alt="Link"></p>
<h2 id="u5E26_u65B9_u5411_u8FDE_u7EBF"><a href="#u5E26_u65B9_u5411_u8FDE_u7EBF" class="headerlink" title="带方向连线"></a>带方向连线</h2><p>一般情况下我们都需要使用带方向的连线，即带箭头的连线。我们只需要修改一下<code>linkTemplate</code>即可，我们在连线模板中加入一个箭头，通过在<code>Link</code>中再添加一个<code>Shape</code>，然后设置<code>Shape.toArrow</code>属性为<code>OpenTrigangle</code>。  </p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Auto&quot;,
  new go.Binding(&quot;location&quot;, &quot;loc&quot;, go.Point.parse),
  $(go.Shape, &quot;RoundedRectangle&quot;, { fill: &quot;lightgray&quot; }),
  $(go.TextBlock, { margin: 5 },
    new go.Binding(&quot;text&quot;, &quot;key&quot;))
);

diagram.linkTemplate =
$(go.Link,
  $(go.Shape),  // the link shape
  $(go.Shape,   // the arrowhead
    { toArrow: &quot;OpenTriangle&quot;, fill: null })
);

var nodeDataArray = [
    { key: &quot;Alpha&quot;, loc: &quot;0 0&quot; },
    { key: &quot;Beta&quot;, loc: &quot;100 50&quot; }
];
var linkDataArray = [
    { from: &quot;Alpha&quot;, to: &quot;Beta&quot; }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/link2.jpg" alt="Link"></p>
<h2 id="u8FDE_u7EBF_u8DEF_u5F84"><a href="#u8FDE_u7EBF_u8DEF_u5F84" class="headerlink" title="连线路径"></a>连线路径</h2><p>如果你想改变连线的路径，那么需要设置<code>Link.routing</code>属性，下面的例子中展示了<code>Link.Normal</code>和<code>Link.Orthogonal</code>两种连线路径。  </p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Auto&quot;,
  new go.Binding(&quot;location&quot;, &quot;loc&quot;, go.Point.parse),
  $(go.Shape, &quot;RoundedRectangle&quot;, { fill: &quot;lightgray&quot; }),
  $(go.TextBlock, { margin: 5 },
    new go.Binding(&quot;text&quot;, &quot;key&quot;))
);

diagram.linkTemplate =
$(go.Link,
  new go.Binding(&quot;routing&quot;, &quot;routing&quot;),
  $(go.Shape),
  $(go.Shape, { toArrow: &quot;Standard&quot; })
);

var nodeDataArray = [
    { key: &quot;Alpha&quot;, loc: &quot;0 0&quot; },
    { key: &quot;Beta&quot;, loc: &quot;50 50&quot; },
    { key: &quot;Gamma&quot;, loc: &quot;100 25&quot; }
];
var linkDataArray = [
    { from: &quot;Alpha&quot;, to: &quot;Beta&quot;, routing: go.Link.Normal },
    { from: &quot;Alpha&quot;, to: &quot;Gamma&quot;, routing: go.Link.Orthogonal }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/link3.jpg" alt="Link"></p>
<p>要注意的是，这里设置连线路径的是<code>Shape</code>里的属性，在<code>GraphObject</code>中也有设置路径的属性，<code>GraphObject.fromSpot</code>和<code>GraphObject.toSpot</code>，前者是作用于<code>Shape</code>上的，后者是作用于容器上的。</p>
<p>你还可以设置<code>Link.routing</code>属性为<code>Link.AvoidsNodes</code>，可以让连线自动避开<code>Node</code>，也就是说可以避免<code>Link</code>与<code>Node</code>相交。但是如果有一个<code>Node</code>离起始<code>Node</code>或者终点<code>Node</code>非常近的时候，连线就没有办法避让了，因为它没有足够的空间去计算避让路线。  </p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Auto&quot;,
  new go.Binding(&quot;location&quot;, &quot;loc&quot;, go.Point.parse),
  $(go.Shape, &quot;RoundedRectangle&quot;, { fill: &quot;lightgray&quot; }),
  $(go.TextBlock, { margin: 5 },
    new go.Binding(&quot;text&quot;, &quot;key&quot;))
);

diagram.linkTemplate =
$(go.Link,
  { routing: go.Link.AvoidsNodes },  // link route should avoid nodes
  $(go.Shape),
  $(go.Shape, { toArrow: &quot;Standard&quot; })
);

var nodeDataArray = [
    { key: &quot;Alpha&quot;, loc: &quot;0 0&quot; },
    { key: &quot;Beta&quot;, loc: &quot;250 40&quot; },
    { key: &quot;Gamma&quot;, loc: &quot;100 0&quot; },
    { key: &quot;Delta&quot;, loc: &quot;75 50&quot; },
    { key: &quot;Epsilon&quot;, loc: &quot;150 30&quot; }
];
var linkDataArray = [
    { from: &quot;Alpha&quot;, to: &quot;Beta&quot; }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/link4.jpg" alt="Link"></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<h2 id="u8FDE_u7EBF_u7684_u5F2F_u66F2_u5EA6_u548C_u89D2_u5EA6"><a href="#u8FDE_u7EBF_u7684_u5F2F_u66F2_u5EA6_u548C_u89D2_u5EA6" class="headerlink" title="连线的弯曲度和角度"></a>连线的弯曲度和角度</h2><p>在我们创建好连线关系以及路径后，就可以使用其他属性来控制连线的其他特性，比如说弯曲度。我们可以通过设置<code>Link.curve</code>属性设置连线的弯曲度，默认情况下该属性的值为<code>Link.Node</code>。</p>
<p>下面的例子中，我们将<code>Link.curve</code>属性设置为<code>Link.bezier</code>，让连线产生弧度。</p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Auto&quot;,
  new go.Binding(&quot;location&quot;, &quot;loc&quot;, go.Point.parse),
  $(go.Shape, &quot;RoundedRectangle&quot;, { fill: &quot;lightgray&quot; }),
  $(go.TextBlock, { margin: 5 },
    new go.Binding(&quot;text&quot;, &quot;key&quot;))
);

diagram.linkTemplate =
$(go.Link,
  { curve: go.Link.Bezier },  // Bezier curve
  $(go.Shape),
  $(go.Shape, { toArrow: &quot;Standard&quot; })
);

var nodeDataArray = [
    { key: &quot;Alpha&quot;, loc: &quot;0 0&quot; },
    { key: &quot;Beta&quot;, loc: &quot;100 50&quot; }
];
var linkDataArray = [
    { from: &quot;Alpha&quot;, to: &quot;Beta&quot; }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/link5.jpg" alt="Link"></p>
<p>我们还可以通过<code>Link.curviness</code>属性设置连线的弯曲力度。</p>
<p>下面的例子中，两个<code>Node</code>之间有多条连线，并且我们没有设置连线的弯曲度，但是我们可以看到，每条连线都自动的产生了轻微的弯曲度的变化。</p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Auto&quot;,
  new go.Binding(&quot;location&quot;, &quot;loc&quot;, go.Point.parse),
  $(go.Shape, &quot;RoundedRectangle&quot;, { fill: &quot;lightgray&quot; }),
  $(go.TextBlock, { margin: 5 },
    new go.Binding(&quot;text&quot;, &quot;key&quot;))
);

diagram.linkTemplate =
$(go.Link,
  { curve: go.Link.Bezier },
  $(go.Shape),
  $(go.Shape, { toArrow: &quot;Standard&quot; })
);

var nodeDataArray = [
    { key: &quot;Alpha&quot;, loc: &quot;0 0&quot; },
    { key: &quot;Beta&quot;, loc: &quot;100 50&quot; }
];
var linkDataArray = [
    { from: &quot;Alpha&quot;, to: &quot;Beta&quot; },  // multiple links between the same nodes
    { from: &quot;Alpha&quot;, to: &quot;Beta&quot; },
    { from: &quot;Alpha&quot;, to: &quot;Beta&quot; },
    { from: &quot;Alpha&quot;, to: &quot;Beta&quot; }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/link6.jpg" alt="Link"></p>
<p>上面第四个例子中，连线避让<code>Node</code>时折角都是直角，我们还可以通过<code>Link.corner</code>属性，设置连线折角的弧度。</p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Auto&quot;,
  new go.Binding(&quot;location&quot;, &quot;loc&quot;, go.Point.parse),
  $(go.Shape, &quot;RoundedRectangle&quot;, { fill: &quot;lightgray&quot; }),
  $(go.TextBlock, { margin: 5 },
    new go.Binding(&quot;text&quot;, &quot;key&quot;))
);

diagram.linkTemplate =
$(go.Link,
  { routing: go.Link.AvoidsNodes,
    corner: 10 },                  // rounded corners
  $(go.Shape),
  $(go.Shape, { toArrow: &quot;Standard&quot; })
);

var nodeDataArray = [
    { key: &quot;Alpha&quot;, loc: &quot;0 0&quot; },
    { key: &quot;Beta&quot;, loc: &quot;250 40&quot; },
    { key: &quot;Gamma&quot;, loc: &quot;100 0&quot; },
    { key: &quot;Delta&quot;, loc: &quot;75 50&quot; },
    { key: &quot;Epsilon&quot;, loc: &quot;150 30&quot; }
];
var linkDataArray = [
    { from: &quot;Alpha&quot;, to: &quot;Beta&quot; }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/link7.jpg" alt="Link"></p>
<p>当两条连线相交时，我们希望在视觉上能有所表示。那么我们可以设置<code>Link.curve</code>属性为<code>Link.JumpOver</code>属性，展现出的效果就是一条线越过了交叉的另一条线。 </p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Auto&quot;,
  { locationSpot: go.Spot.Center },
  new go.Binding(&quot;location&quot;, &quot;loc&quot;, go.Point.parse),
  $(go.Shape, &quot;RoundedRectangle&quot;, { fill: &quot;lightgray&quot; }),
  $(go.TextBlock, { margin: 5 },
    new go.Binding(&quot;text&quot;, &quot;key&quot;))
);

diagram.linkTemplate =
$(go.Link,
  { routing: go.Link.Orthogonal,  // may be either Orthogonal or AvoidsNodes
    curve: go.Link.JumpOver },
  $(go.Shape),
  $(go.Shape, { toArrow: &quot;Standard&quot; })
);

var nodeDataArray = [
    { key: &quot;Alpha&quot;, loc: &quot;0 50&quot; },
    { key: &quot;Beta&quot;, loc: &quot;100 50&quot; },
    { key: &quot;Alpha2&quot;, loc: &quot;50 0&quot; },
    { key: &quot;Beta2&quot;, loc: &quot;50 100&quot; }
];
var linkDataArray = [
    { from: &quot;Alpha&quot;, to: &quot;Beta&quot; },  // these two links will cross
    { from: &quot;Alpha2&quot;, to: &quot;Beta2&quot; }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/link8.jpg" alt="Link"></p>
<p>或者我们也可以将<code>Link.curve</code>属性设置为<code>Link.JumpGap</code>，表现为当两条连线相交时，其中一条在相交处会断开。</p>
<pre><code>diagram.nodeTemplate =
$(go.Node, &quot;Auto&quot;,
  { locationSpot: go.Spot.Center },
  new go.Binding(&quot;location&quot;, &quot;loc&quot;, go.Point.parse),
  $(go.Shape, &quot;RoundedRectangle&quot;, { fill: &quot;lightgray&quot; }),
  $(go.TextBlock, { margin: 5 },
    new go.Binding(&quot;text&quot;, &quot;key&quot;))
);

diagram.linkTemplate =
$(go.Link,
  { routing: go.Link.Orthogonal,  // may be either Orthogonal or AvoidsNodes
    curve: go.Link.JumpGap },
  $(go.Shape),
  $(go.Shape, { toArrow: &quot;Standard&quot; })
);

var nodeDataArray = [
    { key: &quot;Alpha&quot;, loc: &quot;0 50&quot; },
    { key: &quot;Beta&quot;, loc: &quot;100 50&quot; },
    { key: &quot;Alpha2&quot;, loc: &quot;50 0&quot; },
    { key: &quot;Beta2&quot;, loc: &quot;50 100&quot; }
];
var linkDataArray = [
    { from: &quot;Alpha&quot;, to: &quot;Beta&quot; },  // these two links will cross
    { from: &quot;Alpha2&quot;, to: &quot;Beta2&quot; }
];
diagram.model = new go.GraphLinksModel(nodeDataArray, linkDataArray);
</code></pre><p>结果：<br><img src="http://www.devtalking.com/postImages/link9.jpg" alt="Link"></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://www.devtalking.com/devtalking.png" alt="DevTalking" itemprop="image"/>
          <p class="site-author-name" itemprop="name">DevTalking</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">74</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

         <!-- <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分類</span>
              
          </div> -->

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">36</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jacefu" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:jace.fu@icloud.com" target="_blank">
                  
                    <i class="fa fa-envelope"></i> Email
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.devtalking.com/qrcode.jpg" target="_blank">
                  
                    <i class="fa fa-qrcode"></i> 微信公众号
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DevTalking</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'jacefu';
      var disqus_identifier = 'page/13/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
