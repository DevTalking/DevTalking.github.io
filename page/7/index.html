<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>




  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="程序员说" type="application/atom+xml" />



  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="程序员说">
<meta property="og:url" content="http://www.devtalking.com/page/7/index.html">
<meta property="og:site_name" content="程序员说">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员说">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> 程序员说 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?980738dc41a50d91861a17ad4b768a1f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">程序员说</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/text-kit-tutorial-in-swift-1/" itemprop="url">
                  如何在Swift中运用Text Kit框架（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-31T00:00:00+08:00" content="2014-10-31">
              2014-10-31
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/text-kit-tutorial-in-swift-1/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/text-kit-tutorial-in-swift-1/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>



<p>由于Apple近几年在iOS系统的不断改进过程中添加了许多新的特性和功能，这使得iOS系统对文本的渲染能力有了大大的提升。在iOS7中我们就已经能感觉到在文本渲染方面有了很大改进和提升。现在iOS8发布了，在文本渲染方面在延续了之前强大功能的基础上，又提升了其易用性。简单纵观iOS文本渲染的发展史，你也许对目前文本渲染的强大能有更深刻的体会。</p>
<p>在iOS6之前，使用web视图渲染文本是当时最为容易的一种方式，因为它能较为有效的处理混合编排的文本，比如有粗体字、斜体字、有颜色的字等。</p>
<p>2012年，iOS6在UIKit框架中添加一些支持字符串编辑或渲染的控件。这使得在渲染文本时，使用web视图不再是唯一的选择了。并且在文本排版方面不用再依赖通过HTML布局这种方式了。</p>
<p>在iOS6中，UIKit中支持字符串编辑和渲染的控件是同时基于WebKit和Core Graphic的<code>String drawing</code>函数开发出的，整个如下图所示：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-1.png" alt="pic"></p>
<blockquote>
<p>注意：在这张图上有没有让你疑惑的地方呢？没错，<code>UITextView</code>是基于WebKit框架的。实际上，UIKit中与文本相关的这些控件在底层还是使用HTML渲染的。没有深入研究过相关框架的开发者是不太容易察觉这一点的。</p>
</blockquote>
<p>尽管iOS6中提供的这些文本控件在实际开发中的确带来了不少便利，但是当遇到复杂的布局、多行混合渲染等这种高级应用场景时，这些控件就显得捉襟见肘了，此时虽然Core Text是相对底层而且用法繁复的框架，但使用它来解决问题仍是唯一可以选择的方法。</p>
<p>直到iOS7的问世，这种窘境得以改善。随着扁平化的设计思路，iOS的UI拚弃了沿用多年的拟物化风格，将重点和关注点集中在排版工艺上。比如<code>UIButton</code>在iOS7中去掉了整个外边框和阴影，只留下了按钮文字。所以Apple在iOS7中加入了用于文本编排和渲染的<strong>Text Kit</strong>框架就不足为奇了。</p>
<p>在iOS7中关于文本渲染的控件及框架结构就比较清晰和合理了。因为所有UIKit中的文本控件都基于Text Kit框架，而不像iOS6中还有基于Web Kit框架的：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-2.png" alt="pic"></p>
<p>Text Kit在继承了Core Text所有强大功能的基础上，将功能封装为面向对象的API，让开发者们都乐开了花。</p>
<p>在这篇教程中，你要去探索Text Kit的各种功能特性，并且你要创建一个简单的但又功能丰富的iPhone笔记应用。</p>
<p>本教程包含一个初始的项目，里面含有事先创建好的UI部分，以便使同学们只关注于Text Kit的部分。在这里可以下载该<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2014/09/SwiftTextKitNotepad-starter6.zip" target="_blank" rel="external">项目</a>。下载完成后解压并在Xcode中打开项目，编译运行后你会看到如下的界面：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-3.png" alt="pic"></p>
<p>该示例应用创建了一个初始的数组用于存放笔记实例，然后在TableViewController中将其渲染出来，当你点击选择某条笔记时，Storyboard和segue会捕获到你的行为，然后处理视图转换的先关工作，使你看到该条笔记的详细信息。</p>
<h2 id="Dynamic_Type"><a href="#Dynamic_Type" class="headerlink" title="Dynamic Type"></a>Dynamic Type</h2><p><strong>Dynamic Type</strong>是iOS7中给我们的开发带来变化最多的特性之一，它的作用是让应用中的字体大小遵循你设置的字体大小和粗细。</p>
<p>在iOS7中，打开设置，可以在 <strong>通用/辅助功能（General/Accessibility）</strong> 和 <strong>通用/字体大小（General/Text Size）</strong> 中查看和设置系统中应用显示字体的属性： </p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-4.png" alt="pic"></p>
<p>在iOS8中，打开设置，可以在 <strong>通用/辅助功能/更大字体（General/Accessibility/Larger Text）</strong> 查看Dynamic Type的文本尺寸。</p>
<p>不管是增加文字粗细还是改变文字大小，在支持Dynamic Type的应用中这都能给用户带来极大的便利，增加了文字的可读性。</p>
<p>为了让应用支持Dynamic Type，你需要设置文本遵循某一<strong>风格</strong>，而不是明确的指定文本的字体名称和大小。在iOS7中已经为<code>UIFont</code>增加了一个新的方法<code>preferredFontForTextStyle</code>，它的作用是给创建出一个由用户在设置中根据自身需要设定的风格的字体。</p>
<p>下表中展示了六种不同字体样式的不同大小和粗细程度：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-5.png" alt="pic"></p>
<p>表中最左边的字体是用户可选择的最小的字体，中间是可选择的最大的字体，最右边是选择了辅助功能中给字体加粗后的样式。</p>
<h2 id="u6700_u57FA_u672C_u7684_u529F_u80FD_u652F_u6301"><a href="#u6700_u57FA_u672C_u7684_u529F_u80FD_u652F_u6301" class="headerlink" title="最基本的功能支持"></a>最基本的功能支持</h2><p>实现动态文本的基本功能还是相对较简单的。应用中的字体不再是一个明确的字体，而是需要请求一个特殊的字体样式。在运行时，应用会根据用户在设置应用中对字体的设置以及请求到的字体样式中选择一个合适的字体样式。</p>
<p>到了iOS8，Apple让实现Dynamic Type变得比iOS7更加容易了。尤其是TableView中的默认Label自动支持Dynamic Type，这个很赞！但是如果还想适配iOS7的话那就要在TableView中使用自定义的Label了。所以首先同学们要学会如何在iOS7中处理Dynamic Type，然后你就会发现到了iOS8后，生活是多么美好，晴空万里，没有雾霾！</p>
<h2 id="u4E3A_u4EC0_u4E48iOS7_u662F_u4F18_u79C0_u7684_u7CFB_u7EDF_uFF0C_u800CiOS8_u662F_u8D8B_u8FD1_u5B8C_u7F8E_u7684_u7CFB_u7EDF"><a href="#u4E3A_u4EC0_u4E48iOS7_u662F_u4F18_u79C0_u7684_u7CFB_u7EDF_uFF0C_u800CiOS8_u662F_u8D8B_u8FD1_u5B8C_u7F8E_u7684_u7CFB_u7EDF" class="headerlink" title="为什么iOS7是优秀的系统，而iOS8是趋近完美的系统"></a>为什么iOS7是优秀的系统，而iOS8是趋近完美的系统</h2><p>该教程中初始项目的设置和配置是基于iOS8的。在我们开始学习之前，先编译运行应用，然后尝试改变默认的文本字体大小，多试几次不同的字体大小。你会发现不光是字体大小变了，TableView列表的Cell高度也相应发生了改变。但是你对这个项目还没动过一根手指。同时你也应该发现了点击选择一条笔记后，该笔的详细信息的文本字体却没有发生变化。</p>
<p>但在iOS7中我们的确还要做一些额外的事，没有十全十美的事应该指的就是这个吧。如果你的编译环境是iOS7或iOS8（确保你使用的Xcode版本是6），那么本教程的绝大部分内容都是没问题的。现在我们需要将Xcode的编译环境设置为iOS7已经选择合适的iOS模拟器（iPhone5s）。如果你不打算支持iOS8之前的系统，那么你可以直接使用iOS8的编译环境。</p>
<p>现在咱们在iOS7下编译运行应用，然后重复之前修改字体的操作，你会发现什么？没错，发现了悲剧。应用中的字体会忽略你对字体的设置，根本不起作用。所以，同学们必须要做点什么让Dynamic Type在iOS7跑起来。</p>
<p>打开<strong>NoteEditorViewController.swift</strong>，在<code>viewDidLoad</code>方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">textView.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleBody</span>)</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是你并没有给<code>textView.font</code>设置具体的字体，比如Helvetica Neue之类。相反，你只是请求了一个适合主体文本的字体样式<code>UIFontTextStyleBody</code>。</p>
<p>然后打开<strong>NotesListViewController.swift</strong>，在<code>tableView(_:cellForRowAtIndexPath:)</code>方法的<code>return</code>语句后添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">cell.textLabel?.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleHeadline</span>)</span><br></pre></td></tr></table></figure>
<p>你依然没有给字体具体的类型，而是请求了一个合适的字体样式。</p>
<p>使用语义接近的字体样式名称，比如<code>UIFontTextStyleSubHeadline</code>，可以避免在代码中对字体样式使用硬编码，并确保你的应用中的文本信息能正确的响应用户的设置。</p>
<p>现在再编译和运行应用，你会发现TableView和笔记详细信息页面中的文本字体都发生了变化。下面的截图是设置不同字体大小后的笔记详细信息页面：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-6.png" alt="pic"></p>
<p>目前看起来一起都很完美，但是细心的读者可能会发现这种解决方法只能解决一半的问题。让我们回到设置应用然后再次更改字体大小，然后我们通过后台程序回到我们的笔记应用中，我们发现了什么？没错，文本字体没有响应我们刚才的设置从而发生变化。</p>
<p>我相信我们的用户是不会允许这种事情发生的。又一个挑战出现了，让我们来看看如何解决这个问题。</p>
<h2 id="u5373_u65F6_u54CD_u5E94_u5B57_u4F53_u8BBE_u7F6E"><a href="#u5373_u65F6_u54CD_u5E94_u5B57_u4F53_u8BBE_u7F6E" class="headerlink" title="即时响应字体设置"></a>即时响应字体设置</h2><p>打开<code>NoteEditorViewController.swift</code>，在<code>viewDidLoad</code>方法中添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>, </span><br><span class="line">    selector: <span class="string">"preferredContentSizeChanged:"</span>, </span><br><span class="line">    name: <span class="type">UIContentSizeCategoryDidChangeNotification</span>,</span><br><span class="line">    object: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>
<p>上面这段代码的作用是将我们的<code>NodeEditorViewController</code>注册到通知中心里，当字体发生改变时会通知<code>NodeEditorViewController</code>中的<code>preferredContentSizeChanged</code>方法。</p>
<p>我们再来看看<code>preferredContentSizeChanged</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">preferredContentSizeChanged</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">  textView.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleBody</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中我们就可以改变文本的字体样式了。</p>
<blockquote>
<p>注意：这里你可能会有疑惑，已经更改过字体样式了，为什么这里再次请求样式的时候还是<code>UIFontTextStyleBody</code>呢？当用户更改完字体样式后，你需要通过<code>preferredFontForTextStyle</code>方法重新请求一次字体样式，该方法的参数只代表文本的类型和所在位置，比如是Body里的还是Head中的等，所以<code>UIFont.preferredFontForTextStyle(UIFontTextStyleBody)</code>的意思就是请求类型和位置在Body中显示文本的字体样式，每次请求都是获取最新一次设置的字体样式。</p>
</blockquote>
<p>打开<code>NotesListViewController.swift</code>，重写<code>viewDidLoad</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">  <span class="type">NSNotificationCenter</span>.defaultCenter().addObserver(<span class="keyword">self</span>,</span><br><span class="line">      selector: <span class="string">"preferredContentSizeChanged:"</span>, </span><br><span class="line">      name: <span class="type">UIContentSizeCategoryDidChangeNotification</span>, </span><br><span class="line">      object: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同学们应该注意到了，我们刚才添加的方法和<code>NoteEditorViewController.swift</code>中添加的方法一样。没错，给<code>NSNotificationCenter</code>注册的方法是相同的，但是<code>preferredContentSizeChanged</code>方法会有点区别。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p>然后在<code>NotesListViewController.swift</code>中再添加<code>preferredContentSizeChanged</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">preferredContentSizeChanged</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">  tableView.reloadData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码的作用是让Tableview重新加载可见的Cell，在更新时就会触发<code>preferredFontForTextStyle()</code>方法，将新设置的字体样式应用到Tableview的Cell中。</p>
<p>再次编译运行应用，设置字体样式，然后看看我们的应用有没有正确的响应你的设置。</p>
<h2 id="u4F7FCell_u9AD8_u5EA6_u81EA_u9002_u5E94"><a href="#u4F7FCell_u9AD8_u5EA6_u81EA_u9002_u5E94" class="headerlink" title="使Cell高度自适应"></a>使Cell高度自适应</h2><p>响应字体设置这部分到目前为止我们已经处理完了，效果也不错，但是当你把字体设置为一个足够小的，或者最小的字体时，在TableView中看起来就不怎么好看了，因为Cell的高度没有变化，而字体很小，所以看起来很不美观，比如下面左侧的截图一样：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-7.png" alt="pic"></p>
<p>这个问题是iOS7中在Dynamic Type中比较坑爹的一个问题。想要使你的应用在不同字体样式下都显示的比较完美，你必须要让Cell的高度根据字体样式的大小做出相应的调整。虽然Auto Layout能帮你解决大部分布局适配上的问题，但在这个问题上，它就比较无力了，这得需要你自己去解决了。</p>
<p>解决这个问题的原理很简单，就是让TableView的Cell高度根据字体样式的大小进行改变。那么可以通过实现<code>UITextViewDelegate</code>的<code>tableView(_:heightForRowAtIndexPath:)</code>方法来解决该问题。</p>
<p>在<code>NotesListViewController.swift</code>中加入如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> label: <span class="type">UILabel</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> temporaryLabel = <span class="type">UILabel</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="type">Int</span>.<span class="built_in">max</span>, height: <span class="type">Int</span>.<span class="built_in">max</span>))</span><br><span class="line">  temporaryLabel.text = <span class="string">"test"</span></span><br><span class="line">  <span class="keyword">return</span> temporaryLabel</span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView!, heightForRowAtIndexPath indexPath: NSIndexPath!)</span></span> -&gt; <span class="type">CGFloat</span> &#123;</span><br><span class="line">  label.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleHeadline</span>)</span><br><span class="line">  label.sizeToFit()</span><br><span class="line">  <span class="keyword">return</span> label.frame.height * <span class="number">1.7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，首先创建了一个<code>UILabel</code>的实例，用于计算TableView中Cell的高度，也就是这个<code>UILabel</code>的高度就是Cell的高度，然后在<code>tableView(_:heightForRowAtIndexPath:)</code>方法中设置该<code>UILabel</code>的字体样式，调用<code>sizeToFit</code>方法使Label的高度适配字体的高度，最后将Label的高度返回，也就相当于将Cell的高度设置为Label的高度了。这里需要注意的是当调用完<code>sizeToFit</code>方法后，Label与它里面字体之间几乎没有上下间隔，所以我们在返回高度的时候乘以一个上下间隔的比例系数。</p>
<p>再次编译和运行你的应用，多更改几次字体样式，你会看到Cell的高度随着字体样式也进行着调整：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-8.png" alt="pic"></p>
<h2 id="u7ED9_u6587_u672C_u6DFB_u52A0_u5370_u5237_u6548_u679C"><a href="#u7ED9_u6587_u672C_u6DFB_u52A0_u5370_u5237_u6548_u679C" class="headerlink" title="给文本添加印刷效果"></a>给文本添加印刷效果</h2><p>给文本添加一点高亮和阴影来达到文本像嵌入纸张的那种印刷效果。</p>
<p>打开<code>NotesListViewController.swift</code>用下面的代码替换<code>tableView(_:cellForRowAtIndexPath:)</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(tableView: UITableView!, cellForRowAtIndexPath indexPath: NSIndexPath!)</span></span> -&gt; <span class="type">UITableViewCell</span>? &#123;</span><br><span class="line">  <span class="keyword">let</span> cell = tableView.dequeueReusableCellWithIdentifier(<span class="string">"Cell"</span>, forIndexPath: indexPath) <span class="keyword">as</span> <span class="type">UITableViewCell</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> note = notes[indexPath.row]</span><br><span class="line">  <span class="keyword">let</span> font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleHeadline</span>)</span><br><span class="line">  <span class="keyword">let</span> textColor = <span class="type">UIColor</span>(red: <span class="number">0.175</span>, green: <span class="number">0.458</span>, blue: <span class="number">0.831</span>, alpha: <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> attributes = [</span><br><span class="line">    <span class="type">NSForegroundColorAttributeName</span> : textColor,</span><br><span class="line">    <span class="type">NSFontAttributeName</span> : font,</span><br><span class="line">    <span class="type">NSTextEffectAttributeName</span> : <span class="type">NSTextEffectLetterpressStyle</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="keyword">let</span> attributedString = <span class="type">NSAttributedString</span>(string: note.title, attributes: attributes)</span><br><span class="line"> </span><br><span class="line">  cell.textLabel?.attributedText = attributedString</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> cell</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码给TableView的Cell中的文本添加了颜色和<code>NSTextEffectLetterpressStyle</code>文字样式。</p>
<p>编译运行应用，你会看到更加立体的文本：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-9.png" alt="pic"></p>
<p>这种印刷效果虽然只是一种较为细微的效果，但这并不代表你就能滥用这种效果，它虽然能使文本看起来有立体感，但是有可能会影响到文本的清晰度。</p>
<h2 id="u6587_u672C_u7ED5_u884C_u6392_u7248"><a href="#u6587_u672C_u7ED5_u884C_u6392_u7248" class="headerlink" title="文本绕行排版"></a>文本绕行排版</h2><p>一般我们在常用的文本编辑器，比如Word中都能看到文本围绕图片或表格等其他元素的排版格式。TextKit也提供了能让文本按指定的路径排版或按一定形状排版的功能，叫做绕行路径。</p>
<p>下面我们希望在笔记详细页中添加一个圆形的视图，放在右上角，用于显示这篇笔记的创建时间。</p>
<p>当你创建完视图摆好位置后，你会发现这个圆形的视图会遮盖住笔记文本信息，所以我们需要给文本创建一个绕行路径来绕开这个圆形的视图。</p>
<h3 id="u6DFB_u52A0_u5706_u5F62_u89C6_u56FE"><a href="#u6DFB_u52A0_u5706_u5F62_u89C6_u56FE" class="headerlink" title="添加圆形视图"></a>添加圆形视图</h3><p>打开<code>NoteEditorViewController.swift</code>，申明一个属性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> timeView: <span class="type">TimeIndicatorView</span>!</span><br></pre></td></tr></table></figure>
<p>然后在<code>viewDidLoad</code>方法的最后添加如下代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">timeView = <span class="type">TimeIndicatorView</span>(date: note.timestamp)</span><br><span class="line">textView.addSubview(timeView)</span><br></pre></td></tr></table></figure>
<p>创建一个<code>timeView</code>的示例，然后将它作为一个子视图添加到<code>textView</code>中。</p>
<p>刚才创建的视图需要合适的尺寸大小，你需要一种机制在ViewController绘制子视图调用<code>updateSize</code>方法来计算尺寸。</p>
<p>所以我们加入如下两个方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">  updateTimeIndicatorFrame()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">updateTimeIndicatorFrame</span><span class="params">()</span></span> &#123;</span><br><span class="line">  timeView.updateSize()</span><br><span class="line">  timeView.frame = <span class="type">CGRectOffset</span>(timeView.frame, textView.frame.width - timeView.frame.width, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>viewDidLayoutSubviews</code>方法会调用<code>updateTimeIndicatorFrame</code>方法，该方法会处理两件事，一个是调用<code>updateSize</code>方法设置<code>timeView</code>的尺寸，另一个是设置<code>timeView</code>的位置，使它处于<code>textView</code>的右上角。</p>
<p>之后每次当ViewController接收到文本字体样式更改的时候都会调用<code>updateTimeIndicatorFrame</code>方法，以便将<code>timeView</code>的尺寸和位置调整到合适的状态。所以我们更改一下<code>preferredContentSizeChanged</code>方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">preferredContentSizeChanged</span><span class="params">(notification: NSNotification)</span></span> &#123;</span><br><span class="line">  textView.font = <span class="type">UIFont</span>.preferredFontForTextStyle(<span class="type">UIFontTextStyleBody</span>)</span><br><span class="line">  updateTimeIndicatorFrame()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在编译运行应用，点击笔记条目进入详细信息页后你就会在右上角看到一个显示创建时间的圆形视图：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-10.png" alt="pic"></p>
<p>你可以在设置中改变字体样式，显示创建日期的视图会根据字体样式自动调整到合适的大小。</p>
<p>但是你们会发现还有一些美中不足的地方，那就是日期视图把笔记文本信息给遮住了，幸运的是TextKit提供的文本绕行路径能帮我们解决这个问题。</p>
<h3 id="u521B_u5EFA_u7ED5_u884C_u8DEF_u5F84"><a href="#u521B_u5EFA_u7ED5_u884C_u8DEF_u5F84" class="headerlink" title="创建绕行路径"></a>创建绕行路径</h3><p>打开<code>TimeIndicatorView.swift</code>，看看<code>curvePathWithOrigin</code>方法，日期视图在填充渲染背景色的时候会调用该方法，但是你可以通过该方法来决定文本的绕行路径，该方法会自己计算视图的贝塞尔曲线，也就相当于是文本的绕行路径了。</p>
<p>打开<code>NoteEditorViewController.swift</code>，在<code>updateTimeIndicatorFrame</code>方法末尾中添加如下两行代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> exclusionPath = timeView.curvePathWithOrigin(timeView.center)</span><br><span class="line">textView.textContainer.exclusionPaths = [exclusionPath]</span><br></pre></td></tr></table></figure>
<p>上面的代码通过日期视图的<code>curvePathWithOrigin</code>方法基于贝塞尔曲线计算出绕行路径，然后放在数组中赋值给<code>textView.textContainter.exclusionPaths</code>属性。这里要注意的是绕行路径的起点和坐标与文本信息是相对位置。</p>
<p>编译运行应用，现在你就可以看到文本信息都绕开了日期视图：</p>
<p><img src="http://www.devtalking.com/postImages/text-kit-tutorial-in-swift-11.png" alt="pic"></p>
<p>这个简单的示例只是体现出了绕行路径强大功能的冰山一角，从上面的代码中你可能也注意到了，绕行路径是放在数组中进行赋值的，所以这就意味着每个容器，不管是文本容器还是其他容器都可以被设置多个绕行路径。</p>
<p>除此之外，绕行路径可以随着你的想法变得简单或者复杂，你甚至可以让文本围绕着星星形状或者蝴蝶形状排版。</p>
<p>每当绕行路径发生改变时，文本容器就会通知布局管理器，你可以让绕行路径进行动态的改变，比如从星星形状的路径变成蝴蝶形状的路径，此时文本容器也会动态的改变排版。但是这样做会得不偿失，因为用户在阅读的时候看到文字动来动去，估计会砸了手机！</p>
<p>未完待续……</p>
<p>原文地址：<a href="http://www.raywenderlich.com/77092/text-kit-tutorial-swift" target="_blank" rel="external">Text Kit Tutorial in Swift</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/failable-initializers/" itemprop="url">
                  可失败构造器（Failable Initializers）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-21T00:00:00+08:00" content="2014-10-21">
              2014-10-21
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/failable-initializers/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/failable-initializers/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


<p><a href="https://developer.apple.com/xcode/downloads/" target="_blank" rel="external">Xcode6.1</a>中Swift的最新版本是1.1，在该版本中引入了一个新的特性：可失败构造器。通过构造器初始化实际上是给<code>class</code>或<code>struct</code>的每一个存储属性（参数）提供初始值，进行对象实例化的过程。在一些情况下，初始化的过程是有可能失败的。比如，实例化一个对象，在实例化的过程中需要访问资源文件，就像从文件中加载图片一样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">NSImage</span>(contentsOfFile: <span class="string">"swift.png"</span>)</span><br></pre></td></tr></table></figure>
<p>如果该文件不存在或者因为某种原因不允许访问，那么<code>NSImage</code>的初始化过程就会失败。在Swift 1.1版本中，像这种情况可以通过可失败构造器进行捕获。如果在构造一个对象时使用可失败构造器，那么当对象构造成功时返回该对象，当对象构造失败时则返回<code>nil</code>。因此可以直接用条件判断语句使用可失败构造器来实例化对象：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> image = <span class="type">NSImage</span>(contentsOfFile: <span class="string">"swift.png"</span>) &#123;</span><br><span class="line">    <span class="comment">// loaded the image successfully</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// could not load the image</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>init</code>初始化方法可以通过在<code>init</code>关键字后面加上<code>?</code>或<code>!</code>将其变为可失败初始化方法，这样就表示某对象的初始化方法会产生两种结果。比如，将<code>Int</code>类型的<code>init</code>初始化方法变为可失败初始化方法，然后执行<code>String</code>类型转换：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>?(fromString: <span class="type">String</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> i = fromString.toInt() &#123;</span><br><span class="line">            <span class="comment">// Initialize</span></span><br><span class="line">            <span class="keyword">self</span> = i</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// return nil, discarding self is implied</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在可失败构造器或可失败初始化方法中，一旦返回<code>nil</code>就代表构造失败或初始化失败，不会再返回其他的值。在上述的示例中，当<code>String</code>不能解析为<code>Integer</code>时会导致初始化失败，返回<code>nil</code>，否则返回解析成功后的值。</p>
<p>可失败构造器/初始化方法解决了以前在Swift中只能通过工厂方法捕获构造或初始化失败情况的问题。比如，一个枚举，通过<code>fromRaw</code>工厂方法通过一个原始值来寻找它所对应的枚举成员，返回类型为可选枚举类型。即如果该原始值对应的枚举成员存在，那么返回该枚举成员，如果不存在则返回<code>nil</code>。现在，Swift编译器结合可失败构造器，通过可失败的初始化方法用<code>switch</code>语句判断原始值对应的枚举成员，如果没有对应的则返回<code>nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> : <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Red</span> = <span class="number">0</span>, <span class="type">Green</span> = <span class="number">1</span>, <span class="type">Blue</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// implicitly synthesized</span></span><br><span class="line">    <span class="keyword">var</span> rawValue: <span class="type">Int</span> &#123; <span class="comment">/* returns raw value for current case */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// implicitly synthesized</span></span><br><span class="line">    <span class="keyword">init</span>?(rawValue: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> rawValue &#123; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">self</span> = .<span class="type">Red</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">self</span> = .<span class="type">Green</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">self</span> = .<span class="type">Blue</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用可失败构造器可极大程度的统一Swift中的构造对象语法，消除了构造器与工厂方法之间混乱、重复的冗余语法，使Swift更加简洁。随着可失败构造器这一特性的加入，Swift将对大多数Cocoa中带<code>NSError</code>参数的工厂初始化方法进行调整，从而加强Swift中构造对象语法的统一性，给开发者带来更好的开发体验。</p>
<p>原文地址：<a href="https://developer.apple.com/swift/blog/?id=17" target="_blank" rel="external">Failable Initializers</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/adaptive-layout-for-iphone6-2/" itemprop="url">
                  为iPhone6设计自适应布局（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-17T00:00:00+08:00" content="2014-10-17">
              2014-10-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/adaptive-layout-for-iphone6-2/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/adaptive-layout-for-iphone6-2/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h2 id="Size_Classes"><a href="#Size_Classes" class="headerlink" title="Size Classes"></a>Size Classes</h2><p>自适应布局的布局约束自然是好东西，但也不是万能的，有时候我们也需要使用最基本的布局，所以使用size classes将它们两者结合起来才能碰撞出更有激情的火花。</p>
<blockquote>
<p>引用我上篇译文中的一段话：<br>Size Classes并不代表真正的尺寸，而是我们从感官上感觉尺寸的种类，通过这种种类的组合，表示出不同屏幕尺寸设备的横屏及竖屏。</p>
</blockquote>
<p>我们在给storyboard中的对象添加约束时可以选择给某一个size class添加约束，所以在你选择特定的size class时，只能看到你添加的只适用于该size class的约束。</p>
<p>这些特性能使我们有效的在不同的设备和屏幕方向中定义、设计不同的用户界面。</p>
<h3 id="Size_Classes_u4E2D_u7684_u9AD8_u548C_u5BBD"><a href="#Size_Classes_u4E2D_u7684_u9AD8_u548C_u5BBD" class="headerlink" title="Size Classes中的高和宽"></a>Size Classes中的高和宽</h3><p>Size Classes为高和宽分别提供了三种类型：紧凑型（compact）、普通型（regular）、任意型（any）。用这三种高和宽的类型就可以组合出9种size class，来表示不同的设备屏幕。</p>
<p>在实际运用中，我们发现并不是所有的尺寸都能在Size Classes中找到明确的组合（比如没有组合可以明确表示iPhone6 Plus的竖屏，iPad的横竖屏也不好区分），但是我们可以使用表示这个尺寸范围的组合。比如我们可以用Compact Width | Regular Height来表示iPhone6 Plus的竖屏。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-23.png" alt="图片"></p>
<p>接下来还是用一个活生生的示例来向大家介绍Size Classes。</p>
<h3 id="u6211_u4EEC_u7684_u76EE_u6807"><a href="#u6211_u4EEC_u7684_u76EE_u6807" class="headerlink" title="我们的目标"></a>我们的目标</h3><p>这个示例是实现Instagram的一个详细信息页面，并让它自适应更大的屏幕尺寸，在竖屏和横屏中都展现出最合适的布局。</p>
<p>我们的目标是让布局自适应iPhone6的屏幕（这里需要注意一下，我所说的自适应是指图片、文字信息的布局排版，对于个人信息的头像不会根据布局的变化而变化），在竖屏中各个信息按照堆栈方式从上到下布局，在横屏时各元素按照大小进行有序排列，而不再是堆栈的方式：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-24.png" alt="图片"></p>
<h3 id="u7ED9_u901A_u7528_u7684size_class_u6DFB_u52A0_u7EA6_u675F"><a href="#u7ED9_u901A_u7528_u7684size_class_u6DFB_u52A0_u7EA6_u675F" class="headerlink" title="给通用的size class添加约束"></a>给通用的size class添加约束</h3><p>在这个示例中，我们不会像上个示例那样使用模拟器的实际尺寸来设计布局，我们使用Size Classes提供的抽象的屏幕尺寸，这里我们先使用通用的尺寸来设计布局，也就是<strong>w Any | h Any</strong>尺寸。我们要注意的是，在这个尺寸下添加的view或者约束必须是一些公用的，也就是说在任何尺寸，任何屏幕方向的情况下都适用的。</p>
<p>这些约束包括：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-25.png" alt="图片"></p>
<p>除了之前介绍过的页边间距约束、水平间距约束、等高等宽约束、方向比例约束外还有顶部、底部间距约束。</p>
<p>添加完上述的view和约束后，storyboard里应该是这番景象：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-26.png" alt="图片"></p>
<p>这里要注意一下，目前这个界面的布局还有很多关键点需要考虑横屏和竖屏的布局，但是这些工作不会在<strong>w Any | h Any</strong>尺寸下进行。大伙接着往下看。</p>
<h3 id="u4E3AiPhone_u7684_u7AD6_u5C4F_u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F"><a href="#u4E3AiPhone_u7684_u7AD6_u5C4F_u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F" class="headerlink" title="为iPhone的竖屏添加布局约束"></a>为iPhone的竖屏添加布局约束</h3><p>现在在Size Classes选择器中选择<strong>w Compact | h Regular</strong>尺寸，这个size class适用于所有iPhone设备的竖屏界面，不论尺寸是多少。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-27.gif" alt="图片"></p>
<p>当你在Size Classes选择器中选择某一个size class后，storyboard<br>中的view controller会实时的反映出你改变后的尺寸大小。</p>
<p>现在你就可以为iPhone的竖屏状态重新设计view的位置和添加新的布局约束了。下图中说明了我在竖屏状态下添加的约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-28.png" alt="图片"></p>
<p>我的storyboard中看起来是这样的：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-29.png" alt="图片"></p>
<p>在这个阶段，你可以在3.5、4、4.7、5.5这几个尺寸的模拟器中编译运行应用，在竖屏状态下看看它们的运行情况，尽管在横屏状态表现的还很糟糕。</p>
<p>这里要注意的是我们并没有定义图片的宽度，我们只是给图片添加了相对父容器的左右边间距，并将其值设为了0。所以当屏幕尺寸增大的时候图片的宽度在布局约束的作用下也会增加，这时又因为我们给图片添加了高宽比例约束，所以图片的高度也会随之增加。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-30.png" alt="图片"></p>
<h3 id="u4E3AiPhone_u7684_u6A2A_u5C4F_u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F"><a href="#u4E3AiPhone_u7684_u6A2A_u5C4F_u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F" class="headerlink" title="为iPhone的横屏添加布局约束"></a>为iPhone的横屏添加布局约束</h3><p>打开Size Classes选择器，选择<strong>w Any | h Compact</strong>，这个size class适用于任何一个尺寸的横屏状态。我们将在这个size class下设计我们希望在iPhone横屏时显示的用户界面。</p>
<p>此时图片的顶部、左侧、底部都添加了相对于父容器的边界约束。在显示评论的label上添加了右侧边界约束。</p>
<p>当设备横屏时，图片在布局约束的作用下移到了左侧，个人信息label和评论label在约束的作用下被挤到了右侧，并且评论label的高度增加，宽度减少。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-31.png" alt="图片"></p>
<p>现在来看看我的storyboard中显示的内容。大家注意左侧的对象结构树中有很多个约束，但是有些是灰色的。那是因为这些灰色的约束在当前的size class下是禁用的，或者说不适用、不起作用。那些是竖屏时用到的约束。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-32.png" alt="图片"></p>
<p>现在在storyboard中切换size class时布局也会随之变化，更新非常及时和平滑。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-33.gif" alt="图片"></p>
<p>我们在模拟器中编译运行应用，切换横竖屏，可以看到布局切换的效果，过度非常自然平滑。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-1.gif" alt="图片"></p>
<blockquote>
<p>为了能让大家看清楚布局变化过度的细节，我放慢了这个git动画。大家注意，在布局变化时屏幕上的组件有一个层级关系，从该示例中我们可以看到图片view的层级高于个人信息label和评论label。所以我们在设计布局的时候就要考虑如何给view分层，包括在普通布局中不会被覆盖的view。这是一个细节问题。</p>
</blockquote>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h3 id="u5C4F_u5E55_u9884_u89C8_u52A9_u624B_u7F16_u8F91_u5668"><a href="#u5C4F_u5E55_u9884_u89C8_u52A9_u624B_u7F16_u8F91_u5668" class="headerlink" title="屏幕预览助手编辑器"></a>屏幕预览助手编辑器</h3><p>Xcode6中另一个值得关注的功能是屏幕预览助手。它可以避免你一遍遍的在不同屏幕尺寸的模拟器中编译运行应用来检查布局的正确与否。你可以在屏幕预览编辑器中添加一个或多个你想查看的屏幕尺寸，并可以让他们呈现横屏或竖屏的状态。</p>
<p>当然它也不是非常完美（因为在预览时导航栏的颜色会丢失），但是切换<em>Double Length Pseudolanguage</em>选项很方便，便于你检查问题。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-34.gif" alt="图片"></p>
<p>从上图中大家可以看到我在屏幕预览编辑器中显示了3.5寸屏幕的横屏和4寸屏幕的竖屏，整体布局没有问题，但是当选择<em>Double Length Pseudolanguage</em>使label中的文字都增加一倍时，问题就出现了，个人信息和评论的label长度没有自适应。</p>
<h3 id="u4E3AiPad_u5E03_u5C40_u6DFB_u52A0_u7EA6_u675F"><a href="#u4E3AiPad_u5E03_u5C40_u6DFB_u52A0_u7EA6_u675F" class="headerlink" title="为iPad布局添加约束"></a>为iPad布局添加约束</h3><p>现在我们将Sizae Classes调整为<strong>w Regular | h Regular</strong>，这个size class表示了iPad的横屏和竖屏大小。</p>
<p>和往常一样，我们先调整图片和各个label的位置及大小，调整满意后，再添加相关的约束。在iPad布局中我打算将图片的尺寸设置为固定尺寸（不像iPhone中那样随着横屏和竖屏改变图片的尺寸），并将个人信息和评论label紧跟在图片下面。</p>
<p>我的storyboard现在看起来是这样的：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-35.png" alt="图片"></p>
<p>以往，我们都是在特定的size class中添加相关的约束，但在iPad布局中，我们不仅仅只添加一些约束。</p>
<p>因为在iPad布局中有很大的空余空间，所以我们不只是重新排列一下组件的位置和大小，我们还要添加一些其他的组件。在这个示例中，我们再添加两个图片view（分别表示当前显示图片的上一张图片和下一张图片）。</p>
<p>再来看看我的storyboard：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-36.png" alt="图片"></p>
<p>我们不需要对这两个图片手动的设置高宽，而是给它们设置对于主显示图片的相对高宽即可。</p>
<p>这样做的好处是当主显示图片的尺寸更改时，我们不需要自己手动计算和更改这两个图片的尺寸，相对高宽会自动针对主显示图片的尺寸调整这两个图片的尺寸。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-37.gif" alt="图片"></p>
<p>我没有制作在iPad上运行的gif动画，但这里有iPad横屏竖屏的运行图片，大家可以看看：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-38.png" alt="图片"></p>
<h2 id="u4F7F_u7528_u5E03_u5C40_u89C6_u56FE_u548C_u95F4_u8DDD_u89C6_u56FE"><a href="#u4F7F_u7528_u5E03_u5C40_u89C6_u56FE_u548C_u95F4_u8DDD_u89C6_u56FE" class="headerlink" title="使用布局视图和间距视图"></a>使用布局视图和间距视图</h2><p>目前Xcode提供的布局约束可以满足大部分的布局需求，但是有些场景下需要变通的使用约束才能达到我们想要的效果。</p>
<h3 id="u5E03_u5C40_u89C6_u56FE_u793A_u4F8B"><a href="#u5E03_u5C40_u89C6_u56FE_u793A_u4F8B" class="headerlink" title="布局视图示例"></a>布局视图示例</h3><p>通过Xcode提供的约束，我们可以很容易设置组件与view controller view的边缘的间距，也可以很容易的让组件在view controller view中水平居中显示和垂直居中显示。但是却不太容易设置组件与view controller view的水平中线或垂直中线的间距。像这样：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-39.png" alt="图片"></p>
<p>下面向大家介绍两种实现该需求的方法。首先我们先添加一个view，背景色设置为透明，让它在屏幕中垂直居中显示，它作为该需求中组件的父容器，因为父容器在屏幕中是垂直居中的，所以可以给组件添加相对于父容器的Center X约束，就可以达到我们的需求了：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-40.png" alt="图片"></p>
<p>但是通过上述的方式未免会使我们的布局的层级关系太过复杂，我更希望布局比较扁平一些，不需要太多的层级关系。因为上述方法中的容器view主要是用于布局使用，所以这种view我称之为布局视图。</p>
<p>我们来改进一下方法，首先也是在view controller view中添加一个布局视图，我习惯将高度设置为20（这个值随个人喜好或实际情况而定），然后将它和屏幕的顶部、左侧、右侧的间距设为0，这样的话这个布局视图就和状态栏重合了，我们将这个布局视图设置一个深一点的颜色，然后将它的<code>hidden</code>属性设置为<code>true</code>，这样布局视图的颜色就会变浅，也不太会影响我们的布局，而且在应用运行时是不会显示该视图的。现在我们的组件就可以设置相对于布局视图的Center X约束来实现我们的需求了。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-41.png" alt="图片"></p>
<h3 id="u95F4_u9694_u89C6_u56FE_u793A_u4F8B"><a href="#u95F4_u9694_u89C6_u56FE_u793A_u4F8B" class="headerlink" title="间隔视图示例"></a>间隔视图示例</h3><p>之前我们学习了如何使用约束设置视图和视图边缘的间距，并且当屏幕尺寸增加时视图也会相应的改变大小，但它们的间距不会改变。</p>
<p>但是如果我们希望当屏幕增加尺寸时，视图的大小保持不变，只是增加间距呢？</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-42.png" alt="图片"></p>
<p>从理论上讲，实现该需求可能可以使用类似等宽这样的约束，但是现实往往的是骨干感的。</p>
<p>这时我们就需要间距视图出场了，和布局视图一样，间距视图可以设置一个深一点的颜色，<code>hidden</code>属性要设置为<code>true</code>。</p>
<p>我们在每个视图与视图间距之间添加一个间距视图，设置每个视图与相邻间距视图的边缘间距约束，然后给所有的间距视图添加相对于view controller view的等宽约束，设置合适的比例即可。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-43.png" alt="图片"></p>
<p>原文地址：<a href="http://mathewsanders.com/designing-adaptive-layouts-for-iphone-6-plus" target="_blank" rel="external">ADAPTIVE LAYOUTS FOR iPHONE 6</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/adaptive-layout-for-iphone6-1/" itemprop="url">
                  为iPhone6设计自适应布局（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-16T00:00:00+08:00" content="2014-10-16">
              2014-10-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/adaptive-layout-for-iphone6-1/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/adaptive-layout-for-iphone6-1/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<blockquote>
<p>译者的话：<br>本文是自适应布局的巩固篇，所以对布局约束的添加操作步骤等没有详细的说明。如果看着吃力的话请先移步<a href="http://www.devtalking.com/articles/adaptive-layout-1/">Swift自适应布局（Adaptive Layout）教程</a>。</p>
</blockquote>
<p>Apple从iOS6加入了Auto Layout后开始就比较委婉的开始鼓励、建议开发者使用自适应布局，但是到目前为止，我感觉大多数开发者一直在回避这个问题，不管是不是由于历史原因造成的，至少他们在心底还坚守着固定布局的老传统思想。</p>
<p>随着iPhone6、iPhone6 Plus的到来，使用自适应布局更是迫在眉睫的事，固定布局的老传统思想脆弱的不堪一击。现在的iPhone有4种尺寸，如果算上iPad，现在Apple的iOS设备有5种尺寸。我们在准备使用自适应布局设计应用界面之前，可以把这5种尺寸划分为3种分辨率和屏幕方向，这样在设计时分类会更加清晰一些。</p>
<p>我们先来看一张自适应布局的效果图：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-1.gif" alt="图片"></p>
<p>当你们学习完这篇文章后，你们应该会比较自如的使用 <em>storyboard</em>、<em>constaints</em>、<em>size classes</em> 这三个Apple在Xcode里提供的工具，去探索和构建巧妙的自适应布局。</p>
<h2 id="Storyboards"><a href="#Storyboards" class="headerlink" title="Storyboards"></a>Storyboards</h2><p>在Xcode中，storyboard是一个可以让我们对应用界面进行可视化布局的工具，你首先可以在storyboard文件中看到一个或若干个iOS设备屏幕大小的布局区，然后你可以从组件库（Object Library）中拖拽组件到屏幕布局区中进行布局（比如按钮、图片、文本框、labels等），你还可以定义屏幕布局区之间的连接关系。</p>
<p>用Xcode的术语来说，人们可以看到、触碰到或以其他方式（按钮、图片、文本框、labels等）进行交互的用户界面被称为<em>views</em>。屏幕中包含和管理这些views的容器称为<em>view controller</em>。</p>
<p>当我们在storyboard中添加一个view controller后，我们所看到的并不是一个我们熟知的屏幕尺寸，而是一个600X600的正方形：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-2.png" alt="图片"></p>
<p>从上图我们可以很明显的看出，storyboard中显示的屏幕尺寸不是实际设备的尺寸。Apple这样做的目的是将屏幕尺寸进行了抽象化，也就是说你可以将这个正方形的屏幕看成iphone4的屏幕，也可以将它看成iphone6的屏幕。</p>
<h3 id="u6A21_u62DF_u5668_u7684_u5C3A_u5BF8"><a href="#u6A21_u62DF_u5668_u7684_u5C3A_u5BF8" class="headerlink" title="模拟器的尺寸"></a>模拟器的尺寸</h3><p>当你习惯了600X600的屏幕后，你可能会用着很爽，但是有些时候，我们也需要将它改成实际的屏幕尺寸来设计一些东西。</p>
<p>我们可以很方便的在Xcode中改变view controller的模拟屏幕尺寸和屏幕方向：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-3.gif" alt="图片"></p>
<h2 id="u5E03_u5C40_u7EA6_u675F"><a href="#u5E03_u5C40_u7EA6_u675F" class="headerlink" title="布局约束"></a>布局约束</h2><p>介绍布局约束的最好、最直观的方法就是向你们展示一个示例。</p>
<p>首先我们将storyboard中的屏幕布局区域的尺寸调整为iphone5s的尺寸，也就是4寸屏幕，然后添加两个正方形的view，并排放置在屏幕顶部，一个设置为蓝色，一个设置为粉色。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-4.png" alt="图片"></p>
<p>我们选择iPhone5s模拟器设备并编译运行应用，可以看到一蓝一粉这两个方块按照我们设定的那样杵在竖屏方向的屏幕上，没有问题。当我们把设备调整为横屏时，这两个方块像拥护党一样拥护着他们的坐标位置，所以在横屏的时候看着就不是那么完美：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-5.gif" alt="图片"></p>
<p>我们再将模拟器改为iPhone6，然后编译运行，此时在竖屏的时候就已经感觉无法再爱了。这两个方块并没有按照我们设置或设想的那样在屏幕顶部中间，而是偏向了左边，在右边有一块留白区域。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-6.png" alt="图片"></p>
<p>这是就是没有布局约束而导致的，蓝色粉色方块的大小、坐标位置都是固定的，都是在4寸屏幕的参照下设置的，不论在哪种尺寸的屏幕下，它们都在固定的那个坐标位置和固定的大小，所以就会出现上面的情况。</p>
<p>那么接下来让我们给这两个方块添加一些布局约束，再看看会有什么神奇的事情发生。</p>
<h3 id="u9875_u8FB9_u95F4_u8DDD_u7EA6_u675F_uFF08Leading_and_Trailing_space_uFF09"><a href="#u9875_u8FB9_u95F4_u8DDD_u7EA6_u675F_uFF08Leading_and_Trailing_space_uFF09" class="headerlink" title="页边间距约束（Leading and Trailing space）"></a>页边间距约束（Leading and Trailing space）</h3><p>页边间距约束分前部间距约束（Leading space constaint）和尾部间距约束（Trailing space constaint）。从屏幕上说就是左边距和右边距。我们给蓝色方块添加左边距约束，其值设置为10，给粉色方块设置右边距约束，其值也设置为10。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-7.png" alt="图片"></p>
<p>我们再次在iPhone5s模拟器中运行应用，当横屏时蓝色方块被左边距约束拉到了屏幕左边，粉色方块被右边距约束拉到了屏幕右边。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-8.gif" alt="图片"></p>
<h3 id="u6C34_u5E73_u95F4_u8DDD_u7EA6_u675F_uFF08Horizontal_space_constaint_uFF09"><a href="#u6C34_u5E73_u95F4_u8DDD_u7EA6_u675F_uFF08Horizontal_space_constaint_uFF09" class="headerlink" title="水平间距约束（Horizontal space constaint）"></a>水平间距约束（Horizontal space constaint）</h3><p>给蓝色方块和粉色方块添加水平间距约束，其值设置为10。这个约束会使这两个方块之间的距离永远约束为10。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-9.png" alt="图片"></p>
<p>我们再来运行应用，现在横屏时两个方块之间的间距、它们与屏幕边缘的间距都和竖屏时显示的一样了。但是其中粉色方块为了满足水平间距约束自行增加了方块的宽度，变成了长方形。简直是一只老鼠坏了一锅汤有木有。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-10.gif" alt="图片"></p>
<p>从上面这个效果我们可以得知，除非我们特别限制了view的尺寸，否则的话iOS会为满足布局约束而改变view的尺寸，也就是保持一个自然的尺寸。</p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h3 id="u7B49_u5BBD_u7EA6_u675F_uFF08Equal_widths_constaint_uFF09"><a href="#u7B49_u5BBD_u7EA6_u675F_uFF08Equal_widths_constaint_uFF09" class="headerlink" title="等宽约束（Equal widths constaint）"></a>等宽约束（Equal widths constaint）</h3><p>我们给这两个方块添加一个等宽约束来改善上面的情况。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-11.png" alt="图片"></p>
<p>再次运行应用，现在在横屏时由于等宽约束的作用，两个方块的宽度保持了一致。我们已经非常接近完美了。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-12.gif" alt="图片"></p>
<h3 id="u65B9_u5411_u6BD4_u4F8B_u7EA6_u675F_uFF08Aspect_ratio_constaint_uFF09"><a href="#u65B9_u5411_u6BD4_u4F8B_u7EA6_u675F_uFF08Aspect_ratio_constaint_uFF09" class="headerlink" title="方向比例约束（Aspect ratio constaint）"></a>方向比例约束（Aspect ratio constaint）</h3><p>从上面的运行情况来看各个约束都工作正常，但唯一不足的是本来在竖屏是两个正方形方块，在横屏时缺变成了长方形方块，由范爷变成了凤姐这是人类无法接受的。</p>
<p>我们给这两个方块添加方向比例约束来解决这个问题。这个约束使方块在满足其他约束的前提下始终保持高和宽的比例相同。所以在横屏时就会以方块的宽度为比例标准，将高度的比例改为宽度的比例。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-13.png" alt="图片"></p>
<p>用iPhone5s模拟器编译运行应用，现在在横屏状态下两个正方形方块完美的呈现在我们眼前。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-14.gif" alt="图片"></p>
<p>我们在iPhone6模拟器上再编译运行应用，从下面的图中我们可以很清晰的看到添加约束之前和之后的变化。布局约束根据多出的空间大小将方块放大到合适的尺寸以满足约束。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-15.png" alt="图片"></p>
<h3 id="u5B9E_u8DF5_u5E03_u5C40_u7EA6_u675F"><a href="#u5B9E_u8DF5_u5E03_u5C40_u7EA6_u675F" class="headerlink" title="实践布局约束"></a>实践布局约束</h3><p>到目前为止，你们已经看到布局约束神奇的作用和效果。是时候让你们在你们自己的storyboard文件中添加布局约束了。</p>
<p>熟练布局约束最好的方法就是多练习，从添加少量的布局约束开始，一步步达到自己想要的效果。</p>
<p>另外有一点，我始终不认为添加过多的布局约束会对应用的性能产生影响。但是我们也不能滥用约束布局，好钢要用在刀刃上，我们尽可能用最节俭的约束布局达到我们想要的效果。</p>
<h3 id="u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F_u7684_u65B9_u5F0F"><a href="#u6DFB_u52A0_u5E03_u5C40_u7EA6_u675F_u7684_u65B9_u5F0F" class="headerlink" title="添加布局约束的方式"></a>添加布局约束的方式</h3><p>这里向大家介绍三种在storyboard中添加约束的方式：</p>
<h4 id="1-_u5E95_u90E8_u5E03_u5C40_u7EA6_u675F_u6309_u94AE"><a href="#1-_u5E95_u90E8_u5E03_u5C40_u7EA6_u675F_u6309_u94AE" class="headerlink" title="1.底部布局约束按钮"></a>1.底部布局约束按钮</h4><p>这种方式可能是最简单直观的一种方式，在屏幕上选择一个或多个对象，然后点击底部的布局约束按钮添加一个或多个需要的约束。它的好处是可以直观的看到当前选择的对象已经添加了该类中的那些约束。</p>
<p>如果你指选择了一个对象想要添加某个约束，但发现该约束是不可选的，那么就意味着这个约束是适用于两个以上对象的约束。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-16.gif" alt="图片"></p>
<h4 id="2-_u6309_u4F4FControl_u952E_u62D6_u62FD_u9F20_u6807"><a href="#2-_u6309_u4F4FControl_u952E_u62D6_u62FD_u9F20_u6807" class="headerlink" title="2.按住Control键拖拽鼠标"></a>2.按住Control键拖拽鼠标</h4><p>你也可以选择一个对象，然后按住Control键和鼠标左键，拖拽鼠标到另一个对象（容器对象，也就是父对象或者选中对象自己），松开鼠标后会弹出适用的约束菜单，你可以选择约束进行添加。</p>
<p>这是我偏爱的一种方式，因为它比上面那种方式来的快多了。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-17.gif" alt="图片"></p>
<h4 id="3-_u83DC_u5355/_u7ED1_u5B9A_u5FEB_u6377_u952E"><a href="#3-_u83DC_u5355/_u7ED1_u5B9A_u5FEB_u6377_u952E" class="headerlink" title="3.菜单/绑定快捷键"></a>3.菜单/绑定快捷键</h4><p>你也可以通过菜单选项<code>editor —&gt; pin</code>给一个或多个对象添加布局约束。这是效率最低的一种方式。如果你发现有些约束你会一遍遍的反复添加，那么你就可以给该约束绑定一个快捷键来提高效率。</p>
<h3 id="u68C0_u67E5_u548C_u7F16_u8F91_u5DF2_u6DFB_u52A0_u7684_u5E03_u5C40_u7EA6_u675F"><a href="#u68C0_u67E5_u548C_u7F16_u8F91_u5DF2_u6DFB_u52A0_u7684_u5E03_u5C40_u7EA6_u675F" class="headerlink" title="检查和编辑已添加的布局约束"></a>检查和编辑已添加的布局约束</h3><p>检查约束最简单的方式就是选中一个对象，然后打开右侧工具栏，选择Size Inspector面板。或者在storyboard界面左侧的结构树中查看约束。</p>
<p>通过这两种方式，你都可以选择某个约束，然后编辑它。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-18.gif" alt="图片"></p>
<h3 id="u79FB_u9664_u5E03_u5C40_u7EA6_u675F"><a href="#u79FB_u9664_u5E03_u5C40_u7EA6_u675F" class="headerlink" title="移除布局约束"></a>移除布局约束</h3><p>布局约束可以添加自然也就可以删除。选中某个约束使其高亮显示，然后按下Delete键移除该约束。</p>
<p>如果想移除某个对象上所有的约束，有一个快捷的方式。选择该对象，然后在底部点击Resolve Auto Layout Issues按钮，选择Clear Constaints。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-19.gif" alt="图片"></p>
<h3 id="u5E03_u5C40_u51FA_u73B0_u7684_u95EE_u9898_u548C_u51B2_u7A81"><a href="#u5E03_u5C40_u51FA_u73B0_u7684_u95EE_u9898_u548C_u51B2_u7A81" class="headerlink" title="布局出现的问题和冲突"></a>布局出现的问题和冲突</h3><p>我们在添加约束时，经常伴随有警告或者错误出现。虽然有些警告是因为我们还没有添加完约束出现的，当我们添加完我们设想的约束后警告就会自然消失。但大多数的警告还是指明我们的约束确实存在问题，需要我们修复。</p>
<p>查看警告或错误最方便的方式就是在storyboard左侧的结构树中，在view controller的右边会出现一个红色或黄色的小图标，向我们指明这里存在问题：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-20.gif" alt="图片"></p>
<h3 id="u9519_u8BEF_u6446_u653Eview_u7684_u8B66_u544A"><a href="#u9519_u8BEF_u6446_u653Eview_u7684_u8B66_u544A" class="headerlink" title="错误摆放view的警告"></a>错误摆放view的警告</h3><p>view位置的错误摆放是一个很常见的警告。当一个view没有摆放在约束规定的位置的时候，会出现该警告。</p>
<p>这些问题会在你切换不同设备的模拟器或鼠标不小心移动了某个对象时出现。</p>
<p>选中一个错误摆放的对象，在屏幕上会出现布局约束给你提示的正确的摆放位置。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-21.gif" alt="图片"></p>
<p>点击左侧出现的黄色警告图片，会弹出一个菜单，你可以选择让Xcode改变约束，以适应当前该对象的位置，但通常情况下我们都选择让Xcode将该对象移动到约束规定的位置。</p>
<h3 id="u7F3A_u5C11_u5E03_u5C40_u7EA6_u675F_u7684_u9519_u8BEF"><a href="#u7F3A_u5C11_u5E03_u5C40_u7EA6_u675F_u7684_u9519_u8BEF" class="headerlink" title="缺少布局约束的错误"></a>缺少布局约束的错误</h3><p>我们回到早些时候的示例中。这时候我们没有给方块添加Y坐标位置的约束。在运行时没有问题，因为iOS会假设方块的位置就是我们在storyboard中摆放的那个位置。但是Xcode会提示我们一个缺失约束的错误，为了避免意外发生（更换设备尺寸），我还是要根据Xcode的提示添加缺失的约束。</p>
<p>我们给这两个方块添加一个<em>top space to to layout guide</em>约束使方块的位置更加清晰，并消除Xcode的错误提示。</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-for-iphone6-22.gif" alt="图片"></p>
<p>未完待续……</p>
<p>原文地址：<a href="http://mathewsanders.com/designing-adaptive-layouts-for-iphone-6-plus" target="_blank" rel="external">ADAPTIVE LAYOUTS FOR iPHONE 6</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/adaptive-layout-2/" itemprop="url">
                  Swift自适应布局（Adaptive Layout）教程（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-13T00:00:00+08:00" content="2014-10-13">
              2014-10-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/adaptive-layout-2/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/adaptive-layout-2/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<h2 id="u7ED9TextContainer_u4E2D_u6DFB_u52A0_u5185_u5BB9"><a href="#u7ED9TextContainer_u4E2D_u6DFB_u52A0_u5185_u5BB9" class="headerlink" title="给TextContainer中添加内容"></a>给TextContainer中添加内容</h2><p>打开 <strong>Main.storyboard</strong> ，从组件库（Object Library）中拖拽两个 <strong>Label</strong> 组件到TextContainer中，位置可以随意摆放：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-35.png" alt="图片"></p>
<p>先选择靠上的Label，然后点击底部的 <strong>Align</strong> 按钮，添加一个 <strong>Horizontal Center in Container</strong> 约束，再点击 <strong>Pin</strong> 按钮，添加一个 <strong>Top Spacing to nearest neighbor</strong> 约束，设置其值为10：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-36.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-37.png" alt="图片"></p>
<p>然后选择右侧工具栏中的 <strong>Attribute Inspector</strong> 页签，将该Label的 <strong>Text</strong> 属性设置为 <strong>Cupertino</strong> ，<strong>Color</strong> 属性设置为 <strong>White</strong> ，<strong>Font</strong> 属性设置为 <strong>Helvetica Neue, Thin</strong> ， <strong>Size</strong> 属性设置为 <strong>150</strong>。</p>
<p>这时同学们可能会发现基本看不到刚才设置的文字的全貌，这是因为Label大小的原因。别着急，我们很快就会解决这个问题。</p>
<p>现在选择另一个Label，按照上述的方法给它也添加一个 <strong>Horizontal Center in Container</strong> 约束以及一个 **Bottom Spacing<br>to nearest neighbor** 约束，将其值设置为10。打开右侧工具栏中的 <strong>Size Inspector</strong> 看看：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-38.png" alt="图片"></p>
<p>然后选择 <strong>Attribute Inspector</strong> 将该Label的 <strong>Text</strong> 属性设置为 <strong>28C</strong> ， <strong>Color</strong> 属性设置为 <strong>White</strong>， 将 <strong>Font</strong> 属性设置为 <strong>Helvetica Neue, Thin</strong>， 将 <strong>Size</strong> 属性设置为 <strong>250</strong>。</p>
<p>现在是时候解决Label大小的问题了。选中view controller的view，点击底部的 <strong>Resolve Auto Layout Issues</strong> 按钮，在弹出菜单中选择 <strong>All Views\Update Frames</strong> ，现在看看<code>storyboard</code>中发生了什么：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-39.png" alt="图片"></p>
<p>我们看到了刚才设置的城市和温度，但是他们有一点点重叠，这可不是我们想要的结果。在我们修改这个问题之前，先看看预览编辑区的显示情况。我们发现在iPad下显示貌似还挺完美：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-40.png" alt="图片"></p>
<p>但是在iPhone下不出所料的无法直视，字体太大了：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-41.png" alt="图片"></p>
<p>接下来让我们解决这个重叠和字体大小的问题。</p>
<h2 id="Size_Classes"><a href="#Size_Classes" class="headerlink" title="Size Classes"></a>Size Classes</h2><p>通用的<code>storyboard</code>文件固然很好，但是你想真正把它玩转还是得花功夫去研究它，这是一件很有挑战性的工作，当然我们也要懂得运用一些现有的工具来帮助我们。Xcode6就为我们提供了一些工具和技巧，帮助我们更好的实现自适应布局。</p>
<p>自适应布局有一个很重要的概念就是 <strong>Size Classes</strong>。它并不代表真正的尺寸，而是我们从感官上感觉尺寸的种类，通过这种种类的组合，表示出不同屏幕尺寸设备的横屏及竖屏。</p>
<p>Xcode6为我们提供了两个种类：普通（<strong>Regular</strong>）和紧凑（<strong>Compact</strong>）。虽然它们涉及到视图的物理尺寸，但一般它们只代表视图的语义尺寸，即不是真正的尺寸，而是我们从感官上分出的尺寸种类。</p>
<p>下面这个表格向同学们展示了size classes和各个尺寸设备竖屏、横屏之间的关系：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-42.png" alt="图片"></p>
<p>上表中的这些size classes组合都是我们在开发应用中经常碰到的。然而你也可以在视图的任何一个层级中覆盖这些size classes。当以后我们开发Apple Watch应用时显得尤其有用。</p>
<h2 id="Size_Classes_u4E0E_u5F00_u53D1_u8005"><a href="#Size_Classes_u4E0E_u5F00_u53D1_u8005" class="headerlink" title="Size Classes与开发者"></a>Size Classes与开发者</h2><p>何为设计应用的UI？虽然现在你们的应用已经知道要使用Size Classes，并且你们在<code>storyboard</code>文件中设计应用界面时已经抛开了具体尺寸大小的束缚。但是你们难道没有发现在所有尺寸的设备中，不管是竖屏还是横屏，应用的界面布局都是一致的吗？只是自适应了尺寸大小而已。这还远远不是设计。</p>
<p>当你们决心要设计自适应的界面并已经开始设计的时候，有一点很关键。那就是要知道界面在不同的Size Classes要有继承的关系。你们应该首先设计一个基础的界面，然后根据不同尺寸的横竖屏在基础的界面上进行自定义。千万不要把不同的Size Classes当做独立的屏幕尺寸去设计UI。应该在你们的脑海中建立起界面的一个继承关系的思想，也就是大多数的设备使用基础界面，然后特别的尺寸及横竖屏再根据情况基于基础界面修改。</p>
<p>在本文中，一直没有像大家介绍过如何设置特殊设备的布局，那是应为自适应布局的核心概念Size Classes本身就是由各种特殊设备的特点抽象而来的。也就是说一个Size Classes就意味着一种特殊设备的布局特点，其实普通情况也是特殊情况中的一种。所以说我们可以组合不同的Size Classes来满足各种特殊的布局情况，比如一个支持自适应的视图，它可以在应用的父视图控制器中自适应，也可以在某一个功能的视图控制器容器中自适应。但是两者自适应后的布局却不相同。</p>
<p>这种改进对Apple本身也是有益的，因为他们不断的改变移动设备的尺寸，但从来没有强迫开发者和设计者重新开发和设计他们的应用以适应新尺寸的设备。这就不会让开发者和设计者对Apple不断改变设备尺寸这件事有抗拒心理。</p>
<p>接下来，我们将自定义Size Classes以适应iPhone横屏的时候，因为现在的布局在横屏时用户体验很糟糕。</p>
<h2 id="u4F7F_u7528Size_Classes"><a href="#u4F7F_u7528Size_Classes" class="headerlink" title="使用Size Classes"></a>使用Size Classes</h2><p>回到 <strong>Main.storyboard</strong>，点击底部的 <strong>w Any h Any</strong>，你就可以看到Size Classes的选择器了：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-43.png" alt="图片"></p>
<p>在这个由9个方格组成的网格中，你就可以选择你想在<code>storyboard</code>中显示的Size Class。一共有9种组合方式：3种垂直的也就是竖屏的（任意尺寸（Any），普通（regular），紧凑（compact））选择和3种水平的也就是横屏（任意尺寸（Any），普通（regular），紧凑（compact））的选择。</p>
<blockquote>
<p>注意：这里有一点需要大家注意。在Size Classes中，有两个重要的概念叫做<em>水平（Horizontal）</em>和<em>垂直（Vertical）</em>。但是在IB中叫做 <em>宽（Width）</em>和<em>高（Height）</em>。但他们是等价的，所以大家记住这个概念有两种叫法就可以了。</p>
</blockquote>
<p>目前我们的布局在紧凑高度（Compact Height）时显示的很糟糕，也就是iPhone横屏时。我们来解决这个问题，在Size Classes选择器中选择 <strong>Any Width | Compact Height</strong> 的组合：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-44.png" alt="图片"></p>
<p>这时你会发现在<code>storyboard</code>中会立即出现2个变化：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-45.png" alt="图片"></p>
<ol>
<li><code>storyboard</code>中的view controller变成了我们刚才设置的size class。</li>
<li><code>storyboard</code>底部会出现蓝色的长条区域，并显示出当前我们正在使用的size class。</li>
</ol>
<p>为了在该size class下改变布局，我们要临时改变一些之前设置好的约束。在自动布局中这种操作有个术语叫做 <strong>装配（installing）</strong> 和 <strong>卸载（uninstalling）</strong> 约束。当一个约束在当前的size class中是适用的，我们就将该约束装配在当前的size class中，如果不适用，我们就卸载它。</p>
<p>选择image view，在右侧工具栏中选择 <strong>Size Inspector</strong>。你可以看到在image view上添加的所有约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-46.png" alt="图片"></p>
<p>单击鼠标左键选择 <strong>Align Center X to: Superview</strong> 约束，然后按下键盘上的 <strong>Delete</strong> 键来卸载该约束。这时我们可以看到在<code>storyboard</code>中这个约束就立即消失了，并且在<code>storyboard</code>的结构目中和 Size Inspector中该约束都变成了灰色：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-47.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-48.png" alt="图片"></p>
<blockquote>
<p>注意：你可以在Size Inspector中点击 <strong>All</strong> 来查看当前size class卸载掉的约束。</p>
</blockquote>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

<p>鼠标双击刚才卸载的那条约束，我们可以看到在约束编辑界面的底部出现了额外的2个选项：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-49.png" alt="图片"></p>
<p>这两个选项的意思就是这条约束在基础布局中是可用的，但在当前的 <strong>Any Width | Compact Height</strong> 布局中是不可用的。  </p>
<p>按照上面的步骤卸载掉image view上的另外3个约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-50.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-51.png" alt="图片"></p>
<p>现在你就可以添加适合当前size class的约束了。我们添加一个 <strong>Align/Vertical Center in Container</strong> 约束，再添加一个 <strong>Pin/Left Spacing to nearest neighbor</strong> 约束，其值设置为10：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-52.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-53.png" alt="图片"></p>
<p>选择image view，按住 <strong>Ctrl</strong> 键从image view上拖拽至view controller的view上，在弹出的菜单中选择 <strong>Equal Widths</strong> 约束。</p>
<p>打开右侧工具栏中的 <strong>Size Inspector</strong> 页签，双击 <strong>Equal Width to: Superview</strong> 打开该约束的属性编辑界面。如果 <strong>First Item</strong> 属性的值不是 <strong>cloud.Width</strong> ，那么点击输入框，在下拉菜单中选择 <strong>Reverse First and Second Item</strong>。然后将 <strong>Multiplier</strong> 属性的值设置为 <strong>0.45</strong>。</p>
<p>现在image view在所有的size class中显示应该都没有什么问题了。但是text container view还有点问题。你需要给它添加一个约束，让它显示在该size class屏幕的右侧。</p>
<p><code>TextContainer</code> view现在有两种约束在身。一种是内部约束，它约束了两个Label的位置，这些约束在各size class中表现的还不错。另一种是外部的约束，它们限制了text container view的左、右、底部与它容器的左、右、底部的间距。这些约束在当前的size class中表现的就不尽如人意了。如果想使text container view在当前size class中位于容器的右下角位置，你得卸载掉左侧的约束。</p>
<p>选中 <strong>Left Spacing to nearest neighbor</strong> 约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-54.png" alt="图片"></p>
<p>按 <strong>Cmd-Delete</strong> 卸载该约束，和之前一样，被卸载的约束显示为灰色。</p>
<p>现在你需要再添加两个约束将TextContainer限制在正确的位置上。一个是让text container view的宽度为它容器（view controller的view）宽度的一半。另一个是将text container view固定在顶部。</p>
<p>按理来说，你现在需要选中text container view然后按住Ctrl键和鼠标左键拖动鼠标到view controller view上，然后选择约束。但是目前的情况由于image view和text container view占满了整个view controller，所以你很难选中view controller的view。同学们可以通过<code>storyboard</code>的结构树上进行该操作，会容易很多。</p>
<p>在结构树中选中TextContainer，按住 <strong>Ctrl</strong> 键和鼠标左键，拖动鼠标到结构树的View上：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-55.png" alt="图片"></p>
<p>弹出菜单中显示了可用的约束，按住 <strong>Shift</strong> 键点击 <strong>Top Space to Top Layout Guide</strong> 和 <strong>Equal Widths</strong> 约束：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-56.png" alt="图片"></p>
<p>然后选中TextContainer，在 <strong>Size Inspector</strong> 中设置刚刚添加的两个约束：</p>
<ul>
<li>将 **Top Space to: Top Layout Guide ** 约束的值设置为0。</li>
<li>将 <strong>Equal Width</strong> 约束的 <strong>Multiplier</strong> 的值设置为0.5。这里要注意 <strong>First Item</strong> 和 <strong>Second Item</strong> 这两个属性的值。前者应为TextContainer view，后者为view controller view。如果不一致，那么点击任意一个输入框，选择 <strong>Reverse First and Second Item</strong>。</li>
</ul>
<p>现在点击<code>storyboard</code>界面底部的 <strong>Resolve Auto Layout Issues</strong> 按钮，然后选择 <strong>All Views\Update frames</strong> 。看看发生了什么变化呢：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-57.png" alt="图片"></p>
<p>到目前为止，我们的布局已经越来越接近完美了，唯一一点不足的就是字体大小的自适应，我们会在下一节解决它！</p>
<h2 id="u6587_u5B57_u5C5E_u6027_u7684_u81EA_u9002_u5E94"><a href="#u6587_u5B57_u5C5E_u6027_u7684_u81EA_u9002_u5E94" class="headerlink" title="文字属性的自适应"></a>文字属性的自适应</h2><p>目前TextContainer中的文字尺寸在iPad设备上，也就是使用普通（Regular）size class显示还比较正常。但是当使用紧凑（Compact）size class时文字尺寸就显得太大了，以至于都超出了视图。不过同学们不要怕，我们照样可以在不同的Size Classes中设置不同的文字尺寸来做到自适应。</p>
<blockquote>
<p>注意：与重写布局不同，在不同的size class中改变文字的属性始终会影响基础布局中的文字。它不能像布局一样，在不同的size class中设置不同的属性值。我们通过下面的方法来解决这一问题。</p>
</blockquote>
<p>回到<code>storyboard</code>文件中，将目前的size class改为最基础的 <strong>Any Width | Any Height</strong> 。</p>
<p>选择显示Cupertino的Label，打开 <strong>Attribute Inspector</strong> 。点击 <strong>Font</strong> 属性前面的 <strong>+</strong> 号：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-58.png" alt="图片"></p>
<p>弹出的菜单内容是让我们选择一种size class的组合来重写该组合下的文字属性。我们选择 <strong>Compact Width > Any Height</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-59.png" alt="图片"></p>
<p>这时就会出现另外一个文字属性下拉框，针对于我们刚才选择的 <strong>Compact Width | Any Height</strong> size class，我们将字体大小改为90：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-60.png" alt="图片"></p>
<p>再选择显示温度的Label，重复刚才的操作，选择size class组合时选择 <strong>Compact Width > Any Height</strong>。设置字体大小为150。</p>
<p>在预览区域会自动更新我们刚才的设置：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-61.png" alt="图片"></p>
<p>现在看起来稍微好一些了，但是显示 <strong>Cupertino</strong> 的Label被截掉了两头。同学们可能会继续调整字体大小使Cupertino显示完全，虽然目前看起来完美了，但是当换一个城市名称后或许又会出现刚才的问题。比如Washington, D.C这么长的名称，又比如Kleinfeltersville, PA这个更长的名称。那么我们应该如何设计呢？</p>
<p>我们的救世主 <strong>自动布局（Auto Layout）</strong> 再次出马。你只需要给显示城市名称和温度的这两个Label设置一个相对于TextContainer view的宽度约束即可。选中显示Cupertino的Label，按住 <strong>Ctrl</strong> 键和鼠标左键，拖动鼠标到TextContainer view，在弹出菜单中选择 <strong>Equal Widths</strong> 约束。对显示温度的Label做相同的操作。之后在预览界面看看发生了什么：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-62.png" alt="图片"></p>
<p>呃……貌似还是有问题，城市名显示不完全。Label中的文字长度超出了允许显示的空间。不过我们可以通过一个选项，让Label自动判断当前的空间可以显示多大的字体。</p>
<p>选择显示Cupertino的Label，然后打开 <strong>Attribute Inspector</strong>。将 <strong>AutoShrink</strong> 属性设置为 <strong>Minimum font scale</strong>，将其值设置为0.5。将 <strong>Alignment</strong> 属性设置为 <strong>Centered</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-63.png" alt="图片"></p>
<p>对显示温度的Label做相同的操作。</p>
<p>再来看看预览区域，是不是在不同尺寸的iPhone横屏、竖屏下显示都比较完美了：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-64.png" alt="图片"></p>
<p>是时候在不同的设备上编译运行我们的程序了。用设备来检验才是最保险的。iPhone下的横屏、竖屏是多么的完美：</p>
<p><img src="http://www.devtalking.com/postImages/adaptive-layout-65.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/adaptive-layout-66.png" alt="图片"></p>
<p>同学们，至此你们已经学习到了自适应布局最基本的技能。恭喜你们！</p>
<p>原文地址：<a href="http://www.raywenderlich.com/83276/beginning-adaptive-layout-tutorial" target="_blank" rel="external">Beginning Adaptive Layout Tutorial</a></p>
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- DevTalking Banner1 -->
<ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-4115205380866695" data-ad-slot="5844761160"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://www.devtalking.com/devtalking.png" alt="DevTalking" itemprop="image"/>
          <p class="site-author-name" itemprop="name">DevTalking</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">76</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

         <!-- <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分類</span>
              
          </div> -->

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">40</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jacefu" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:jace.fu@icloud.com" target="_blank">
                  
                    <i class="fa fa-envelope"></i> Email
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.devtalking.com/qrcode.jpg" target="_blank">
                  
                    <i class="fa fa-qrcode"></i> 微信公众号
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DevTalking</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'jacefu';
      var disqus_identifier = 'page/7/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/lib/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
