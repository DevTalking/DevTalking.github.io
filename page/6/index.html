<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  
    <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  


<link rel="stylesheet" type="text/css" href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" />

<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.2"/>




  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="程序员说" type="application/atom+xml" />



  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="程序员说">
<meta property="og:url" content="http://www.devtalking.com/page/6/index.html">
<meta property="og:site_name" content="程序员说">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="程序员说">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>



  <title> 程序员说 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?980738dc41a50d91861a17ad4b768a1f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">程序员说</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/tuple-in-swift/" itemprop="url">
                  Swift中的元组（Tuples）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-10-08T00:00:00+08:00" content="2014-10-08">
              2014-10-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/tuple-in-swift/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/tuple-in-swift/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="u521B_u5EFA_u5143_u7EC4"><a href="#u521B_u5EFA_u5143_u7EC4" class="headerlink" title="创建元组"></a>创建元组</h2><p>在Swift中创建元组的方式很简单，它的语法有点类似数组，但是需要把方括号替换为圆括号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstHighScore = (<span class="string">"Mary"</span>, <span class="number">9001</span>)</span><br></pre></td></tr></table></figure>
<p>与数组不同的是，元组中的元素可以是任意类型。上面代码中<code>firstHighScore</code>元组就包含一个<code>String</code>类型的元素和一个<code>Int</code>类型的元素。</p>
<p>另外，在创建元组时你还可以给元组中的元素命名：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> secondHighScore = (name: <span class="string">"James"</span>, score: <span class="number">4096</span>)</span><br></pre></td></tr></table></figure>
<p>这样可以让我们在使用元组的时候明确的指定某个元素，非常有用。在后面的文章中大家可以看到给元素命名的好处。</p>
<p>以上就是创建元组的两种方式，非常简单和简洁。你不需要像创建<code>struct</code>一样写出它的结构和内部属性，也不需要像创建<code>class</code>一样要写初始化方法。你只需要把你想用的、任何类型的值放在圆括号内，用逗号隔开即可。如果你愿意你还可以给每个元素命名，提高元组使用效率。</p>
<h2 id="u4ECE_u5143_u7EC4_u4E2D_u8BFB_u5143_u7D20"><a href="#u4ECE_u5143_u7EC4_u4E2D_u8BFB_u5143_u7D20" class="headerlink" title="从元组中读元素"></a>从元组中读元素</h2><p>从元组中读取元素有几种方式，但一般我们会选择最适合当前应用场景的方式，并且确保选择的方式是在当前情况下最简单的一种。</p>
<h3 id="u5143_u7EC4_u5143_u7D20_u6CA1_u6709_u547D_u540D"><a href="#u5143_u7EC4_u5143_u7D20_u6CA1_u6709_u547D_u540D" class="headerlink" title="元组元素没有命名"></a>元组元素没有命名</h3><p>如果我们没有给元组的元素命名，我们可以用点语法，通过定义好的元组变量或常量获取它的第1个到第n个元素：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstHighScore = (<span class="string">"Mary"</span>, <span class="number">9001</span>)</span><br><span class="line">firstHighScore.<span class="number">0</span>			<span class="comment">// Mary</span></span><br><span class="line">firstHighScore.<span class="number">1</span> 		<span class="comment">// 9001</span></span><br></pre></td></tr></table></figure>
<p>如果你觉得上述这种方法会造成语义的不明确，那么我们还可以将元组赋值给一个带有元素名称的元组（元素名称个数要对应）：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> (firstName, firstScore) = firstHighScore</span><br><span class="line">firstName		<span class="comment">// Mary</span></span><br><span class="line">firstScore		<span class="comment">// 9001</span></span><br></pre></td></tr></table></figure>
<p>如果你只想读取<code>firstHighScore</code>元组中的分数，那么你可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> (<span class="number">_</span>, firstScore) = firstHighScore</span><br><span class="line">firstScore		<span class="comment">// 9001</span></span><br></pre></td></tr></table></figure>
<h3 id="u5143_u7EC4_u5143_u7D20_u6709_u547D_u540D"><a href="#u5143_u7EC4_u5143_u7D20_u6709_u547D_u540D" class="headerlink" title="元组元素有命名"></a>元组元素有命名</h3><p>如果我们已经给元组中的元素命名了名称，那么我们可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> secondName = secondHighScore.name</span><br><span class="line"><span class="keyword">let</span> secondScore = secondHighScore.score</span><br><span class="line">secondName		<span class="comment">// James</span></span><br><span class="line">secondScore		<span class="comment">// 4096</span></span><br></pre></td></tr></table></figure>
<h2 id="u5C06_u5143_u7EC4_u4F5C_u4E3A_u51FD_u6570_u8FD4_u56DE_u503C"><a href="#u5C06_u5143_u7EC4_u4F5C_u4E3A_u51FD_u6570_u8FD4_u56DE_u503C" class="headerlink" title="将元组作为函数返回值"></a>将元组作为函数返回值</h2><p>我们可以将元组作为函数的返回值，下面这个函数的返回值就是我们之前定义过的<code>secondHighScore</code>元组：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getAHighScore</span><span class="params">()</span></span> -&gt; (name: <span class="type">String</span>, score: <span class="type">Int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> theName = <span class="string">"Patricia"</span></span><br><span class="line">    <span class="keyword">let</span> theScore = <span class="number">3894</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (theName, theScore)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么说上述函数的返回值是<code>secondHighScore</code>元组呢？因为<code>getAHighScore</code>函数返回的元组元素个数、元素名称、元素类型均和<code>secondHighScore</code>相同。</p>
<p>其实将元组作为函数的返回值时也可以不必对元素进行命名，只要你明白每个元素代表的含义即可：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">getAHighScore</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>, <span class="type">Int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> theName = <span class="string">"Patricia"</span></span><br><span class="line">    <span class="keyword">let</span> theScore = <span class="number">3894</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (theName, theScore)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你不确定返回的元组一定不为<code>nil</code>，那么你可以返回一个可选的元组类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">maybeGetHighScore</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>, <span class="type">Int</span>)?</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为是可选的元组类型，所以当返回的元组不为<code>nil</code>时，你需要对元组进行解包：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> possibleScore = maybeGetHighScore()</span><br><span class="line">&#123;</span><br><span class="line">    possibleScore.<span class="number">0</span></span><br><span class="line">    possibleScore.<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"Nothing Here"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：当你定义了一个没有返回值的函数时，其实该函数是返回一个空的元组<code>()</code>。</p>
</blockquote>
<h2 id="u5143_u7EC4_u7684_u8BBF_u95EE_u7EA7_u522B"><a href="#u5143_u7EC4_u7684_u8BBF_u95EE_u7EA7_u522B" class="headerlink" title="元组的访问级别"></a>元组的访问级别</h2><p>元组的访问级别取决于它包含的元素。比如元组里的元素都是<code>private</code>级别的，那么该元组也是<code>private</code>级别的。但这里有一个遵循最小的原则，也就是说如果一个元组中有两个元素，一个为<code>private</code>级别，另一个为<code>public</code>级别，那么该元组遵循最小原则，它的访问级别为<code>private</code>。</p>
<h2 id="u5143_u7EC4_u662F_u503C_u7C7B_u578B"><a href="#u5143_u7EC4_u662F_u503C_u7C7B_u578B" class="headerlink" title="元组是值类型"></a>元组是值类型</h2><p>关于值类型和引用类型的知识这里不再累赘，我们通过一个代码示例来看看元组是哪种类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> someScore = (<span class="string">"John"</span>, <span class="number">55</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> anotherScore = someScore</span><br><span class="line">anotherScore.<span class="number">0</span> = <span class="string">"Robert"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">println</span>(anotherScore.<span class="number">0</span>)  <span class="comment">//Outputs:  "Robert"</span></span><br><span class="line"><span class="built_in">println</span>(someScore.<span class="number">0</span>)     <span class="comment">//Outputs:  "John"</span></span><br></pre></td></tr></table></figure>
<p>通过上述的代码示例可以看出，我把<code>someScore</code>元组赋值给了<code>anotherScore</code>，然后修改了<code>anotherScore</code>的第1个元素的值，最后分别打印了<code>someScore</code>和<code>anotherScore</code>第1个元素的值。<code>someScore</code>元组第一个元素的值为<code>Robert</code>，而<code>anotherScore</code>元组第一个元素的值仍然为<code>John</code>。由此可见元组是值类型。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/how-to-create-action-extension/" itemprop="url">
                  如何在Swift中创建Action扩展
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-09-22T00:00:00+08:00" content="2014-09-22">
              2014-09-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/how-to-create-action-extension/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/how-to-create-action-extension/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>我们先想象一下，我们已经有一个很牛逼的应用了，我们姑且叫做重要信息记事本。它的功能就是将我们认为是重要的信息记录下，便于我们随时查看。那么何为重要信息呢？重要信息可以是很多类型的信息，比如武功秘籍、食谱、生日、一段牛逼的代码等等。当我们已经有了这样一个应用后，接下来应该考虑的事情就是如何记录重要信息了。通常思维下，你们可能认为应该是先打开这个应用，然后将重要信息敲进去。是这样么？你当用户是傻子么，什么年代了还手敲，简直弱爆了。下面我向你们介绍一个很酷的方法，那就是通过Action扩展，将信息记录到我们的应用中。下面例子的主要功能是将Safari浏览的网页中的信息保存在我们应用中。</p>
<h2 id="u89C1_u8BC1_u5947_u8FF9_u7684_u65F6_u523B"><a href="#u89C1_u8BC1_u5947_u8FF9_u7684_u65F6_u523B" class="headerlink" title="见证奇迹的时刻"></a>见证奇迹的时刻</h2><p>先通过<em>File &gt; New &gt; Project</em>菜单创建一个新的工程，选择<strong>Single View Application</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension1.png" alt="图片"></p>
<p>然后通过<em>File &gt; New &gt; Target</em>菜单给给工程添加一个<strong>Target</strong>，选择<strong>Action Extension</strong>：</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension2.png" alt="图片"></p>
<p>在创建Action扩展时需要指定一个Aciton类型，Apple提供了两种Action扩展的类型模板。一种是有用户界面的类型，包含一个<code>UIViewController</code>和一个<code>Storeboard</code>文件，可以自定义显示界面和行为。另一种是不带用户界面的类型，这种类型只允许我们处理来自Host应用的请求。</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension3.png" alt="图片"></p>
<p>现在我们在工程中就可以看到刚才创建的Action扩展<strong>NoteAppExtension</strong>，它包含两个主要的文件，一个是<code>Action.js</code>，另一个是<code>ActionRequestHandler.swift</code>：</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension4.png" alt="图片"></p>
<p>我们来看看这两个文件的作用。<code>Action.js</code>文件用来实现和处理浏览器中请求的逻辑，在本文的例子中，它主要实现用户在浏览器中选中文本并发送到我们的应用中。<code>ActionRequestHandler.swift</code>用来处理Host应用发送的请求和参数。</p>
<p>在实现逻辑之前我们需要设置一下扩展的属性，打开<code>Info.plist</code>文件将<code>NSExtensionActivationSupportsWebURLWithMaxCount</code>属性设置为1，该设置让扩展知道我们需要请求一个URL。</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension5.png" alt="图片"></p>
<p>我们<code>Action.js</code>文件中有如下内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">Action</span> = function() &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">Action</span>.prototype = &#123;</span><br><span class="line">    </span><br><span class="line">    run: function(arguments) &#123;</span><br><span class="line">		<span class="comment">// 在这个方法里，你可以通过document操作HTML中的元素，或者可以将HTML中的内容传给ActionRequestHandler文件的代码。</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 在本文的例子中，我们不做任何更新，只是将HTML中选中的内容穿给ActionRequestHandler文件的代码。</span></span><br><span class="line">        <span class="keyword">var</span> selected = <span class="string">"No Text Selected"</span>;</span><br><span class="line">        <span class="keyword">if</span> (window.getSelection) &#123;</span><br><span class="line">            selected = window.getSelection().getRangeAt(<span class="number">0</span>).<span class="built_in">toString</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            selected = document.getSelection().getRangeAt(<span class="number">0</span>).<span class="built_in">toString</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        arguments.completionFunction(&#123;<span class="string">"args"</span> : selected&#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    finalize: function(arguments) &#123;</span><br><span class="line">		<span class="comment">// 当ActionRequestHandler文件中的itemLoadCompletedWithPreprocessingResults方法执行完之后会调用该方法。</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 如果ActionRequestHandler文件向HTML返回了信息，我们可以通过arguments["message"]来查看，并且可以根据该信息操作HTML中的元素。</span></span><br><span class="line">        alert(arguments[<span class="string">"message"</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> <span class="type">ExtensionPreprocessingJS</span> = new <span class="type">Action</span></span><br></pre></td></tr></table></figure>
<p>Safari与Action扩展的交互就是通过<code>Action.js</code>文件中的<code>run</code>和<code>finalize</code>这两个方法实现的。当我们在Safari中使用Action扩展时就会调用<code>run</code>方法，它能让我们在该方法中操作当前Safari显示页面的DOM元素。当Action扩展处理完逻辑向Safari返回信息时会调用<code>finalize</code>方法，在我们的例子中，我们通过<code>self.extensionContext!.completeRequestReturningItems(nil, completionHandler: nil)</code>这段代码向Safari返回信息。该方法的第一个参数就是要返回的信息，它会将信息传给<code>Action.js</code>文件，然后通过js代码操作HTML。如果第一个参数传入<code>nil</code>，那就意味着不会调用<code>Action.js</code>文件中的<code>finalize</code>方法。<code>run</code>和<code>finalize</code>这两个方法的参数<code>arguments</code>都包含着一些信息，只不过一个是来自与HTML，一个来自<code>ActionRequestHandler</code>文件。</p>
<p><strong>一定要记住：</strong>我们必须要实例化<code>ExtensionPreprocessingJS</code>这个全局变量，因为它是Safari和Action扩展之间的桥梁。</p>
<p>我们的<code>ActionRequestHandler</code>文件内容如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionRequestHandler</span>: <span class="title">NSObject</span>, <span class="title">NSExtensionRequestHandling</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> extensionContext: <span class="type">NSExtensionContext</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">beginRequestWithExtensionContext</span><span class="params">(context: NSExtensionContext!)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.extensionContext = context</span><br><span class="line">        <span class="keyword">let</span> identifierType = <span class="type">NSString</span>(format: kUTTypePropertyList, <span class="type">NSUTF8StringEncoding</span>)</span><br><span class="line">        <span class="keyword">for</span> (item: <span class="type">NSExtensionItem</span>) <span class="keyword">in</span> context.inputItems <span class="keyword">as</span> [<span class="type">NSExtensionItem</span>] &#123;</span><br><span class="line">            <span class="keyword">for</span> (itemProvider: <span class="type">NSItemProvider</span>) <span class="keyword">in</span> item.attachments <span class="keyword">as</span> [<span class="type">NSItemProvider</span>] &#123;</span><br><span class="line">                <span class="keyword">if</span> itemProvider.hasItemConformingToTypeIdentifier(identifierType) &#123;</span><br><span class="line">                    itemProvider.loadItemForTypeIdentifier(identifierType, options: <span class="literal">nil</span>, completionHandler: &#123;(item, error) <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">let</span> dictionary = item <span class="keyword">as</span> <span class="type">NSDictionary</span></span><br><span class="line">                        dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">                            <span class="keyword">self</span>.itemLoadCompletedWithPreprocessingResults(dictionary[<span class="type">NSExtensionJavaScriptPreprocessingResultsKey</span>] <span class="keyword">as</span> <span class="type">NSDictionary</span>)</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">itemLoadCompletedWithPreprocessingResults</span><span class="params">(javaScriptPreprocessingResults: NSDictionary)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text = javaScriptPreprocessingResults[<span class="string">"args"</span>] <span class="keyword">as</span>? <span class="type">String</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> userDefaults = <span class="type">NSUserDefaults</span>(suiteName: <span class="string">"group.name"</span>)</span><br><span class="line">            userDefaults.setValue(text, forKey: <span class="string">"note"</span>)</span><br><span class="line">            userDefaults.synchronize()</span><br><span class="line">            <span class="keyword">self</span>.doneWithResults([<span class="string">"message"</span>: <span class="string">"Successfully added to the note app"</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">doneWithResults</span><span class="params">(resultsForJavaScriptFinalizeArg: NSDictionary?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> resultsForJavaScriptFinalize = resultsForJavaScriptFinalizeArg &#123;</span><br><span class="line">            <span class="keyword">let</span> identifierType = <span class="type">NSString</span>(format: kUTTypePropertyList, <span class="type">NSUTF8StringEncoding</span>)</span><br><span class="line">			<span class="comment">// 创建合适返回类型的标示符。            </span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// 这里创建的resultsItem将作为Action.js文件中finalize方法的参数。</span></span><br><span class="line">            <span class="keyword">var</span> resultsDictionary = [<span class="type">NSExtensionJavaScriptFinalizeArgumentKey</span>: resultsForJavaScriptFinalize]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> resultsProvider = <span class="type">NSItemProvider</span>(item: resultsDictionary, typeIdentifier: identifierType)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> resultsItem = <span class="type">NSExtensionItem</span>()</span><br><span class="line">            resultsItem.attachments = [resultsProvider]</span><br><span class="line">            </span><br><span class="line">			<span class="comment">// 这段代码意味着Action扩展已经处理完了逻辑，现在将信息返回给Action.js文件。</span></span><br><span class="line">            <span class="keyword">self</span>.extensionContext!.completeRequestReturningItems([resultsItem], completionHandler: <span class="literal">nil</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 就算我们没有任何要返回的信息，也要执行这段代码，用于告知我们的Action扩展已经完成了逻辑处理。</span></span><br><span class="line">            <span class="keyword">self</span>.extensionContext!.completeRequestReturningItems(<span class="literal">nil</span>, completionHandler: <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.extensionContext = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以运行一下我们的应用，然后打开Safari，在Action选项中开启我们的Action扩展：</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension6.png" alt="图片"></p>
<p>然后我们就可以在Action栏中看到我们的扩展了：</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension7.png" alt="图片"></p>
<p>我们使用Safari随便打开一个含有文字的页面，选中一段文字，然后打开Action栏，点击<strong>NoteApp</strong>扩展，此时我们的扩展就会将选中的这段文字发送给我们的应用，形成一条新的重要信息。</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension8.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension9.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/2014-09-22-how-to-create-action-extension10.png" alt="图片"></p>
<p>以上只是一个简单的Aciton扩展的例子，但我们可以由此延伸出更多有用、有创意的功能，让我们的生活更加美好。</p>
<p>本文例子的代码可以在这里下载：<a href="https://github.com/jorjuela33/NoteApp" target="_blank" rel="external">NoteApp</a></p>
<p>原文地址：<a href="http://nsnerd.co/action-extension-in-swift/" target="_blank" rel="external">Action Extension in Swift</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/ios8-day-by-day-day2-sharing-extension/" itemprop="url">
                  iOS8 Day-by-Day-- Day2 -- 分享应用扩展
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-09-17T00:00:00+08:00" content="2014-09-17">
              2014-09-17
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/ios8-day-by-day-day2-sharing-extension/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/ios8-day-by-day-day2-sharing-extension/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="u5F00_u573A_u767D"><a href="#u5F00_u573A_u767D" class="headerlink" title="开场白"></a>开场白</h2><p>在iOS8中，有一个重量级的特性，那就是应用扩展。不论是第三方的应用还是Apple自家的应用，开发者们都可以根据这些应用自身的特点通过应用扩展提升应用与系统之间的交互性、应用的用户体验等等。目前在iOS中提供6种应用场景的扩展：</p>
<ul>
<li>通知界面widget</li>
<li>分享扩展</li>
<li>Action</li>
<li>照片编辑扩展</li>
<li>资源存储扩展</li>
<li>自定义键盘</li>
</ul>
<p>我们在今后的文章中都会介绍以上这些场景的应用扩展，但今天我们的主角是分享扩展。</p>
<p>关于分享其实我们都不陌生，比如我们打开一个应用，在某个内容页会有系统提供的分享按钮，点击该按钮后会出现一个应用图标列表（比如Twitter，Flickr，新浪微博等），意在让我们选择一个希望分享内容的应用。分享扩展就是能让我们可以增加这个列表，让我们自己的应用图标能出现在分享列表里。</p>
<p>这里需要注意的是，这篇文章的内容有一定的难度，Apple提供的应用扩展特性还是比较复杂的。本文会列举最常用的使用场景作为示例来讲解分享扩展，当然你也可以在我们提供的示例基础上设计属于你自己的应用界面风格。Apple在应用扩展方面提供了非常详尽的文档，如果你在学习这篇文章的过程中有不懂的地方，你可以参阅Apple官方文档。</p>
<p>本文的示例应用名为“ShareAlike”，我们会通过该示例应用向大家展示如何实现图片、文本信息的分享。该示例的代码可以在<a href="https://github.com/ShinobiControls/iOS8-day-by-day" target="_blank" rel="external">Github</a>中下载。</p>
<h2 id="u521B_u5EFA_u4E00_u4E2A_u5206_u4EAB_u6269_u5C55"><a href="#u521B_u5EFA_u4E00_u4E2A_u5206_u4EAB_u6269_u5C55" class="headerlink" title="创建一个分享扩展"></a>创建一个分享扩展</h2><p>首先我们要清楚，应用扩展不能单独存在，它必须要依附一个应用程序，我们称之为应用扩展的载体应用。应用扩展以二进制文件形式存在于载体应用中。Xcode为每一种应用扩展都提供了一个模板，但是我们必须通过给一个应用程序添加Target的方式创建应用扩展的模板，创建好模板后，会在工程中增加一个应用扩展模块以及必要的属性文件。</p>
<p>我们执行一个分享操作主要是通过一系列界面来完成，所以分享扩展的主要部分就是UI展现。因此我们可以看到分享扩展模板为我们提供了一个继承了<code>SLComposeServiceViewController</code>的类以及一个<code>storyboard</code>文件。<code>SLComposeServiceViewController</code>为我们提供了一些常规的行为（包括字数、图片展示、文本输入、发送和取消按钮），并且这些行为对应的界面都符合iOS UI的标准。在本文的示例中我们基本都会用到这些默认的行为。</p>
<p>除了<code>UIViewController</code>的标准方法外，<code>SLComposeServiceViewController</code>还提供了一些与分享功能生命周期相关的属性和方法：</p>
<ul>
<li><code>presentationAnimationDidFinish()</code>方法可以让我们执行大数据量的分享任务，我们在分享图片时会用到它。</li>
<li><code>contentText</code>是一个<code>String</code>类型的属性，它存储分享者编辑的一些文字描述。</li>
<li><code>didSelectPost()</code>函数在点击<strong>Post</strong>按钮时调用。它是上传分享数据的入口。</li>
<li><code>didSelectCancel()</code>函数在点击<strong>Cancel</strong>按钮时调用。</li>
<li><code>isContentValid()</code>函数在分享者编辑的文字有变化时调用。</li>
<li><code>charactersRemaining</code>是一个<code>Int</code>类型的属性，当描述内容有字数限制时，它表示当前还能编写的字数，如果超出字数，该属性展示的字数会变红，并用负数表示已经超出了多少字数。</li>
</ul>
<p>只要你的应用工程里添加了分享扩展，那么用户就能很轻松的将选中的内容分享到你的应用中。我们会一步一步展示如何实现这些有用的功能，但首先我们要学习如何编译、运行和调试。</p>
<h2 id="u7F16_u8BD1_uFF0C_u8FD0_u884C_u548C_u8C03_u8BD5"><a href="#u7F16_u8BD1_uFF0C_u8FD0_u884C_u548C_u8C03_u8BD5" class="headerlink" title="编译，运行和调试"></a>编译，运行和调试</h2><p>在添加一个扩展Target时，Xcode会让你激活扩展的Scheme。在运行工程之前，如果我们选择app的Scheme，那么会直接运行app，如果选择扩展的Scheme，那么会出现让你选择在哪个应用程序中运行该扩展，也就是选择一个扩展的Host应用，然后就可以针对扩展进行调试了。通常情况下运行分享扩展最好的Host应用是照片应用（Photos），所以我们一般都选择照片应用，然后调试分享扩展。</p>
<p>下面有几个步骤能帮助我们熟悉这个过程：</p>
<ul>
<li>不管是选择一个扩展的Host应用还是使用扩展的载体应用充当Host应用，它们都应该有比较容易能分享的内容。在示例项目中，<strong>ShareAlike</strong>扩展使用它的载体应用充当Host应用，载体应用包含一张图片和一个分享按钮，点击分享按钮时会弹出标准的分享内容界面：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">@IBAction</span> <span class="func"><span class="keyword">func</span> <span class="title">handleShareSampleTapped</span><span class="params">(sender: AnyObject)</span></span> &#123;</span><br><span class="line">  shareContent(sharingText: <span class="string">"Highland Cow"</span>,</span><br><span class="line">                       sharingImage: sharingContentImageView.image)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Utility methods</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">shareContent</span><span class="params">(#sharingText: String?, sharingImage: UIImage?)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> itemsToShare = [<span class="type">AnyObject</span>]()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> text = sharingText &#123;</span><br><span class="line">    itemsToShare.append(text)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> image = sharingImage &#123;</span><br><span class="line">    itemsToShare.append(image)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> activityViewController = <span class="type">UIActivityViewController</span>(activityItems: itemsToShare, applicationActivities: <span class="literal">nil</span>)</span><br><span class="line">  presentViewController(activityViewController, animated: <span class="literal">true</span>, completion: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension1.png" alt="图片">  </p>
<ul>
<li>在扩展中编写相关代码。</li>
<li>调试或测试时，选择载体应用的Scheme编译并运行，当点击Share Sample时，调试器会自动关联到扩展的进程上，简言之也就是可以捕获到你在分享扩展代码中设置的断点。</li>
<li>你也可以选择模拟器中的其他应用作为Host应用来使用分享扩展。但是调试器不会捕获到你设置的断点，也就是无法进行调试。你可以使用这种方式来测试扩展的运行情况，通常分享扩展最佳的Host应用是Photos。</li>
</ul>
<h2 id="u5206_u4EAB_u6269_u5C55_u7684_u5206_u4EAB_u5185_u5BB9_u5C5E_u6027_u8BBE_u7F6E"><a href="#u5206_u4EAB_u6269_u5C55_u7684_u5206_u4EAB_u5185_u5BB9_u5C5E_u6027_u8BBE_u7F6E" class="headerlink" title="分享扩展的分享内容属性设置"></a>分享扩展的分享内容属性设置</h2><p>与在<strong>Info.plist</strong>文件中设置应用一样，在扩展中也有这个文件。在该文件中有一个属性代表在分享应用列表中，我们扩展的显示名称（分享应用列表中图标下的文字）。</p>
<p>这个属性是<strong>Bundle display name</strong>（<code>CFBundleDisplayName</code>）：</p>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension2.png" alt="图片"></p>
<p>你还可以在<strong>Info.plist</strong>文件中定义你的分享扩展可以处理什么样的分享任务，比如说是否可以处理分享视频？</p>
<p>在该文件中有一个名为<code>NSExtension</code>字典类型属性，展开该属性后，可以看到<code>NSExtensionAttributes</code>属性，同样是字典类型，再展开该属性我们可以看到<code>NSExtenionActivationRule</code>属性，依然是字典类型的属性。可以看到<code>NSExtension</code>中有<code>Boolean</code>类型的、<code>String</code>类型的、<code>Number</code>类型的或者字典类型的各种属性。在<code>NSExtenionActivationRule</code>属性中就有设置分享图片数量，分享视频、文件、URL数量的属性：</p>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension3.png" alt="图片"></p>
<p>每一个属性表示的意思从字面上就可以理解，比如<code>NSExtensionActivationSupportsImageWithMaxCount</code>，类型为<code>Number</code>，值为1。意思就是我们的分享扩展支持的最大分享图片数为1，我们可以测试一下看看：</p>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension4.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension5.png" alt="图片"></p>
<p>从上图中可以看到，当我们选择了一张照片时，在分享应用列表中有我们的ShareAlike，如果选择了两张照片，分享应用列表中就没有我们的扩展了。</p>
<h2 id="u9A8C_u8BC1_u7528_u6237_u8F93_u5165_u7684_u5185_u5BB9"><a href="#u9A8C_u8BC1_u7528_u6237_u8F93_u5165_u7684_u5185_u5BB9" class="headerlink" title="验证用户输入的内容"></a>验证用户输入的内容</h2><p>到目前为止，你大概已经知道如何创建一个扩展并设置它的相关属性了，现在让我们看看如何实现一些自定义的扩展行为。首先，我们要知道如何验证用户的输入内容。比如我们通常情况下都需要的一个验证，就是限制用户输入的文字数量，我们可以通过<code>SLComposeServiceViewController</code>来实现它。</p>
<p>在之前我们提到过<code>SLComposeServiceViewController</code>类的一些属性方法，其中有一个方法叫<code>isContentValid() -&gt; Bool</code>。该方法的作用时随时监听着分享界面文本域的变化，也就是说一旦用户输入或删除文字，都会触发该方法。该方法如果返回<code>true</code>，那说明用户输入的内容合法，并可以使用<strong>Post</strong>按钮完成分享，如果返回<code>false</code>，那说明输入内容不合法，并且不能使用<strong>Post</strong>按钮。下面的代码片段展示了如何实现文字数量限制功能：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> sc_maxCharactersAllowed = <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">isContentValid</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> currentMessage = contentText &#123;</span><br><span class="line">    <span class="keyword">let</span> currentMessageLength = <span class="built_in">countElements</span>(currentMessage)</span><br><span class="line">    charactersRemaining = sc_maxCharactersAllowed - currentMessageLength</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="type">Int</span>(charactersRemaining) &lt; <span class="number">0</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>contentText</code>是<code>SLComposeServiceViewController</code>中的属性，类型为<code>String!</code>，它存储着分享界面中<code>TextView</code>中的文本信息。<code>charactersRemaining</code>也是<code>SLComposeServiceViewController</code>中的属性，类型为<code>NSNumber</code>，他表示还有多少合法的字数以及超出的字数，并显示在分享界面的左下角。你可以用<code>countElements()</code>方法获取输入文本的字数，用于计算<code>charactersRemaining</code>的值并判断是否超出了限定的最大字数。至于<strong>Post</strong>按钮的可用和禁用由<code>charactersRemaining</code>决定，不需要我们额外设置。</p>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension6.png" alt="图片"><br><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension7.png" alt="图片"></p>
<h2 id="u4E0A_u4F20_u5206_u4EAB_u5185_u5BB9"><a href="#u4E0A_u4F20_u5206_u4EAB_u5185_u5BB9" class="headerlink" title="上传分享内容"></a>上传分享内容</h2><p>到目前为止，我们已经知道了如何创建一个应用扩展、如何对应用扩展进行配置、如何控制用户的操作行为等。但是作为分享扩展，它的遵旨应该是将文本、图片、视频等资源上传至某个网络客户端（比如FaceBook、Twitter、新浪微博等）。下面就让我们看看应该如何做吧。</p>
<p>应用扩展相比载体应用或者Host应用来说，它是一个轻量级的、处理单一功能任务的组件，所以用户一般不会因为使用扩展而停止当前使用的应用或关闭正在看的内容。你可以试想一下，如果一个Host应用使用某个应用扩展让它处理一个简单的任务时，该扩展因为同时占用了Host应用的运行内存从而使Host应用不可用、退出以至于崩溃，这是多么令人发指的事情。因此，所有的上传操作都应该在后台执行（iOS7中<code>NSURLSession</code>类对实现该功能很有帮助）。你可能会认为跟着去年<a href="https://leanpub.com/ios7daybyday" target="_blank" rel="external">iOS7 Day-by-Day</a>系列文章就能很容易的实现该功能，但事实并非如此。</p>
<p>事情往往不是你想象的那么简单。首先提取分享的内容就不是一件容易的事（比如图片），而且你还要将它们分享出去，其次应用扩展没有任何写硬盘的权限。关于第二点，有人可能会有疑问：为什么应用扩展需要写硬盘的权限呢？因为所有后台上传的网络程序，在上传时都会先将上传内容缓存在硬盘中，然后从硬盘获取缓存的内容开始上传。为了能模拟硬盘缓存，我们需要在Host应用中创建一个存放分享内容的容器，并且要允许应用扩展使用该容器缓存分享内容。我们会在下面的内容中讲解如何实现该功能，但首先，我们先来看看如何提出分享内容中的图片。</p>
<h2 id="u63D0_u53D6_u8981_u5206_u4EAB_u7684_u56FE_u7247"><a href="#u63D0_u53D6_u8981_u5206_u4EAB_u7684_u56FE_u7247" class="headerlink" title="提取要分享的图片"></a>提取要分享的图片</h2><p>在<code>SLComposeServiceViewController</code>类中有一个属性叫<code>extensionContext</code>，它存储着与当前应用扩展有关联的所有数据，其中包含一个<code>NSInputItem</code>类型的数组，名叫<code>inputItems</code>。每个<code>NSInputItem</code>都含有一个<code>attachments</code>集合，它们的类型都为<code>NSItemProvider</code>。这些<code>attachments</code>存储的就是分享内容中的媒体资源，比如图片、视频、文件或链接。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">imageFromExtensionItem</span><span class="params">(extensionItem: NSExtensionItem, callback: <span class="params">(image: UIImage?)</span></span></span>-&gt;<span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> attachment <span class="keyword">in</span> extensionItem.attachments <span class="keyword">as</span> [<span class="type">NSItemProvider</span>] &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个方法的作用是从分享内容中提取图片（<code>UIImage</code>），注意这个方法没有返回值，而是用一个闭包回调函数来替代。</p>
<p>为了确定<code>attachments</code>中是否包含了图片类型的资源，我们需要用到<code>hasItemConformingToTypeIdentifier()</code>方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(attachment.hasItemConformingToTypeIdentifier(kUTTypeImage <span class="keyword">as</span> <span class="type">NSString</span>)) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的参数类型是<code>NSString</code>，并且类型标示符<code>kUTTypeImage</code>属于<strong>MobileCoreServices</strong>框架中的属性，所以我们要引入<strong>MobileCoreServices</strong>框架：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> MobileCoreServices</span><br></pre></td></tr></table></figure>
<p>该框架中还包含几种类型标示符：</p>
<ul>
<li><code>kUTTypeImage</code></li>
<li><code>kUTTypeMovie</code></li>
<li><code>kUTTypeAudio</code></li>
<li><code>kUTTypeSpreadsheet</code></li>
</ul>
<p>现在你可以确定<code>attachments</code>中至少包含了一个图片资源，并且需要将该图片资源提取出来。因为执行该任务会消耗很高的内存资源，所以为了确保在执行时UI界面不会出现无响应的情况，它应该在后台队列中执行。我们可以使用<code>loadItemForTypeIdentifier()</code>方法，与刚才的方法类似，该方法也有类型标示符参数，并且用闭包实现对图片的操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Marshal on to a background thread</span></span><br><span class="line">dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="type">UInt</span>(<span class="number">0</span>))) &#123;</span><br><span class="line">  attachment.loadItemForTypeIdentifier(kUTTypeImage <span class="keyword">as</span> <span class="type">NSString</span>, options: <span class="literal">nil</span>) &#123;</span><br><span class="line">      (imageProvider, error) -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用Objective-C，那么你可以用block将返回结果强制转换为你期望的类型（比如<code>UIImage</code>），然后实现回调。但是在Swift中就行不通了，所以上面代码中的<code>imageProvider</code>变量的类型应该是<code>NSSecureCoding</code>，然后你可以将它强转为<code>UIImage</code>类型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> image: <span class="type">UIImage</span>? = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> e = error &#123;</span><br><span class="line">  <span class="built_in">println</span>(<span class="string">"Item loading error: <span class="subst">\(e.localizedDescription)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">image = imageProvider <span class="keyword">as</span>? <span class="type">UIImage</span></span><br><span class="line">dispatch_async(dispatch_get_main_queue()) &#123;</span><br><span class="line">  callback(image: image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大家注意，在<code>dispatch_async</code>中我使用了<code>callback()</code>函数，也就是<code>imageFromExtensionItem</code>方法的第二个参数，并将刚才强转为<code>UIImage</code>类型的<code>image</code>对象作为其参数。</p>
<p>这段代码可以让用户在输入分享文本信息的同时将<code>attachments</code>中的图片提取出来。看起来非常完美：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> attachedImage: <span class="type">UIImage</span>?</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">presentationAnimationDidFinish</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Only interested in the first item</span></span><br><span class="line">  <span class="keyword">let</span> extensionItem = extensionContext.inputItems[<span class="number">0</span>] <span class="keyword">as</span> <span class="type">NSExtensionItem</span></span><br><span class="line">  <span class="comment">// Extract an image (if one exists)</span></span><br><span class="line">  imageFromExtensionItem(extensionItem) &#123;</span><br><span class="line">    image <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> image &#123;</span><br><span class="line">      dispatch_async(dispatch_get_main_queue()) &#123;</span><br><span class="line">        <span class="keyword">self</span>.attachedImage = image</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的作用就是提取出图片，并将提取出的图片赋值给我们定义的<code>attachedImage</code>变量。</p>
<h2 id="u6267_u884C_u540E_u53F0_u4E0A_u4F20_u7684_u4EFB_u52A1"><a href="#u6267_u884C_u540E_u53F0_u4E0A_u4F20_u7684_u4EFB_u52A1" class="headerlink" title="执行后台上传的任务"></a>执行后台上传的任务</h2><p>一旦用户输入完要分享的文本信息，按下<strong>Post</strong>按钮后，分享扩展就应该将所有内容通过Web服务上传到某个地方。本文的示例为了达到这个目的，我们在视图控制器中定义了一个常量属性<code>sc_uploadURL</code>，值为一个URL，也就是一个服务地址：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> sc_uploadURL = <span class="string">"http://requestb.in/oha28noh"</span></span><br></pre></td></tr></table></figure>
<p>这个URL是Request Bin的服务，Request Bin可以给你提供一个临时的URL，用于测试一些网络操作。上面代码中的这个URL对你们来说没有什么用，因为这是我申请的，你们可以去<a href="http://requestb.in/" target="_blank" rel="external">requestb.in</a>申请一个自己的URL用于测试。</p>
<p>在前面我们提到过，应用扩展不应该和Host应用抢占内存资源，它应该在后台执行相关任务。因此，当<strong>Post</strong>按钮被按下时，在当前的Host应用中我们不会看到任何有关应用扩展的执行痕迹，像同步、网络操作等。此时，我们就需要使用<code>NSURLSession</code>给我们提供的API来实现后台的网络操作。</p>
<p>当用户点击<strong>Post</strong>按钮后会调用<code>didSelectPost()</code>方法，它的代码片段应该是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">didSelectPost</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Perform upload</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Inform the host that we're done, so it un-blocks its UI.</span></span><br><span class="line">  extensionContext.completeRequestReturningItems(<span class="literal">nil</span>, completionHandler: <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置<code>NSURLSession</code>很简单，有规范的设置流程：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> configName = <span class="string">"com.shinobicontrols.ShareAlike.BackgroundSessionConfig"</span></span><br><span class="line"><span class="keyword">let</span> sessionConfig = <span class="type">NSURLSessionConfiguration</span>.backgroundSessionConfigurationWithIdentifier(configName)</span><br><span class="line"><span class="comment">// Extensions aren't allowed their own cache disk space. Need to share with application</span></span><br><span class="line">sessionConfig.sharedContainerIdentifier = <span class="string">"group.ShareAlike"</span></span><br><span class="line"><span class="keyword">let</span> session = <span class="type">NSURLSession</span>(configuration: sessionConfig)</span><br></pre></td></tr></table></figure>
<p>我们要特别注意上面代码片段中<code>sharedContainerIdentifier</code>的设置，它给<code>NSURLSession</code>使用的共享容器（用于缓存分享内容）指定了一个名称，这个容器也是扩展载体应用的一部分（在这个例子中，载体应用就是ShareAlike），所以我们要通过Xcode对载体应用进行设置：</p>
<ol>
<li>在工程设置面板中选择<strong>Capabilities</strong>页签，然后在左侧<strong>Targets</strong>栏中选中载体应用。</li>
<li>开启载体应用的<strong>App Groups</strong>。</li>
<li>创建一个App Group，起一个合适的名称，但是必须要以<code>group.</code>开头。在我们的示例中，我们刚才设置的名称为<code>group.ShareAlike</code>。</li>
<li>Xcode会进行一系列检查，然后创建App Group。</li>
</ol>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension8.png" alt="图片"></p>
<p>然后选中应用扩展，开启<strong>App Groups</strong>，然后选择刚才创建好的App Group。</p>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension9.png" alt="图片"></p>
<p>这些App Group都是登记在你的开发者账号下的，这样才能确保只有你的应用可以使用这些共享容器。</p>
<p>Xcode会为每个工程创建一个<code>.entitlements</code>授权文件，里面就包含有共享容器的访问名称。</p>
<p>现在<code>NSURLSession</code>就已经设置成功了，你还需要创建一个URL request对象来发送请求：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Prepare the URL Request</span></span><br><span class="line"><span class="keyword">let</span> request = urlRequestWithImage(attachedImage, text: contentText)</span><br></pre></td></tr></table></figure>
<p><code>urlRequestWithImage</code>函数的作用是构造一个URL请求结构，通过HTTP Post方式发送一些JSON格式的数据。这其中就包含了文本内容和图片的元数据信息：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">urlRequestWithImage</span><span class="params">(image: UIImage?, text: String)</span></span> -&gt; <span class="type">NSURLRequest</span>? &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="type">NSURL</span>.<span class="type">URLWithString</span>(sc_uploadURL)</span><br><span class="line">  <span class="keyword">let</span> request = <span class="type">NSMutableURLRequest</span>(<span class="type">URL</span>: url)</span><br><span class="line">  request.addValue(<span class="string">"application/json"</span>, forHTTPHeaderField: <span class="string">"Content-Type"</span>)</span><br><span class="line">  request.addValue(<span class="string">"application/json"</span>, forHTTPHeaderField: <span class="string">"Accept"</span>)</span><br><span class="line">  request.<span class="type">HTTPMethod</span> = <span class="string">"POST"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> jsonObject = <span class="type">NSMutableDictionary</span>()</span><br><span class="line">  jsonObject[<span class="string">"text"</span>] = text</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> image = image &#123;</span><br><span class="line">    jsonObject[<span class="string">"image_details"</span>] = extractDetailsFromImage(image)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the JSON payload</span></span><br><span class="line">  <span class="keyword">var</span> jsonError: <span class="type">NSError</span>?</span><br><span class="line">  <span class="keyword">let</span> jsonData = <span class="type">NSJSONSerialization</span>.dataWithJSONObject(jsonObject, options: <span class="literal">nil</span>, error: &amp;jsonError)</span><br><span class="line">  <span class="keyword">if</span> jsonData &#123;</span><br><span class="line">    request.<span class="type">HTTPBody</span> = jsonData</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = jsonError &#123;</span><br><span class="line">      <span class="built_in">println</span>(<span class="string">"JSON Error: <span class="subst">\(error.localizedDescription)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> request</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法实际上并不是创建一个上传图片的请求，虽然也可以这样做，但这里我们将图片的详细信息（元数据）提取出来进行上传，下面代码是提取图片详细信息的方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">extractDetailsFromImage</span><span class="params">(image: UIImage)</span></span> -&gt; <span class="type">NSDictionary</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> resultDict = <span class="type">NSMutableDictionary</span>()</span><br><span class="line">  resultDict[<span class="string">"height"</span>] = image.size.height</span><br><span class="line">  resultDict[<span class="string">"width"</span>] = image.size.width</span><br><span class="line">  resultDict[<span class="string">"orientation"</span>] = image.imageOrientation.toRaw()</span><br><span class="line">  resultDict[<span class="string">"scale"</span>] = image.scale</span><br><span class="line">  resultDict[<span class="string">"description"</span>] = image.description</span><br><span class="line">  <span class="keyword">return</span> resultDict.copy() <span class="keyword">as</span> <span class="type">NSDictionary</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后你就可以通过<code>resume()</code>在后台发起上传请求了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Create the task, and kick it off</span></span><br><span class="line"><span class="keyword">let</span> task = session.dataTaskWithRequest(request)</span><br><span class="line">task.resume()</span><br></pre></td></tr></table></figure>
<p>如果你按下<strong>Post</strong>按钮完成分享后，在requestb.in中，你应该可以看到如下的结果：</p>
<p><img src="http://www.devtalking.com/postImages/iOS8%20Day-by-Day-Day2-sharing-extension10.png" alt="图片"></p>
<p>原文地址：<a href="http://www.shinobicontrols.com/blog/posts/2014/07/21/ios8-day-by-day-day-2-sharing-extension" target="_blank" rel="external">iOS8 Day-by-Day :: Day 2 :: Sharing Extension</a></p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/create-documentation-in-playground/" itemprop="url">
                  在Playground中添加说明文档
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-09-15T00:00:00+08:00" content="2014-09-15">
              2014-09-15
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/create-documentation-in-playground/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/create-documentation-in-playground/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>大家应该还记得Swift官方博客中的《Patterns Playground》和《Balloons》这两篇文章，虽然博文很短，但是它们都包含了一个Playground文件，通过这个文件向我们阐述当前文章的主题。当我们打开这两个Playground文件时，发现里面别有洞天，里面有代码，有说明文档，有引用，而且格式规整。它们看起来非常像《The Swift Programming Language》、《Using Swift with Cocoa and Objective-C》这两本iBook，但是却比这两本书有更高的交互性。让我们来看看这两个Playground文件的片段：</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-15-create-documentation-in-playground1.png" alt="片段"><br><img src="http://www.devtalking.com/postImages/2014-09-15-create-documentation-in-playground2.png" alt="片段"> </p>
<p>大家可以看到，在Playground中还有小练习，加上它所见所得的特性，运用在教学中再好不过。可以想象，以后Objective-C，Swift的教学视频、材料都少不了Playground的身影。</p>
<p>说了这么多，大家一定很捉急想知道如何在Playground中添加说明文档吧。别着急，让我们一步一步进行：</p>
<ul>
<li>创建一个Playground文件，并保存。</li>
<li>找到刚刚保存的Playground文件，在其上点击鼠标右键，选择<strong>显示包内容</strong>。</li>
<li>在该Playground文件包内新建一个文件夹，命名为“Documentation”。</li>
<li>使用Mou或MacDown编辑你的说明文档：</li>
</ul>
<p><img src="http://www.devtalking.com/postImages/2014-09-15-create-documentation-in-playground3.png" alt="图片"> </p>
<ul>
<li>这里以MacDown为例（其实Mou也一样），点击File -&gt; Export -&gt; HTML，将编辑好的.md说明文档导出HTML文件，然后将该HTML文件拷贝到刚才创建的“Documentation”文件夹中。</li>
</ul>
<blockquote>
<p>你也可以自己添加CSS文件，修饰你的HTML内容。</p>
</blockquote>
<ul>
<li>打开Playground文件包内的contents.xcplayground文件，在<code>&lt;sections&gt;</code>标签中加入下面这行：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;documentation relative-path='playgroundDocumentation.html'&gt;&lt;/documentation&gt;</span><br></pre></td></tr></table></figure>
<p>也就是将我们刚才拷贝到“Documentation”文件夹中的HTML文件添加到Playground文件的xml文件中，使用<code>&lt;documentation&gt;</code>标签，将<code>relative-path</code>的值设置为HTML文件的名称：</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-15-create-documentation-in-playground4.png" alt="图片"> </p>
<p>现在再打开刚才创建的Playground文件看看，是不是很酷呢！</p>
<p><img src="http://www.devtalking.com/postImages/2014-09-15-create-documentation-in-playground5.png" alt="图片"> </p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                <a class="post-title-link" href="/articles/swift-required/" itemprop="url">
                  Swift中的required修饰符（Xcode 6 GM）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            發表於
            <time itemprop="dateCreated" datetime="2014-09-12T00:00:00+08:00" content="2014-09-12">
              2014-09-12
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/articles/swift-required/#comments" itemprop="discussionUrl">
                <span class="post-comments-count disqus-comment-count" data-disqus-identifier="/articles/swift-required/" itemprop="commentsCount"></span>
              </a>
            </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="u666E_u901A_u5B50_u7C7B"><a href="#u666E_u901A_u5B50_u7C7B" class="headerlink" title="普通子类"></a>普通子类</h2><p>通常情况下，一说到<code>required</code>修饰符，我们最先想到的应该就是普通类（class）的<code>init()</code>方法了。比如下面这个类：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str:<span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们定义一个<code>MyClass</code>的子类（subclass）并实例化这个子类时，我们一般会如何做呢？没错，通常情况下都会是这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str:<span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>:<span class="title">MyClass</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">MySubClass</span>(str:<span class="string">"Hello Swift"</span>)</span><br></pre></td></tr></table></figure>
<p>大伙应该已经注意到了，在实例化<code>MySubClass</code>时，其实是继承了它父类<code>MyClass</code>的<code>init()</code>方法。那我们再来看看子类的初始化方法。</p>
<h2 id="u5B50_u7C7B_u7684_u521D_u59CB_u5316_u65B9_u6CD5"><a href="#u5B50_u7C7B_u7684_u521D_u59CB_u5316_u65B9_u6CD5" class="headerlink" title="子类的初始化方法"></a>子类的初始化方法</h2><p>如果我们在子类中添加一个<code>init()</code>方法，像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str:<span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>:<span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(str:str)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="type">MySubClass</span>(str:<span class="string">"Hello Swift"</span>)</span><br></pre></td></tr></table></figure>
<p>那么我们首先要在<code>init()</code>方法前加上<code>override</code>修饰符，表示<code>MySubClass</code>重写了其父类的<code>init()</code>方法，然后还要调用父类的<code>init()</code>方法，并将参数一并传给父类的方法。</p>
<p>在实际运用中，也有另外一种情况，当子类的初始化方法参数类型与父类的初始化方法参数类型不同时，我们就不必在子类的初始化方法前加<code>override</code>修饰符了，但是要把子类初始化方法的参数类型转换为符合父类初始化方法的参数类型，然后传给父类的初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str:<span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>:<span class="title">MyClass</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(i:<span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(str:<span class="type">String</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MySubClass</span>(i: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h2 id="required_u4FEE_u9970_u7B26"><a href="#required_u4FEE_u9970_u7B26" class="headerlink" title="required修饰符"></a>required修饰符</h2><p>我们给父类的<code>init()</code>方法加上<code>required</code>修饰符后会发生什么呢，我们来看看：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str:<span class="type">String</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>:<span class="title">MyClass</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(i:<span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(str:<span class="type">String</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MySubClass</span>(i: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以看到上面的代码在编译会发生错误，因为我们没有实现父类中要去必须要实现的方法。我们应该这样写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str:<span class="type">String</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>:<span class="title">MyClass</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(str: str)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(i:<span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(str:<span class="type">String</span>(i))</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MySubClass</span>(i: <span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>从上面的代码示例中不难看出，如果子类需要添加异于父类的初始化方法时，必须先要实现父类中使用<code>required</code>修饰符修饰过的初始化方法，并且也要使用<code>required</code>修饰符而不是<code>override</code>。</p>
<p>如果子类中不需要添加任何初始化方法，我们则可以忽略父类的<code>required</code>初始化方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str:<span class="type">String</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(str:<span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.str = str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySubClass</span>:<span class="title">MyClass</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MySubClass</span>(str: <span class="string">"hello swift"</span>)</span><br></pre></td></tr></table></figure>
<p>在这种情况下，编译器不会报错，因为如果子类没有任何初始化方法时，Swift会默认使用父类的初始化方法。在<a href="https://developer.apple.com/library/prerelease/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-XID_339" target="_blank" rel="external">Apple的文档</a>中也有相关描述：</p>
<blockquote>
<p>You do not have to provide an explicit implementation of a required initializer if you can satisfy the requirement with an inherited initialiser.</p>
</blockquote>
<h2 id="required_u4FEE_u9970_u7B26_u7684_u4F7F_u7528_u89C4_u5219"><a href="#required_u4FEE_u9970_u7B26_u7684_u4F7F_u7528_u89C4_u5219" class="headerlink" title="required修饰符的使用规则"></a>required修饰符的使用规则</h2><ol>
<li><code>required</code>修饰符只能用于修饰类初始化方法。</li>
<li>当子类含有异于父类的初始化方法时（初始化方法参数类型和数量异于父类），子类必须要实现父类的<code>required</code>初始化方法，并且也要使用<code>required</code>修饰符而不是<code>override</code>。</li>
<li>当子类没有初始化方法时，可以不用实现父类的<code>required</code>初始化方法。</li>
</ol>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>


 </div>

        

        
      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://www.devtalking.com/devtalking.png" alt="DevTalking" itemprop="image"/>
          <p class="site-author-name" itemprop="name">DevTalking</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">65</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

         <!-- <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分類</span>
              
          </div> -->

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">31</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jacefu" target="_blank">
                  
                    <i class="fa fa-weibo"></i> Weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="mailto:jace.fu@icloud.com" target="_blank">
                  
                    <i class="fa fa-envelope"></i> Email
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.devtalking.com/qrcode.jpg" target="_blank">
                  
                    <i class="fa fa-qrcode"></i> 微信公众号
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DevTalking</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  

    <script type="text/javascript">
      var disqus_shortname = 'jacefu';
      var disqus_identifier = 'page/6/index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.2" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }

      motionIntegrator.bootstrap();
    });
  </script>

  
  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
